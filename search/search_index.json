{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren\u2019t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one\u2013 and preferably only one \u2013obvious way to do it. Although that way may not be obvious at first unless you\u2019re Dutch. Now is better than never. Although never is often better than right now. If the implementation is hard to explain, it\u2019s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea \u2013 let\u2019s do more of those!","title":"zyc.ai"},{"location":"about/about/","text":"\u4f60\u597d\uff0c\u6b22\u8fce\u8bbf\u95ee\u672c\u7f51\u7ad9\u3002 \u672c\u7f51\u7ad9\u57fa\u4e8e GitHUb Pages \u4e0e MKDocs \u6784\u5efa\uff0c\u65e8\u5728\u63d0\u4f9b\u4e00\u4e2a\u5206\u4eab\u77e5\u8bc6\u7684\u5e73\u53f0\u3002 \u672c\u7f51\u7ad9\u662f\u9648\u965f\u539f\u7684\u4e2a\u4eba\u7f51\u7ad9\uff0c\u4f46\u6211\u4e5f\u6b22\u8fce\u4efb\u4f55\u4eba\u58eb\u63d0\u4ea4commit\u4ee5\u5206\u4eab\u65b0\u7684\u77e5\u8bc6\uff0c\u53ea\u8981\u4f60\u9075\u5faa\u4ee5\u4e0b\u539f\u5219\uff1a Don\u2019t be evil. \u5982\u679c\u4f60\u6709\u610f\u8d21\u732e\uff0c\u656c\u8bf7\u53c2\u9605\u8d21\u732e\u6307\u5357\u3002 \u5982\u679c\u4f60\u6709\u610f\u6350\u8d60\uff0c\u656c\u8bf7\u53c2\u9605 \u6350\u8d60 \u3002 SenseTime SenseTime 3DVAR \u4e09\u7ef4\u89c6\u89c9\u4e0e\u589e\u5f3a\u73b0\u5b9e","title":"\u5173\u4e8e"},{"location":"about/comment/","text":"\u6700\u540e\u4fee\u8ba2 \u672c\u653f\u7b56\u6700\u540e\u4fee\u8ba2\u4e8e2020\u5e7408\u670816\u65e5\u3002 \u60a8\u7684\u8bc4\u8bba\u5bf9\u4e8e\u6211\u4eec\u975e\u5e38\u91cd\u8981\u3002 \u6211\u4eec\u76f8\u4fe1\uff0c\u8a00\u8bba\u81ea\u7531\u5e26\u6765\u7684\u601d\u7ef4\u78b0\u649e\u5c06\u4e16\u754c\u5f15\u4e0a\u4e00\u4e2a\u53c8\u4e00\u4e2a\u65b0\u7684\u9ad8\u5ea6\u3002 \u672c\u8bc4\u8bba\u653f\u7b56\uff08\u4ee5\u4e0b\u7b80\u79f0\u672c\u653f\u7b56\uff09\u9610\u8ff0\u4e86\u60a8\uff08\u4e2a\u4eba\u6216\u5b9e\u4f53\uff09\u4e0e\u6211\u4eec\uff08zyc.ai\uff09\u53ca\u6211\u4eec\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u901a\u8fc7\u8bc4\u8bba\u4e92\u52a8\u65f6\u6240\u9700\u6ce8\u610f\u7684\u4e8b\u9879\u3002 \u5185\u5bb9 \u672c\u653f\u7b56\u6240\u79f0\u7684\u5185\u5bb9\u662f\u6307\u6211\u4eec\u62e5\u6709\u8457\u4f5c\u6743\u6216\u6709\u6743\u4f7f\u7528\u7684\u5185\u5bb9\uff0c\u5305\u62ec\u4f46\u4e0d\u9650\u4e8e\u4ea7\u54c1\u3001\u8f6f\u4ef6\u3001\u786c\u4ef6\u3001\u6e90\u7801\u3001\u5de5\u5177\u3001\u6750\u6599\u3001\u56fe\u7eb8\u3001\u6570\u636e\u3001\u89c6\u9891\u3001\u56fe\u50cf\u3001\u97f3\u9891\u3001\u6587\u6863\u53ca\u5176\u4ed6\u53ef\u88ab\u89c6\u4e3a\u5185\u5bb9\u7684\u4e8c\u8fdb\u5236\u6216\u975e\u4e8c\u8fdb\u5236\u6587\u4ef6\u4ee5\u53ca\u8f7d\u6709\u5176\u7684\u7eb8\u5f20\u3001\u5149\u76d8\u3001U\u76d8\u7b49\u7269\u7406\u8f7d\u4f53\u3002 \u5982\u60a8\u8fdd\u53cd\u672c\u653f\u7b56\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\uff0c\u6211\u4eec\u5c06\u4fdd\u7559\u8ffd\u7a76\u60a8\u76f8\u5173\u6cd5\u5f8b\u8d23\u4efb\u7684\u6743\u5229\u3002 1 \u5185\u5bb9 # \u6211\u4eec\u6df1\u77e5\u8a00\u8bba\u81ea\u7531\u5341\u5206\u91cd\u8981\u3002\u56e0\u6b64\uff0c\u60a8\u6709\u6743\u5728\u4f7f\u7528\u6211\u4eec\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u65f6\u7559\u4e0b\u4efb\u4f55\u8bc4\u4ef7\u3002 \u4f8b\u5916\u60c5\u51b5 \u4e3a\u4e86\u4fdd\u62a4\u4ed6\u4eba\u7684\u6b63\u5f53\u6743\u5229\u4e0d\u53d7\u4fb5\u5bb3\uff0c\u6211\u4eec\u5bf9\u4ee5\u4e0b\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u4e2d\u7684\u8bc4\u8bba\u5185\u5bb9\u4e88\u4ee5\u4f8b\u5916\u60c5\u51b5\u8bf4\u660e\u3002 \u4e0d\u5f53\u5185\u5bb9 \u6211\u4eec\u4e0d\u5141\u8bb8\u4efb\u4f55\u4ec7\u6068\u6027\u3001\u6b67\u89c6\u6027\u7b49\u8fdd\u53cd\u6cd5\u5f8b\u6cd5\u89c4\u6216\u516c\u5e8f\u826f\u4fd7\u7684\u5185\u5bb9\u3002 \u4fb5\u5bb3\u4ed6\u4eba\u6b63\u5f53\u6743\u5229 \u6211\u4eec\u4e0d\u5141\u8bb8\u4efb\u4f55\u4fb5\u5bb3\u4ed6\u4eba\u6b63\u5f53\u6743\u5229\u7684\u5185\u5bb9\u3002 \u8bef\u5bfc\u6027\u5185\u5bb9 \u6211\u4eec\u4e0d\u5141\u8bb8\u4efb\u4f55\u8bef\u5bfc\u6027\u3001\u6b3a\u8bc8\u6027\u5185\u5bb9\u3002 \u513f\u7ae5\u9002\u5b9c \u6211\u4eec\u4e0d\u5141\u8bb8\u4efb\u4f55\u4e0d\u9002\u5b9c\u4e8e\u513f\u7ae5\u9605\u8bfb\u7684\u5185\u5bb9\u3002 \u6709\u6743\u4f7f\u7528 \u60a8\u5fc5\u987b\u786e\u4fdd\u60a8\u6709\u6743\u4f7f\u7528\u76f8\u5173\u5185\u5bb9\uff0c\u8fd9\u4ee3\u8868\u53d7\u7248\u6743\u4fdd\u62a4\u7684\u5185\u5bb9\u4e0d\u80fd\u5728\u8bc4\u8bba\u533a\u88ab\u4f7f\u7528\uff0c\u9664\u975e\u60a8\u6709\u4f7f\u7528\u5b83\u4eec\u7684\u6743\u5229\u3002 2 \u6743\u5229 # \u60a8\u4eab\u6709\u5bf9\u60a8\u7684\u8bc4\u8bba\u7684\u8457\u4f5c\u6743\u4e0e\u7f72\u540d\u6743\u3002 \u540c\u65f6\uff0c\u5728\u60a8\u505a\u51fa\u8bc4\u8bba\u65f6\uff0c\u89c6\u4e3a\u60a8\u6388\u4e88\u6211\u4eec\u6709\u5173\u8be5\u7b49\u8bc4\u8bba\u53ca\u5176\u5185\u5bb9\u7684\u5168\u7403\u8303\u56f4\u7684\u3001\u4e0d\u53ef\u64a4\u9500\u7684\u3001\u6c38\u4e45\u6027\u7684\u3001\u53ef\u518d\u6388\u6743\u7684\u4f7f\u7528\u3001\u53d1\u5e03\u3001\u4f20\u64ad\u3001\u8868\u6f14\u3001\u5c55\u793a\u3001\u5546\u4e1a\u5f00\u53d1\u3001\u590d\u5236\u3001\u4fee\u6539\u3001\u6539\u7f16\u3001\u51fa\u7248\u3001\u7ffb\u8bd1\u3001\u636e\u4ee5\u521b\u4f5c\u884d\u751f\u4f5c\u54c1\u7b49\u6743\u5229\u3002 3 \u672c\u653f\u7b56\u7684\u4fee\u8ba2 # \u6211\u4eec\u53ef\u80fd\u4f1a\u4e0d\u65f6\u66f4\u6539\u672c\u653f\u7b56\uff0c\u4f7f\u4e4b\u80fd\u591f\u51c6\u786e\u53cd\u6620\u6211\u4eec\u7684\u505a\u6cd5\u3001zyc.ai\u5185\u5bb9\u53ca\u6cd5\u5f8b\u8981\u6c42\u3002 \u672c\u653f\u7b56\u9876\u90e8\u7684\u201c\u4e0a\u6b21\u4fee\u6539\u65e5\u671f\u201d\u90e8\u5206\u6307\u51fa\u4e86\u4e0a\u6b21\u4fee\u8ba2\u672c\u653f\u7b56\u7684\u65e5\u671f\uff0c\u6bcf\u6b21\u53d1\u5e03\u4fee\u8ba2\u65f6\u6211\u4eec\u90fd\u4f1a\u66f4\u65b0\u6b64\u65e5\u671f\u3002\u5bf9\u672c\u653f\u7b56\u7684\u4efb\u4f55\u66f4\u6539\u5c06\u5728\u6211\u4eec\u901a\u8fc7\u516c\u5e03\u4fee\u8ba2\u7248\u8bc4\u8bba\u653f\u7b56\u65f6\u751f\u6548\u3002 \u6211\u4eec\u9f13\u52b1\u60a8\u5b9a\u671f\u67e5\u770b\u672c\u653f\u7b56\uff0c\u4e86\u89e3\u60a8\u7684\u6743\u5229\u3002 4 \u9002\u7528\u8303\u56f4 # zyc.ai\u8ba4\u4e3a\u5f00\u653e\u4e0e\u9690\u79c1\u5bf9\u6211\u4eec\u53ca\u6211\u4eec\u7684\u7528\u6237\u5341\u5206\u91cd\u8981\u3002 \u56e0\u6b64\uff0c\u672c\u653f\u7b56\u5c06\u9002\u7528\u4e8e\u4efb\u4f55zyc.ai\u5185\u5bb9\u7684\u884d\u751f\u4f5c\u54c1\u3002 \u5982\u679c\u60a8\u7684\u4f5c\u54c1\u884d\u751f\u81ea\u3001\u4f7f\u7528\u6216\u8005\u90e8\u5206\u4f7f\u7528zyc.ai\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\uff0c\u60a8\u5fc5\u987b\u5c06\u5176\u6309\u7167\u4e0e\u672c\u534f\u8bae\u89c4\u5b9a\u7684\u76f8\u540c\u65b9\u5f0f\u5c06\u8be5\u4f5c\u54c1\u6216\u670d\u52a1\u6574\u4f53\u5411\u60f3\u8981\u83b7\u5f97\u8bb8\u53ef\u7684\u4eba\u6388\u6743\u3002 \u5982\u679c\u60a8\u4e0d\u80fd\u6309\u7167\u672c\u653f\u7b56\u7684\u8981\u6c42\u6765\u63d0\u4f9b\u6216\u8fd0\u8425\u5185\u5bb9\uff0c\u90a3\u4e48\u60a8\u5c06\u4e0d\u80fd\u63d0\u4f9b\u6216\u8fd0\u8425\u5b83\u4eec\u3002","title":"\u8bc4\u8bba\u653f\u7b56"},{"location":"about/comment/#1","text":"\u6211\u4eec\u6df1\u77e5\u8a00\u8bba\u81ea\u7531\u5341\u5206\u91cd\u8981\u3002\u56e0\u6b64\uff0c\u60a8\u6709\u6743\u5728\u4f7f\u7528\u6211\u4eec\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u65f6\u7559\u4e0b\u4efb\u4f55\u8bc4\u4ef7\u3002 \u4f8b\u5916\u60c5\u51b5 \u4e3a\u4e86\u4fdd\u62a4\u4ed6\u4eba\u7684\u6b63\u5f53\u6743\u5229\u4e0d\u53d7\u4fb5\u5bb3\uff0c\u6211\u4eec\u5bf9\u4ee5\u4e0b\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u4e2d\u7684\u8bc4\u8bba\u5185\u5bb9\u4e88\u4ee5\u4f8b\u5916\u60c5\u51b5\u8bf4\u660e\u3002 \u4e0d\u5f53\u5185\u5bb9 \u6211\u4eec\u4e0d\u5141\u8bb8\u4efb\u4f55\u4ec7\u6068\u6027\u3001\u6b67\u89c6\u6027\u7b49\u8fdd\u53cd\u6cd5\u5f8b\u6cd5\u89c4\u6216\u516c\u5e8f\u826f\u4fd7\u7684\u5185\u5bb9\u3002 \u4fb5\u5bb3\u4ed6\u4eba\u6b63\u5f53\u6743\u5229 \u6211\u4eec\u4e0d\u5141\u8bb8\u4efb\u4f55\u4fb5\u5bb3\u4ed6\u4eba\u6b63\u5f53\u6743\u5229\u7684\u5185\u5bb9\u3002 \u8bef\u5bfc\u6027\u5185\u5bb9 \u6211\u4eec\u4e0d\u5141\u8bb8\u4efb\u4f55\u8bef\u5bfc\u6027\u3001\u6b3a\u8bc8\u6027\u5185\u5bb9\u3002 \u513f\u7ae5\u9002\u5b9c \u6211\u4eec\u4e0d\u5141\u8bb8\u4efb\u4f55\u4e0d\u9002\u5b9c\u4e8e\u513f\u7ae5\u9605\u8bfb\u7684\u5185\u5bb9\u3002 \u6709\u6743\u4f7f\u7528 \u60a8\u5fc5\u987b\u786e\u4fdd\u60a8\u6709\u6743\u4f7f\u7528\u76f8\u5173\u5185\u5bb9\uff0c\u8fd9\u4ee3\u8868\u53d7\u7248\u6743\u4fdd\u62a4\u7684\u5185\u5bb9\u4e0d\u80fd\u5728\u8bc4\u8bba\u533a\u88ab\u4f7f\u7528\uff0c\u9664\u975e\u60a8\u6709\u4f7f\u7528\u5b83\u4eec\u7684\u6743\u5229\u3002","title":"1 \u5185\u5bb9"},{"location":"about/comment/#2","text":"\u60a8\u4eab\u6709\u5bf9\u60a8\u7684\u8bc4\u8bba\u7684\u8457\u4f5c\u6743\u4e0e\u7f72\u540d\u6743\u3002 \u540c\u65f6\uff0c\u5728\u60a8\u505a\u51fa\u8bc4\u8bba\u65f6\uff0c\u89c6\u4e3a\u60a8\u6388\u4e88\u6211\u4eec\u6709\u5173\u8be5\u7b49\u8bc4\u8bba\u53ca\u5176\u5185\u5bb9\u7684\u5168\u7403\u8303\u56f4\u7684\u3001\u4e0d\u53ef\u64a4\u9500\u7684\u3001\u6c38\u4e45\u6027\u7684\u3001\u53ef\u518d\u6388\u6743\u7684\u4f7f\u7528\u3001\u53d1\u5e03\u3001\u4f20\u64ad\u3001\u8868\u6f14\u3001\u5c55\u793a\u3001\u5546\u4e1a\u5f00\u53d1\u3001\u590d\u5236\u3001\u4fee\u6539\u3001\u6539\u7f16\u3001\u51fa\u7248\u3001\u7ffb\u8bd1\u3001\u636e\u4ee5\u521b\u4f5c\u884d\u751f\u4f5c\u54c1\u7b49\u6743\u5229\u3002","title":"2 \u6743\u5229"},{"location":"about/comment/#3","text":"\u6211\u4eec\u53ef\u80fd\u4f1a\u4e0d\u65f6\u66f4\u6539\u672c\u653f\u7b56\uff0c\u4f7f\u4e4b\u80fd\u591f\u51c6\u786e\u53cd\u6620\u6211\u4eec\u7684\u505a\u6cd5\u3001zyc.ai\u5185\u5bb9\u53ca\u6cd5\u5f8b\u8981\u6c42\u3002 \u672c\u653f\u7b56\u9876\u90e8\u7684\u201c\u4e0a\u6b21\u4fee\u6539\u65e5\u671f\u201d\u90e8\u5206\u6307\u51fa\u4e86\u4e0a\u6b21\u4fee\u8ba2\u672c\u653f\u7b56\u7684\u65e5\u671f\uff0c\u6bcf\u6b21\u53d1\u5e03\u4fee\u8ba2\u65f6\u6211\u4eec\u90fd\u4f1a\u66f4\u65b0\u6b64\u65e5\u671f\u3002\u5bf9\u672c\u653f\u7b56\u7684\u4efb\u4f55\u66f4\u6539\u5c06\u5728\u6211\u4eec\u901a\u8fc7\u516c\u5e03\u4fee\u8ba2\u7248\u8bc4\u8bba\u653f\u7b56\u65f6\u751f\u6548\u3002 \u6211\u4eec\u9f13\u52b1\u60a8\u5b9a\u671f\u67e5\u770b\u672c\u653f\u7b56\uff0c\u4e86\u89e3\u60a8\u7684\u6743\u5229\u3002","title":"3 \u672c\u653f\u7b56\u7684\u4fee\u8ba2"},{"location":"about/comment/#4","text":"zyc.ai\u8ba4\u4e3a\u5f00\u653e\u4e0e\u9690\u79c1\u5bf9\u6211\u4eec\u53ca\u6211\u4eec\u7684\u7528\u6237\u5341\u5206\u91cd\u8981\u3002 \u56e0\u6b64\uff0c\u672c\u653f\u7b56\u5c06\u9002\u7528\u4e8e\u4efb\u4f55zyc.ai\u5185\u5bb9\u7684\u884d\u751f\u4f5c\u54c1\u3002 \u5982\u679c\u60a8\u7684\u4f5c\u54c1\u884d\u751f\u81ea\u3001\u4f7f\u7528\u6216\u8005\u90e8\u5206\u4f7f\u7528zyc.ai\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\uff0c\u60a8\u5fc5\u987b\u5c06\u5176\u6309\u7167\u4e0e\u672c\u534f\u8bae\u89c4\u5b9a\u7684\u76f8\u540c\u65b9\u5f0f\u5c06\u8be5\u4f5c\u54c1\u6216\u670d\u52a1\u6574\u4f53\u5411\u60f3\u8981\u83b7\u5f97\u8bb8\u53ef\u7684\u4eba\u6388\u6743\u3002 \u5982\u679c\u60a8\u4e0d\u80fd\u6309\u7167\u672c\u653f\u7b56\u7684\u8981\u6c42\u6765\u63d0\u4f9b\u6216\u8fd0\u8425\u5185\u5bb9\uff0c\u90a3\u4e48\u60a8\u5c06\u4e0d\u80fd\u63d0\u4f9b\u6216\u8fd0\u8425\u5b83\u4eec\u3002","title":"4 \u9002\u7528\u8303\u56f4"},{"location":"about/contribute/","text":"\u5728\u4f60\u505a\u51fa\u4efb\u4f55\u8d21\u732e\u4e4b\u524d\uff0c\u6211\u4eec\u5f3a\u70c8\u5efa\u8bae\u4f60\u5148\u9605\u8bfb\u8fd9\u7bc7\u6587\u7ae0\uff0c\u786e\u4fdd\u4f60\u4e86\u89e3\u683c\u5f0f\u4fe1\u606f\u5e76\u638c\u63e1MkDocs\u7684\u8bed\u6cd5\u3002 \u8bed\u6cd5 # \u7279\u6b8a\u8bed\u6cd5 # \u4ee3\u7801 # \u4ee3\u7801\u5757\u5e94\u5f53\u663e\u793a\u4f7f\u7528` `\u548c ``` ``` \u8fdb\u884c\u6307\u5b9a\u3002 \u9664\u975e\u7279\u6b8a\u60c5\u51b5\uff0c\u5e94\u5f53\u6ce8\u660e\u4f7f\u7528\u7684\u8bed\u8a00\u4ee5\u4f7f\u4ee3\u7801\u7740\u8272\u5668\u6b63\u5e38\u5de5\u4f5c\u3002 \u884c\u5916\u4ee3\u7801\u5757\u5e94\u5f53\u5305\u542b\u5728 abstract \u8b66\u544a\u6846\u5f53\u4e2d\u3002 LaTeX # LaTeX\u516c\u5f0f\u5e94\u5f53\u663e\u793a\u4f7f\u7528$ $\u548c $$ $$ \u8fdb\u884c\u6307\u5b9a\u3002 \u6bb5\u843d # \u6807\u9898 # \u6bcf\u4e2a\u6587\u4ef6\u5e94\u5f53\u6709\u4e14\u53ea\u6709\u4e00\u4e2a\u4e00\u7ea7\u6807\u9898\u2013\u9898\u76ee\u3002 \u9898\u76ee\u5e94\u5f53\u4e8e\u6587\u4ef6\u63cf\u8ff0\u90e8\u5206\u7684 title \u4e2d\u6ce8\u660e\u3002 \u6362\u884c # \u6240\u6709\u6807\u9898\u3001\u884c\u5916\u4ee3\u7801\u3001\u884c\u5916LaTeX\u524d\u540e\u4ee5\u53ca\u6587\u5b57\u6bb5\u843d\u4e4b\u95f4\u7a7a\u4e00\u884c\u3002 \u7981\u6b62\u4e3a\u4e86\u89c6\u89c9\u6548\u679c\u800c\u523b\u610f\u7a7a\u884c\u3002 \u5206\u9694 # \u6240\u6709\u6587\u4ef6\u4f7f\u7528\u56db\u4e2a\u7a7a\u683c\u4f5c\u4e3a\u4e00\u4e2a\u5236\u8868\u7b26\u3002 \u6587\u4ef6\u5185\u65e0\u7528\u7684\u5206\u9694\u7b26\u5e94\u5f53\u5220\u53bb \u7a7a\u767d\u884c # \u5982\u9700\u663e\u793a\u7a7a\u767d\u884c\u65f6\uff0c\u5e94\u5f53\u4f7f\u7528 <br/> \u6587\u4ef6 # \u6ce8\u610f \u6240\u6709\u6587\u4ef6\u540d\u53ca\u76ee\u5f55\u540d\u5747\u5e94\u5f53\u4f7f\u7528\u5c0f\u5199+\u4e0b\u5212\u7ebf\u3002 \u6587\u4ef6\u5939 # \u6bcf\u4e00\u4e2a\u7ae0\u8282\u5e94\u5f53\u521b\u5efa\u5355\u72ec\u7684\u76ee\u5f55\u3002\u5982\u5185\u5bb9\u4e0d\u8db3\u4ee5\u6784\u6210\u7ae0\u8282\uff0c\u5219\u5e94\u5c06\u6587\u4ef6\u5b58\u653e\u4e8e master \u3001 document \u6216 sketch \u76ee\u5f55\u4e2d\u3002 \u8b66\u544a\u6846 # \u524d\u8a00\u4e0e\u540e\u8bb0\u5747\u5e94\u5f53\u4f7f\u7528 abstract \u8b66\u544a\u6846\u6ce8\u660e\uff0c\u4e14\u5e94\u5f53\u4f4d\u4e8e\u6587\u9996\u548c\u6587\u672b\u3002 \u7f16\u64b0 # \u64b0\u5199 # \u64b0\u5199\u6587\u7ae0\u5f53\u4e2d\uff0c\u5e94\u5c3d\u91cf\u907f\u514d\u5728\u4e00\u4e2a\u6587\u4ef6\u5f53\u4e2d\u64b0\u5199\u592a\u591a\u6216\u592a\u5c11\u5185\u5bb9\uff0c\u4ee5\u6570\u5206\u949f\u80fd\u5b8c\u6210\u6d4f\u89c8\u4e3a\u4f73\u3002\u590d\u6742\u5185\u5bb9\u53ef\u4ee5\u5206\u591a\u4e2a\u7cfb\u5217\u8fdb\u884c\u8ba8\u8bba\u3002 \u591a\u8bed\u8a00 # \u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u7684\u5f88\u591a\u6587\u7ae0\u5747\u6d89\u53ca\u4e2d\u3001\u82f1\u53cc\u8bed\u3002\u5728\u7f16\u64b0\u6587\u7ae0\u65f6\uff0c\u5e94\u6ce8\u610f\u4ee5\u4e0b\u4e24\u70b9\uff1a \u8bed\u8a00\u7eaf\u6d01 \u9664\u975e\u7279\u6b8a\u60c5\u51b5\uff0c\u7981\u6b62\u5728\u4e00\u79cd\u8bed\u8a00\u5f53\u4e2d\u5939\u6742\u53e6\u4e00\u79cd\u8bed\u8a00\u3002 \u7ffb\u8bd1\u5e94\u5f53\u5c3d\u91cf\u4f7f\u7528\u884c\u4e1a\u7edf\u4e00\u7684\u672f\u8bed\uff0c\u6bd4\u5982 \u673a\u5668\u5b66\u4e60\u672f\u8bed\u8868 \u3002 \u4f8b\u5916\u60c5\u51b5 \u5e7f\u4e3a\u4eba\u77e5\u7684\u540d\u5b57 \u6ca1\u6709\u53ef\u4fe1\u7684\u7ffb\u8bd1 \u51c6\u786e\u7ffb\u8bd1 \u7ffb\u8bd1\u5e94\u5f53\u5c3d\u53ef\u80fd\u4fdd\u8bc1\u51c6\u786e\uff0c\u4e0d\u7834\u574f\u539f\u6587\u610f\u601d\u3002 \u4e0d\u8fc7\u5ea6\u7ffb\u8bd1 \u80fd\u6839\u636e\u524d\u540e\u6587\u5f97\u51fa\u7684\u5185\u5bb9\u4e0d\u9700\u7279\u610f\u6dfb\u52a0\u3002 \u4e25\u7981\u5c06\u201dI love you\u201d\u7ffb\u8bd1\u4e3a\u201c\u4eca\u591c\u6708\u8272\u5f88\u7f8e\u201d\u3002 \u5f88\u9ad8\u5174\u80fd\u4e0e\u4f60\u4e00\u8d77\u5206\u4eab\u77e5\u8bc6\u3002","title":"\u8d21\u732e"},{"location":"about/contribute/#_1","text":"","title":"\u8bed\u6cd5"},{"location":"about/contribute/#_2","text":"","title":"\u7279\u6b8a\u8bed\u6cd5"},{"location":"about/contribute/#_3","text":"\u4ee3\u7801\u5757\u5e94\u5f53\u663e\u793a\u4f7f\u7528` `\u548c ``` ``` \u8fdb\u884c\u6307\u5b9a\u3002 \u9664\u975e\u7279\u6b8a\u60c5\u51b5\uff0c\u5e94\u5f53\u6ce8\u660e\u4f7f\u7528\u7684\u8bed\u8a00\u4ee5\u4f7f\u4ee3\u7801\u7740\u8272\u5668\u6b63\u5e38\u5de5\u4f5c\u3002 \u884c\u5916\u4ee3\u7801\u5757\u5e94\u5f53\u5305\u542b\u5728 abstract \u8b66\u544a\u6846\u5f53\u4e2d\u3002","title":"\u4ee3\u7801"},{"location":"about/contribute/#latex","text":"LaTeX\u516c\u5f0f\u5e94\u5f53\u663e\u793a\u4f7f\u7528$ $\u548c $$ $$ \u8fdb\u884c\u6307\u5b9a\u3002","title":"LaTeX"},{"location":"about/contribute/#_4","text":"","title":"\u6bb5\u843d"},{"location":"about/contribute/#_5","text":"\u6bcf\u4e2a\u6587\u4ef6\u5e94\u5f53\u6709\u4e14\u53ea\u6709\u4e00\u4e2a\u4e00\u7ea7\u6807\u9898\u2013\u9898\u76ee\u3002 \u9898\u76ee\u5e94\u5f53\u4e8e\u6587\u4ef6\u63cf\u8ff0\u90e8\u5206\u7684 title \u4e2d\u6ce8\u660e\u3002","title":"\u6807\u9898"},{"location":"about/contribute/#_6","text":"\u6240\u6709\u6807\u9898\u3001\u884c\u5916\u4ee3\u7801\u3001\u884c\u5916LaTeX\u524d\u540e\u4ee5\u53ca\u6587\u5b57\u6bb5\u843d\u4e4b\u95f4\u7a7a\u4e00\u884c\u3002 \u7981\u6b62\u4e3a\u4e86\u89c6\u89c9\u6548\u679c\u800c\u523b\u610f\u7a7a\u884c\u3002","title":"\u6362\u884c"},{"location":"about/contribute/#_7","text":"\u6240\u6709\u6587\u4ef6\u4f7f\u7528\u56db\u4e2a\u7a7a\u683c\u4f5c\u4e3a\u4e00\u4e2a\u5236\u8868\u7b26\u3002 \u6587\u4ef6\u5185\u65e0\u7528\u7684\u5206\u9694\u7b26\u5e94\u5f53\u5220\u53bb","title":"\u5206\u9694"},{"location":"about/contribute/#_8","text":"\u5982\u9700\u663e\u793a\u7a7a\u767d\u884c\u65f6\uff0c\u5e94\u5f53\u4f7f\u7528 <br/>","title":"\u7a7a\u767d\u884c"},{"location":"about/contribute/#_9","text":"\u6ce8\u610f \u6240\u6709\u6587\u4ef6\u540d\u53ca\u76ee\u5f55\u540d\u5747\u5e94\u5f53\u4f7f\u7528\u5c0f\u5199+\u4e0b\u5212\u7ebf\u3002","title":"\u6587\u4ef6"},{"location":"about/contribute/#_10","text":"\u6bcf\u4e00\u4e2a\u7ae0\u8282\u5e94\u5f53\u521b\u5efa\u5355\u72ec\u7684\u76ee\u5f55\u3002\u5982\u5185\u5bb9\u4e0d\u8db3\u4ee5\u6784\u6210\u7ae0\u8282\uff0c\u5219\u5e94\u5c06\u6587\u4ef6\u5b58\u653e\u4e8e master \u3001 document \u6216 sketch \u76ee\u5f55\u4e2d\u3002","title":"\u6587\u4ef6\u5939"},{"location":"about/contribute/#_11","text":"\u524d\u8a00\u4e0e\u540e\u8bb0\u5747\u5e94\u5f53\u4f7f\u7528 abstract \u8b66\u544a\u6846\u6ce8\u660e\uff0c\u4e14\u5e94\u5f53\u4f4d\u4e8e\u6587\u9996\u548c\u6587\u672b\u3002","title":"\u8b66\u544a\u6846"},{"location":"about/contribute/#_12","text":"","title":"\u7f16\u64b0"},{"location":"about/contribute/#_13","text":"\u64b0\u5199\u6587\u7ae0\u5f53\u4e2d\uff0c\u5e94\u5c3d\u91cf\u907f\u514d\u5728\u4e00\u4e2a\u6587\u4ef6\u5f53\u4e2d\u64b0\u5199\u592a\u591a\u6216\u592a\u5c11\u5185\u5bb9\uff0c\u4ee5\u6570\u5206\u949f\u80fd\u5b8c\u6210\u6d4f\u89c8\u4e3a\u4f73\u3002\u590d\u6742\u5185\u5bb9\u53ef\u4ee5\u5206\u591a\u4e2a\u7cfb\u5217\u8fdb\u884c\u8ba8\u8bba\u3002","title":"\u64b0\u5199"},{"location":"about/contribute/#_14","text":"\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u7684\u5f88\u591a\u6587\u7ae0\u5747\u6d89\u53ca\u4e2d\u3001\u82f1\u53cc\u8bed\u3002\u5728\u7f16\u64b0\u6587\u7ae0\u65f6\uff0c\u5e94\u6ce8\u610f\u4ee5\u4e0b\u4e24\u70b9\uff1a \u8bed\u8a00\u7eaf\u6d01 \u9664\u975e\u7279\u6b8a\u60c5\u51b5\uff0c\u7981\u6b62\u5728\u4e00\u79cd\u8bed\u8a00\u5f53\u4e2d\u5939\u6742\u53e6\u4e00\u79cd\u8bed\u8a00\u3002 \u7ffb\u8bd1\u5e94\u5f53\u5c3d\u91cf\u4f7f\u7528\u884c\u4e1a\u7edf\u4e00\u7684\u672f\u8bed\uff0c\u6bd4\u5982 \u673a\u5668\u5b66\u4e60\u672f\u8bed\u8868 \u3002 \u4f8b\u5916\u60c5\u51b5 \u5e7f\u4e3a\u4eba\u77e5\u7684\u540d\u5b57 \u6ca1\u6709\u53ef\u4fe1\u7684\u7ffb\u8bd1 \u51c6\u786e\u7ffb\u8bd1 \u7ffb\u8bd1\u5e94\u5f53\u5c3d\u53ef\u80fd\u4fdd\u8bc1\u51c6\u786e\uff0c\u4e0d\u7834\u574f\u539f\u6587\u610f\u601d\u3002 \u4e0d\u8fc7\u5ea6\u7ffb\u8bd1 \u80fd\u6839\u636e\u524d\u540e\u6587\u5f97\u51fa\u7684\u5185\u5bb9\u4e0d\u9700\u7279\u610f\u6dfb\u52a0\u3002 \u4e25\u7981\u5c06\u201dI love you\u201d\u7ffb\u8bd1\u4e3a\u201c\u4eca\u591c\u6708\u8272\u5f88\u7f8e\u201d\u3002 \u5f88\u9ad8\u5174\u80fd\u4e0e\u4f60\u4e00\u8d77\u5206\u4eab\u77e5\u8bc6\u3002","title":"\u591a\u8bed\u8a00"},{"location":"about/curriculum_vitae/","text":"zc@int.ac.cn \u6559\u80b2\u7ecf\u5386 # \u4fe1\u606f\u6280\u672f\u5b66\u58eb # \u6fb3\u5927\u5229\u4e9a\u56fd\u7acb\u5927\u5b66 2017 \u4e8c\u6708 - \u73b0\u5728 \u8bfe\u7a0b \u8ba1\u7b97\u673a\u89c6\u89c9 \u81ea\u7136\u8bed\u8a00\u5904\u7406 \u673a\u5668\u5b66\u4e60\u5bfc\u8bba \u5411\u91cf\u5fae\u79ef\u5206 \u6570\u636e\u5e93 Java \u57fa\u4e8e\u8ba1\u7b97\u673a\u6a21\u62df\u73af\u5883\u7684\u81ea\u52a8\u9a7e\u9a76\u8f85\u52a9 \u8ba1\u7b97\u673a\u89c6\u89c9 ENGN4528 \u57fa\u4e8eMask-RCNN\u7684\u969c\u788d\u7269\u68c0\u6d4b \u57fa\u4e8eSpatialCNN\u7684\u8f66\u9053\u7ebf\u68c0\u6d4b \u57fa\u4e8e\u6d88\u606f\u961f\u5217\u7684\u5fae\u670d\u52a1 \u57fa\u4e8eKubernetes\u7684\u9ad8\u53ef\u7528\u90e8\u7f72 \u8bfe\u7a0b\u8868 \u8f6f\u4ef6\u5f00\u53d1\u65b9\u6cd5 COMP2100 \u57fa\u4e8eRxJava\u3001Retrofit\u3001OkHtttp\u7684\u7f51\u7edc\u6846\u67b6 \u62fc\u5e03\u827a\u672f\uff08\u684c\u6e38\uff09 \u7ed3\u6784\u5316\u7f16\u7a0b\uff08\u9ad8\u7b49\uff09 COMP1140 \u57fa\u4e8eJavaFX\u7684\u56fe\u5f62\u5316\u7528\u6237\u754c\u9762\u8bbe\u8ba1 \u57fa\u4e8e\u9057\u4f20\u7b97\u6cd5\u7684\u4eba\u5de5\u667a\u80fd\u73a9\u5bb6 \u6691\u671f\u7814\u7a76 # \u5317\u4eac\u5927\u5b66\u524d\u6cbf\u8ba1\u7b97\u7814\u7a76\u4e2d\u5fc3 \u89c6\u89c9\u8ba1\u7b97\u4e0e\u5b66\u4e60\u5b9e\u9a8c\u5ba4 2019 \u4e03\u6708 - \u4e5d\u6708 \u77f3\u5934\u526a\u5200\u5e03 \u76ee\u6807\u68c0\u6d4b\u7b97\u6cd5 \u5de5\u4f5c\u7ecf\u5386 # \u89c1\u4e60\u7814\u7a76\u5458 # \u5546\u6c64\u79d1\u6280 \u4e09\u7ef4\u89c6\u89c9\u4e0e\u589e\u5f3a\u73b0\u5b9e 2019 \u5341\u4e8c\u6708 - \u73b0\u5728 \u5355\u76ee\u6807\u8ddf\u8e2a \u5b6a\u751f\u67b6\u6784\u7684\u76ee\u6807\u8ddf\u8e2a SiamMargin SiamRPN++ SiamRPN SiamFC PySOT\u5f00\u6e90\u9879\u76ee PySOT\u5f00\u6e90\u9879\u76ee\u7684\u7ef4\u62a4 \u52a9\u6559 # \u5317\u4eac\u5927\u5b66 \u5de5\u5b66\u9662 2019 \u516d\u6708 - 2019 \u4e03\u6708 \u4f18\u5316\u548c\u5b66\u4e60\u7684\u6a21\u62df\u65b9\u6cd5 \u8499\u7279\u5361\u6d1b\u7b97\u6cd5 \u51f8\u4f18\u5316 \u7efc\u5408\u6c34\u8d44\u6e90\u7ba1\u7406\uff1a\u56fd\u9645\u89c6\u89d2 \u5b9e\u5730\u8003\u5bdf\u5e26\u961f\u52a9\u7406 \u8d44\u6df1\u5b66\u751f\u52a9\u7406 # \u5317\u4eac\u5927\u5b66 \u7559\u5b66\u751f\u529e\u516c\u5ba4 2019 \u516d\u6708 - 2019 \u4e03\u6708 \u5b66\u751f\u670d\u52a1 \u5b66\u751f\u7ba1\u7406 \u6d3b\u52a8\u7ec4\u7ec7 \u89c6\u9891\u6444\u5236 \u89c6\u9891\u62cd\u6444 \u5b9e\u4e60\u751f # \u8054\u60f3 \u8054\u60f3\u7814\u7a76\u9662 2018 \u5341\u4e00\u6708 - 2019 \u4e8c\u6708 .Net\u524d\u7aef Windows\u5ba2\u6237\u7aef Python\u4e2d\u95f4\u4ef6 \u5e76\u53d1 RabbitMQ Redis Java\u540e\u7aef SpringMVC RabbitMQ MySQL \u7b97\u6cd5\u9ad8\u53ef\u7528\u5c01\u88c5\u4e0e\u8c03\u5ea6 Kubernetes Rancher Docker \u5b66\u751f\u52a9\u7406 # \u5317\u4eac\u5927\u5b66 \u7559\u5b66\u751f\u529e\u516c\u5ba4 2018 \u516d\u6708 - 2018 \u516b\u6708 \u5b66\u751f\u670d\u52a1 \u5b66\u751f\u7ba1\u7406 \u6d3b\u52a8\u7ec4\u7ec7 \u89c6\u9891\u6444\u5236 \u89c6\u9891\u62cd\u6444 \u52a9\u6559 # \u5b66\u4e3a\u8d35 \u5170\u5dde\u5206\u6821 2017 \u5341\u4e8c\u6708 - 2018 \u4e00\u6708 \u9879\u76ee\u7ecf\u5386 # \u5317\u5927\u672a\u540dBBS\u5b89\u5353\u5ba2\u6237\u7aef # \u5317\u4eac\u5927\u5b66 \u5317\u4eac\u5927\u5b66\u9752\u5e74\u7814\u7a76\u4e2d\u5fc3 2018 \u5341\u4e00\u6708 - \u73b0\u5728 \u5317\u5927\u672a\u540dBBS\u5b89\u5353\u5ba2\u6237\u7aef Project ZCbot # \u4e2a\u4eba\u9879\u76ee 2018 \u5341\u4e00\u6708 - \u73b0\u5728 \u4e00\u952e\u62a5\u8b66 \u81ea\u52a8\u56de\u590d\u3001\u62c9\u7fa4\u7b49 \u684c\u6e38\u673a\u5668\u4eba\u6cd5\u5b98 \u7b2c\u4e00\u6444\u5f71\u52a9\u7406 # \u65e9\u6849 2018 \u56db\u6708 - 2018 \u4e94\u6708 \u6444\u5f71\u673a\u64cd\u4f5c \u65e0\u4eba\u673a\u64cd\u4f5c \u6267\u884c\u5bfc\u6f14 # \u4e00\u6b21\u522b\u79bb \u5fae\u7535\u5f71 2017 \u4e03\u6708 - 2017 \u4e5d\u6708 \u5f55\u97f3 \u706f\u5149 \u65e0\u4eba\u673a\u64cd\u4f5c \u5fd7\u613f\u7ecf\u5386 # SET4ANU\u5fd7\u613f\u8005 # \u6fb3\u5927\u5229\u4e9a\u56fd\u7acb\u5927\u5b66 DRSS 2019 \u4e8c\u6708 - 2019 \u4e8c\u6708 \u6821\u56ed\u6e38\u89c8 \u7591\u95ee\u89e3\u7b54 \u6d3b\u52a8\u961f\u5458 # UniLodge Australia Weeden Lodge 2017 \u4e00\u6708 - 2017 \u5341\u4e8c\u6708 \u6d3b\u52a8\u7ec4\u7ec7 \u4eba\u9053\u5b89\u7f6e\u5fd7\u613f\u8005 # \u6fb3\u5927\u5229\u4e9a\u7ea2\u5341\u5b57\u4f1a \u6fb3\u5927\u5229\u4e9a\u9996\u90fd\u9886\u5730\u5206\u90e8 2016 - 2018 \u534f\u52a9\u96be\u6c11\u5728\u582a\u57f9\u62c9\u5b89\u7f6e \u65b0\u5a92\u4f53\u8fd0\u8425 # \u767e\u5ea6 \u767e\u79d1\u6821\u56ed 2016 - 2016 \u521b\u5efa\u5e76\u7ba1\u7406\u767e\u79d1\u6821\u56ed\u65b0\u5a92\u4f53\u8fd0\u8425\u56e2\u961f\uff0c\u767e\u79d1MT \u767e\u79d1\u6821\u56ed\u8d34\u5427\u3001\u5fae\u4fe1\u516c\u4f17\u53f7\u3001\u5fae\u535a\u7684\u8fd0\u8425 \u767e\u79d1\u6821\u56ed\u6d3b\u52a8\u7684\u7ebf\u4e0a\u652f\u6301 \u6307\u5bfc\u767e\u79d1\u6821\u56ed\u5206\u90e8\u65b0\u5a92\u4f53\u56e2\u961f\u7684\u8fd0\u8425","title":"\u9648\u965f\u539f"},{"location":"about/curriculum_vitae/#_1","text":"","title":"\u6559\u80b2\u7ecf\u5386"},{"location":"about/curriculum_vitae/#_2","text":"\u6fb3\u5927\u5229\u4e9a\u56fd\u7acb\u5927\u5b66 2017 \u4e8c\u6708 - \u73b0\u5728 \u8bfe\u7a0b \u8ba1\u7b97\u673a\u89c6\u89c9 \u81ea\u7136\u8bed\u8a00\u5904\u7406 \u673a\u5668\u5b66\u4e60\u5bfc\u8bba \u5411\u91cf\u5fae\u79ef\u5206 \u6570\u636e\u5e93 Java \u57fa\u4e8e\u8ba1\u7b97\u673a\u6a21\u62df\u73af\u5883\u7684\u81ea\u52a8\u9a7e\u9a76\u8f85\u52a9 \u8ba1\u7b97\u673a\u89c6\u89c9 ENGN4528 \u57fa\u4e8eMask-RCNN\u7684\u969c\u788d\u7269\u68c0\u6d4b \u57fa\u4e8eSpatialCNN\u7684\u8f66\u9053\u7ebf\u68c0\u6d4b \u57fa\u4e8e\u6d88\u606f\u961f\u5217\u7684\u5fae\u670d\u52a1 \u57fa\u4e8eKubernetes\u7684\u9ad8\u53ef\u7528\u90e8\u7f72 \u8bfe\u7a0b\u8868 \u8f6f\u4ef6\u5f00\u53d1\u65b9\u6cd5 COMP2100 \u57fa\u4e8eRxJava\u3001Retrofit\u3001OkHtttp\u7684\u7f51\u7edc\u6846\u67b6 \u62fc\u5e03\u827a\u672f\uff08\u684c\u6e38\uff09 \u7ed3\u6784\u5316\u7f16\u7a0b\uff08\u9ad8\u7b49\uff09 COMP1140 \u57fa\u4e8eJavaFX\u7684\u56fe\u5f62\u5316\u7528\u6237\u754c\u9762\u8bbe\u8ba1 \u57fa\u4e8e\u9057\u4f20\u7b97\u6cd5\u7684\u4eba\u5de5\u667a\u80fd\u73a9\u5bb6","title":"\u4fe1\u606f\u6280\u672f\u5b66\u58eb"},{"location":"about/curriculum_vitae/#_3","text":"\u5317\u4eac\u5927\u5b66\u524d\u6cbf\u8ba1\u7b97\u7814\u7a76\u4e2d\u5fc3 \u89c6\u89c9\u8ba1\u7b97\u4e0e\u5b66\u4e60\u5b9e\u9a8c\u5ba4 2019 \u4e03\u6708 - \u4e5d\u6708 \u77f3\u5934\u526a\u5200\u5e03 \u76ee\u6807\u68c0\u6d4b\u7b97\u6cd5","title":"\u6691\u671f\u7814\u7a76"},{"location":"about/curriculum_vitae/#_4","text":"","title":"\u5de5\u4f5c\u7ecf\u5386"},{"location":"about/curriculum_vitae/#_5","text":"\u5546\u6c64\u79d1\u6280 \u4e09\u7ef4\u89c6\u89c9\u4e0e\u589e\u5f3a\u73b0\u5b9e 2019 \u5341\u4e8c\u6708 - \u73b0\u5728 \u5355\u76ee\u6807\u8ddf\u8e2a \u5b6a\u751f\u67b6\u6784\u7684\u76ee\u6807\u8ddf\u8e2a SiamMargin SiamRPN++ SiamRPN SiamFC PySOT\u5f00\u6e90\u9879\u76ee PySOT\u5f00\u6e90\u9879\u76ee\u7684\u7ef4\u62a4","title":"\u89c1\u4e60\u7814\u7a76\u5458"},{"location":"about/curriculum_vitae/#_6","text":"\u5317\u4eac\u5927\u5b66 \u5de5\u5b66\u9662 2019 \u516d\u6708 - 2019 \u4e03\u6708 \u4f18\u5316\u548c\u5b66\u4e60\u7684\u6a21\u62df\u65b9\u6cd5 \u8499\u7279\u5361\u6d1b\u7b97\u6cd5 \u51f8\u4f18\u5316 \u7efc\u5408\u6c34\u8d44\u6e90\u7ba1\u7406\uff1a\u56fd\u9645\u89c6\u89d2 \u5b9e\u5730\u8003\u5bdf\u5e26\u961f\u52a9\u7406","title":"\u52a9\u6559"},{"location":"about/curriculum_vitae/#_7","text":"\u5317\u4eac\u5927\u5b66 \u7559\u5b66\u751f\u529e\u516c\u5ba4 2019 \u516d\u6708 - 2019 \u4e03\u6708 \u5b66\u751f\u670d\u52a1 \u5b66\u751f\u7ba1\u7406 \u6d3b\u52a8\u7ec4\u7ec7 \u89c6\u9891\u6444\u5236 \u89c6\u9891\u62cd\u6444","title":"\u8d44\u6df1\u5b66\u751f\u52a9\u7406"},{"location":"about/curriculum_vitae/#_8","text":"\u8054\u60f3 \u8054\u60f3\u7814\u7a76\u9662 2018 \u5341\u4e00\u6708 - 2019 \u4e8c\u6708 .Net\u524d\u7aef Windows\u5ba2\u6237\u7aef Python\u4e2d\u95f4\u4ef6 \u5e76\u53d1 RabbitMQ Redis Java\u540e\u7aef SpringMVC RabbitMQ MySQL \u7b97\u6cd5\u9ad8\u53ef\u7528\u5c01\u88c5\u4e0e\u8c03\u5ea6 Kubernetes Rancher Docker","title":"\u5b9e\u4e60\u751f"},{"location":"about/curriculum_vitae/#_9","text":"\u5317\u4eac\u5927\u5b66 \u7559\u5b66\u751f\u529e\u516c\u5ba4 2018 \u516d\u6708 - 2018 \u516b\u6708 \u5b66\u751f\u670d\u52a1 \u5b66\u751f\u7ba1\u7406 \u6d3b\u52a8\u7ec4\u7ec7 \u89c6\u9891\u6444\u5236 \u89c6\u9891\u62cd\u6444","title":"\u5b66\u751f\u52a9\u7406"},{"location":"about/curriculum_vitae/#_10","text":"\u5b66\u4e3a\u8d35 \u5170\u5dde\u5206\u6821 2017 \u5341\u4e8c\u6708 - 2018 \u4e00\u6708","title":"\u52a9\u6559"},{"location":"about/curriculum_vitae/#_11","text":"","title":"\u9879\u76ee\u7ecf\u5386"},{"location":"about/curriculum_vitae/#bbs","text":"\u5317\u4eac\u5927\u5b66 \u5317\u4eac\u5927\u5b66\u9752\u5e74\u7814\u7a76\u4e2d\u5fc3 2018 \u5341\u4e00\u6708 - \u73b0\u5728 \u5317\u5927\u672a\u540dBBS\u5b89\u5353\u5ba2\u6237\u7aef","title":"\u5317\u5927\u672a\u540dBBS\u5b89\u5353\u5ba2\u6237\u7aef"},{"location":"about/curriculum_vitae/#project-zcbot","text":"\u4e2a\u4eba\u9879\u76ee 2018 \u5341\u4e00\u6708 - \u73b0\u5728 \u4e00\u952e\u62a5\u8b66 \u81ea\u52a8\u56de\u590d\u3001\u62c9\u7fa4\u7b49 \u684c\u6e38\u673a\u5668\u4eba\u6cd5\u5b98","title":"Project ZCbot"},{"location":"about/curriculum_vitae/#_12","text":"\u65e9\u6849 2018 \u56db\u6708 - 2018 \u4e94\u6708 \u6444\u5f71\u673a\u64cd\u4f5c \u65e0\u4eba\u673a\u64cd\u4f5c","title":"\u7b2c\u4e00\u6444\u5f71\u52a9\u7406"},{"location":"about/curriculum_vitae/#_13","text":"\u4e00\u6b21\u522b\u79bb \u5fae\u7535\u5f71 2017 \u4e03\u6708 - 2017 \u4e5d\u6708 \u5f55\u97f3 \u706f\u5149 \u65e0\u4eba\u673a\u64cd\u4f5c","title":"\u6267\u884c\u5bfc\u6f14"},{"location":"about/curriculum_vitae/#_14","text":"","title":"\u5fd7\u613f\u7ecf\u5386"},{"location":"about/curriculum_vitae/#set4anu","text":"\u6fb3\u5927\u5229\u4e9a\u56fd\u7acb\u5927\u5b66 DRSS 2019 \u4e8c\u6708 - 2019 \u4e8c\u6708 \u6821\u56ed\u6e38\u89c8 \u7591\u95ee\u89e3\u7b54","title":"SET4ANU\u5fd7\u613f\u8005"},{"location":"about/curriculum_vitae/#_15","text":"UniLodge Australia Weeden Lodge 2017 \u4e00\u6708 - 2017 \u5341\u4e8c\u6708 \u6d3b\u52a8\u7ec4\u7ec7","title":"\u6d3b\u52a8\u961f\u5458"},{"location":"about/curriculum_vitae/#_16","text":"\u6fb3\u5927\u5229\u4e9a\u7ea2\u5341\u5b57\u4f1a \u6fb3\u5927\u5229\u4e9a\u9996\u90fd\u9886\u5730\u5206\u90e8 2016 - 2018 \u534f\u52a9\u96be\u6c11\u5728\u582a\u57f9\u62c9\u5b89\u7f6e","title":"\u4eba\u9053\u5b89\u7f6e\u5fd7\u613f\u8005"},{"location":"about/curriculum_vitae/#_17","text":"\u767e\u5ea6 \u767e\u79d1\u6821\u56ed 2016 - 2016 \u521b\u5efa\u5e76\u7ba1\u7406\u767e\u79d1\u6821\u56ed\u65b0\u5a92\u4f53\u8fd0\u8425\u56e2\u961f\uff0c\u767e\u79d1MT \u767e\u79d1\u6821\u56ed\u8d34\u5427\u3001\u5fae\u4fe1\u516c\u4f17\u53f7\u3001\u5fae\u535a\u7684\u8fd0\u8425 \u767e\u79d1\u6821\u56ed\u6d3b\u52a8\u7684\u7ebf\u4e0a\u652f\u6301 \u6307\u5bfc\u767e\u79d1\u6821\u56ed\u5206\u90e8\u65b0\u5a92\u4f53\u56e2\u961f\u7684\u8fd0\u8425","title":"\u65b0\u5a92\u4f53\u8fd0\u8425"},{"location":"about/donate/","text":"\u6211\u4eec\u5f88\u9ad8\u5174\u5982\u679c\u60a8\u8ba4\u4e3a\u8fd9\u4e2a\u7f51\u7ad9\u662f\u6709\u5e2e\u52a9\u7684\u3002 \u77e5\u8bc6\u5e94\u5f53\u662f\u81ea\u7531\u7684\uff0c\u4efb\u4f55\u5f62\u5f0f\u7684\u6350\u8d60\u90fd\u73b7\u6c61\u4e86\u77e5\u8bc6\u7684\u795e\u5723\u6027\u3002 \u4f46\u662f\uff0c\u4e3a\u5f00\u6e90\u8f6f\u4ef6\u6350\u6b3e\u4e0d\u4f1a\u3002 \u60a8\u53ef\u4ee5\u5411 Apache\u57fa\u91d1\u4f1a \u6216\u8005 \u81ea\u7531\u8f6f\u4ef6\u57fa\u91d1\u4f1a \u6350\u6b3e\uff0c\u8ba9\u5f00\u6e90\u8f6f\u4ef6\u5f00\u53d1\u8005\u4eec\u80fd\u4ed8\u5f97\u8d77\u4e00\u987f\u80af\u5fb7\u57fa\u3002 \u6211\u975e\u5e38\u611f\u8c22\u6211\u7236\u6bcd\u4e3a\u6211\u505a\u51fa\u7684\u4e00\u5207\uff0c\u6ca1\u6709\u4ed6\u4eec\u7684\u8f9b\u52e4\u4ed8\u51fa\uff0c\u6211\u4e0d\u53ef\u80fd\u6709\u80fd\u529b\u5236\u4f5c\u8fd9\u4e2a\u7f51\u7ad9\u3002 \u4f46\u662f\uff0c\u4e0d\u662f\u6240\u6709\u4eba\u90fd\u80fd\u8fd9\u6837\u5e78\u8fd0\u3002 \u60a8\u53ef\u4ee5\u5411 \u4e2d\u56fd\u7ea2\u5341\u5b57\u57fa\u91d1\u4f1a \u6216\u8005 \u4e2d\u56fd\u513f\u7ae5\u5c11\u5e74\u57fa\u91d1\u4f1a \u6350\u6b3e\uff0c\u8ba9\u4e0b\u4e00\u4ee3\u80fd\u5750\u5728\u6559\u5ba4\u91cc\u653b\u8bfb\u5b66\u4e1a\u3002 \u6211\u4eec\u975e\u5e38\u611f\u8c22\u5e76\u656c\u4ef0\u60a8\u7684\u5584\u5fc3\u3002","title":"\u6350\u8d60"},{"location":"about/eula/","text":"\u6700\u540e\u4fee\u8ba2 \u672c\u534f\u8bae\u6700\u540e\u4fee\u8ba2\u4e8e2020\u5e7408\u670816\u65e5\u3002 \u611f\u8c22\u60a8\u8bbf\u95eezyc.ai\u3002 \u6211\u4eec\u76f8\u4fe1\uff0c\u8ba1\u7b97\u673a\u79d1\u5b66\u4f7f\u8fd9\u4e2a\u4e16\u754c\u66f4\u7f8e\u597d\u3002 \u672c\u6700\u7ec8\u7528\u6237\u8bb8\u53ef\u534f\u8bae\uff08\u4ee5\u4e0b\u7b80\u79f0\u672c\u534f\u8bae\uff09\u662f\u60a8\uff08\u4e2a\u4eba\u6216\u5b9e\u4f53\uff09\u4e0e\u6211\u4eec\uff08zyc.ai\uff09\u4e4b\u95f4\u5c31\u6211\u4eec\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u8fbe\u6210\u7684\u6cd5\u5f8b\u534f\u8bae\u3002\u672c\u534f\u8bae\u4ea6\u9002\u7528\u4e8e\u4e0a\u8ff0\u5185\u5bb9\u7684\u4efb\u4f55\u66f4\u65b0\u6216\u8865\u4e01\u3002 \u5185\u5bb9 \u672c\u534f\u8bae\u6240\u79f0\u7684\u5185\u5bb9\u662f\u6307\u6211\u4eec\u62e5\u6709\u8457\u4f5c\u6743\u6216\u6709\u6743\u4f7f\u7528\u7684\u5185\u5bb9\uff0c\u5305\u62ec\u4f46\u4e0d\u9650\u4e8e\u4ea7\u54c1\u3001\u8f6f\u4ef6\u3001\u786c\u4ef6\u3001\u6e90\u7801\u3001\u5de5\u5177\u3001\u6750\u6599\u3001\u56fe\u7eb8\u3001\u6570\u636e\u3001\u89c6\u9891\u3001\u56fe\u50cf\u3001\u97f3\u9891\u3001\u6587\u6863\u53ca\u5176\u4ed6\u53ef\u88ab\u89c6\u4e3a\u5185\u5bb9\u7684\u4e8c\u8fdb\u5236\u6216\u975e\u4e8c\u8fdb\u5236\u6587\u4ef6\u4ee5\u53ca\u8f7d\u6709\u5176\u7684\u7eb8\u5f20\u3001\u5149\u76d8\u3001U\u76d8\u7b49\u7269\u7406\u8f7d\u4f53\u3002 \u53ea\u6709\u5f53\u60a8\u63a5\u53d7\u672c\u534f\u8bae\u65f6\uff0c\u6211\u4eec\u624d\u8bb8\u53ef\u60a8\u4f7f\u7528\u6211\u4eec\u5411\u60a8\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u3002\u4e0b\u8f7d\u3001\u5b89\u88c5\u3001\u590d\u5236\u6216\u4f7f\u7528\u6211\u4eec\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u5373\u8868\u793a\u60a8\u63a5\u53d7\u672c\u534f\u8bae\u7684\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\u3002\u5982\u679c\u60a8\u4e0d\u63a5\u53d7\u4e0a\u8ff0\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\uff0c\u8bf7\u4e0d\u8981\u4e0b\u8f7d\u3001\u5b89\u88c5\u3001\u590d\u5236\u548c\u4f7f\u7528\u4e0a\u8ff0\u5185\u5bb9\u3002\u5982\u60a8\u5df2\u5b89\u88c5\u3001\u4e0b\u8f7d\u3001\u590d\u5236\u6216\u4f7f\u7528\u4e0a\u8ff0\u5185\u5bb9\uff0c\u8bf7\u5c06\u5176\u5378\u8f7d\u5e76\u5220\u9664\u5168\u90e8\u526f\u672c\u53ca\u5176\u5168\u90e8\u7ec4\u6210\u90e8\u5206\u6216\u505c\u6b62\u4f7f\u7528\u3002 \u5982\u60a8\u8fdd\u53cd\u672c\u534f\u8bae\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\uff0c\u6211\u4eec\u5c06\u4fdd\u7559\u8ffd\u7a76\u60a8\u76f8\u5173\u6cd5\u5f8b\u8d23\u4efb\u7684\u6743\u5229\u3002 1 \u8bb8\u53ef # 1.1 \u63d0\u4f9b\u7684\u5185\u5bb9 # \u6211\u4eec\u4f9d\u636eGNU GPLv3\u5411\u60a8\u6388\u4e88\u5bf9\u6211\u4eec\u6240\u63d0\u4f9b\u7684\u5185\u5bb9\u7684\u4f7f\u7528\u6743\u5229\u3002 1.2 \u8fd0\u8425\u7684\u5185\u5bb9 # \u82e5\u60a8\u9075\u5b88\u672c\u534f\u8bae\u5404\u9879\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\u548c\u6761\u4ef6\uff0c\u6211\u4eec\u5c06\u6388\u4e88\u60a8\u4ee5\u4e0b\u975e\u4e13\u6709\u7684\u3001\u6c38\u4e45\u6027\u7684\uff0c\u5e76\u4e14\u53ef\u64a4\u9500\u7684\u6388\u6743\u8bb8\u53ef\uff1a 1.2.1 \u4f7f\u7528 # \u60a8\u6709\u6743\u5728\u4fdd\u8bc1\u5584\u610f\u4f7f\u7528\u7684\u60c5\u51b5\u4e0b\uff0c\u4f9d\u636e\u76f8\u5173\u6cd5\u5f8b\u6cd5\u89c4\u53ca\u9002\u7528\u7684\u56fd\u9645\u6cd5\u4f7f\u7528\u6211\u4eec\u6240\u8fd0\u8425\u7684\u5185\u5bb9\u3002 \u60a8\u4e0d\u5f97\u5c06\u6211\u4eec\u6240\u8fd0\u8425\u7684\u5185\u5bb9\u7528\u4e8e\u8fdd\u6cd5\u3001\u72af\u7f6a\u6d3b\u52a8\u53ca\u5176\u4ed6\u88ab\u8ba4\u4e3a\u6216\u53ef\u80fd\u88ab\u8ba4\u4e3a\u6709\u5bb3\u793e\u4f1a\u7684\u884c\u4e3a\u3002 1.2.2 \u8f6c\u53d1 # \u5982\u679c\u60a8\u5728\u60a8\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u4e2d\u4f7f\u7528\u6216\u8005\u90e8\u5206\u4f7f\u7528\u6211\u4eec\u6240\u8fd0\u8425\u7684\u5185\u5bb9\uff0c\u5219\u60a8\u5fc5\u987b\u5c06\u5176\u6309\u7167\u672c\u534f\u8bae\u7b2c1\u7ae0\u89c4\u5b9a\u7684\u4e24\u79cd\u65b9\u5f0f\u4e4b\u4e00\u5c06\u8be5\u5185\u5bb9\u6574\u4f53\u5411\u60f3\u8981\u83b7\u5f97\u8bb8\u53ef\u7684\u4eba\u6388\u6743\u3002\u672c\u534f\u8bae\u5c31\u6b64\u9002\u7528\u4e8e\u6574\u4e2a\u4f5c\u54c1\uff0c\u5373\u5176\u6bcf\u4e00\u90e8\u5206\uff0c\u4e0d\u7ba1\u5982\u4f55\u5efa\u5305\u3002\u672c\u534f\u8bae\u4e0d\u5141\u8bb8\u4ee5\u5176\u4ed6\u5f62\u5f0f\u6388\u6743\u8be5\u4f5c\u54c1\uff0c\u4f46\u5018\u82e5\u60a8\u6536\u5230\u5176\u4ed6\u8bb8\u53ef\u5219\u53e6\u5f53\u522b\u8bba\u3002 \u60a8\u987b\u5728\u60a8\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u6216\u5728\u9002\u5f53\u7684\u6cd5\u5f8b\u58f0\u660e\u4e2d\u4fdd\u7559\u6211\u4eec\u7684\u6807\u8bc6\u53ca\u53ef\u4ee5\u8ffd\u6eaf\u5230\u6211\u4eec\u6240\u63d0\u4f9b\u7684\u539f\u59cb\u6765\u6e90\u7684\u521b\u4f5c\u5370\u8bb0\uff08\u5982\u679c\u6709\uff09\u3002\u5982\u679c\u60a8\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u6709\u4ea4\u4e92\u5f0f\u7528\u6237\u754c\u9762\uff0c\u90a3\u4e48\u5176\u8fd8\u987b\u663e\u793a\u9002\u5f53\u7684\u6cd5\u5f8b\u58f0\u660e\u3002 \u5373\u4fbf\u60a8\u9762\u4e34\u4e0e\u672c\u534f\u8bae\u6761\u6b3e\u51b2\u7a81\u7684\u6761\u4ef6\uff08\u6765\u81ea\u4e8e\u6cd5\u5ead\u8981\u6c42\u3001\u534f\u8bae\u6216\u5176\u4ed6\uff09\uff0c\u90a3\u4e5f\u4e0d\u80fd\u6210\u4e3a\u60a8\u8fdd\u80cc\u672c\u534f\u8bae\u7684\u7406\u7531\u3002\u5018\u82e5\u60a8\u4e0d\u80fd\u5728\u8f6c\u53d1\u53d7\u4fdd\u62a4\u4f5c\u54c1\u65f6\u540c\u65f6\u6ee1\u8db3\u672c\u534f\u8bae\u548c\u5176\u4ed6\u6587\u4ef6\u7684\u8981\u6c42\uff0c\u60a8\u5c31\u4e0d\u80fd\u8f6c\u53d1\u4e0a\u8ff0\u5185\u5bb9\u3002 1.3 \u7b2c\u4e09\u65b9\u5185\u5bb9 # \u67d0\u4e9b\u6211\u4eec\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u4ee5\u53ca\u5c06\u6765\u7684\u66f4\u65b0\u53ef\u80fd\u5305\u542b\u7b2c\u4e09\u65b9\u7684\u4ea7\u54c1\u548c\u670d\u52a1\u3002\u8fd9\u4e9b\u7b2c\u4e09\u65b9\u7ec4\u4ef6\u5c06\u6309\u7167\u5355\u72ec\u7684\u3001\u4e0d\u540c\u4e8e\u672c\u534f\u8bae\u7684\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\u548c\u6761\u4ef6\u5411\u60a8\u63d0\u4f9b\uff0c\u8fd9\u4e9b\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\u548c\u6761\u4ef6\u901a\u5e38\u53ef\u4ee5\u5728\u5355\u72ec\u7684\u8bb8\u53ef\u534f\u8bae\u6216\u201d\u81ea\u8ff0\u6587\u4ef6\uff08README\uff09\u201d\u6216\u5176\u4ed6\u7c7b\u4f3c\u6807\u9898\u7684\u6587\u4ef6\u4e2d\u627e\u5230\u3002\u8be5\u7b2c\u4e09\u65b9\u7684\u8bb8\u53ef\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\u548c\u4f7f\u7528\u9650\u5236\u4ec5\u9002\u7528\u4e8e\u6b64\u7c7b\u7ec4\u4ef6\u7684\u4f7f\u7528\u3002 \u5982\u7b2c\u4e09\u65b9\u6ca1\u6709\u72ec\u7acb\u7684\u8bb8\u53ef\u534f\u8bae\u6216\u81ea\u8ff0\u6587\u4ef6\uff0c\u5219\u9002\u7528\u672c\u534f\u8bae\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\u7684\u5236\u7ea6\u3002 1.4 \u8bb8\u53ef\u4e2d\u6b62 # \u5982\u679c\u60a8\u672a\u9075\u5b88\u672c\u534f\u8bae\u7684\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\u548c\u6761\u4ef6\uff0c\u672c\u534f\u8bae\u81ea\u52a8\u7ec8\u6b62\uff0c\u60a8\u88ab\u6388\u4e88\u7684\u6388\u6743\u5c06\u88ab\u5373\u65f6\u64a4\u9500\u3002 \u5982\u6b64\u7c7b\u60c5\u51b5\u53d1\u751f\uff0c\u60a8\u987b\u7acb\u5373\u9500\u6bc1\u6211\u4eec\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u7684\u6240\u6709\u526f\u672c\u53ca\u5176\u5168\u90e8\u7ec4\u6210\u90e8\u4efd\u3002 2 \u670d\u52a1\u8303\u56f4 # \u6211\u4eec\u5728\u672c\u534f\u8bae\u4e0b\u63d0\u4f9b\u7684\u610f\u89c1\u3001\u7ed3\u8bba\u6216\u5efa\u8bae\u5747\u5c5e\u4e8e\u987e\u95ee\u548c\u54a8\u8be2\u6027\u8d28\uff0c\u60a8\u5e94\u81ea\u884c\u51b3\u5b9a\u662f\u5426\u4ee5\u53ca\u5982\u4f55\u4f7f\u7528\u6211\u4eec\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\uff0c\u5e76\u72ec\u7acb\u627f\u62c5\u56e0\u6b64\u6240\u4ea7\u751f\u7684\u4e00\u5207\u6cd5\u5f8b\u540e\u679c\u3002 \u60a8\u7406\u89e3\u5e76\u540c\u610f\uff0c\u6211\u4eec\u4e0d\u4fdd\u8bc1\u4efb\u4f55\u5185\u5bb9\u4e0d\u4e2d\u65ad\u64cd\u4f5c\u6216\u5b8c\u5168\u6b63\u786e\uff0c\u4e5f\u4e0d\u4fdd\u8bc1\u6211\u4eec\u80fd\u591f\u7ea0\u6b63\u6240\u6709\u7f3a\u9677\u6216\u95ee\u9898\u3002 \u6211\u4eec\u7279\u522b\u63d0\u8bf7\u60a8\u6ce8\u610f\uff0c\u4e3a\u4fdd\u969c\u6211\u4eec\u4e1a\u52a1\u53d1\u5c55\u548c\u8c03\u6574\u7684\u81ea\u4e3b\u6743\uff0c\u9664\u975e\u6211\u4eec\u53e6\u6709\u4e0d\u540c\u7684\u4e66\u9762\u660e\u786e\u627f\u8bfa\uff0c\u6211\u4eec\u53ef\u968f\u65f6\u81ea\u884c\u4fee\u6539\u6216\u4e2d\u65ad\u4e0a\u8ff0\u5185\u5bb9\u6216\u5176\u4ed6\u6211\u4eec\u660e\u786e\u627f\u8bfa\u63d0\u4f9b\u7684\u5185\u5bb9\u800c\u65e0\u987b\u901a\u77e5\u60a8\u3002 \u6211\u4eec\u5408\u6cd5\u62e5\u6709\u4e00\u5207\u5728\u670d\u52a1\u671f\u95f4\u65b0\u5f00\u53d1\u3001\u521b\u4f5c\u7684\u5de5\u4f5c\u6210\u679c\u7684\u77e5\u8bc6\u4ea7\u6743\u3002 \u6211\u4eec\u4fdd\u8bc1\u5c06\u4ee5\u5ba1\u614e\u6001\u5ea6\u4e0e\u4e13\u4e1a\u6280\u80fd\u63d0\u4f9b\u4e0a\u8ff0\u5185\u5bb9\uff0c\u5e76\u4e14\u6240\u63d0\u4f9b\u7684\u670d\u52a1\u5c06\u9075\u5faa\u4e1a\u754c\u63d0\u4f9b\u6b64\u7c7b\u670d\u52a1\u7684\u826f\u597d\u60ef\u4f8b\u3002\u4e0a\u8ff0\u4fdd\u8bc1\u662f\u6211\u4eec\u5c31\u672c\u534f\u8bae\u9879\u4e0b\u7684\u5185\u5bb9\u505a\u51fa\u7684\u5168\u90e8\u4fdd\u8bc1\u3002\u6211\u4eec\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u4e0d\u5e94\u56e0\u4e0e\u7ea6\u5b9a\u7684\u5de5\u4f5c\u89c4\u683c\u3001\u6807\u51c6\u6216\u8981\u6c42\u4e0d\u7b26\u800c\u88ab\u8ba4\u4e3a\u4e0d\u5408\u683c\u3002 3 \u8d23\u4efb\u514d\u9664 # \u6211\u4eec\u5bf9\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u4ee5\u53ca\u5c06\u6765\u7684\u66f4\u65b0\u53ef\u80fd\u5305\u542b\u7b2c\u4e09\u65b9\u7684\u4ea7\u54c1\u548c\u670d\u52a1\u4ee5\u53ca\u8bb8\u53ef\u6750\u6599\uff0c\u5305\u62ec\u4efb\u4f55\u7ec8\u7aef\u7528\u6237\u6587\u6863\u3001\u8f6f\u4ef6\u3001\u7ef4\u62a4\u5347\u7ea7\u3001\u6587\u4ef6\u53ca\u5176\u5b83\u6750\u6599\u5747\u4f9d\u73b0\u72b6\u63d0\u4f9b\u3002 \u6211\u4eec\u5426\u8ba4\u4e00\u5207\u660e\u793a\u6216\u9ed8\u793a\u7684\u4fdd\u8bc1\u3001\u6761\u4ef6\u548c\u5176\u4ed6\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\uff08\u4e0d\u8bba\u662f\u6210\u6587\u6cd5\u3001\u666e\u901a\u6cd5\u89c4\u5b9a\u7684\u3001\u9644\u5e26\u7684\u6216\u5176\u4ed6\u7684\uff09\uff0c\u5305\u62ec\u4f46\u4e0d\u9650\u4e8e\u4e0a\u8ff0\u5185\u5bb9\u7684\u771f\u5b9e\u6027\u548c\u51c6\u786e\u6027\u7684\u9ed8\u793a\u4fdd\u8bc1\u3002\u4e0d\u80fd\u4e88\u4ee5\u6392\u9664\u7684\u4efb\u4f55\u9ed8\u793a\u4fdd\u8bc1\u4ec5\u9650\u4e8e\u9002\u7528\u6cd5\u5f8b\u5141\u8bb8\u7684\u6700\u77ed\u671f\u95f4\u5185\u6709\u6548\u3002\u6211\u4eec\u4e5f\u4e0d\u5bf9\u4e0a\u8ff0\u5185\u5bb9\u662f\u5426\u4fb5\u72af\u4efb\u4f55\u7b2c\u4e09\u65b9\u7684\u4efb\u4f55\u77e5\u8bc6\u4ea7\u6743\u4f5c\u4efb\u4f55\u4fdd\u8bc1\u3002 \u5728\u9002\u7528\u6cd5\u5f8b\u5141\u8bb8\u7684\u6700\u5927\u8303\u56f4\u5185\uff0c\u6211\u4eec\u5747\u4e0d\u5bf9\u4efb\u4f55\u4f7f\u7528\u6216\u4e0d\u80fd\u4f7f\u7528\u4e0a\u8ff0\u5185\u5bb9\u800c\u53d1\u751f\u7684\u635f\u5bb3\u8d1f\u8d23\uff0c\u4e5f\u4e0d\u5bf9\u56e0\u4f7f\u7528\u4e0a\u8ff0\u5185\u5bb9\u5bfc\u81f4\u7684\u6216\u4e0e\u6b64\u6709\u5173\u7684\u4efb\u4f55\u7279\u6b8a\u7684\u3001\u9644\u5e26\u53d1\u751f\u7684\u6216\u95f4\u63a5\u7684\u635f\u5bb3\u8d1f\u8d23\u3002\u5373\u4f7f\u6211\u4eec\u77e5\u9053\u6216\u5e94\u8be5\u77e5\u9053\u635f\u5bb3\u7684\u53ef\u80fd\u3002 \u9664\u6839\u636e\u9002\u7528\u6cd5\u5f8b\u4e0d\u80fd\u514d\u9664\u6216\u9650\u5236\u7684\u8d23\u4efb\u5916\uff0c\u60a8\u653e\u5f03\u5411\u6211\u4eec\u8981\u6c42\u8d54\u507f\u635f\u5931\u7684\u6743\u5229\uff08\u5305\u62ec\u91cd\u5927\u8fdd\u7ea6\u3001\u8fc7\u5931\u3001\u865a\u5047\u9648\u8ff0\u6216\u5176\u4ed6\u5408\u540c\u6216\u4fb5\u6743\u65b9\u9762\u7684\u7d22\u8d54\uff09\u3002\u5728\u4efb\u4f55\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5bf9\u4e0b\u5217\u60c5\u5f62\u5747\u4e0d\u627f\u62c5\u8d23\u4efb\uff0c\u5373\u4f7f\u77e5\u9053\u6216\u5e94\u8be5\u77e5\u9053\u8be5\u60c5\u5f62\u6709\u53ef\u80fd\u53d1\u751f\uff1a \u7b2c\u4e09\u65b9\u5411\u60a8\u63d0\u51fa\u7684\u7d22\u8d54\uff1b \u60a8\u7684\u6570\u636e\u4e22\u5931\u6216\u635f\u574f\uff1b \u7279\u6b8a\u7684\u3001\u9644\u5e26\u7684\u6216\u95f4\u63a5\u7684\u635f\u5bb3\u8d54\u507f\u6216\u4efb\u4f55\u540e\u679c\u6027\u7684\u7ecf\u6d4e\u635f\u5bb3\u8d54\u507f\uff0c\u5305\u62ec\u5229\u6da6\u3001\u4e1a\u52a1\u6536\u5165\u3001\u5546\u8a89\u6216\u9884\u671f\u8282\u4f59\u7684\u635f\u5931\u3002 \u5728\u76f8\u5173\u6cd5\u5f8b\u6cd5\u89c4\u4e0e\u9002\u7528\u7684\u56fd\u9645\u6cd5\u89c4\u5b9a\u7684\u6700\u5927\u8303\u56f4\u4e4b\u5185\u6392\u9664\u6211\u4eec\u7684\u8d23\u4efb\u3002 \u67d0\u4e9b\u56fd\u5bb6/\u5730\u533a\u6216\u53f8\u6cd5\u7ba1\u8f96\u533a\u4e0d\u5141\u8bb8\u5bf9\u9644\u5e26\u7684\u6216\u540e\u679c\u6027\u7684\u635f\u5bb3\u8d54\u507f\u8fdb\u884c\u6392\u9664\u6216\u9650\u5236\uff0c\u5982\u679c\u8fd9\u6837\uff0c\u5219\u4e0a\u8ff0\u6392\u9664\u6216\u9650\u5236\u53ef\u80fd\u4e0d\u9002\u7528\u4e8e\u60a8\u3002 \u672c\u534f\u8bae\u7684\u4efb\u4f55\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\u5747\u4e0d\u5f71\u54cd\u4e0d\u80fd\u901a\u8fc7\u5408\u540c\u4e88\u4ee5\u653e\u5f03\u6216\u9650\u5236\u7684\u6d88\u8d39\u8005\u7684\u4efb\u4f55\u6cd5\u5b9a\u6743\u5229\u3002\u672c\u534f\u8bae\u4e5f\u4e0d\u6539\u53d8\u6839\u636e\u53ef\u9002\u7528\u7684\u5f53\u5730\u6cd5\u5f8b\u6846\u67b6\u4fdd\u62a4\u4e0b\u60a8\u53ef\u80fd\u62e5\u6709\u7684\u5176\u4ed6\u6743\u5229\u3002 4 \u672c\u534f\u8bae\u7684\u4fee\u8ba2 # \u6211\u4eec\u53ef\u80fd\u4f1a\u4e0d\u65f6\u66f4\u6539\u672c\u534f\u8bae\uff0c\u4f7f\u4e4b\u80fd\u591f\u51c6\u786e\u53cd\u6620\u6211\u4eec\u7684\u505a\u6cd5\u3001zyc.ai\u5185\u5bb9\u53ca\u6cd5\u5f8b\u8981\u6c42\u3002 \u672c\u58f0\u660e\u9876\u90e8\u7684\u201c\u4e0a\u6b21\u4fee\u6539\u65e5\u671f\u201d\u90e8\u5206\u6307\u51fa\u4e86\u4e0a\u6b21\u4fee\u8ba2\u672c\u534f\u8bae\u7684\u65e5\u671f\uff0c\u6bcf\u6b21\u53d1\u5e03\u4fee\u8ba2\u65f6\u6211\u4eec\u90fd\u4f1a\u66f4\u65b0\u6b64\u65e5\u671f\u3002\u5bf9\u672c\u534f\u8bae\u7684\u4efb\u4f55\u66f4\u6539\u5c06\u5728\u6211\u4eec\u901a\u8fc7\u516c\u5e03\u4fee\u8ba2\u7248\u6700\u7ec8\u7528\u6237\u8bb8\u53ef\u534f\u8bae\u65f6\u751f\u6548\u3002 \u6211\u4eec\u9f13\u52b1\u60a8\u5b9a\u671f\u67e5\u770b\u672c\u534f\u8bae\uff0c\u4e86\u89e3\u6211\u4eec\u5982\u4f55\u63d0\u4f9b\u5185\u5bb9\u3002 5 \u9002\u7528\u8303\u56f4 # zyc.ai\u8ba4\u4e3a\u5f00\u653e\u4e0e\u9690\u79c1\u5bf9\u6211\u4eec\u53ca\u6211\u4eec\u7684\u7528\u6237\u5341\u5206\u91cd\u8981\u3002 \u56e0\u6b64\uff0c\u672c\u534f\u8bae\u5c06\u9002\u7528\u4e8e\u4efb\u4f55zyc.ai\u5185\u5bb9\u7684\u884d\u751f\u4f5c\u54c1\u3002 \u5982\u679c\u60a8\u7684\u4f5c\u54c1\u884d\u751f\u81ea\u3001\u4f7f\u7528\u6216\u8005\u90e8\u5206\u4f7f\u7528zyc.ai\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\uff0c\u60a8\u5fc5\u987b\u5c06\u5176\u6309\u7167\u4e0e\u672c\u534f\u8bae\u89c4\u5b9a\u7684\u76f8\u540c\u65b9\u5f0f\u5c06\u8be5\u4f5c\u54c1\u6216\u670d\u52a1\u6574\u4f53\u5411\u60f3\u8981\u83b7\u5f97\u8bb8\u53ef\u7684\u4eba\u6388\u6743\u3002 \u5982\u679c\u60a8\u4e0d\u80fd\u6309\u7167\u672c\u534f\u8bae\u7684\u8981\u6c42\u6765\u63d0\u4f9b\u6216\u8fd0\u8425\u5185\u5bb9\uff0c\u90a3\u4e48\u60a8\u5c06\u4e0d\u80fd\u63d0\u4f9b\u6216\u8fd0\u8425\u5b83\u4eec\u3002","title":"\u6700\u7ec8\u7528\u6237\u8bb8\u53ef\u534f\u8bae"},{"location":"about/eula/#1","text":"","title":"1 \u8bb8\u53ef"},{"location":"about/eula/#11","text":"\u6211\u4eec\u4f9d\u636eGNU GPLv3\u5411\u60a8\u6388\u4e88\u5bf9\u6211\u4eec\u6240\u63d0\u4f9b\u7684\u5185\u5bb9\u7684\u4f7f\u7528\u6743\u5229\u3002","title":"1.1 \u63d0\u4f9b\u7684\u5185\u5bb9"},{"location":"about/eula/#12","text":"\u82e5\u60a8\u9075\u5b88\u672c\u534f\u8bae\u5404\u9879\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\u548c\u6761\u4ef6\uff0c\u6211\u4eec\u5c06\u6388\u4e88\u60a8\u4ee5\u4e0b\u975e\u4e13\u6709\u7684\u3001\u6c38\u4e45\u6027\u7684\uff0c\u5e76\u4e14\u53ef\u64a4\u9500\u7684\u6388\u6743\u8bb8\u53ef\uff1a","title":"1.2 \u8fd0\u8425\u7684\u5185\u5bb9"},{"location":"about/eula/#121","text":"\u60a8\u6709\u6743\u5728\u4fdd\u8bc1\u5584\u610f\u4f7f\u7528\u7684\u60c5\u51b5\u4e0b\uff0c\u4f9d\u636e\u76f8\u5173\u6cd5\u5f8b\u6cd5\u89c4\u53ca\u9002\u7528\u7684\u56fd\u9645\u6cd5\u4f7f\u7528\u6211\u4eec\u6240\u8fd0\u8425\u7684\u5185\u5bb9\u3002 \u60a8\u4e0d\u5f97\u5c06\u6211\u4eec\u6240\u8fd0\u8425\u7684\u5185\u5bb9\u7528\u4e8e\u8fdd\u6cd5\u3001\u72af\u7f6a\u6d3b\u52a8\u53ca\u5176\u4ed6\u88ab\u8ba4\u4e3a\u6216\u53ef\u80fd\u88ab\u8ba4\u4e3a\u6709\u5bb3\u793e\u4f1a\u7684\u884c\u4e3a\u3002","title":"1.2.1 \u4f7f\u7528"},{"location":"about/eula/#122","text":"\u5982\u679c\u60a8\u5728\u60a8\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u4e2d\u4f7f\u7528\u6216\u8005\u90e8\u5206\u4f7f\u7528\u6211\u4eec\u6240\u8fd0\u8425\u7684\u5185\u5bb9\uff0c\u5219\u60a8\u5fc5\u987b\u5c06\u5176\u6309\u7167\u672c\u534f\u8bae\u7b2c1\u7ae0\u89c4\u5b9a\u7684\u4e24\u79cd\u65b9\u5f0f\u4e4b\u4e00\u5c06\u8be5\u5185\u5bb9\u6574\u4f53\u5411\u60f3\u8981\u83b7\u5f97\u8bb8\u53ef\u7684\u4eba\u6388\u6743\u3002\u672c\u534f\u8bae\u5c31\u6b64\u9002\u7528\u4e8e\u6574\u4e2a\u4f5c\u54c1\uff0c\u5373\u5176\u6bcf\u4e00\u90e8\u5206\uff0c\u4e0d\u7ba1\u5982\u4f55\u5efa\u5305\u3002\u672c\u534f\u8bae\u4e0d\u5141\u8bb8\u4ee5\u5176\u4ed6\u5f62\u5f0f\u6388\u6743\u8be5\u4f5c\u54c1\uff0c\u4f46\u5018\u82e5\u60a8\u6536\u5230\u5176\u4ed6\u8bb8\u53ef\u5219\u53e6\u5f53\u522b\u8bba\u3002 \u60a8\u987b\u5728\u60a8\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u6216\u5728\u9002\u5f53\u7684\u6cd5\u5f8b\u58f0\u660e\u4e2d\u4fdd\u7559\u6211\u4eec\u7684\u6807\u8bc6\u53ca\u53ef\u4ee5\u8ffd\u6eaf\u5230\u6211\u4eec\u6240\u63d0\u4f9b\u7684\u539f\u59cb\u6765\u6e90\u7684\u521b\u4f5c\u5370\u8bb0\uff08\u5982\u679c\u6709\uff09\u3002\u5982\u679c\u60a8\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u6709\u4ea4\u4e92\u5f0f\u7528\u6237\u754c\u9762\uff0c\u90a3\u4e48\u5176\u8fd8\u987b\u663e\u793a\u9002\u5f53\u7684\u6cd5\u5f8b\u58f0\u660e\u3002 \u5373\u4fbf\u60a8\u9762\u4e34\u4e0e\u672c\u534f\u8bae\u6761\u6b3e\u51b2\u7a81\u7684\u6761\u4ef6\uff08\u6765\u81ea\u4e8e\u6cd5\u5ead\u8981\u6c42\u3001\u534f\u8bae\u6216\u5176\u4ed6\uff09\uff0c\u90a3\u4e5f\u4e0d\u80fd\u6210\u4e3a\u60a8\u8fdd\u80cc\u672c\u534f\u8bae\u7684\u7406\u7531\u3002\u5018\u82e5\u60a8\u4e0d\u80fd\u5728\u8f6c\u53d1\u53d7\u4fdd\u62a4\u4f5c\u54c1\u65f6\u540c\u65f6\u6ee1\u8db3\u672c\u534f\u8bae\u548c\u5176\u4ed6\u6587\u4ef6\u7684\u8981\u6c42\uff0c\u60a8\u5c31\u4e0d\u80fd\u8f6c\u53d1\u4e0a\u8ff0\u5185\u5bb9\u3002","title":"1.2.2 \u8f6c\u53d1"},{"location":"about/eula/#13","text":"\u67d0\u4e9b\u6211\u4eec\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u4ee5\u53ca\u5c06\u6765\u7684\u66f4\u65b0\u53ef\u80fd\u5305\u542b\u7b2c\u4e09\u65b9\u7684\u4ea7\u54c1\u548c\u670d\u52a1\u3002\u8fd9\u4e9b\u7b2c\u4e09\u65b9\u7ec4\u4ef6\u5c06\u6309\u7167\u5355\u72ec\u7684\u3001\u4e0d\u540c\u4e8e\u672c\u534f\u8bae\u7684\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\u548c\u6761\u4ef6\u5411\u60a8\u63d0\u4f9b\uff0c\u8fd9\u4e9b\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\u548c\u6761\u4ef6\u901a\u5e38\u53ef\u4ee5\u5728\u5355\u72ec\u7684\u8bb8\u53ef\u534f\u8bae\u6216\u201d\u81ea\u8ff0\u6587\u4ef6\uff08README\uff09\u201d\u6216\u5176\u4ed6\u7c7b\u4f3c\u6807\u9898\u7684\u6587\u4ef6\u4e2d\u627e\u5230\u3002\u8be5\u7b2c\u4e09\u65b9\u7684\u8bb8\u53ef\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\u548c\u4f7f\u7528\u9650\u5236\u4ec5\u9002\u7528\u4e8e\u6b64\u7c7b\u7ec4\u4ef6\u7684\u4f7f\u7528\u3002 \u5982\u7b2c\u4e09\u65b9\u6ca1\u6709\u72ec\u7acb\u7684\u8bb8\u53ef\u534f\u8bae\u6216\u81ea\u8ff0\u6587\u4ef6\uff0c\u5219\u9002\u7528\u672c\u534f\u8bae\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\u7684\u5236\u7ea6\u3002","title":"1.3 \u7b2c\u4e09\u65b9\u5185\u5bb9"},{"location":"about/eula/#14","text":"\u5982\u679c\u60a8\u672a\u9075\u5b88\u672c\u534f\u8bae\u7684\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\u548c\u6761\u4ef6\uff0c\u672c\u534f\u8bae\u81ea\u52a8\u7ec8\u6b62\uff0c\u60a8\u88ab\u6388\u4e88\u7684\u6388\u6743\u5c06\u88ab\u5373\u65f6\u64a4\u9500\u3002 \u5982\u6b64\u7c7b\u60c5\u51b5\u53d1\u751f\uff0c\u60a8\u987b\u7acb\u5373\u9500\u6bc1\u6211\u4eec\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u7684\u6240\u6709\u526f\u672c\u53ca\u5176\u5168\u90e8\u7ec4\u6210\u90e8\u4efd\u3002","title":"1.4 \u8bb8\u53ef\u4e2d\u6b62"},{"location":"about/eula/#2","text":"\u6211\u4eec\u5728\u672c\u534f\u8bae\u4e0b\u63d0\u4f9b\u7684\u610f\u89c1\u3001\u7ed3\u8bba\u6216\u5efa\u8bae\u5747\u5c5e\u4e8e\u987e\u95ee\u548c\u54a8\u8be2\u6027\u8d28\uff0c\u60a8\u5e94\u81ea\u884c\u51b3\u5b9a\u662f\u5426\u4ee5\u53ca\u5982\u4f55\u4f7f\u7528\u6211\u4eec\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\uff0c\u5e76\u72ec\u7acb\u627f\u62c5\u56e0\u6b64\u6240\u4ea7\u751f\u7684\u4e00\u5207\u6cd5\u5f8b\u540e\u679c\u3002 \u60a8\u7406\u89e3\u5e76\u540c\u610f\uff0c\u6211\u4eec\u4e0d\u4fdd\u8bc1\u4efb\u4f55\u5185\u5bb9\u4e0d\u4e2d\u65ad\u64cd\u4f5c\u6216\u5b8c\u5168\u6b63\u786e\uff0c\u4e5f\u4e0d\u4fdd\u8bc1\u6211\u4eec\u80fd\u591f\u7ea0\u6b63\u6240\u6709\u7f3a\u9677\u6216\u95ee\u9898\u3002 \u6211\u4eec\u7279\u522b\u63d0\u8bf7\u60a8\u6ce8\u610f\uff0c\u4e3a\u4fdd\u969c\u6211\u4eec\u4e1a\u52a1\u53d1\u5c55\u548c\u8c03\u6574\u7684\u81ea\u4e3b\u6743\uff0c\u9664\u975e\u6211\u4eec\u53e6\u6709\u4e0d\u540c\u7684\u4e66\u9762\u660e\u786e\u627f\u8bfa\uff0c\u6211\u4eec\u53ef\u968f\u65f6\u81ea\u884c\u4fee\u6539\u6216\u4e2d\u65ad\u4e0a\u8ff0\u5185\u5bb9\u6216\u5176\u4ed6\u6211\u4eec\u660e\u786e\u627f\u8bfa\u63d0\u4f9b\u7684\u5185\u5bb9\u800c\u65e0\u987b\u901a\u77e5\u60a8\u3002 \u6211\u4eec\u5408\u6cd5\u62e5\u6709\u4e00\u5207\u5728\u670d\u52a1\u671f\u95f4\u65b0\u5f00\u53d1\u3001\u521b\u4f5c\u7684\u5de5\u4f5c\u6210\u679c\u7684\u77e5\u8bc6\u4ea7\u6743\u3002 \u6211\u4eec\u4fdd\u8bc1\u5c06\u4ee5\u5ba1\u614e\u6001\u5ea6\u4e0e\u4e13\u4e1a\u6280\u80fd\u63d0\u4f9b\u4e0a\u8ff0\u5185\u5bb9\uff0c\u5e76\u4e14\u6240\u63d0\u4f9b\u7684\u670d\u52a1\u5c06\u9075\u5faa\u4e1a\u754c\u63d0\u4f9b\u6b64\u7c7b\u670d\u52a1\u7684\u826f\u597d\u60ef\u4f8b\u3002\u4e0a\u8ff0\u4fdd\u8bc1\u662f\u6211\u4eec\u5c31\u672c\u534f\u8bae\u9879\u4e0b\u7684\u5185\u5bb9\u505a\u51fa\u7684\u5168\u90e8\u4fdd\u8bc1\u3002\u6211\u4eec\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u4e0d\u5e94\u56e0\u4e0e\u7ea6\u5b9a\u7684\u5de5\u4f5c\u89c4\u683c\u3001\u6807\u51c6\u6216\u8981\u6c42\u4e0d\u7b26\u800c\u88ab\u8ba4\u4e3a\u4e0d\u5408\u683c\u3002","title":"2 \u670d\u52a1\u8303\u56f4"},{"location":"about/eula/#3","text":"\u6211\u4eec\u5bf9\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u4ee5\u53ca\u5c06\u6765\u7684\u66f4\u65b0\u53ef\u80fd\u5305\u542b\u7b2c\u4e09\u65b9\u7684\u4ea7\u54c1\u548c\u670d\u52a1\u4ee5\u53ca\u8bb8\u53ef\u6750\u6599\uff0c\u5305\u62ec\u4efb\u4f55\u7ec8\u7aef\u7528\u6237\u6587\u6863\u3001\u8f6f\u4ef6\u3001\u7ef4\u62a4\u5347\u7ea7\u3001\u6587\u4ef6\u53ca\u5176\u5b83\u6750\u6599\u5747\u4f9d\u73b0\u72b6\u63d0\u4f9b\u3002 \u6211\u4eec\u5426\u8ba4\u4e00\u5207\u660e\u793a\u6216\u9ed8\u793a\u7684\u4fdd\u8bc1\u3001\u6761\u4ef6\u548c\u5176\u4ed6\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\uff08\u4e0d\u8bba\u662f\u6210\u6587\u6cd5\u3001\u666e\u901a\u6cd5\u89c4\u5b9a\u7684\u3001\u9644\u5e26\u7684\u6216\u5176\u4ed6\u7684\uff09\uff0c\u5305\u62ec\u4f46\u4e0d\u9650\u4e8e\u4e0a\u8ff0\u5185\u5bb9\u7684\u771f\u5b9e\u6027\u548c\u51c6\u786e\u6027\u7684\u9ed8\u793a\u4fdd\u8bc1\u3002\u4e0d\u80fd\u4e88\u4ee5\u6392\u9664\u7684\u4efb\u4f55\u9ed8\u793a\u4fdd\u8bc1\u4ec5\u9650\u4e8e\u9002\u7528\u6cd5\u5f8b\u5141\u8bb8\u7684\u6700\u77ed\u671f\u95f4\u5185\u6709\u6548\u3002\u6211\u4eec\u4e5f\u4e0d\u5bf9\u4e0a\u8ff0\u5185\u5bb9\u662f\u5426\u4fb5\u72af\u4efb\u4f55\u7b2c\u4e09\u65b9\u7684\u4efb\u4f55\u77e5\u8bc6\u4ea7\u6743\u4f5c\u4efb\u4f55\u4fdd\u8bc1\u3002 \u5728\u9002\u7528\u6cd5\u5f8b\u5141\u8bb8\u7684\u6700\u5927\u8303\u56f4\u5185\uff0c\u6211\u4eec\u5747\u4e0d\u5bf9\u4efb\u4f55\u4f7f\u7528\u6216\u4e0d\u80fd\u4f7f\u7528\u4e0a\u8ff0\u5185\u5bb9\u800c\u53d1\u751f\u7684\u635f\u5bb3\u8d1f\u8d23\uff0c\u4e5f\u4e0d\u5bf9\u56e0\u4f7f\u7528\u4e0a\u8ff0\u5185\u5bb9\u5bfc\u81f4\u7684\u6216\u4e0e\u6b64\u6709\u5173\u7684\u4efb\u4f55\u7279\u6b8a\u7684\u3001\u9644\u5e26\u53d1\u751f\u7684\u6216\u95f4\u63a5\u7684\u635f\u5bb3\u8d1f\u8d23\u3002\u5373\u4f7f\u6211\u4eec\u77e5\u9053\u6216\u5e94\u8be5\u77e5\u9053\u635f\u5bb3\u7684\u53ef\u80fd\u3002 \u9664\u6839\u636e\u9002\u7528\u6cd5\u5f8b\u4e0d\u80fd\u514d\u9664\u6216\u9650\u5236\u7684\u8d23\u4efb\u5916\uff0c\u60a8\u653e\u5f03\u5411\u6211\u4eec\u8981\u6c42\u8d54\u507f\u635f\u5931\u7684\u6743\u5229\uff08\u5305\u62ec\u91cd\u5927\u8fdd\u7ea6\u3001\u8fc7\u5931\u3001\u865a\u5047\u9648\u8ff0\u6216\u5176\u4ed6\u5408\u540c\u6216\u4fb5\u6743\u65b9\u9762\u7684\u7d22\u8d54\uff09\u3002\u5728\u4efb\u4f55\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5bf9\u4e0b\u5217\u60c5\u5f62\u5747\u4e0d\u627f\u62c5\u8d23\u4efb\uff0c\u5373\u4f7f\u77e5\u9053\u6216\u5e94\u8be5\u77e5\u9053\u8be5\u60c5\u5f62\u6709\u53ef\u80fd\u53d1\u751f\uff1a \u7b2c\u4e09\u65b9\u5411\u60a8\u63d0\u51fa\u7684\u7d22\u8d54\uff1b \u60a8\u7684\u6570\u636e\u4e22\u5931\u6216\u635f\u574f\uff1b \u7279\u6b8a\u7684\u3001\u9644\u5e26\u7684\u6216\u95f4\u63a5\u7684\u635f\u5bb3\u8d54\u507f\u6216\u4efb\u4f55\u540e\u679c\u6027\u7684\u7ecf\u6d4e\u635f\u5bb3\u8d54\u507f\uff0c\u5305\u62ec\u5229\u6da6\u3001\u4e1a\u52a1\u6536\u5165\u3001\u5546\u8a89\u6216\u9884\u671f\u8282\u4f59\u7684\u635f\u5931\u3002 \u5728\u76f8\u5173\u6cd5\u5f8b\u6cd5\u89c4\u4e0e\u9002\u7528\u7684\u56fd\u9645\u6cd5\u89c4\u5b9a\u7684\u6700\u5927\u8303\u56f4\u4e4b\u5185\u6392\u9664\u6211\u4eec\u7684\u8d23\u4efb\u3002 \u67d0\u4e9b\u56fd\u5bb6/\u5730\u533a\u6216\u53f8\u6cd5\u7ba1\u8f96\u533a\u4e0d\u5141\u8bb8\u5bf9\u9644\u5e26\u7684\u6216\u540e\u679c\u6027\u7684\u635f\u5bb3\u8d54\u507f\u8fdb\u884c\u6392\u9664\u6216\u9650\u5236\uff0c\u5982\u679c\u8fd9\u6837\uff0c\u5219\u4e0a\u8ff0\u6392\u9664\u6216\u9650\u5236\u53ef\u80fd\u4e0d\u9002\u7528\u4e8e\u60a8\u3002 \u672c\u534f\u8bae\u7684\u4efb\u4f55\u6761\u6b3e\u53ca\u5176\u9644\u5c5e\u6761\u4ef6\u5747\u4e0d\u5f71\u54cd\u4e0d\u80fd\u901a\u8fc7\u5408\u540c\u4e88\u4ee5\u653e\u5f03\u6216\u9650\u5236\u7684\u6d88\u8d39\u8005\u7684\u4efb\u4f55\u6cd5\u5b9a\u6743\u5229\u3002\u672c\u534f\u8bae\u4e5f\u4e0d\u6539\u53d8\u6839\u636e\u53ef\u9002\u7528\u7684\u5f53\u5730\u6cd5\u5f8b\u6846\u67b6\u4fdd\u62a4\u4e0b\u60a8\u53ef\u80fd\u62e5\u6709\u7684\u5176\u4ed6\u6743\u5229\u3002","title":"3 \u8d23\u4efb\u514d\u9664"},{"location":"about/eula/#4","text":"\u6211\u4eec\u53ef\u80fd\u4f1a\u4e0d\u65f6\u66f4\u6539\u672c\u534f\u8bae\uff0c\u4f7f\u4e4b\u80fd\u591f\u51c6\u786e\u53cd\u6620\u6211\u4eec\u7684\u505a\u6cd5\u3001zyc.ai\u5185\u5bb9\u53ca\u6cd5\u5f8b\u8981\u6c42\u3002 \u672c\u58f0\u660e\u9876\u90e8\u7684\u201c\u4e0a\u6b21\u4fee\u6539\u65e5\u671f\u201d\u90e8\u5206\u6307\u51fa\u4e86\u4e0a\u6b21\u4fee\u8ba2\u672c\u534f\u8bae\u7684\u65e5\u671f\uff0c\u6bcf\u6b21\u53d1\u5e03\u4fee\u8ba2\u65f6\u6211\u4eec\u90fd\u4f1a\u66f4\u65b0\u6b64\u65e5\u671f\u3002\u5bf9\u672c\u534f\u8bae\u7684\u4efb\u4f55\u66f4\u6539\u5c06\u5728\u6211\u4eec\u901a\u8fc7\u516c\u5e03\u4fee\u8ba2\u7248\u6700\u7ec8\u7528\u6237\u8bb8\u53ef\u534f\u8bae\u65f6\u751f\u6548\u3002 \u6211\u4eec\u9f13\u52b1\u60a8\u5b9a\u671f\u67e5\u770b\u672c\u534f\u8bae\uff0c\u4e86\u89e3\u6211\u4eec\u5982\u4f55\u63d0\u4f9b\u5185\u5bb9\u3002","title":"4 \u672c\u534f\u8bae\u7684\u4fee\u8ba2"},{"location":"about/eula/#5","text":"zyc.ai\u8ba4\u4e3a\u5f00\u653e\u4e0e\u9690\u79c1\u5bf9\u6211\u4eec\u53ca\u6211\u4eec\u7684\u7528\u6237\u5341\u5206\u91cd\u8981\u3002 \u56e0\u6b64\uff0c\u672c\u534f\u8bae\u5c06\u9002\u7528\u4e8e\u4efb\u4f55zyc.ai\u5185\u5bb9\u7684\u884d\u751f\u4f5c\u54c1\u3002 \u5982\u679c\u60a8\u7684\u4f5c\u54c1\u884d\u751f\u81ea\u3001\u4f7f\u7528\u6216\u8005\u90e8\u5206\u4f7f\u7528zyc.ai\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\uff0c\u60a8\u5fc5\u987b\u5c06\u5176\u6309\u7167\u4e0e\u672c\u534f\u8bae\u89c4\u5b9a\u7684\u76f8\u540c\u65b9\u5f0f\u5c06\u8be5\u4f5c\u54c1\u6216\u670d\u52a1\u6574\u4f53\u5411\u60f3\u8981\u83b7\u5f97\u8bb8\u53ef\u7684\u4eba\u6388\u6743\u3002 \u5982\u679c\u60a8\u4e0d\u80fd\u6309\u7167\u672c\u534f\u8bae\u7684\u8981\u6c42\u6765\u63d0\u4f9b\u6216\u8fd0\u8425\u5185\u5bb9\uff0c\u90a3\u4e48\u60a8\u5c06\u4e0d\u80fd\u63d0\u4f9b\u6216\u8fd0\u8425\u5b83\u4eec\u3002","title":"5 \u9002\u7528\u8303\u56f4"},{"location":"about/license/","text":"GNU GENERAL PUBLIC LICENSE # Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. Preamble # The GNU General Public License is a free, copyleft license for software and other kinds of works. The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program\u2013to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others. For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it. For the developers\u2019 and authors\u2019 protection, the GPL clearly explains that there is no warranty for this free software. For both users\u2019 and authors\u2019 sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions. Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users\u2019 freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users. Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free. The precise terms and conditions for copying, distribution and modification follow. TERMS AND CONDITIONS # 0. Definitions. # \u201cThis License\u201d refers to version 3 of the GNU General Public License. \u201cCopyright\u201d also means copyright-like laws that apply to other kinds of works, such as semiconductor masks. \u201cThe Program\u201d refers to any copyrightable work licensed under this License. Each licensee is addressed as \u201cyou\u201d. \u201cLicensees\u201d and \u201crecipients\u201d may be individuals or organizations. To \u201cmodify\u201d a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \u201cmodified version\u201d of the earlier work or a work \u201cbased on\u201d the earlier work. A \u201ccovered work\u201d means either the unmodified Program or a work based on the Program. To \u201cpropagate\u201d a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well. To \u201cconvey\u201d a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying. An interactive user interface displays \u201cAppropriate Legal Notices\u201d to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion. 1. Source Code. # The \u201csource code\u201d for a work means the preferred form of the work for making modifications to it. \u201cObject code\u201d means any non-source form of a work. A \u201cStandard Interface\u201d means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language. The \u201cSystem Libraries\u201d of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \u201cMajor Component\u201d, in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it. The \u201cCorresponding Source\u201d for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work\u2019s System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work. The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source. The Corresponding Source for a work in source code form is that same work. 2. Basic Permissions. # All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law. You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you. Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary. 3. Protecting Users\u2019 Legal Rights From Anti-Circumvention Law. # No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures. When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work\u2019s users, your or third parties\u2019 legal rights to forbid circumvention of technological measures. 4. Conveying Verbatim Copies. # You may convey verbatim copies of the Program\u2019s source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program. You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee. 5. Conveying Modified Source Versions. # You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions: a) The work must carry prominent notices stating that you modified it, and giving a relevant date. b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \u201ckeep intact all notices\u201d. c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it. d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so. A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \u201caggregate\u201d if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation\u2019s users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate. 6. Conveying Non-Source Forms. # You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways: a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange. b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge. c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b. d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements. e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d. A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work. A \u201cUser Product\u201d is either (1) a \u201cconsumer product\u201d, which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \u201cnormally used\u201d refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product. \u201cInstallation Information\u201d for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made. If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM). The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network. Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying. 7. Additional Terms. # \u201cAdditional permissions\u201d are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions. When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission. Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms: a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or d) Limiting the use for publicity purposes of names of licensors or authors of the material; or e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors. All other non-permissive additional terms are considered \u201cfurther restrictions\u201d within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying. If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms. Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way. 8. Termination. # You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11). However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10. 9. Acceptance Not Required for Having Copies. # You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so. 10. Automatic Licensing of Downstream Recipients. # Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License. An \u201centity transaction\u201d is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party\u2019s predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts. You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it. 11. Patents. # A \u201ccontributor\u201d is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor\u2019s \u201ccontributor version\u201d. A contributor\u2019s \u201cessential patent claims\u201d are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \u201ccontrol\u201d includes the right to grant patent sublicenses in a manner consistent with the requirements of this License. Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor\u2019s essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version. In the following three paragraphs, a \u201cpatent license\u201d is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \u201cgrant\u201d such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party. If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \u201cKnowingly relying\u201d means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient\u2019s use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid. If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it. A patent license is \u201cdiscriminatory\u201d if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007. Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law. 12. No Surrender of Others\u2019 Freedom. # If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program. 13. Use with the GNU Affero General Public License. # Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such. 14. Revised Versions of this License. # The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \u201cor any later version\u201d applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation. If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy\u2019s public statement of acceptance of a version permanently authorizes you to choose that version for the Program. Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version. 15. Disclaimer of Warranty. # THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201cAS IS\u201d WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. Limitation of Liability. # IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 17. Interpretation of Sections 15 and 16. # If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee. END OF TERMS AND CONDITIONS How to Apply These Terms to Your New Programs # If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms. To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \u201ccopyright\u201d line and a pointer to where the full notice is found. <one line to give the program's name and a brief idea of what it does.> Copyright (C) <year> <name of author> This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>. Also add information on how to contact you by electronic and paper mail. If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode: <program> Copyright (C) <year> <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. The hypothetical commands `show w\u2019 and `show c\u2019 should show the appropriate parts of the General Public License. Of course, your program\u2019s commands might be different; for a GUI interface, you would use an \u201cabout box\u201d. You should also get your employer (if you work as a programmer) or school, if any, to sign a \u201ccopyright disclaimer\u201d for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see https://www.gnu.org/licenses/ . The GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read https://www.gnu.org/licenses/why-not-lgpl.html .","title":"GPLv3"},{"location":"about/license/#gnu-general-public-license","text":"Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.","title":"GNU GENERAL PUBLIC LICENSE"},{"location":"about/license/#preamble","text":"The GNU General Public License is a free, copyleft license for software and other kinds of works. The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program\u2013to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others. For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it. For the developers\u2019 and authors\u2019 protection, the GPL clearly explains that there is no warranty for this free software. For both users\u2019 and authors\u2019 sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions. Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users\u2019 freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users. Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free. The precise terms and conditions for copying, distribution and modification follow.","title":"Preamble"},{"location":"about/license/#terms-and-conditions","text":"","title":"TERMS AND CONDITIONS"},{"location":"about/license/#0-definitions","text":"\u201cThis License\u201d refers to version 3 of the GNU General Public License. \u201cCopyright\u201d also means copyright-like laws that apply to other kinds of works, such as semiconductor masks. \u201cThe Program\u201d refers to any copyrightable work licensed under this License. Each licensee is addressed as \u201cyou\u201d. \u201cLicensees\u201d and \u201crecipients\u201d may be individuals or organizations. To \u201cmodify\u201d a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \u201cmodified version\u201d of the earlier work or a work \u201cbased on\u201d the earlier work. A \u201ccovered work\u201d means either the unmodified Program or a work based on the Program. To \u201cpropagate\u201d a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well. To \u201cconvey\u201d a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying. An interactive user interface displays \u201cAppropriate Legal Notices\u201d to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.","title":"0. Definitions."},{"location":"about/license/#1-source-code","text":"The \u201csource code\u201d for a work means the preferred form of the work for making modifications to it. \u201cObject code\u201d means any non-source form of a work. A \u201cStandard Interface\u201d means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language. The \u201cSystem Libraries\u201d of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \u201cMajor Component\u201d, in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it. The \u201cCorresponding Source\u201d for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work\u2019s System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work. The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source. The Corresponding Source for a work in source code form is that same work.","title":"1. Source Code."},{"location":"about/license/#2-basic-permissions","text":"All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law. You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you. Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.","title":"2. Basic Permissions."},{"location":"about/license/#3-protecting-users-legal-rights-from-anti-circumvention-law","text":"No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures. When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work\u2019s users, your or third parties\u2019 legal rights to forbid circumvention of technological measures.","title":"3. Protecting Users' Legal Rights From Anti-Circumvention Law."},{"location":"about/license/#4-conveying-verbatim-copies","text":"You may convey verbatim copies of the Program\u2019s source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program. You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.","title":"4. Conveying Verbatim Copies."},{"location":"about/license/#5-conveying-modified-source-versions","text":"You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions: a) The work must carry prominent notices stating that you modified it, and giving a relevant date. b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \u201ckeep intact all notices\u201d. c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it. d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so. A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \u201caggregate\u201d if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation\u2019s users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.","title":"5. Conveying Modified Source Versions."},{"location":"about/license/#6-conveying-non-source-forms","text":"You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways: a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange. b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge. c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b. d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements. e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d. A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work. A \u201cUser Product\u201d is either (1) a \u201cconsumer product\u201d, which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \u201cnormally used\u201d refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product. \u201cInstallation Information\u201d for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made. If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM). The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network. Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.","title":"6. Conveying Non-Source Forms."},{"location":"about/license/#7-additional-terms","text":"\u201cAdditional permissions\u201d are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions. When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission. Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms: a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or d) Limiting the use for publicity purposes of names of licensors or authors of the material; or e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors. All other non-permissive additional terms are considered \u201cfurther restrictions\u201d within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying. If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms. Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.","title":"7. Additional Terms."},{"location":"about/license/#8-termination","text":"You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11). However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.","title":"8. Termination."},{"location":"about/license/#9-acceptance-not-required-for-having-copies","text":"You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.","title":"9. Acceptance Not Required for Having Copies."},{"location":"about/license/#10-automatic-licensing-of-downstream-recipients","text":"Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License. An \u201centity transaction\u201d is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party\u2019s predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts. You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.","title":"10. Automatic Licensing of Downstream Recipients."},{"location":"about/license/#11-patents","text":"A \u201ccontributor\u201d is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor\u2019s \u201ccontributor version\u201d. A contributor\u2019s \u201cessential patent claims\u201d are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \u201ccontrol\u201d includes the right to grant patent sublicenses in a manner consistent with the requirements of this License. Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor\u2019s essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version. In the following three paragraphs, a \u201cpatent license\u201d is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \u201cgrant\u201d such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party. If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \u201cKnowingly relying\u201d means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient\u2019s use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid. If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it. A patent license is \u201cdiscriminatory\u201d if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007. Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.","title":"11. Patents."},{"location":"about/license/#12-no-surrender-of-others-freedom","text":"If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.","title":"12. No Surrender of Others' Freedom."},{"location":"about/license/#13-use-with-the-gnu-affero-general-public-license","text":"Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.","title":"13. Use with the GNU Affero General Public License."},{"location":"about/license/#14-revised-versions-of-this-license","text":"The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \u201cor any later version\u201d applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation. If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy\u2019s public statement of acceptance of a version permanently authorizes you to choose that version for the Program. Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.","title":"14. Revised Versions of this License."},{"location":"about/license/#15-disclaimer-of-warranty","text":"THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201cAS IS\u201d WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.","title":"15. Disclaimer of Warranty."},{"location":"about/license/#16-limitation-of-liability","text":"IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.","title":"16. Limitation of Liability."},{"location":"about/license/#17-interpretation-of-sections-15-and-16","text":"If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee. END OF TERMS AND CONDITIONS","title":"17. Interpretation of Sections 15 and 16."},{"location":"about/license/#how-to-apply-these-terms-to-your-new-programs","text":"If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms. To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \u201ccopyright\u201d line and a pointer to where the full notice is found. <one line to give the program's name and a brief idea of what it does.> Copyright (C) <year> <name of author> This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>. Also add information on how to contact you by electronic and paper mail. If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode: <program> Copyright (C) <year> <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. The hypothetical commands `show w\u2019 and `show c\u2019 should show the appropriate parts of the General Public License. Of course, your program\u2019s commands might be different; for a GUI interface, you would use an \u201cabout box\u201d. You should also get your employer (if you work as a programmer) or school, if any, to sign a \u201ccopyright disclaimer\u201d for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see https://www.gnu.org/licenses/ . The GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read https://www.gnu.org/licenses/why-not-lgpl.html .","title":"How to Apply These Terms to Your New Programs"},{"location":"about/privacy/","text":"\u6700\u540e\u4fee\u8ba2 \u672c\u58f0\u660e\u6700\u540e\u4fee\u8ba2\u4e8e2020\u5e7408\u670816\u65e5\u3002 zyc.ai\u6df1\u77e5\uff0c\u9690\u79c1\u6743\u662f\u4e00\u9879\u57fa\u672c\u4eba\u6743\u3002 zyc.ai\u8ba9\u79d1\u6280\u4e3a\u5927\u5bb6\u5e26\u6765\u4ee4\u4eba\u60ca\u53f9\u7684\u4f53\u9a8c\uff0c\u540c\u65f6\uff0c\u5e76\u4e0d\u4f1a\u4ee5\u727a\u7272\u60a8\u7684\u9690\u79c1\u4e3a\u4ee3\u4ef7\u3002 \u6211\u4eec\u76f8\u4fe1\u901a\u8fc7\u521b\u65b0\u548c\u6267\u884c\u80fd\u591f\u4e3a\u60a8\u7684\u9690\u79c1\u6743\u5229\u63d0\u4f9b\u652f\u6301\uff0c\u800c\u4e14\u5728\u8bbe\u8ba1\u6280\u672f\u65f6\u4e5f\u4f1a\u5c06\u8fd9\u4e9b\u6743\u5229\u94ed\u8bb0\u4e8e\u5fc3\u3002 \u672c\u9690\u79c1\u58f0\u660e\uff08\u4ee5\u4e0b\u7b80\u79f0\u672c\u58f0\u660e\uff09\u9610\u8ff0\u4e86\u60a8\uff08\u4e2a\u4eba\u6216\u5b9e\u4f53\uff09\u5728\u4f7f\u7528\u7531\u6211\u4eec\uff08zyc.ai\uff09\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\u65f6\uff0c\u6211\u4eec\u5982\u4f55\u6536\u96c6\u3001\u5904\u7406\u3001\u5b58\u50a8\u548c\u4fdd\u62a4\u5173\u4e8e\u60a8\u7684\u4fe1\u606f\u3002 \u5185\u5bb9 \u672c\u58f0\u660e\u6240\u79f0\u7684\u5185\u5bb9\u662f\u6307\u6211\u4eec\u62e5\u6709\u8457\u4f5c\u6743\u6216\u6709\u6743\u4f7f\u7528\u7684\u5185\u5bb9\uff0c\u5305\u62ec\u4f46\u4e0d\u9650\u4e8e\u4ea7\u54c1\u3001\u8f6f\u4ef6\u3001\u786c\u4ef6\u3001\u6e90\u7801\u3001\u5de5\u5177\u3001\u6750\u6599\u3001\u56fe\u7eb8\u3001\u6570\u636e\u3001\u89c6\u9891\u3001\u56fe\u50cf\u3001\u97f3\u9891\u3001\u6587\u6863\u53ca\u5176\u4ed6\u53ef\u88ab\u89c6\u4e3a\u5185\u5bb9\u7684\u4e8c\u8fdb\u5236\u6216\u975e\u4e8c\u8fdb\u5236\u6587\u4ef6\u4ee5\u53ca\u8f7d\u6709\u5176\u7684\u7eb8\u5f20\u3001\u5149\u76d8\u3001U\u76d8\u7b49\u7269\u7406\u8f7d\u4f53\u3002 1 \u6211\u4eec\u6536\u96c6\u7684\u4e2a\u4eba\u4fe1\u606f # \u6211\u4eec\u4e0d\u6536\u96c6\u4efb\u4f55\u60a8\u7684\u9690\u79c1\u4fe1\u606f\uff0c\u5305\u62ec\u4f46\u4e0d\u9650\u4e8e\u60a8\u7684\u59d3\u540d\u3001\u79cd\u65cf\u3001\u6c11\u65cf\u3001\u5b97\u6559\u4fe1\u4ef0\u3001\u72af\u7f6a\u8bb0\u5f55\u3001\u8eab\u4f53\u3001\u5fc3\u7406\u5065\u5eb7\u72b6\u51b5\u6216\u6027\u53d6\u5411\u3002 \u6211\u4eec\u4e0d\u63a5\u53d7\u4efb\u4f55\u7b2c\u4e09\u65b9\u5411\u6211\u4eec\u63d0\u4f9b\u7684\u9690\u79c1\u4fe1\u606f\u3002 \u4f8b\u5916\u60c5\u51b5 \u4e3a\u4e86\u5b9e\u73b0\u7f51\u7ad9\u6574\u5408\u4fe1\u606f\u3001\u96c6\u4e2d\u6700\u4f18\u3001\u89e3\u51b3\u95ee\u9898\u7684\u5b9e\u9645\u6548\u80fd\uff0c\u6211\u4eec\u5bf9\u4ee5\u4e0b\u63d0\u4f9b\u5185\u5bb9\u4e4b\u987b\u8981\u4fe1\u606f\u7684\u6536\u96c6\u53ca\u4f7f\u7528\u4e88\u4ee5\u4f8b\u5916\u60c5\u51b5\u8bf4\u660e\u3002 \u4f7f\u7528\u4fe1\u606f \u5728\u60a8\u7684\u4f7f\u7528\u4e2d\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u8d4b\u4e88\u60a8\u552f\u4e00\u4e14\u533f\u540d\u7684\u7528\u6237\u6807\u8bc6\uff08\u53d6\u51b3\u4e8e\u60a8\u4f7f\u7528\u7684\u5185\u5bb9\uff09\u3002\u8be5\u7528\u6237\u6807\u8bc6\uff08\u5982\u679c\u6709\uff09\u5c06\u88ab\u7528\u4e8e\u8bc6\u522b\u60a8\u5728\u4f55\u65f6\u4f7f\u7528\u4e86\u6211\u4eec\u7684\u5185\u5bb9\u3001\u4f7f\u7528\u4e86\u54ea\u4e9b\u5185\u5bb9\u3001\u4f7f\u7528\u4e86\u591a\u957f\u65f6\u95f4\u7b49\u60a8\u5bf9\u6211\u4eec\u5185\u5bb9\u7684\u4f7f\u7528\u4fe1\u606f\u3002\u8fd9\u4e9b\u4fe1\u606f\u5c06\u88ab\u7528\u4e8e\u7528\u6237\u4f53\u9a8c\u8bbe\u8ba1\u3002 \u5730\u7406\u4f4d\u7f6e \u6211\u4eec\u4f1a\u6536\u96c6\u60a8\u4e3b\u52a8\u63d0\u4f9b\u7684\u5730\u7406\u4f4d\u7f6e\u4fe1\u606f\u7528\u4e8e\u4e3a\u60a8\u63d0\u4f9b\u8ba2\u9605\u3001\u5bfc\u822a\u7b49\u670d\u52a1 ^\\star ^\\star \u3002 \u9700\u6ce8\u610f\uff0c\u6b64\u9879\u4fe1\u606f\u5e76\u4e0d\u4f1a\u88ab\u4fdd\u5b58\uff0c\u5373\u60a8\u6bcf\u6b21\u4f7f\u7528\u90fd\u9700\u8981\u5411\u6211\u4eec\u63d0\u4f9b\u3002 \u804a\u5929\u5185\u5bb9 \u6211\u4eec\u63d0\u4f9b\u7684\u5fae\u4fe1\u673a\u5668\u4eba\u53ef\u80fd\u4f1a\u4f7f\u7528\u5fae\u4fe1\u7fa4\u5185\u7684\u804a\u5929\u5185\u5bb9\uff08\u53d6\u51b3\u4e8e\u60a8\u7684\u8bbe\u5b9a\uff09\u7528\u4e8e\u81ea\u52a8\u8f9f\u8c23\u7b49\u529f\u80fd\u7684\u5b9e\u73b0 ^\\star ^\\star \u3002 \u9700\u6ce8\u610f\uff0c\u6b64\u9879\u4fe1\u606f\u5e76\u4e0d\u4f1a\u88ab\u4fdd\u5b58\uff0c\u5373\u60a8\u6bcf\u6b21\u4f7f\u7528\u90fd\u9700\u8981\u5411\u6211\u4eec\u63d0\u4f9b\u3002 ^\\star ^\\star \uff1a\u5982\u60a8\u4e3a\u670d\u52a1\u7684\u8fd0\u8425\u8005\u65f6\uff0c\u60a8\u5e94\u81ea\u884c\u5224\u65ad\u60a8\u662f\u5426\u80fd\u5f97\u5230\u6700\u7ec8\u7528\u6237\u7684\u6388\u6743\u3002 2 \u6211\u4eec\u4f7f\u7528\u7684\u4e2a\u4eba\u4fe1\u606f # \u6211\u4eec\u4ec5\u4f7f\u7528\u524d\u6b3e\u63d0\u5230\u7684\u4f7f\u7528\u4fe1\u606f\u8fdb\u884c\u7528\u6237\u4f53\u9a8c\u8bbe\u8ba1\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u6211\u4eec\u4e0d\u901a\u8fc7\u4efb\u4f55\u5f62\u5f0f\u4f7f\u7528\u4efb\u4f55\u7528\u6237\u7684\u4e2a\u4eba\u4fe1\u606f\u3002 3 \u6211\u4eec\u62ab\u9732\u7684\u4e2a\u4eba\u4fe1\u606f # \u7531\u4e8e\u6211\u4eec\u4e0d\u6536\u96c6\u60a8\u7684\u9690\u79c1\u4fe1\u606f\uff0c\u6211\u4eec\u4e0d\u62ab\u9732\u4e5f\u65e0\u6cd5\u62ab\u9732\u60a8\u7684\u9690\u79c1\u4fe1\u606f\u3002 4 \u60a8\u7684\u6743\u5229 # \u6211\u4eec\u53ea\u4fdd\u5b58\u901a\u8fc7\u552f\u4e00\u4e14\u533f\u540d\u7684\u7528\u6237\u6807\u8bc6\u6240\u83b7\u53d6\u7684\u60a8\u7684\u4f7f\u7528\u4fe1\u606f\uff0c\u800c\u4e0d\u6536\u96c6\u60a8\u7684\u4e2a\u4eba\u4fe1\u606f\u3002\u56e0\u6b64\u6211\u4eec\u65e0\u6cd5\u5efa\u7acb\u60a8\u4e0e\u67d0\u4e2a\u6216\u8005\u67d0\u51e0\u4e2a\u7528\u6237\u6807\u8bc6\u4e4b\u95f4\u7684\u5173\u8054\uff0c\u6240\u4ee5\u60a8\u65e0\u6cd5\u66f4\u6b63\u6216\u5220\u9664\u60a8\u7684\u9690\u79c1\u4fe1\u606f\u3002 \u5982\u679c\u60a8\u8ba4\u4e3a\u6211\u4eec\u5bf9\u60a8\u7684\u4e2a\u4eba\u4fe1\u606f\u7684\u4f7f\u7528\u65b9\u5f0f\u4e0e\u672c\u58f0\u660e\u4e0d\u7b26\uff0c\u6216\u8005\u8981\u4e86\u89e3\u6709\u5173\u60a8\u7684\u6743\u5229\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u8054\u7cfb\u60a8\u5f53\u5730\u7684\u6570\u636e\u4fdd\u62a4\u5f53\u5c40\u3002 5 \u7b2c\u4e09\u65b9\u5185\u5bb9 # \u672c\u58f0\u660e\u6ca1\u6709\u8ff0\u53ca\u7b2c\u4e09\u65b9\u6216\u5e76\u975e\u4ee3\u8868\u6211\u4eec\u7684\u5176\u4ed6\u7ec4\u7ec7\u7684\u653f\u7b56\u548c\u505a\u6cd5\uff08\u5305\u62ec\u6709\u5173\u9690\u79c1\u548c\u5b89\u5168\u3001\u6570\u636e\u6536\u96c6\u3001\u5904\u7406\u3001\u4f7f\u7528\u3001\u5b58\u50a8\u548c\u62ab\u9732\u7684\u653f\u7b56\u548c\u505a\u6cd5\uff09\uff0c\u6211\u4eec\u5bf9\u8fd9\u4e9b\u653f\u7b56\u548c\u505a\u6cd5\u6982\u4e0d\u8d1f\u8d23\u3002 6 \u672c\u58f0\u660e\u7684\u4fee\u8ba2 # \u6211\u4eec\u53ef\u80fd\u4f1a\u4e0d\u65f6\u66f4\u6539\u672c\u58f0\u660e\uff0c\u4f7f\u4e4b\u80fd\u591f\u51c6\u786e\u53cd\u6620\u6211\u4eec\u7684\u505a\u6cd5\u3001\u6211\u4eec\u5185\u5bb9\u53ca\u6cd5\u5f8b\u8981\u6c42\u3002 \u672c\u58f0\u660e\u9876\u90e8\u7684\u201c\u4e0a\u6b21\u4fee\u6539\u65e5\u671f\u201d\u90e8\u5206\u6307\u51fa\u4e86\u4e0a\u6b21\u4fee\u8ba2\u672c\u58f0\u660e\u7684\u65e5\u671f\uff0c\u6bcf\u6b21\u53d1\u5e03\u4fee\u8ba2\u65f6\u6211\u4eec\u90fd\u4f1a\u66f4\u65b0\u6b64\u65e5\u671f\u3002\u5bf9\u672c\u58f0\u660e\u7684\u4efb\u4f55\u66f4\u6539\u5c06\u5728\u6211\u4eec\u516c\u5e03\u4fee\u8ba2\u7248\u9690\u79c1\u58f0\u660e\u65f6\u751f\u6548\u3002 \u6211\u4eec\u9f13\u52b1\u60a8\u5b9a\u671f\u67e5\u770b\u672c\u58f0\u660e\uff0c\u4e86\u89e3\u6211\u4eec\u5982\u4f55\u6536\u96c6\u3001\u4f7f\u7528\u548c\u5171\u4eab\u4e2a\u4eba\u4fe1\u606f\u3002 7 \u9002\u7528\u8303\u56f4 # zyc.ai\u8ba4\u4e3a\u5f00\u653e\u4e0e\u9690\u79c1\u5bf9\u6211\u4eec\u53ca\u6211\u4eec\u7684\u7528\u6237\u5341\u5206\u91cd\u8981\u3002 \u56e0\u6b64\uff0c\u672c\u9690\u79c1\u653f\u7b56\u5c06\u9002\u7528\u4e8e\u4efb\u4f55zyc.ai\u5185\u5bb9\u7684\u884d\u751f\u4f5c\u54c1\u3002 \u5982\u679c\u60a8\u7684\u4f5c\u54c1\u884d\u751f\u81ea\u3001\u4f7f\u7528\u6216\u8005\u90e8\u5206\u4f7f\u7528zyc.ai\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\uff0c\u60a8\u5fc5\u987b\u5c06\u5176\u6309\u7167\u4e0e\u672c\u534f\u8bae\u89c4\u5b9a\u7684\u76f8\u540c\u65b9\u5f0f\u5c06\u8be5\u4f5c\u54c1\u6216\u670d\u52a1\u6574\u4f53\u5411\u60f3\u8981\u83b7\u5f97\u8bb8\u53ef\u7684\u4eba\u6388\u6743\u3002 \u5982\u679c\u60a8\u4e0d\u80fd\u6309\u7167\u672c\u58f0\u660e\u7684\u8981\u6c42\u6765\u63d0\u4f9b\u6216\u8fd0\u8425\u5185\u5bb9\uff0c\u90a3\u4e48\u60a8\u5c06\u4e0d\u80fd\u63d0\u4f9b\u6216\u8fd0\u8425\u5b83\u4eec\u3002","title":"\u9690\u79c1\u58f0\u660e"},{"location":"about/privacy/#1","text":"\u6211\u4eec\u4e0d\u6536\u96c6\u4efb\u4f55\u60a8\u7684\u9690\u79c1\u4fe1\u606f\uff0c\u5305\u62ec\u4f46\u4e0d\u9650\u4e8e\u60a8\u7684\u59d3\u540d\u3001\u79cd\u65cf\u3001\u6c11\u65cf\u3001\u5b97\u6559\u4fe1\u4ef0\u3001\u72af\u7f6a\u8bb0\u5f55\u3001\u8eab\u4f53\u3001\u5fc3\u7406\u5065\u5eb7\u72b6\u51b5\u6216\u6027\u53d6\u5411\u3002 \u6211\u4eec\u4e0d\u63a5\u53d7\u4efb\u4f55\u7b2c\u4e09\u65b9\u5411\u6211\u4eec\u63d0\u4f9b\u7684\u9690\u79c1\u4fe1\u606f\u3002 \u4f8b\u5916\u60c5\u51b5 \u4e3a\u4e86\u5b9e\u73b0\u7f51\u7ad9\u6574\u5408\u4fe1\u606f\u3001\u96c6\u4e2d\u6700\u4f18\u3001\u89e3\u51b3\u95ee\u9898\u7684\u5b9e\u9645\u6548\u80fd\uff0c\u6211\u4eec\u5bf9\u4ee5\u4e0b\u63d0\u4f9b\u5185\u5bb9\u4e4b\u987b\u8981\u4fe1\u606f\u7684\u6536\u96c6\u53ca\u4f7f\u7528\u4e88\u4ee5\u4f8b\u5916\u60c5\u51b5\u8bf4\u660e\u3002 \u4f7f\u7528\u4fe1\u606f \u5728\u60a8\u7684\u4f7f\u7528\u4e2d\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u8d4b\u4e88\u60a8\u552f\u4e00\u4e14\u533f\u540d\u7684\u7528\u6237\u6807\u8bc6\uff08\u53d6\u51b3\u4e8e\u60a8\u4f7f\u7528\u7684\u5185\u5bb9\uff09\u3002\u8be5\u7528\u6237\u6807\u8bc6\uff08\u5982\u679c\u6709\uff09\u5c06\u88ab\u7528\u4e8e\u8bc6\u522b\u60a8\u5728\u4f55\u65f6\u4f7f\u7528\u4e86\u6211\u4eec\u7684\u5185\u5bb9\u3001\u4f7f\u7528\u4e86\u54ea\u4e9b\u5185\u5bb9\u3001\u4f7f\u7528\u4e86\u591a\u957f\u65f6\u95f4\u7b49\u60a8\u5bf9\u6211\u4eec\u5185\u5bb9\u7684\u4f7f\u7528\u4fe1\u606f\u3002\u8fd9\u4e9b\u4fe1\u606f\u5c06\u88ab\u7528\u4e8e\u7528\u6237\u4f53\u9a8c\u8bbe\u8ba1\u3002 \u5730\u7406\u4f4d\u7f6e \u6211\u4eec\u4f1a\u6536\u96c6\u60a8\u4e3b\u52a8\u63d0\u4f9b\u7684\u5730\u7406\u4f4d\u7f6e\u4fe1\u606f\u7528\u4e8e\u4e3a\u60a8\u63d0\u4f9b\u8ba2\u9605\u3001\u5bfc\u822a\u7b49\u670d\u52a1 ^\\star ^\\star \u3002 \u9700\u6ce8\u610f\uff0c\u6b64\u9879\u4fe1\u606f\u5e76\u4e0d\u4f1a\u88ab\u4fdd\u5b58\uff0c\u5373\u60a8\u6bcf\u6b21\u4f7f\u7528\u90fd\u9700\u8981\u5411\u6211\u4eec\u63d0\u4f9b\u3002 \u804a\u5929\u5185\u5bb9 \u6211\u4eec\u63d0\u4f9b\u7684\u5fae\u4fe1\u673a\u5668\u4eba\u53ef\u80fd\u4f1a\u4f7f\u7528\u5fae\u4fe1\u7fa4\u5185\u7684\u804a\u5929\u5185\u5bb9\uff08\u53d6\u51b3\u4e8e\u60a8\u7684\u8bbe\u5b9a\uff09\u7528\u4e8e\u81ea\u52a8\u8f9f\u8c23\u7b49\u529f\u80fd\u7684\u5b9e\u73b0 ^\\star ^\\star \u3002 \u9700\u6ce8\u610f\uff0c\u6b64\u9879\u4fe1\u606f\u5e76\u4e0d\u4f1a\u88ab\u4fdd\u5b58\uff0c\u5373\u60a8\u6bcf\u6b21\u4f7f\u7528\u90fd\u9700\u8981\u5411\u6211\u4eec\u63d0\u4f9b\u3002 ^\\star ^\\star \uff1a\u5982\u60a8\u4e3a\u670d\u52a1\u7684\u8fd0\u8425\u8005\u65f6\uff0c\u60a8\u5e94\u81ea\u884c\u5224\u65ad\u60a8\u662f\u5426\u80fd\u5f97\u5230\u6700\u7ec8\u7528\u6237\u7684\u6388\u6743\u3002","title":"1 \u6211\u4eec\u6536\u96c6\u7684\u4e2a\u4eba\u4fe1\u606f"},{"location":"about/privacy/#2","text":"\u6211\u4eec\u4ec5\u4f7f\u7528\u524d\u6b3e\u63d0\u5230\u7684\u4f7f\u7528\u4fe1\u606f\u8fdb\u884c\u7528\u6237\u4f53\u9a8c\u8bbe\u8ba1\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u6211\u4eec\u4e0d\u901a\u8fc7\u4efb\u4f55\u5f62\u5f0f\u4f7f\u7528\u4efb\u4f55\u7528\u6237\u7684\u4e2a\u4eba\u4fe1\u606f\u3002","title":"2 \u6211\u4eec\u4f7f\u7528\u7684\u4e2a\u4eba\u4fe1\u606f"},{"location":"about/privacy/#3","text":"\u7531\u4e8e\u6211\u4eec\u4e0d\u6536\u96c6\u60a8\u7684\u9690\u79c1\u4fe1\u606f\uff0c\u6211\u4eec\u4e0d\u62ab\u9732\u4e5f\u65e0\u6cd5\u62ab\u9732\u60a8\u7684\u9690\u79c1\u4fe1\u606f\u3002","title":"3 \u6211\u4eec\u62ab\u9732\u7684\u4e2a\u4eba\u4fe1\u606f"},{"location":"about/privacy/#4","text":"\u6211\u4eec\u53ea\u4fdd\u5b58\u901a\u8fc7\u552f\u4e00\u4e14\u533f\u540d\u7684\u7528\u6237\u6807\u8bc6\u6240\u83b7\u53d6\u7684\u60a8\u7684\u4f7f\u7528\u4fe1\u606f\uff0c\u800c\u4e0d\u6536\u96c6\u60a8\u7684\u4e2a\u4eba\u4fe1\u606f\u3002\u56e0\u6b64\u6211\u4eec\u65e0\u6cd5\u5efa\u7acb\u60a8\u4e0e\u67d0\u4e2a\u6216\u8005\u67d0\u51e0\u4e2a\u7528\u6237\u6807\u8bc6\u4e4b\u95f4\u7684\u5173\u8054\uff0c\u6240\u4ee5\u60a8\u65e0\u6cd5\u66f4\u6b63\u6216\u5220\u9664\u60a8\u7684\u9690\u79c1\u4fe1\u606f\u3002 \u5982\u679c\u60a8\u8ba4\u4e3a\u6211\u4eec\u5bf9\u60a8\u7684\u4e2a\u4eba\u4fe1\u606f\u7684\u4f7f\u7528\u65b9\u5f0f\u4e0e\u672c\u58f0\u660e\u4e0d\u7b26\uff0c\u6216\u8005\u8981\u4e86\u89e3\u6709\u5173\u60a8\u7684\u6743\u5229\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u8054\u7cfb\u60a8\u5f53\u5730\u7684\u6570\u636e\u4fdd\u62a4\u5f53\u5c40\u3002","title":"4 \u60a8\u7684\u6743\u5229"},{"location":"about/privacy/#5","text":"\u672c\u58f0\u660e\u6ca1\u6709\u8ff0\u53ca\u7b2c\u4e09\u65b9\u6216\u5e76\u975e\u4ee3\u8868\u6211\u4eec\u7684\u5176\u4ed6\u7ec4\u7ec7\u7684\u653f\u7b56\u548c\u505a\u6cd5\uff08\u5305\u62ec\u6709\u5173\u9690\u79c1\u548c\u5b89\u5168\u3001\u6570\u636e\u6536\u96c6\u3001\u5904\u7406\u3001\u4f7f\u7528\u3001\u5b58\u50a8\u548c\u62ab\u9732\u7684\u653f\u7b56\u548c\u505a\u6cd5\uff09\uff0c\u6211\u4eec\u5bf9\u8fd9\u4e9b\u653f\u7b56\u548c\u505a\u6cd5\u6982\u4e0d\u8d1f\u8d23\u3002","title":"5 \u7b2c\u4e09\u65b9\u5185\u5bb9"},{"location":"about/privacy/#6","text":"\u6211\u4eec\u53ef\u80fd\u4f1a\u4e0d\u65f6\u66f4\u6539\u672c\u58f0\u660e\uff0c\u4f7f\u4e4b\u80fd\u591f\u51c6\u786e\u53cd\u6620\u6211\u4eec\u7684\u505a\u6cd5\u3001\u6211\u4eec\u5185\u5bb9\u53ca\u6cd5\u5f8b\u8981\u6c42\u3002 \u672c\u58f0\u660e\u9876\u90e8\u7684\u201c\u4e0a\u6b21\u4fee\u6539\u65e5\u671f\u201d\u90e8\u5206\u6307\u51fa\u4e86\u4e0a\u6b21\u4fee\u8ba2\u672c\u58f0\u660e\u7684\u65e5\u671f\uff0c\u6bcf\u6b21\u53d1\u5e03\u4fee\u8ba2\u65f6\u6211\u4eec\u90fd\u4f1a\u66f4\u65b0\u6b64\u65e5\u671f\u3002\u5bf9\u672c\u58f0\u660e\u7684\u4efb\u4f55\u66f4\u6539\u5c06\u5728\u6211\u4eec\u516c\u5e03\u4fee\u8ba2\u7248\u9690\u79c1\u58f0\u660e\u65f6\u751f\u6548\u3002 \u6211\u4eec\u9f13\u52b1\u60a8\u5b9a\u671f\u67e5\u770b\u672c\u58f0\u660e\uff0c\u4e86\u89e3\u6211\u4eec\u5982\u4f55\u6536\u96c6\u3001\u4f7f\u7528\u548c\u5171\u4eab\u4e2a\u4eba\u4fe1\u606f\u3002","title":"6 \u672c\u58f0\u660e\u7684\u4fee\u8ba2"},{"location":"about/privacy/#7","text":"zyc.ai\u8ba4\u4e3a\u5f00\u653e\u4e0e\u9690\u79c1\u5bf9\u6211\u4eec\u53ca\u6211\u4eec\u7684\u7528\u6237\u5341\u5206\u91cd\u8981\u3002 \u56e0\u6b64\uff0c\u672c\u9690\u79c1\u653f\u7b56\u5c06\u9002\u7528\u4e8e\u4efb\u4f55zyc.ai\u5185\u5bb9\u7684\u884d\u751f\u4f5c\u54c1\u3002 \u5982\u679c\u60a8\u7684\u4f5c\u54c1\u884d\u751f\u81ea\u3001\u4f7f\u7528\u6216\u8005\u90e8\u5206\u4f7f\u7528zyc.ai\u6240\u63d0\u4f9b\u6216\u8fd0\u8425\u7684\u5185\u5bb9\uff0c\u60a8\u5fc5\u987b\u5c06\u5176\u6309\u7167\u4e0e\u672c\u534f\u8bae\u89c4\u5b9a\u7684\u76f8\u540c\u65b9\u5f0f\u5c06\u8be5\u4f5c\u54c1\u6216\u670d\u52a1\u6574\u4f53\u5411\u60f3\u8981\u83b7\u5f97\u8bb8\u53ef\u7684\u4eba\u6388\u6743\u3002 \u5982\u679c\u60a8\u4e0d\u80fd\u6309\u7167\u672c\u58f0\u660e\u7684\u8981\u6c42\u6765\u63d0\u4f9b\u6216\u8fd0\u8425\u5185\u5bb9\uff0c\u90a3\u4e48\u60a8\u5c06\u4e0d\u80fd\u63d0\u4f9b\u6216\u8fd0\u8425\u5b83\u4eec\u3002","title":"7 \u9002\u7528\u8303\u56f4"},{"location":"about/resume/","text":"zc@int.ac.cn Educational Experience # Bachelor of Information Technology # Australian National University 2017 February - Present Course Computer Vision Data Analysis Introduction to Machine Learning Vector Calculus Database Java Self Driving Assistant in Computer Simulation Environment Computer Vision ENGN4528 Obstacle detection based on Mask-RCNN Lane line detection based on SpatialCNN Micro service based on Message Queue High-Availability deployments based on Kubernetes Calendar Software Design Methodologies COMP2100 Network framework based on RxJava, Retrofit, and OkHtttp Patchwork (Board game) Structural Programming\uff08Advanced\uff09 COMP1140 GUI design based on JavaFX AI player based on genetic algorithm Summer Research # Visual Computing and Learning Laboratory, Peking University Center on Frontiers of Computer Science 2019 July - 2019 September Rock, Paper & Scissor Object Detection algorithms Working Experience # Research Intern # SenseTime Research 2019 December - Present Single Object Tracking Single Object Tracking using Siamese architecture SiamMargin SiamRPN++ SiamRPN SiamFC PySOT open source project Maintenance of the PySOT open source project Teaching Assistant # Peking University College of Engineering 2019 June - 2019 July Simulation Methods for Optimization and Learning Monte-Carlo algorithm Convex Optimization Integrated Water Resources Management: International Aspects Field trip leader Senior Student Assistant # Peking University International Student Division 2019 June - 2019 July Student Service Administration Events organizing Cinematography Video taking Intern # Lenovo Research 2018 November - 2019 February .Net Frontend Windows client Python Midlayer Concurrent RabbitMQ Redis Java Backend SpringMVC RabbitMQ MySQL Algorithm high-availability encapsulation and scheduling Kubernetes Rancher Docker Student Assistant # Peking University International Student Division 2018 June - 2018 August Student Service Administration Events organizing Cinematography Video taking Teaching Assistant # Xueweigui Education Lanzhou School 2017 December - 2018 January Professional Experience # Android app Development # Peking University Center of Youth Studies 2018 November - Present Android application of the BDWM BBS Project ZCbot # Personal Project 2018 November - Present One-key emergency report auto reply, group invitation, etc. Board game robot judge 1 st Assistant Camera # Zaoan 2018 April - 2018 May Camera Operation UAV Operation 1 st Assistant Director # A Separation (micro movie) 2017 July - 2017 September Production Sound Mixer Gaffer UAV Operation Voluntary Experience # Lecturer # leiphone.com, AI Yanxishe 2016 - Present Lectures of T-SNE algorithms, etc. Participate in translation and proof of lectures including CS224N, CS231N by the Stanford University. SET4ANU Volunteer # DRSS, Australian National University 2019 February - 2019 February Campus Tour Question Answering Events Crew # Weeden Lodge, UniLodge Australia 2017 January - 2017 December Event Organizing Humanitarian Settlement Volunteer # Australian Red Cross 2016 - 2018 Helping refugees to settle in the city of Canberra. New Media Operation # Baidu Baike Campus 2016 - 2016 Found and manage the new media operation team of the Baike Campus, Baike MT Operation of the Tieba, WeChat official account, and Weibo of the Baike Campus Online support of events host by the Baike Campus Instruction of operations of the divisions of Baike Campus","title":"Zhiyuan Chen"},{"location":"about/resume/#educational-experience","text":"","title":"Educational Experience"},{"location":"about/resume/#bachelor-of-information-technology","text":"Australian National University 2017 February - Present Course Computer Vision Data Analysis Introduction to Machine Learning Vector Calculus Database Java Self Driving Assistant in Computer Simulation Environment Computer Vision ENGN4528 Obstacle detection based on Mask-RCNN Lane line detection based on SpatialCNN Micro service based on Message Queue High-Availability deployments based on Kubernetes Calendar Software Design Methodologies COMP2100 Network framework based on RxJava, Retrofit, and OkHtttp Patchwork (Board game) Structural Programming\uff08Advanced\uff09 COMP1140 GUI design based on JavaFX AI player based on genetic algorithm","title":"Bachelor of Information Technology"},{"location":"about/resume/#summer-research","text":"Visual Computing and Learning Laboratory, Peking University Center on Frontiers of Computer Science 2019 July - 2019 September Rock, Paper & Scissor Object Detection algorithms","title":"Summer Research"},{"location":"about/resume/#working-experience","text":"","title":"Working Experience"},{"location":"about/resume/#research-intern","text":"SenseTime Research 2019 December - Present Single Object Tracking Single Object Tracking using Siamese architecture SiamMargin SiamRPN++ SiamRPN SiamFC PySOT open source project Maintenance of the PySOT open source project","title":"Research Intern"},{"location":"about/resume/#teaching-assistant","text":"Peking University College of Engineering 2019 June - 2019 July Simulation Methods for Optimization and Learning Monte-Carlo algorithm Convex Optimization Integrated Water Resources Management: International Aspects Field trip leader","title":"Teaching Assistant"},{"location":"about/resume/#senior-student-assistant","text":"Peking University International Student Division 2019 June - 2019 July Student Service Administration Events organizing Cinematography Video taking","title":"Senior Student Assistant"},{"location":"about/resume/#intern","text":"Lenovo Research 2018 November - 2019 February .Net Frontend Windows client Python Midlayer Concurrent RabbitMQ Redis Java Backend SpringMVC RabbitMQ MySQL Algorithm high-availability encapsulation and scheduling Kubernetes Rancher Docker","title":"Intern"},{"location":"about/resume/#student-assistant","text":"Peking University International Student Division 2018 June - 2018 August Student Service Administration Events organizing Cinematography Video taking","title":"Student Assistant"},{"location":"about/resume/#teaching-assistant_1","text":"Xueweigui Education Lanzhou School 2017 December - 2018 January","title":"Teaching Assistant"},{"location":"about/resume/#professional-experience","text":"","title":"Professional Experience"},{"location":"about/resume/#android-app-development","text":"Peking University Center of Youth Studies 2018 November - Present Android application of the BDWM BBS","title":"Android app Development"},{"location":"about/resume/#project-zcbot","text":"Personal Project 2018 November - Present One-key emergency report auto reply, group invitation, etc. Board game robot judge","title":"Project ZCbot"},{"location":"about/resume/#1st-assistant-camera","text":"Zaoan 2018 April - 2018 May Camera Operation UAV Operation","title":"1st Assistant Camera"},{"location":"about/resume/#1st-assistant-director","text":"A Separation (micro movie) 2017 July - 2017 September Production Sound Mixer Gaffer UAV Operation","title":"1st Assistant Director"},{"location":"about/resume/#voluntary-experience","text":"","title":"Voluntary Experience"},{"location":"about/resume/#lecturer","text":"leiphone.com, AI Yanxishe 2016 - Present Lectures of T-SNE algorithms, etc. Participate in translation and proof of lectures including CS224N, CS231N by the Stanford University.","title":"Lecturer"},{"location":"about/resume/#set4anu-volunteer","text":"DRSS, Australian National University 2019 February - 2019 February Campus Tour Question Answering","title":"SET4ANU Volunteer"},{"location":"about/resume/#events-crew","text":"Weeden Lodge, UniLodge Australia 2017 January - 2017 December Event Organizing","title":"Events Crew"},{"location":"about/resume/#humanitarian-settlement-volunteer","text":"Australian Red Cross 2016 - 2018 Helping refugees to settle in the city of Canberra.","title":"Humanitarian Settlement Volunteer"},{"location":"about/resume/#new-media-operation","text":"Baidu Baike Campus 2016 - 2016 Found and manage the new media operation team of the Baike Campus, Baike MT Operation of the Tieba, WeChat official account, and Weibo of the Baike Campus Online support of events host by the Baike Campus Instruction of operations of the divisions of Baike Campus","title":"New Media Operation"},{"location":"about/zhiyuan_chen/","text":"Zhiyuan is currently a visiting student at the Westlake University under supervision of Prof. Changbin Yu, he is also a summer research student at the Massachusetts Institute of Technology supervised by Dr. Yaju Fang. Prior to these, he was a research intern at the SenseTime supervised by Mr. Guangqi Chen. He is pursuing his Bachelor\u2019s degree at the Australian National University.","title":"Zhiyuan Chen"},{"location":"algorithm/complexity/","text":"\u7b97\u6cd5\u590d\u6742\u5ea6\u662f\u8861\u91cf\u4e00\u4e2a\u7b97\u6cd5\u4f18\u52a3\u7684\u91d1\u6807\u51c6\u3002\u5b83\u53ef\u4ee5\u5206\u4e3a \u65f6\u95f4\u590d\u6742\u5ea6 \u548c \u7a7a\u95f4\u590d\u6742\u5ea6 \u3002\u65f6\u95f4\u590d\u6742\u5ea6\u8868\u793a\u9700\u8981\u591a\u4e45\u53bb\u8ba1\u7b97\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u5219\u8868\u793a\u9700\u8981\u591a\u5c11\u5185\u5b58\u6765\u5b8c\u6210\u8ba1\u7b97\u3002\u7531\u4e8e\u76ee\u524d\u8ba1\u7b97\u673a\u6280\u672f\u7684\u53d1\u5c55\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u7684\u91cd\u8981\u6027\u8d8a\u6765\u8d8a\u4f4e\uff0c\u800c\u65f6\u95f4\u590d\u6742\u5ea6\u7684\u91cd\u8981\u6027\u8d8a\u6765\u8d8a\u9ad8\uff0c\u6240\u4ee5\u5f53\u6211\u4eec\u63d0\u5230\u590d\u6742\u5ea6\u7684\u65f6\u5019\uff0c\u4e00\u822c\u90fd\u8868\u793a\u65f6\u95f4\u590d\u6742\u5ea6\u3002\u6211\u4eec\u901a\u5e38\u901a\u8fc7 \u6e10\u8fdb\u5206\u6790\uff08Asymptotic Analysis\uff09 \u6765\u5206\u6790\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u3002 \u8ba9\u6211\u4eec\u4ece\u4e00\u4e2a\u7b80\u5355\u7684 n n \u4f4d\u6570\u4e58\u6cd5\u8fd0\u7b97\u4f8b\u5b50\u6765\u5f00\u59cb\u8fd9\u4e00\u7ae0\u3002 \u4f20\u7edf\u8ba1\u7b97\u673a\u662f\u5982\u4f55\u8fdb\u884c\u4e58\u6cd5\u8fd0\u7b97\u7684\u5462\uff1f\u6309\u4f4d\u76f8\u4e58\uff1f\u4e0d\uff0c\u8fd9\u6709\u4e9b\u592a\u4f20\u7edf\u4e86\u3002\u5206\u6cbb\u6cd5\uff08Divide and Conquer\uff09\uff1f\u5bf9\uff0c\u6ca1\u6709\u4ec0\u4e48\u6bd4\u5206\u6cbb\u6cd5\u6700\u7b80\u5355\u5f97\u4e86\uff0c\u5c06\u4e00\u4e2a\u590d\u6742\u7684\u5927\u95ee\u9898\u8f6c\u6362\u6210\u591a\u4e2a\u7b80\u5355\u7684\u5c0f\u95ee\u9898\uff0c\u591a\u4e48\u7f8e\u5999\uff01\u5bf9\u4e8e n n \u4f4d\u6570 x x \u548c y y \uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5b83\u4eec\u4e4b\u95f4\u7684\u4e58\u6cd5\u8fd0\u7b97 x \\times y x \\times y \u8f6c\u6362\u4e3a (a \\times 10^\\frac{n}{2} + b) \\times (c \\times 10^\\frac{n}{2} + d) (a \\times 10^\\frac{n}{2} + b) \\times (c \\times 10^\\frac{n}{2} + d) = (ac) \\cdot 10^n + (ad + bc) \\cdot 10^\\frac{n}{2} + bd (ac) \\cdot 10^n + (ad + bc) \\cdot 10^\\frac{n}{2} + bd \u3002\u5c31\u8fd9\u6837\uff0c\u901a\u8fc7\u51e0\u6b65\u7b80\u5355\u7684\u64cd\u4f5c\uff0c\u6211\u4eec\u5c31\u5c06\u4e00\u4e2a n n \u4f4d\u6570\u76f8\u4e58\u95ee\u9898\u8f6c\u6362\u6210\u4e86\u56db\u4e2a \\frac{n}{2} \\frac{n}{2} \u4f4d\u6570\u76f8\u4e58\u95ee\u9898\u3002\u53ea\u662f\uff0c\u4ed6\u7684\u590d\u6742\u5ea6\u7a0d\u5fae\u9ad8\u4e86\u4e00\u4e9b\uff0c\u6709 O(n{^2}) O(n{^2}) \u3002\u90a3\u4e48\uff0c\u6211\u4eec\u5982\u4f55\u80fd\u4f18\u5316\u4ed6\u5462\uff1f\u901a\u8fc7\u89c2\u5bdf\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0 ad + bc = (a + b) \\cdot (c + d) - ac - bd ad + bc = (a + b) \\cdot (c + d) - ac - bd \u3002\u7531\u4e8e ac ac \u3001 bd bd \u90fd\u662f\u6211\u4eec\u8ba1\u7b97\u6240\u9700\u8981\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u66ff\u4ee3\u6765\u5c06\u8fd9\u91cc\u7684\u4e24\u4e2a\u4e58\u6cd5\u7f29\u51cf\u5230\u4e00\u4e2a\u65b0\u4e58\u6cd5\uff0c\u6700\u7ec8\u8f6c\u6362\u4e3a\uff1a (ac) \\cdot 10^n + ((a + b) \\cdot (c + d) - ac - bd) \\cdot 10^\\frac{n}{2} + bd (ac) \\cdot 10^n + ((a + b) \\cdot (c + d) - ac - bd) \\cdot 10^\\frac{n}{2} + bd \u3002\u8fd9\u4e2a\u5f0f\u5b50\u770b\u8d77\u6765\u8981\u66f4\u590d\u6742\u4e00\u4e9b\uff0c\u4f46\u5b9e\u9645\u4e0a\u6211\u4eec\u5c06\u8fd9\u4e2a n n \u4f4d\u6570\u76f8\u4e58\u95ee\u9898\u8f6c\u6362\u6210\u4e86\u4e09\u4e2a \\frac{n}{2} \\frac{n}{2} \u4f4d\u6570\u76f8\u4e58\u95ee\u9898\uff0c\u4f7f\u5f97\u65f6\u95f4\u590d\u6742\u5ea6\u964d\u4f4e\u5230\u4e86 O(n^{\\log_2 3}) O(n^{\\log_2 3}) \uff08\u5982\u679c\u4f60\u5728\u8fd9\u91cc\u8fd8\u4e00\u5934\u96fe\u6c34\u7684\u8bdd\uff0c\u8bf7\u4e0d\u8981\u62c5\u5fc3\uff0c\u6211\u4eec\u7a0d\u540e\u4f1a\u8be6\u7ec6\u89e3\u91ca\uff09\u3002\u8fd9\u4e2a\u7b97\u6cd5\u4e5f\u88ab\u79f0\u4f5cKaratsuba\u7b97\u6cd5\uff0c\u4e0e\u4e4b\u7c7b\u4f3c\u7684\u8fd8\u6709Toom-Cook\u7b97\u6cd5\uff0c\u4ed6\u5c06\u8fd9\u4e2a n n \u4f4d\u6570\u76f8\u4e58\u95ee\u9898\u8f6c\u6362\u6210\u4e86\u4e94\u4e2a \\frac{n}{3} \\frac{n}{3} \u4f4d\u6570\u76f8\u4e58\u95ee\u9898\uff0c\u4f7f\u5f97\u65f6\u95f4\u590d\u6742\u5ea6\u8fdb\u4e00\u6b65\u964d\u4f4e\u5230\u4e86 O(n^{\\log_3 5}) O(n^{\\log_3 5}) \u3002\u6211\u4eec\u5f3a\u70c8\u5efa\u8bae\u4f60\u8bd5\u8bd5\u80fd\u4e0d\u80fd\u81ea\u5df1\u53bb\u627e\u5230\u5982\u4f55\u5b8c\u6210\u8fd9\u6837\u7684\u5206\u89e3\u3002\u6b64\u5916\uff0c\u5982\u679c\u4f60\u6709\u5fd7\u4e8e\u7b97\u6cd5\u7684\u8bdd\uff0cArnold Sch\u00f6nhage\u548cVolker Strassen\u4e8e1971\u5e74\u63d0\u51fa\u4f7f\u7528\u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362\uff08FFT\uff09\u8fdb\u884c\u4e58\u6cd5\u8fd0\u7b97\u7684SSA\uff08Sch\u00f6nhage-Strassen algorithm\uff09\u5c06\u4e58\u6cd5\u8fd0\u7b97\u63d0\u5347\u5230\u4e86\u591a\u9879\u5f0f\u65f6\u95f4\uff0c\u4eca\u5e74\u65e9\u4e9b\u65f6\u5019\uff0cDavid Harvey\u548cJoris van der Hoeven\u53d1\u5e03\u7684\u8bba\u6587 Integer multiplication in time O(n log n) \u5c06\u4e58\u6cd5\u8fd0\u7b97\u7684\u901f\u5ea6\u63d0\u5347\u5230\u4e86\u76ee\u524d\u7684\u7406\u8bba\u6781\u9650 \u2013 O(n log n) O(n log n) \u3002 \u7b26\u53f7 # \u6211\u4eec\u521a\u624d\u63d0\u5230\u4e86\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u662f O(n log n) O(n log n) \uff0c\u8fd9\u53c8\u662f\u4ec0\u4e48\u610f\u601d\u5462\uff1f \u5927O\u7b26\u53f7\uff0c\u53c8\u79f0\u6e10\u8fdb\u7b26\u53f7\uff0c\u662f\u5fb7\u56fd\u6570\u5b66\u5bb61892\u5e74\u5f15\u5165\u7684\u3002\u9664\u6b64\u4e4b\u5916\u8fd8\u6709\u5927\u03a9\u7b26\u53f7\u4e0e\u5927\u0398\u7b26\u53f7\uff08\u4e00\u4e2a\u6709\u8da3\u7684\u4e8b\u5b9e\uff0c\u5927O\u7b26\u53f7\u5176\u5b9e\u5e94\u8be5\u662f\u5927\u039f\u7b26\u53f7\uff08\u5e0c\u814a\u5b57\u6bcd\uff0cOmicron\uff0c\u4f46\u662f\u56e0\u4e3a\u039f\u548cO\u6ca1\u4ec0\u4e48\u89c6\u89c9\u533a\u522b\uff0c\u6240\u4ee5\u4e00\u822c\u4f1a\u76f4\u63a5\u8bf4O\u3002 \u65f6\u95f4\u9891\u5ea6 \u65f6\u95f4\u9891\u5ea6\u4f7f\u7528 T(n) T(n) \u7b26\u53f7\u8868\u793a\uff0c\u4ed6\u4ee3\u8868\u4e00\u4e2a\u7b97\u6cd5\u6267\u884c\u6240\u9700\u8981\u82b1\u8d39\u7684\u65f6\u95f4\u3002 \u5927O \u5bf9\u4e8e\u4e24\u4e2a\u5728\u4efb\u610f\u6b63\u5b9e\u6570\u7684\u65e0\u754c\u5b50\u96c6\u4e0a\u5b9a\u4e49\u7684\u5173\u4e8e n n \u7684\u5b9e\u6570\u6216\u590d\u6570\u51fd\u6570 f(n) f(n) \u548c\u5b9e\u6570\u51fd\u6570 g(n) g(n) \u5f53\u4e14\u4ec5\u5f53\u5b58\u5728\u6b63\u5b9e\u6570 c c \u548c n_0 n_0 \uff0c\u4f7f\u5f97\u5bf9\u4e8e\u6240\u6709 n, n > n_0 n, n > n_0 \u90fd\u6709 0 \\leq f(n) \\leq c g(n) 0 \\leq f(n) \\leq c g(n) \u5219\u6211\u4eec\u79f0 f(n) f(n) \u7684\u6e10\u8fdb\u4e0a\u754c\u4e3a g(n) g(n) \uff0c\u8bb0\u4f5c f(n) = O(g(n)) f(n) = O(g(n)) \u3002 \u4e00\u822c\u800c\u8a00\uff0c O(g(n)) O(g(n)) \u8868\u793a\u7b97\u6cd5 f(n) f(n) \u7684\u6700\u5dee\u60c5\u51b5\u8fd0\u884c\u65f6\u95f4\u3002 \u5927\u03a9 \u5bf9\u4e8e\u4e24\u4e2a\u5728\u4efb\u610f\u6b63\u5b9e\u6570\u7684\u65e0\u754c\u5b50\u96c6\u4e0a\u5b9a\u4e49\u7684\u5173\u4e8e n n \u7684\u5b9e\u6570\u6216\u590d\u6570\u51fd\u6570 f(n) f(n) \u548c\u5b9e\u6570\u51fd\u6570 g(n) g(n) \u5f53\u4e14\u4ec5\u5f53\u5b58\u5728\u6b63\u5b9e\u6570 c c \u548c n_0 n_0 \uff0c\u4f7f\u5f97\u5bf9\u4e8e\u6240\u6709 n, n > n_0 n, n > n_0 \u90fd\u6709 0 \\leq c g(n) \\leq f(n) 0 \\leq c g(n) \\leq f(n) \u5219\u6211\u4eec\u79f0 f(n) f(n) \u7684\u6e10\u8fdb\u4e0b\u754c\u4e3a g(n) g(n) \uff0c\u8bb0\u4f5c f(n) = \\Omega(g(n)) f(n) = \\Omega(g(n)) \u3002 \u4e00\u822c\u800c\u8a00\uff0c \\Omega(g(n)) \\Omega(g(n)) \u8868\u793a\u7b97\u6cd5 f(n) f(n) \u7684\u6700\u597d\u60c5\u51b5\u8fd0\u884c\u65f6\u95f4\u3002 \u5927\u0398 \u5bf9\u4e8e\u4e24\u4e2a\u5728\u4efb\u610f\u6b63\u5b9e\u6570\u7684\u65e0\u754c\u5b50\u96c6\u4e0a\u5b9a\u4e49\u7684\u5173\u4e8e n n \u7684\u5b9e\u6570\u6216\u590d\u6570\u51fd\u6570 f(n) f(n) \u548c\u5b9e\u6570\u51fd\u6570g(n) \u548c\u5b9e\u6570\u51fd\u6570g(n) \u5f53\u4e14\u4ec5\u5f53\u5b58\u5728\u6b63\u5b9e\u6570 c_1 c_1 \u3001 c_2 c_2 \u548c n_0 n_0 \uff0c\u4f7f\u5f97\u5bf9\u4e8e\u6240\u6709 n, n>n_0 n, n>n_0 \u90fd\u6709 0 \\leq c_1 g(n) \\leq f(n) \\leq c_2 g(n) 0 \\leq c_1 g(n) \\leq f(n) \\leq c_2 g(n) \uff0c\u5373 O(g(n)) = f(n) = \u03a9(g(n)) O(g(n)) = f(n) = \u03a9(g(n)) \u5219\u8bb0\u4f5c f(n) = \u0398(g(n)) f(n) = \u0398(g(n)) \u3002 \u4e00\u822c\u800c\u8a00\uff0c \\Theta(g(n)) \\Theta(g(n)) \u8868\u793a\u7b97\u6cd5 f(n) f(n) \u7684\u8fd0\u884c\u65f6\u95f4\u3002 \u7b97\u6cd5\u662f\u591a\u6837\u7684\uff0c\u540c\u4e00\u4e2a\u7b97\u6cd5\u5728\u4e0d\u540c\u60c5\u51b5\u4e0b\u7684\u590d\u6742\u5ea6\u4e00\u822c\u4e0d\u540c\uff08\u6bd4\u5982\u5feb\u901f\u6392\u5e8f\u548c\u5f52\u5e76\u6392\u5e8f\u6700\u597d\u60c5\u51b5\u90fd\u4e3a \\Omega(n \\log n) \\Omega(n \\log n) \uff0c\u4f46\u5feb\u901f\u6392\u5e8f\u6700\u574f\u60c5\u51b5\u662f O(n^2) O(n^2) \uff0c\u800c\u5f52\u5e76\u6392\u5e8f\u5219\u662f O(n \\log n) O(n \\log n) \uff09\uff0c\u0398\u5728\u5b9e\u9645\u5f53\u4e2d\u5f88\u5c11\u5e94\u7528\u3002\u6b64\u5916\uff0c\u4e00\u4e2a\u7b97\u6cd5\u7684\u6700\u574f\u60c5\u51b5\u8981\u6bd4\u6700\u597d\u60c5\u51b5\u66f4\u6709\u4ef7\u503c\u3002\u6240\u4ee5\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u8bf4\u5230\u590d\u6742\u5ea6\u7684\u65f6\u5019\u90fd\u4f1a\u4f7f\u7528O\uff0c\u751a\u81f3\u6709\u4e9b\u65f6\u5019\u6211\u4eec\u4f1a\u8bf4\u67d0\u4e2a\u7b97\u6cd5\u7684\u6700\u597d\u60c5\u51b5\u662f O(n \\log n) O(n \\log n) \uff0c\u800c\u4e0d\u4f7f\u7528\u03a9\u3002 \u6709\u4e86\u5927O\u548c\u5927\u03a9\uff0c\u81ea\u7136\u5c31\u6709\u5c0fo\u548c\u5c0f\u03c9\u3002 \u5c0fo \u5bf9\u4e8e\u4e24\u4e2a\u5728\u4efb\u610f\u6b63\u5b9e\u6570\u7684\u65e0\u754c\u5b50\u96c6\u4e0a\u5b9a\u4e49\u7684\u5173\u4e8e n n \u7684\u5b9e\u6570\u6216\u590d\u6570\u51fd\u6570 f(n) f(n) \u548c\u5b9e\u6570\u51fd\u6570 g(n) g(n) \u5f53\u4e14\u4ec5\u5f53\u5bf9\u4e8e\u4efb\u610f\u6b63\u5b9e\u6570 c c \u90fd\u5b58\u5728 n_0 n_0 \uff0c\u4f7f\u5f97\u5bf9\u4e8e\u6240\u6709\u7684 n, n > n_0 n, n > n_0 \u90fd\u6709 0 \\leq f(n) < c g(n) 0 \\leq f(n) < c g(n) \u5219\u8bb0\u4f5c f(n) = o(g(n)) f(n) = o(g(n)) \u3002 \u5c0f\u03c9 \u5bf9\u4e8e\u4e24\u4e2a\u5728\u4efb\u610f\u6b63\u5b9e\u6570\u7684\u65e0\u754c\u5b50\u96c6\u4e0a\u5b9a\u4e49\u7684\u5173\u4e8e n n \u7684\u5b9e\u6570\u6216\u590d\u6570\u51fd\u6570 f(n) f(n) \u548c\u5b9e\u6570\u51fd\u6570 g(n) g(n) \u5f53\u4e14\u4ec5\u5f53\u5bf9\u4e8e\u4efb\u610f\u6b63\u5b9e\u6570 c c \u90fd\u5b58\u5728 n_0 n_0 \uff0c\u4f7f\u5f97\u5bf9\u4e8e\u6240\u6709\u7684 n, n > n_0 n, n > n_0 \u90fd\u6709 0 \\leq c g(n) < f(n) 0 \\leq c g(n) < f(n) \u5219\u8bb0\u4f5c f(n) = \u03c9(g(n)) f(n) = \u03c9(g(n)) \u3002 \u5c0fo\u548c\u5c0f\u03c9\u8868\u793a\u7684\u662f\u7edd\u5bf9\u5927\u4e8e\uff0c\u8b6c\u5982\u8bf4\u5f53 f(n) = n^2 + n f(n) = n^2 + n \u65f6\uff0c f(n) = \u03a9(n^2) f(n) = \u03a9(n^2) \u4f46 f(n) \\neq \u03c9(n^2) f(n) \\neq \u03c9(n^2) \u3002\u51fd\u6570 f(n) f(n) \u7684\u590d\u6742\u5ea6\u53ef\u80fd\u65e2\u4e3a O(g(n)) O(g(n)) \u4e5f\u4e3a \\Omega(g(n)) \\Omega(g(n)) \uff08\u6b64\u65f6\u5373\u4e3a \\Theta(g(n)) \\Theta(g(n)) \uff0c\u4f46\u4e0d\u53ef\u80fd\u540c\u65f6\u4e3a o(g(n)) o(g(n)) \u548c \\Omega(g(n)) \\Omega(g(n)) \u6216\u8005 O(g(n)) O(g(n)) \u548c \\Omega(g(n)) \\Omega(g(n)) \u3002\u5c0fo\u548c\u5c0f\u03c9\u4ec5\u5728\u8fd9\u91cc\u5217\u51fa\u4ee5\u4f9b\u8bfb\u8005\u4e86\u89e3\uff0c\u73b0\u5b9e\u5f53\u4e2d\u51e0\u4e4e\u6ca1\u6709\u4eba\u4f7f\u7528\u8fd9\u4e9b\u7b26\u53f7\u3002 \\log \\log \u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u5f53\u4e2d\uff0c\u9664\u975e\u7279\u522b\u58f0\u660e\uff0c\u5426\u5219\u6211\u4eec\u4f1a\u9ed8\u8ba4 \\log \\log \u7684\u5e95\u6570\u4e3a2\u3002 \u65f6\u95f4 # \u6211\u4eec\u901a\u5e38\u4f1a\u6309\u7167\u590d\u6742\u5ea6\u79f0\u8fd9\u4e2a\u7b97\u6cd5\u662f\u67d0\u67d0\u65f6\u95f4\u7684\u3002 \u5e38\u6570\u65f6\u95f4 \u7b97\u6cd5\u590d\u6742\u5ea6\u4e0e\u95ee\u9898\u89c4\u6a21\u65e0\u5173\u7684\u4e00\u822c\u8bb0\u4e3a O(1) O(1) \uff0c\u8fd9\u6837\u7684\u7b97\u6cd5\u53ef\u4ee5\u88ab\u79f0\u4e3a\u5e38\u6570\u65f6\u95f4\u3002 \u73b0\u5b9e\u5f53\u4e2d\u5e38\u6570\u65f6\u95f4\u53ef\u89e3\u7684\u95ee\u9898\u975e\u5e38\u5c11\uff0c\u6bd4\u5982\u5728\u4e00\u4e2aHashSet\u5f53\u4e2d\u5bfb\u627e\u5143\u7d20\u3002 \u5bf9\u6570\u65f6\u95f4 O(\\log n) O(\\log n) \u4e00\u822c\u88ab\u79f0\u4f5c\u5bf9\u6570\u65f6\u95f4\u3002 \u4e0e\u5e38\u6570\u65f6\u95f4\u76f8\u4f3c\uff0c\u4ec5\u6709\u5f88\u5c11\u7684\u95ee\u9898\u80fd\u5728\u5bf9\u6570\u65f6\u95f4\u5f53\u4e2d\u89e3\u51b3\u3002\u56e0\u6b64\u8fd9\u4e2a\u547d\u540d\u4e5f\u5e76\u4e0d\u5e38\u7528\u3002 \u7ebf\u6027\u65f6\u95f4 \u6211\u4eec\u4e00\u822c\u5c06 O(n) O(n) \u3001 O(n \\log n) O(n \\log n) \u79f0\u4f5c\u7ebf\u6027\u65f6\u95f4\u3002 \u5927\u591a\u6570\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u90fd\u4e3a O(n) O(n) \u6216\u8005\u66f4\u9ad8\uff0c\u56e0\u4e3a\u4e00\u4e2a\u7b97\u6cd5\u4e00\u822c\u9700\u8981 O(n) O(n) \u6765\u8bfb\u53d6\u6570\u636e\u3002 \u591a\u9879\u5f0f\u65f6\u95f4 \u6211\u4eec\u5c06\u590d\u6742\u5ea6\u4e3a O(n^c), c > 1 O(n^c), c > 1 \u6216\u66f4\u4f4e\u7684\u79f0\u4f5c\u591a\u9879\u5f0f\u65f6\u95f4\u3002 \u591a\u9879\u5f0f\u65f6\u95f4\u5305\u542b\u4e86\u6b64\u524d\u63d0\u5230\u7684\u7ebf\u6027\u65f6\u95f4\u3001\u5bf9\u6570\u65f6\u95f4\u548c\u5e38\u6570\u65f6\u95f4\u2013\u4e8b\u5b9e\u4e0a\uff0c\u591a\u9879\u5f0f\u65f6\u95f4\u8fd9\u4e2a\u540d\u8bcd\u51fa\u73b0\u7684\u6982\u7387\u4e5f\u4f1a\u6bd4\u6b64\u524d\u7684\u4e09\u4e2a\u8981\u5e7f\u6cdb\u5f97\u591a\u3002\u6211\u4eec\u5c06\u53ef\u4ee5\u5728\u591a\u9879\u5f0f\u65f6\u95f4\u5185\u6c42\u89e3\u7684\u95ee\u9898\u79f0\u4f5c\u591a\u9879\u5f0f\u65f6\u95f4\u53ef\u89e3\u7684\u95ee\u9898\uff0c\u5373P\uff08polynomial\uff09\u95ee\u9898\uff1b\u5c06\u53ef\u4ee5\u5728\u591a\u9879\u5f0f\u65f6\u95f4\u5185\u9a8c\u8bc1\u4e00\u4e2a\u89e3\u662f\u5426\u6b63\u786e\u7684\u95ee\u9898\u79f0\u4e3a\u975e\u51b3\u5b9a\u6027\u591a\u9879\u5f0f\u65f6\u95f4\u53ef\u89e3\u95ee\u9898\uff0c\u5373NP\uff08nondeterministic polynomial\uff09\u95ee\u9898\u3002\u6709\u5173\u8fd9\u4e9b\u95ee\u9898\u7684\u5177\u4f53\u63cf\u8ff0\u53caNP\u56f0\u96be\uff08NP-hardness\uff09\u95ee\u9898\u548cNP\u5b8c\u5168\uff08NP-complete\uff09\u95ee\u9898\uff0c\u6211\u4eec\u5c06\u5728\u4e13\u95e8\u7684\u7ae0\u8282\u8fdb\u884c\u8ba8\u8bba\u3002 \u6307\u6570\u65f6\u95f4\u548c\u9636\u4e58\u65f6\u95f4 \u6211\u4eec\u5c06\u628a O(c^n), c > 1 O(c^n), c > 1 \u79f0\u4f5c\u6307\u6570\u65f6\u95f4\uff0c\u5c06 O(n!) O(n!) \u79f0\u4f5c\u9636\u4e58\u65f6\u95f4\u3002 \u5f53\u590d\u6742\u5ea6\u8fbe\u5230\u8fd9\u4e2a\u7ea7\u522b\u65f6\uff0c\u6211\u4eec\u901a\u5e38\u4f1a\u8ba4\u4e3a\u8fd9\u4e2a\u7b97\u6cd5\u662f\u4e0d\u53ef\u7528\u7684\u3002 \u4e0b\u8868\u63d0\u4f9b\u4e86\u5f53c=2\uff0cn=1000\u65f6\u5404\u4e2a\u65f6\u95f4\u6240\u9700\u7684\u8fd0\u7b97\u6b21\u6570\uff0c\u53ef\u4ee5\u76f4\u89c2\u5730\u53d1\u73b0\u591a\u9879\u5f0f\u65f6\u95f4\u53ca\u4ee5\u4e0a\u7684\u7b97\u6cd5\u4e0d\u53ef\u89e3\u3002 \u5e38\u6570\u65f6\u95f4 \u7ebf\u6027\u65f6\u95f4 \u591a\u9879\u5f0f\u65f6\u95f4 \u6307\u6570\u65f6\u95f4 \u9636\u4e58\u65f6\u95f4 \u8fd0\u7b97\u6b21\u6570 1 3000 1000000 1.07 \\times 10^{301} 1.07 \\times 10^{301} 4.02 \\times 10^{2568} 4.02 \\times 10^{2568} \u5206\u6790 # \u8bf4\u4e86\u8fd9\u4e48\u591a\uff0c\u7ec8\u4e8e\u5230\u4e86\u8fd9\u6700\u91cd\u8981\u7684\u4e00\u6b65\u4e86\u3002\u5982\u679c\u5206\u6790\u4e00\u4e2a\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u5462\uff1f \u7528\u6211\u4eec\u4e4b\u524d\u7684Karatsuba\u7b97\u6cd5\u4e3e\u4f8b\u6765\u8bf4\uff1a Karatsuba def karatsuba ( x , y ): x_len = len ( str ( x )) y_len = len ( str ( y )) if x_len == 1 or y_len == 1 : return x * y else : n = ceil ( max ( len_x , len_y ) / 2 ) a = floor ( x / 10 ** n ) b = x % 10 ** n c = floor ( y / 10 ** n ) d = y % 10 ** n ac = karatsuba ( a , c ) bd = karatsuba ( b , d ) e = karatsuba ( a + b , c + d ) - ac - bd return ac * 10 ** ( n * 2 ) + ( e * 10 ** n ) + bd \u6211\u4eec\u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u6ce8\u91ca\u6ce8\u660eRepeat\u7684\u4e09\u884c\u4ee3\u7801\u662f\u4e0d\u65ad\u91cd\u590d\u7684\uff0c\u5373\u6bcf\u6b21\u5206\u6cbb\u5c06\u4e00\u4e2a\u95ee\u9898\u53d8\u6210\u4e09\u4e2a\u95ee\u9898\uff0c\u540c\u65f6\u6bcf\u6b21\u5206\u6cbb\u95ee\u9898\u7684\u5927\u5c0f\u53d8\u4e3a\u539f\u6765\u7684\u4e00\u534a\u3002 \u6700\u7ec8\uff0c\u8fd9\u4e2a\u95ee\u9898\u4f1a\u8f6c\u6362\u4e3a 3^t 3^t \u4e2a \\frac{n}{2^t} \\frac{n}{2^t} \u4e2a\u8ba1\u7b97\uff0c\u90a3\u4e48\u590d\u6742\u5ea6\u5373\u4e3a O(3{^\\log{_2}n}) O(3{^\\log{_2}n}) \uff0c\u4e5f\u5373 O(n{^\\log{_2}3}) O(n{^\\log{_2}3}) \u3002 \u5f88\u7b80\u5355\uff0c\u4e0d\u662f\u5417\uff1f","title":"\u590d\u6742\u5ea6"},{"location":"algorithm/complexity/#_1","text":"\u6211\u4eec\u521a\u624d\u63d0\u5230\u4e86\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u662f O(n log n) O(n log n) \uff0c\u8fd9\u53c8\u662f\u4ec0\u4e48\u610f\u601d\u5462\uff1f \u5927O\u7b26\u53f7\uff0c\u53c8\u79f0\u6e10\u8fdb\u7b26\u53f7\uff0c\u662f\u5fb7\u56fd\u6570\u5b66\u5bb61892\u5e74\u5f15\u5165\u7684\u3002\u9664\u6b64\u4e4b\u5916\u8fd8\u6709\u5927\u03a9\u7b26\u53f7\u4e0e\u5927\u0398\u7b26\u53f7\uff08\u4e00\u4e2a\u6709\u8da3\u7684\u4e8b\u5b9e\uff0c\u5927O\u7b26\u53f7\u5176\u5b9e\u5e94\u8be5\u662f\u5927\u039f\u7b26\u53f7\uff08\u5e0c\u814a\u5b57\u6bcd\uff0cOmicron\uff0c\u4f46\u662f\u56e0\u4e3a\u039f\u548cO\u6ca1\u4ec0\u4e48\u89c6\u89c9\u533a\u522b\uff0c\u6240\u4ee5\u4e00\u822c\u4f1a\u76f4\u63a5\u8bf4O\u3002 \u65f6\u95f4\u9891\u5ea6 \u65f6\u95f4\u9891\u5ea6\u4f7f\u7528 T(n) T(n) \u7b26\u53f7\u8868\u793a\uff0c\u4ed6\u4ee3\u8868\u4e00\u4e2a\u7b97\u6cd5\u6267\u884c\u6240\u9700\u8981\u82b1\u8d39\u7684\u65f6\u95f4\u3002 \u5927O \u5bf9\u4e8e\u4e24\u4e2a\u5728\u4efb\u610f\u6b63\u5b9e\u6570\u7684\u65e0\u754c\u5b50\u96c6\u4e0a\u5b9a\u4e49\u7684\u5173\u4e8e n n \u7684\u5b9e\u6570\u6216\u590d\u6570\u51fd\u6570 f(n) f(n) \u548c\u5b9e\u6570\u51fd\u6570 g(n) g(n) \u5f53\u4e14\u4ec5\u5f53\u5b58\u5728\u6b63\u5b9e\u6570 c c \u548c n_0 n_0 \uff0c\u4f7f\u5f97\u5bf9\u4e8e\u6240\u6709 n, n > n_0 n, n > n_0 \u90fd\u6709 0 \\leq f(n) \\leq c g(n) 0 \\leq f(n) \\leq c g(n) \u5219\u6211\u4eec\u79f0 f(n) f(n) \u7684\u6e10\u8fdb\u4e0a\u754c\u4e3a g(n) g(n) \uff0c\u8bb0\u4f5c f(n) = O(g(n)) f(n) = O(g(n)) \u3002 \u4e00\u822c\u800c\u8a00\uff0c O(g(n)) O(g(n)) \u8868\u793a\u7b97\u6cd5 f(n) f(n) \u7684\u6700\u5dee\u60c5\u51b5\u8fd0\u884c\u65f6\u95f4\u3002 \u5927\u03a9 \u5bf9\u4e8e\u4e24\u4e2a\u5728\u4efb\u610f\u6b63\u5b9e\u6570\u7684\u65e0\u754c\u5b50\u96c6\u4e0a\u5b9a\u4e49\u7684\u5173\u4e8e n n \u7684\u5b9e\u6570\u6216\u590d\u6570\u51fd\u6570 f(n) f(n) \u548c\u5b9e\u6570\u51fd\u6570 g(n) g(n) \u5f53\u4e14\u4ec5\u5f53\u5b58\u5728\u6b63\u5b9e\u6570 c c \u548c n_0 n_0 \uff0c\u4f7f\u5f97\u5bf9\u4e8e\u6240\u6709 n, n > n_0 n, n > n_0 \u90fd\u6709 0 \\leq c g(n) \\leq f(n) 0 \\leq c g(n) \\leq f(n) \u5219\u6211\u4eec\u79f0 f(n) f(n) \u7684\u6e10\u8fdb\u4e0b\u754c\u4e3a g(n) g(n) \uff0c\u8bb0\u4f5c f(n) = \\Omega(g(n)) f(n) = \\Omega(g(n)) \u3002 \u4e00\u822c\u800c\u8a00\uff0c \\Omega(g(n)) \\Omega(g(n)) \u8868\u793a\u7b97\u6cd5 f(n) f(n) \u7684\u6700\u597d\u60c5\u51b5\u8fd0\u884c\u65f6\u95f4\u3002 \u5927\u0398 \u5bf9\u4e8e\u4e24\u4e2a\u5728\u4efb\u610f\u6b63\u5b9e\u6570\u7684\u65e0\u754c\u5b50\u96c6\u4e0a\u5b9a\u4e49\u7684\u5173\u4e8e n n \u7684\u5b9e\u6570\u6216\u590d\u6570\u51fd\u6570 f(n) f(n) \u548c\u5b9e\u6570\u51fd\u6570g(n) \u548c\u5b9e\u6570\u51fd\u6570g(n) \u5f53\u4e14\u4ec5\u5f53\u5b58\u5728\u6b63\u5b9e\u6570 c_1 c_1 \u3001 c_2 c_2 \u548c n_0 n_0 \uff0c\u4f7f\u5f97\u5bf9\u4e8e\u6240\u6709 n, n>n_0 n, n>n_0 \u90fd\u6709 0 \\leq c_1 g(n) \\leq f(n) \\leq c_2 g(n) 0 \\leq c_1 g(n) \\leq f(n) \\leq c_2 g(n) \uff0c\u5373 O(g(n)) = f(n) = \u03a9(g(n)) O(g(n)) = f(n) = \u03a9(g(n)) \u5219\u8bb0\u4f5c f(n) = \u0398(g(n)) f(n) = \u0398(g(n)) \u3002 \u4e00\u822c\u800c\u8a00\uff0c \\Theta(g(n)) \\Theta(g(n)) \u8868\u793a\u7b97\u6cd5 f(n) f(n) \u7684\u8fd0\u884c\u65f6\u95f4\u3002 \u7b97\u6cd5\u662f\u591a\u6837\u7684\uff0c\u540c\u4e00\u4e2a\u7b97\u6cd5\u5728\u4e0d\u540c\u60c5\u51b5\u4e0b\u7684\u590d\u6742\u5ea6\u4e00\u822c\u4e0d\u540c\uff08\u6bd4\u5982\u5feb\u901f\u6392\u5e8f\u548c\u5f52\u5e76\u6392\u5e8f\u6700\u597d\u60c5\u51b5\u90fd\u4e3a \\Omega(n \\log n) \\Omega(n \\log n) \uff0c\u4f46\u5feb\u901f\u6392\u5e8f\u6700\u574f\u60c5\u51b5\u662f O(n^2) O(n^2) \uff0c\u800c\u5f52\u5e76\u6392\u5e8f\u5219\u662f O(n \\log n) O(n \\log n) \uff09\uff0c\u0398\u5728\u5b9e\u9645\u5f53\u4e2d\u5f88\u5c11\u5e94\u7528\u3002\u6b64\u5916\uff0c\u4e00\u4e2a\u7b97\u6cd5\u7684\u6700\u574f\u60c5\u51b5\u8981\u6bd4\u6700\u597d\u60c5\u51b5\u66f4\u6709\u4ef7\u503c\u3002\u6240\u4ee5\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u8bf4\u5230\u590d\u6742\u5ea6\u7684\u65f6\u5019\u90fd\u4f1a\u4f7f\u7528O\uff0c\u751a\u81f3\u6709\u4e9b\u65f6\u5019\u6211\u4eec\u4f1a\u8bf4\u67d0\u4e2a\u7b97\u6cd5\u7684\u6700\u597d\u60c5\u51b5\u662f O(n \\log n) O(n \\log n) \uff0c\u800c\u4e0d\u4f7f\u7528\u03a9\u3002 \u6709\u4e86\u5927O\u548c\u5927\u03a9\uff0c\u81ea\u7136\u5c31\u6709\u5c0fo\u548c\u5c0f\u03c9\u3002 \u5c0fo \u5bf9\u4e8e\u4e24\u4e2a\u5728\u4efb\u610f\u6b63\u5b9e\u6570\u7684\u65e0\u754c\u5b50\u96c6\u4e0a\u5b9a\u4e49\u7684\u5173\u4e8e n n \u7684\u5b9e\u6570\u6216\u590d\u6570\u51fd\u6570 f(n) f(n) \u548c\u5b9e\u6570\u51fd\u6570 g(n) g(n) \u5f53\u4e14\u4ec5\u5f53\u5bf9\u4e8e\u4efb\u610f\u6b63\u5b9e\u6570 c c \u90fd\u5b58\u5728 n_0 n_0 \uff0c\u4f7f\u5f97\u5bf9\u4e8e\u6240\u6709\u7684 n, n > n_0 n, n > n_0 \u90fd\u6709 0 \\leq f(n) < c g(n) 0 \\leq f(n) < c g(n) \u5219\u8bb0\u4f5c f(n) = o(g(n)) f(n) = o(g(n)) \u3002 \u5c0f\u03c9 \u5bf9\u4e8e\u4e24\u4e2a\u5728\u4efb\u610f\u6b63\u5b9e\u6570\u7684\u65e0\u754c\u5b50\u96c6\u4e0a\u5b9a\u4e49\u7684\u5173\u4e8e n n \u7684\u5b9e\u6570\u6216\u590d\u6570\u51fd\u6570 f(n) f(n) \u548c\u5b9e\u6570\u51fd\u6570 g(n) g(n) \u5f53\u4e14\u4ec5\u5f53\u5bf9\u4e8e\u4efb\u610f\u6b63\u5b9e\u6570 c c \u90fd\u5b58\u5728 n_0 n_0 \uff0c\u4f7f\u5f97\u5bf9\u4e8e\u6240\u6709\u7684 n, n > n_0 n, n > n_0 \u90fd\u6709 0 \\leq c g(n) < f(n) 0 \\leq c g(n) < f(n) \u5219\u8bb0\u4f5c f(n) = \u03c9(g(n)) f(n) = \u03c9(g(n)) \u3002 \u5c0fo\u548c\u5c0f\u03c9\u8868\u793a\u7684\u662f\u7edd\u5bf9\u5927\u4e8e\uff0c\u8b6c\u5982\u8bf4\u5f53 f(n) = n^2 + n f(n) = n^2 + n \u65f6\uff0c f(n) = \u03a9(n^2) f(n) = \u03a9(n^2) \u4f46 f(n) \\neq \u03c9(n^2) f(n) \\neq \u03c9(n^2) \u3002\u51fd\u6570 f(n) f(n) \u7684\u590d\u6742\u5ea6\u53ef\u80fd\u65e2\u4e3a O(g(n)) O(g(n)) \u4e5f\u4e3a \\Omega(g(n)) \\Omega(g(n)) \uff08\u6b64\u65f6\u5373\u4e3a \\Theta(g(n)) \\Theta(g(n)) \uff0c\u4f46\u4e0d\u53ef\u80fd\u540c\u65f6\u4e3a o(g(n)) o(g(n)) \u548c \\Omega(g(n)) \\Omega(g(n)) \u6216\u8005 O(g(n)) O(g(n)) \u548c \\Omega(g(n)) \\Omega(g(n)) \u3002\u5c0fo\u548c\u5c0f\u03c9\u4ec5\u5728\u8fd9\u91cc\u5217\u51fa\u4ee5\u4f9b\u8bfb\u8005\u4e86\u89e3\uff0c\u73b0\u5b9e\u5f53\u4e2d\u51e0\u4e4e\u6ca1\u6709\u4eba\u4f7f\u7528\u8fd9\u4e9b\u7b26\u53f7\u3002 \\log \\log \u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u5f53\u4e2d\uff0c\u9664\u975e\u7279\u522b\u58f0\u660e\uff0c\u5426\u5219\u6211\u4eec\u4f1a\u9ed8\u8ba4 \\log \\log \u7684\u5e95\u6570\u4e3a2\u3002","title":"\u7b26\u53f7"},{"location":"algorithm/complexity/#_2","text":"\u6211\u4eec\u901a\u5e38\u4f1a\u6309\u7167\u590d\u6742\u5ea6\u79f0\u8fd9\u4e2a\u7b97\u6cd5\u662f\u67d0\u67d0\u65f6\u95f4\u7684\u3002 \u5e38\u6570\u65f6\u95f4 \u7b97\u6cd5\u590d\u6742\u5ea6\u4e0e\u95ee\u9898\u89c4\u6a21\u65e0\u5173\u7684\u4e00\u822c\u8bb0\u4e3a O(1) O(1) \uff0c\u8fd9\u6837\u7684\u7b97\u6cd5\u53ef\u4ee5\u88ab\u79f0\u4e3a\u5e38\u6570\u65f6\u95f4\u3002 \u73b0\u5b9e\u5f53\u4e2d\u5e38\u6570\u65f6\u95f4\u53ef\u89e3\u7684\u95ee\u9898\u975e\u5e38\u5c11\uff0c\u6bd4\u5982\u5728\u4e00\u4e2aHashSet\u5f53\u4e2d\u5bfb\u627e\u5143\u7d20\u3002 \u5bf9\u6570\u65f6\u95f4 O(\\log n) O(\\log n) \u4e00\u822c\u88ab\u79f0\u4f5c\u5bf9\u6570\u65f6\u95f4\u3002 \u4e0e\u5e38\u6570\u65f6\u95f4\u76f8\u4f3c\uff0c\u4ec5\u6709\u5f88\u5c11\u7684\u95ee\u9898\u80fd\u5728\u5bf9\u6570\u65f6\u95f4\u5f53\u4e2d\u89e3\u51b3\u3002\u56e0\u6b64\u8fd9\u4e2a\u547d\u540d\u4e5f\u5e76\u4e0d\u5e38\u7528\u3002 \u7ebf\u6027\u65f6\u95f4 \u6211\u4eec\u4e00\u822c\u5c06 O(n) O(n) \u3001 O(n \\log n) O(n \\log n) \u79f0\u4f5c\u7ebf\u6027\u65f6\u95f4\u3002 \u5927\u591a\u6570\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u90fd\u4e3a O(n) O(n) \u6216\u8005\u66f4\u9ad8\uff0c\u56e0\u4e3a\u4e00\u4e2a\u7b97\u6cd5\u4e00\u822c\u9700\u8981 O(n) O(n) \u6765\u8bfb\u53d6\u6570\u636e\u3002 \u591a\u9879\u5f0f\u65f6\u95f4 \u6211\u4eec\u5c06\u590d\u6742\u5ea6\u4e3a O(n^c), c > 1 O(n^c), c > 1 \u6216\u66f4\u4f4e\u7684\u79f0\u4f5c\u591a\u9879\u5f0f\u65f6\u95f4\u3002 \u591a\u9879\u5f0f\u65f6\u95f4\u5305\u542b\u4e86\u6b64\u524d\u63d0\u5230\u7684\u7ebf\u6027\u65f6\u95f4\u3001\u5bf9\u6570\u65f6\u95f4\u548c\u5e38\u6570\u65f6\u95f4\u2013\u4e8b\u5b9e\u4e0a\uff0c\u591a\u9879\u5f0f\u65f6\u95f4\u8fd9\u4e2a\u540d\u8bcd\u51fa\u73b0\u7684\u6982\u7387\u4e5f\u4f1a\u6bd4\u6b64\u524d\u7684\u4e09\u4e2a\u8981\u5e7f\u6cdb\u5f97\u591a\u3002\u6211\u4eec\u5c06\u53ef\u4ee5\u5728\u591a\u9879\u5f0f\u65f6\u95f4\u5185\u6c42\u89e3\u7684\u95ee\u9898\u79f0\u4f5c\u591a\u9879\u5f0f\u65f6\u95f4\u53ef\u89e3\u7684\u95ee\u9898\uff0c\u5373P\uff08polynomial\uff09\u95ee\u9898\uff1b\u5c06\u53ef\u4ee5\u5728\u591a\u9879\u5f0f\u65f6\u95f4\u5185\u9a8c\u8bc1\u4e00\u4e2a\u89e3\u662f\u5426\u6b63\u786e\u7684\u95ee\u9898\u79f0\u4e3a\u975e\u51b3\u5b9a\u6027\u591a\u9879\u5f0f\u65f6\u95f4\u53ef\u89e3\u95ee\u9898\uff0c\u5373NP\uff08nondeterministic polynomial\uff09\u95ee\u9898\u3002\u6709\u5173\u8fd9\u4e9b\u95ee\u9898\u7684\u5177\u4f53\u63cf\u8ff0\u53caNP\u56f0\u96be\uff08NP-hardness\uff09\u95ee\u9898\u548cNP\u5b8c\u5168\uff08NP-complete\uff09\u95ee\u9898\uff0c\u6211\u4eec\u5c06\u5728\u4e13\u95e8\u7684\u7ae0\u8282\u8fdb\u884c\u8ba8\u8bba\u3002 \u6307\u6570\u65f6\u95f4\u548c\u9636\u4e58\u65f6\u95f4 \u6211\u4eec\u5c06\u628a O(c^n), c > 1 O(c^n), c > 1 \u79f0\u4f5c\u6307\u6570\u65f6\u95f4\uff0c\u5c06 O(n!) O(n!) \u79f0\u4f5c\u9636\u4e58\u65f6\u95f4\u3002 \u5f53\u590d\u6742\u5ea6\u8fbe\u5230\u8fd9\u4e2a\u7ea7\u522b\u65f6\uff0c\u6211\u4eec\u901a\u5e38\u4f1a\u8ba4\u4e3a\u8fd9\u4e2a\u7b97\u6cd5\u662f\u4e0d\u53ef\u7528\u7684\u3002 \u4e0b\u8868\u63d0\u4f9b\u4e86\u5f53c=2\uff0cn=1000\u65f6\u5404\u4e2a\u65f6\u95f4\u6240\u9700\u7684\u8fd0\u7b97\u6b21\u6570\uff0c\u53ef\u4ee5\u76f4\u89c2\u5730\u53d1\u73b0\u591a\u9879\u5f0f\u65f6\u95f4\u53ca\u4ee5\u4e0a\u7684\u7b97\u6cd5\u4e0d\u53ef\u89e3\u3002 \u5e38\u6570\u65f6\u95f4 \u7ebf\u6027\u65f6\u95f4 \u591a\u9879\u5f0f\u65f6\u95f4 \u6307\u6570\u65f6\u95f4 \u9636\u4e58\u65f6\u95f4 \u8fd0\u7b97\u6b21\u6570 1 3000 1000000 1.07 \\times 10^{301} 1.07 \\times 10^{301} 4.02 \\times 10^{2568} 4.02 \\times 10^{2568}","title":"\u65f6\u95f4"},{"location":"algorithm/complexity/#_3","text":"\u8bf4\u4e86\u8fd9\u4e48\u591a\uff0c\u7ec8\u4e8e\u5230\u4e86\u8fd9\u6700\u91cd\u8981\u7684\u4e00\u6b65\u4e86\u3002\u5982\u679c\u5206\u6790\u4e00\u4e2a\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u5462\uff1f \u7528\u6211\u4eec\u4e4b\u524d\u7684Karatsuba\u7b97\u6cd5\u4e3e\u4f8b\u6765\u8bf4\uff1a Karatsuba def karatsuba ( x , y ): x_len = len ( str ( x )) y_len = len ( str ( y )) if x_len == 1 or y_len == 1 : return x * y else : n = ceil ( max ( len_x , len_y ) / 2 ) a = floor ( x / 10 ** n ) b = x % 10 ** n c = floor ( y / 10 ** n ) d = y % 10 ** n ac = karatsuba ( a , c ) bd = karatsuba ( b , d ) e = karatsuba ( a + b , c + d ) - ac - bd return ac * 10 ** ( n * 2 ) + ( e * 10 ** n ) + bd \u6211\u4eec\u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u6ce8\u91ca\u6ce8\u660eRepeat\u7684\u4e09\u884c\u4ee3\u7801\u662f\u4e0d\u65ad\u91cd\u590d\u7684\uff0c\u5373\u6bcf\u6b21\u5206\u6cbb\u5c06\u4e00\u4e2a\u95ee\u9898\u53d8\u6210\u4e09\u4e2a\u95ee\u9898\uff0c\u540c\u65f6\u6bcf\u6b21\u5206\u6cbb\u95ee\u9898\u7684\u5927\u5c0f\u53d8\u4e3a\u539f\u6765\u7684\u4e00\u534a\u3002 \u6700\u7ec8\uff0c\u8fd9\u4e2a\u95ee\u9898\u4f1a\u8f6c\u6362\u4e3a 3^t 3^t \u4e2a \\frac{n}{2^t} \\frac{n}{2^t} \u4e2a\u8ba1\u7b97\uff0c\u90a3\u4e48\u590d\u6742\u5ea6\u5373\u4e3a O(3{^\\log{_2}n}) O(3{^\\log{_2}n}) \uff0c\u4e5f\u5373 O(n{^\\log{_2}3}) O(n{^\\log{_2}3}) \u3002 \u5f88\u7b80\u5355\uff0c\u4e0d\u662f\u5417\uff1f","title":"\u5206\u6790"},{"location":"algorithm/divide%26conquer/","text":"\u5206\u6cbb\u6cd5 \u5206\u6cbb\uff0c\u5206\u800c\u6cbb\u4e4b\u4e5f\u3002 \u5c06\u4e00\u4e2a\u95ee\u9898\u8f6c\u5316\u4e3a\u4e24\u4e2a\u6216\u66f4\u591a\u7684\u76f8\u540c\u6216\u76f8\u4f3c\u7684\u5b50\u95ee\u9898\uff0c\u76f4\u5230\u6700\u540e\u7684\u5b50\u95ee\u9898\u53ef\u4ee5\u7b80\u5355\u7684\u76f4\u63a5\u6c42\u89e3\u3002\u6b64\u65f6\uff0c\u539f\u95ee\u9898\u7684\u89e3\u5373\u5b50\u95ee\u9898\u7684\u89e3\u7684\u5408\u5e76\u3002 \u5206\u6cbb\u6cd5\u5728\u7b97\u6cd5\u5f53\u4e2d\u53ef\u4ee5\u8bf4\u62e5\u6709\u6700\u4e3a\u5e7f\u6cdb\u7684\u5e94\u7528\u3002\u4e3e\u4f8b\u6765\u8bf4\uff0c\u4e58\u6cd5\u4f5c\u4e3a\u6700\u57fa\u7840\u7684\u7b97\u6cd5\u5728\u5927\u591a\u6570\u8bed\u8a00\u5f53\u4e2d\u90fd\u662f\u901a\u8fc7\u5206\u6cbb\u6cd5\u800c\u5b9e\u73b0\u7684\u3002\u5728\u672c\u5c0f\u8282\u5f53\u4e2d\u6211\u4eec\u4e5f\u5c06\u901a\u8fc7\u4e58\u6cd5\u6765\u8fdb\u884c\u8ba8\u8bba\u3002 \u5728\u5c0f\u5b66\u5f53\u4e2d\u6211\u4eec\u5b66\u8fc7\u7ad6\u5f0f\u4e58\u6cd5\u3002","title":"\u5206\u6cbb\u6cd5\uff08Divide and Conquer\uff09"},{"location":"algorithm/introduction/","text":"\u6211\u4eec\u90fd\u77e5\u9053\uff0c\u8ba1\u7b97\u673a\u79d1\u5b66\u5c5e\u4e8e\u5e94\u7528\u6570\u5b66\u7684\u5206\u652f\u3002\u7b97\u6cd5\uff0c\u81ea\u7136\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\u6700\u91cd\u8981\u7684\u4e00\u90e8\u5206\u3002\u90a3\u4e48\uff0c\u4ec0\u4e48\u662f\u7b97\u6cd5\u5462\uff1f Algorithm\uff08\u7b97\u6cd5\uff09\uff0c\u6e90\u81ea\u4e8e\u53e4\u6cd5\u8bed\u5355\u8bcdAlgorisme\uff0c\u539f\u610f\u662f\u963f\u62c9\u4f2f\u6570\u5b57\u7cfb\u7edf\u3002\u8fd9\u548c\u6211\u4eec\u4eca\u5929\u6240\u8bf4\u7684\u7b97\u6cd5\u81ea\u7136\u6709\u7740\u672c\u8d28\u4e0a\u7684\u533a\u522b\u3002\u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5c06\u7b97\u6cd5\u5b9a\u4e49\u4e3a\uff1a \u7b97\u6cd5 \u7531\u4e00\u7cfb\u5217\u8ba1\u7b97\u6b65\u9aa4\u6784\u6210\u7684\u5c06\u8f93\u5165\u8f6c\u6362\u4e3a\u8f93\u51fa\u7684\u6709\u9650\u4e14\u786e\u5b9a\u7684\u65b9\u6cd5 \u6709\u9650 \u7b97\u6cd5\u80fd\u5728\u6709\u9650\u6b65\u505c\u673a \u786e\u5b9a \u7b97\u6cd5\u7684\u6bcf\u4e00\u6b65\u8ba1\u7b97\u90fd\u662f\u786e\u5b9a\u7684 \u7b97\u6cd5\u4e0e\u7a0b\u5e8f\u65e0\u5173\u3002\u6709\u5f88\u591a\u7a0b\u5e8f\u5e76\u4e0d\u662f\u7b97\u6cd5\uff0c\u8b6c\u5982\u795e\u7ecf\u7f51\u7edc\u4fbf\u5e76\u4e0d\u6ee1\u8db3\u4ee5\u4e0a\u5b9a\u4e49\u3002\u7b97\u6cd5\u4e5f\u4e0e\u7f16\u7a0b\u8bed\u8a00\u65e0\u5173\u3002\u4f7f\u7528\u67d0\u79cd\u8bed\u8a00\u5199\u51fa\u4e00\u4e2a\u7a0b\u5e8f\u53ea\u662f\u8868\u8fbe\u7b97\u6cd5\u7684\u4e00\u79cd\u65b9\u5f0f\u2013\u4f60\u751a\u81f3\u53ef\u4ee5\u7528\u81ea\u7136\u8bed\u8a00\u53bb\u8868\u8fbe\u7b97\u6cd5\uff0c\u5982\u679c\u4f60\u613f\u610f\u7684\u8bdd\u3002\u5728\u672c\u7ae0\u5f53\u4e2d\uff0c\u6211\u4eec\u5c06\u4f7f\u7528Python\u6765\u5b9e\u73b0\u6240\u6709\u7b97\u6cd5\u3002\u73b0\u5b9e\u5f53\u4e2d\u4f60\u53ef\u80fd\u5e76\u4e0d\u60f3\u8fd9\u4e48\u505a\u2013\u4ee5C#\u3001C++\u4e3a\u4ee3\u8868\u7684\u9759\u6001\u7c7b\u578b\u8bed\u8a00\u63d0\u4f9b\u4e86\u65b9\u6cd5\u91cd\u8f7d\u7b49\u9ad8\u7ea7\u529f\u80fd\uff0c\u80fd\u4f7f\u4f60\u66f4\u9ad8\u6548\u7684\u53bb\u5b9e\u73b0\u67d0\u4e2a\u7b97\u6cd5\u3002\u6211\u4eec\u5728\u8fd9\u91cc\u9009\u62e9Python\u4ec5\u4ec5\u662f\u56e0\u4e3a\u6211\u61d2\u5f97\u6253\u62ec\u53f7\u3002 \u672c\u7ae0\u867d\u7136\u540d\u4e3a\u7b97\u6cd5\uff0c\u7136\u800c\u7edd\u5927\u591a\u6570\u7b97\u6cd5\u90fd\u9700\u8981\u6070\u5f53\u7684\u7ec4\u7ec7\u6570\u636e\u3002\u56e0\u6b64\uff0c\u6570\u636e\u7ed3\u6784\u53ef\u4ee5\u8bf4\u662f\u540c\u7b49\u91cd\u8981\u7684\u3002\u6211\u4eec\u5728\u6b64\u6cbf\u7528\u300a\u7b97\u6cd5\uff08\u7b2c\u56db\u7248\uff09\u300b\u4e2d\u7684\u5bf9\u6570\u636e\u7ed3\u6784\u7684\u5b9a\u4e49\uff1a \u6570\u636e\u7ed3\u6784 \u6570\u636e\u7ed3\u6784\u662f\u7b97\u6cd5\u7684\u526f\u4ea7\u54c1\u6216\u662f\u6700\u7ec8\u4ea7\u7269 \u672c\u7ae0\u8282\u5185\u5bb9\u53c2\u8003\u4e86\u8bb8\u591a\u8d44\u6599\uff0c\u5305\u62ecRobert Sedgewick\u548cKevin Wayne\u5408\u8457\u7684\u300a\u7b97\u6cd5\uff08\u7b2c\u56db\u7248\uff09\u300b\u3001Jon Kleinberg\u548c\u00c9va Tardos\u7684\u300a\u7b97\u6cd5\u8bbe\u8ba1\u300b\u3001\u9093\u4fca\u8f89\u7684\u300a\u6570\u636e\u7ed3\u6784\u300b\u3001Jeff Erickson\u7684\u300a\u7b97\u6cd5\u300b\u3001Thomas H. Cormen\u3001Charles E. Leiserson\u3001Ronald L. Rivest\u3001\u548cClifford Stein\u5408\u8457\u7684\u300a\u7b97\u6cd5\u5bfc\u8bba\u300b\u3001Mark Allen Weiss\u7684\u300a\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5\u5206\u6790\u300b\u3001\u4ee5\u53caDonald Knuth\u7684\u300a\u8ba1\u7b97\u673a\u7a0b\u5e8f\u8bbe\u8ba1\u827a\u672f\u300b\uff08\u6309\u7167\u63a8\u8350\u964d\u5e8f\u6392\u5217\uff09\u4ee5\u53ca\u8bb8\u591a\u7ebf\u4e0a\u4e0e\u7ebf\u4e0b\u8bfe\u7a0b\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u672c\u7ae0\u5e76\u4e0d\u610f\u56fe\u6210\u4e3a\u4e00\u672c\u65b0\u7684\u7b97\u6cd5\u6559\u6750\u2013\u4ed6\u4eec\u6240\u64b0\u5199\u7684\u4e66\u7c4d\u8981\u8fdc\u8d85\u6211\u7684\u6c34\u5e73\u3002\u672c\u7ae0\u4ec5\u610f\u5728\u4f7f\u7528\u901a\u4fd7\u6613\u61c2\u7684\u8bed\u8a00\u6765\u5bf9\u5176\u8fdb\u884c\u7b80\u5355\u7684\u63cf\u8ff0\u4ee5\u7ed9\u4f60\u4e00\u4e2a\u76f4\u89c9\u3002\u5982\u679c\u4f60\u6709\u5fd7\u4e8e\u5b66\u4e60\u7b97\u6cd5\uff0c\u6211\u4eec\u5f3a\u70c8\u5efa\u8bae\u4f60\u4ece\u7b2c\u4e00\u672c\u4e66\u5f00\u59cb\u770b\u8d77\u3002","title":"\u7b97\u6cd5\uff08Algorithm\uff09"},{"location":"algorithm/polynomial/","text":"\u5728\u6b64\u524d\u7684\u6587\u7ae0\u5f53\u4e2d\u6211\u4eec\u901a\u8fc7n\u4f4d\u6570\u4e58\u6cd5\u8fd0\u7b97\u7b80\u8981\u7684\u4ecb\u7ecd\u4e86\u7b97\u6cd5\u590d\u6742\u5ea6\u7684\u8ba1\u7b97\u3002\u5728\u672c\u6587\u5f53\u4e2d\u6211\u4eec\u5c06\u5bf9\u591a\u9879\u5f0f\u7684\u8ba1\u7b97\uff08evaluation\uff09\u3001\u52a0\u6cd5\uff08addition\uff09\u548c\u4e58\u6cd5\uff08multiplication\uff09\u63d0\u51fa\u7b97\u6cd5\u3002 \u591a\u9879\u5f0f \u7531\u53d8\u91cf\u4e0e\u7cfb\u6570\u901a\u8fc7\u6709\u9650\u6b21\u52a0\u51cf\u6cd5\u3001\u4e58\u6cd5\u4ee5\u53ca\u81ea\u7136\u6570\u5e42\u6b21\u7684\u4e58\u65b9\u8fd0\u7b97\u5f97\u5230\u7684\u6574\u5f0f\u3002 \u5f62\u5982 A(x) = a_0 + a_1x + a_2x^2 + ... + a_{n-1}x^{n-1} A(x) = a_0 + a_1x + a_2x^2 + ... + a_{n-1}x^{n-1} \u3002 \u5176\u4e2d\uff0c x x \u662f\u591a\u9879\u5f0f\u7684\u53d8\u91cf\u3001 a_0, a_1, a_2, ..., a_{n-1} a_0, a_1, a_2, ..., a_{n-1} \u662f\u591a\u9879\u5f0f\u7684\u7cfb\u6570\uff0c n n \u88ab\u79f0\u4e3a\u591a\u9879\u5f0f\u7684\u6b21\u6570\u3002 \u591a\u9879\u5f0f\u7684\u8868\u793a\uff08Representation\uff09 # \u4e00\u822c\u6765\u8bf4\uff0c\u591a\u9879\u5f0f\u53ef\u4ee5\u901a\u8fc7\u4e09\u79cd\u65b9\u6cd5\u8fdb\u884c\u8868\u793a\u3002\u5b83\u4eec\u5206\u522b\u662f\uff1a \u7cfb\u6570 A(x) = a_0 + a_1x + a_2x^2 + ... + a_{n-1}x^{n-1} A(x) = a_0 + a_1x + a_2x^2 + ... + a_{n-1}x^{n-1} \u5176\u4e2d\u591a\u9879\u5f0f\u7684\u7cfb\u6570\u53ef\u4ee5\u8868\u793a\u4e3a\u957f\u5ea6\u4e3a n n \u7684\u5411\u91cf \\vec{a} = a_0, a_1, a_2, ..., a_{n-1} \\vec{a} = a_0, a_1, a_2, ..., a_{n-1} \u6839 c(x-r_0)(x-r_1)(x-r_2)(x-r_3)(x-r_{n-1}) c(x-r_0)(x-r_1)(x-r_2)(x-r_3)(x-r_{n-1}) \u6837\u672c\uff08\u70b9\u503c\uff09 (x_k, A(x_k)) (x_k, A(x_k)) \u9009\u53d6 n n \u4e2a\u503c\u4e0d\u540c\u7684\u6570 x_0, x_1, x_2, ..., x_{n-1} x_0, x_1, x_2, ..., x_{n-1} \u5bf9\u591a\u9879\u5f0f\u8fdb\u884c\u6c42\u503c\uff0c\u5f97\u5230 A(x_0), A(x_1), A(x_2), ..., A(x_{n-1}) A(x_0), A(x_1), A(x_2), ..., A(x_{n-1}) \u3002 \u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u8f6c\u6362\u4e3a\u8303\u5fb7\u8499\u77e9\u9635\u5f62\u5f0f\uff0c \\mathbf{V} = \\begin{pmatrix}1&x_0&x_{0^2}&\\cdots &x_{0^{n-1}}\\\\ 1&x_1&x_{1^2}&\\cdots &x_{1^{n-1}}\\\\ 1&x_2&x_{2^2}&\\cdots &x_{2^{n-1}}\\\\ \\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\:\\\\ 1&x_{n-1}&x_{n-1^2}&\\cdots \\:&x_{n-1^{n-1}}\\end{pmatrix}\\begin{pmatrix}a_0\\\\ a_1\\\\ a_2\\\\ \\vdots \\:\\\\ a_{n-1}\\end{pmatrix} = \\begin{pmatrix}A(x_0)\\\\ A(x_1)\\\\ A(x_2)\\\\ \\vdots \\:\\\\ A(x_{n-1})\\end{pmatrix} \\mathbf{V} = \\begin{pmatrix}1&x_0&x_{0^2}&\\cdots &x_{0^{n-1}}\\\\ 1&x_1&x_{1^2}&\\cdots &x_{1^{n-1}}\\\\ 1&x_2&x_{2^2}&\\cdots &x_{2^{n-1}}\\\\ \\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\:\\\\ 1&x_{n-1}&x_{n-1^2}&\\cdots \\:&x_{n-1^{n-1}}\\end{pmatrix}\\begin{pmatrix}a_0\\\\ a_1\\\\ a_2\\\\ \\vdots \\:\\\\ a_{n-1}\\end{pmatrix} = \\begin{pmatrix}A(x_0)\\\\ A(x_1)\\\\ A(x_2)\\\\ \\vdots \\:\\\\ A(x_{n-1})\\end{pmatrix} \u6211\u4eec\u5f88\u5bb9\u6613\u53d1\u73b0\uff0c\u4e0d\u540c\u7684\u8fd0\u7b97\u5bf9\u4e0d\u540c\u7684\u8868\u793a\u6cd5\u6765\u8bf4\uff0c\u590d\u6742\u5ea6\u662f\u4e0d\u540c\u7684\u3002\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u8fd9\u6837\u7684\u8ba1\u7b97\u590d\u6742\u5ea6\u8868\uff1a \u8fd0\u7b97 \u7cfb\u6570 \u6839 \u6837\u672c \u8ba1\u7b97 O(n) O(n) O(n) O(n) O(n^2) O(n^2) \u52a0\u6cd5 O(n) O(n) O(\\infty) O(\\infty) O(n) O(n) \u4e58\u6cd5 O(n^2) O(n^2) O(n) O(n) O(n) O(n) \u6b64\u524d\u6211\u4eec\u4e86\u89e3\u5230\u6211\u4eec\u4f1a\u671f\u671b\u4e00\u4e2a\u590d\u6742\u5ea6\u4e3a O(n\\log n) O(n\\log n) \u6216\u66f4\u4f4e\u7684\u7b97\u6cd5\u3002\u901a\u8fc7\u89c2\u5bdf\u8fd9\u4e24\u4e2a\u8868\u683c\uff0c\u6211\u4eec\u53d1\u73b0\u5bf9\u4e8e\u4e24\u4e2a\u591a\u9879\u5f0f\u6765\u8bf4\uff0c\u6211\u4eec\u66f4\u5e0c\u671b\u4f7f\u7528\u7cfb\u6570\u8868\u793a\u53bb\u5b8c\u6210\u8ba1\u7b97\u548c\u52a0\u6cd5\u3001\u4f7f\u7528\u6839\u8868\u793a\u53bb\u5b8c\u6210\u8ba1\u7b97\u548c\u4e58\u6cd5\u3001\u4f7f\u7528\u6837\u672c\u8868\u793a\u53bb\u5b8c\u6210\u52a0\u6cd5\u548c\u4e58\u6cd5\u3002 \u90a3\u4e48\uff0c\u8fd9\u4e09\u79cd\u8868\u793a\u6cd5\u4e4b\u95f4\u4e92\u76f8\u8f6c\u6362\u7684\u590d\u6742\u5ea6\u5982\u4f55\u5462\uff1f\u6211\u4eec\u53ef\u4ee5\u6709\u8fd9\u6837\u7684\u8f6c\u6362\u590d\u6742\u5ea6\u8868\uff1a \u8fd0\u7b97 \u7cfb\u6570 \u6839 \u6837\u672c \u7cfb\u6570 - O(\\infty) O(\\infty) O(n\\log n) O(n\\log n) \u6839 O(n) O(n) - O(n\\log n) O(n\\log n) \u6837\u672c O(n\\log n) O(n\\log n) O(\\infty) O(\\infty) - \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u5bf9\u4e8e\u4e24\u4e2a\u591a\u9879\u5f0f\u6765\u8bf4\uff0c\u6211\u4eec\u5e0c\u671b\u5c06\u6837\u672c\u8868\u793a\u8f6c\u6362\u4e3a\u7cfb\u6570\u8868\u793a\u6765\u5b8c\u6210\u52a0\u6cd5\uff0c\u5c06\u7cfb\u6570\u8868\u793a\u8f6c\u6362\u4e3a\u6837\u672c\u8868\u793a\u6765\u5b8c\u6210\u4e58\u6cd5 \u2013 \u8fd9\u6837\u80fd\u5c06\u590d\u6742\u5ea6\u4ece O(n^2) O(n^2) \u964d\u81f3 O(n\\log n) O(n\\log n) \uff0c\u800c\u8fd9\u6b63\u662f\u6211\u4eec\u60f3\u8981\u7684\uff08\u6839\u8868\u793a\u7684\u4e58\u6cd5\u590d\u6742\u5ea6\u4e5f\u5f88\u597d\uff0c\u4f46\u6211\u4eec\u901a\u5e38\u4e0d\u5e0c\u671b\u53bb\u5b9e\u73b0\u4e00\u4e2a\u590d\u6742\u5ea6\u4e3a O(\\infty) O(\\infty) \u7684\u8f6c\u6362\u7b97\u6cd5 \u6240\u4ee5\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u5728\u7cfb\u6570\u8868\u793a\u6cd5\u548c\u6837\u672c\u8868\u793a\u6cd5\u4e4b\u95f4\u8f6c\u6362\u7684\u7b97\u6cd5\u3002 \u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362\uff08FFT\uff09 # \u79bb\u6563\u5085\u91cc\u53f6\u53d8\u6362\uff08DFT\uff09 # \u79bb\u6563\u5085\u91cc\u53f6\u9006\u53d8\u6362\uff08IDFT\uff09 #","title":"\u591a\u9879\u5f0f\uff08Polynomial\uff09"},{"location":"algorithm/polynomial/#representation","text":"\u4e00\u822c\u6765\u8bf4\uff0c\u591a\u9879\u5f0f\u53ef\u4ee5\u901a\u8fc7\u4e09\u79cd\u65b9\u6cd5\u8fdb\u884c\u8868\u793a\u3002\u5b83\u4eec\u5206\u522b\u662f\uff1a \u7cfb\u6570 A(x) = a_0 + a_1x + a_2x^2 + ... + a_{n-1}x^{n-1} A(x) = a_0 + a_1x + a_2x^2 + ... + a_{n-1}x^{n-1} \u5176\u4e2d\u591a\u9879\u5f0f\u7684\u7cfb\u6570\u53ef\u4ee5\u8868\u793a\u4e3a\u957f\u5ea6\u4e3a n n \u7684\u5411\u91cf \\vec{a} = a_0, a_1, a_2, ..., a_{n-1} \\vec{a} = a_0, a_1, a_2, ..., a_{n-1} \u6839 c(x-r_0)(x-r_1)(x-r_2)(x-r_3)(x-r_{n-1}) c(x-r_0)(x-r_1)(x-r_2)(x-r_3)(x-r_{n-1}) \u6837\u672c\uff08\u70b9\u503c\uff09 (x_k, A(x_k)) (x_k, A(x_k)) \u9009\u53d6 n n \u4e2a\u503c\u4e0d\u540c\u7684\u6570 x_0, x_1, x_2, ..., x_{n-1} x_0, x_1, x_2, ..., x_{n-1} \u5bf9\u591a\u9879\u5f0f\u8fdb\u884c\u6c42\u503c\uff0c\u5f97\u5230 A(x_0), A(x_1), A(x_2), ..., A(x_{n-1}) A(x_0), A(x_1), A(x_2), ..., A(x_{n-1}) \u3002 \u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u8f6c\u6362\u4e3a\u8303\u5fb7\u8499\u77e9\u9635\u5f62\u5f0f\uff0c \\mathbf{V} = \\begin{pmatrix}1&x_0&x_{0^2}&\\cdots &x_{0^{n-1}}\\\\ 1&x_1&x_{1^2}&\\cdots &x_{1^{n-1}}\\\\ 1&x_2&x_{2^2}&\\cdots &x_{2^{n-1}}\\\\ \\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\:\\\\ 1&x_{n-1}&x_{n-1^2}&\\cdots \\:&x_{n-1^{n-1}}\\end{pmatrix}\\begin{pmatrix}a_0\\\\ a_1\\\\ a_2\\\\ \\vdots \\:\\\\ a_{n-1}\\end{pmatrix} = \\begin{pmatrix}A(x_0)\\\\ A(x_1)\\\\ A(x_2)\\\\ \\vdots \\:\\\\ A(x_{n-1})\\end{pmatrix} \\mathbf{V} = \\begin{pmatrix}1&x_0&x_{0^2}&\\cdots &x_{0^{n-1}}\\\\ 1&x_1&x_{1^2}&\\cdots &x_{1^{n-1}}\\\\ 1&x_2&x_{2^2}&\\cdots &x_{2^{n-1}}\\\\ \\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\:\\\\ 1&x_{n-1}&x_{n-1^2}&\\cdots \\:&x_{n-1^{n-1}}\\end{pmatrix}\\begin{pmatrix}a_0\\\\ a_1\\\\ a_2\\\\ \\vdots \\:\\\\ a_{n-1}\\end{pmatrix} = \\begin{pmatrix}A(x_0)\\\\ A(x_1)\\\\ A(x_2)\\\\ \\vdots \\:\\\\ A(x_{n-1})\\end{pmatrix} \u6211\u4eec\u5f88\u5bb9\u6613\u53d1\u73b0\uff0c\u4e0d\u540c\u7684\u8fd0\u7b97\u5bf9\u4e0d\u540c\u7684\u8868\u793a\u6cd5\u6765\u8bf4\uff0c\u590d\u6742\u5ea6\u662f\u4e0d\u540c\u7684\u3002\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u8fd9\u6837\u7684\u8ba1\u7b97\u590d\u6742\u5ea6\u8868\uff1a \u8fd0\u7b97 \u7cfb\u6570 \u6839 \u6837\u672c \u8ba1\u7b97 O(n) O(n) O(n) O(n) O(n^2) O(n^2) \u52a0\u6cd5 O(n) O(n) O(\\infty) O(\\infty) O(n) O(n) \u4e58\u6cd5 O(n^2) O(n^2) O(n) O(n) O(n) O(n) \u6b64\u524d\u6211\u4eec\u4e86\u89e3\u5230\u6211\u4eec\u4f1a\u671f\u671b\u4e00\u4e2a\u590d\u6742\u5ea6\u4e3a O(n\\log n) O(n\\log n) \u6216\u66f4\u4f4e\u7684\u7b97\u6cd5\u3002\u901a\u8fc7\u89c2\u5bdf\u8fd9\u4e24\u4e2a\u8868\u683c\uff0c\u6211\u4eec\u53d1\u73b0\u5bf9\u4e8e\u4e24\u4e2a\u591a\u9879\u5f0f\u6765\u8bf4\uff0c\u6211\u4eec\u66f4\u5e0c\u671b\u4f7f\u7528\u7cfb\u6570\u8868\u793a\u53bb\u5b8c\u6210\u8ba1\u7b97\u548c\u52a0\u6cd5\u3001\u4f7f\u7528\u6839\u8868\u793a\u53bb\u5b8c\u6210\u8ba1\u7b97\u548c\u4e58\u6cd5\u3001\u4f7f\u7528\u6837\u672c\u8868\u793a\u53bb\u5b8c\u6210\u52a0\u6cd5\u548c\u4e58\u6cd5\u3002 \u90a3\u4e48\uff0c\u8fd9\u4e09\u79cd\u8868\u793a\u6cd5\u4e4b\u95f4\u4e92\u76f8\u8f6c\u6362\u7684\u590d\u6742\u5ea6\u5982\u4f55\u5462\uff1f\u6211\u4eec\u53ef\u4ee5\u6709\u8fd9\u6837\u7684\u8f6c\u6362\u590d\u6742\u5ea6\u8868\uff1a \u8fd0\u7b97 \u7cfb\u6570 \u6839 \u6837\u672c \u7cfb\u6570 - O(\\infty) O(\\infty) O(n\\log n) O(n\\log n) \u6839 O(n) O(n) - O(n\\log n) O(n\\log n) \u6837\u672c O(n\\log n) O(n\\log n) O(\\infty) O(\\infty) - \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u5bf9\u4e8e\u4e24\u4e2a\u591a\u9879\u5f0f\u6765\u8bf4\uff0c\u6211\u4eec\u5e0c\u671b\u5c06\u6837\u672c\u8868\u793a\u8f6c\u6362\u4e3a\u7cfb\u6570\u8868\u793a\u6765\u5b8c\u6210\u52a0\u6cd5\uff0c\u5c06\u7cfb\u6570\u8868\u793a\u8f6c\u6362\u4e3a\u6837\u672c\u8868\u793a\u6765\u5b8c\u6210\u4e58\u6cd5 \u2013 \u8fd9\u6837\u80fd\u5c06\u590d\u6742\u5ea6\u4ece O(n^2) O(n^2) \u964d\u81f3 O(n\\log n) O(n\\log n) \uff0c\u800c\u8fd9\u6b63\u662f\u6211\u4eec\u60f3\u8981\u7684\uff08\u6839\u8868\u793a\u7684\u4e58\u6cd5\u590d\u6742\u5ea6\u4e5f\u5f88\u597d\uff0c\u4f46\u6211\u4eec\u901a\u5e38\u4e0d\u5e0c\u671b\u53bb\u5b9e\u73b0\u4e00\u4e2a\u590d\u6742\u5ea6\u4e3a O(\\infty) O(\\infty) \u7684\u8f6c\u6362\u7b97\u6cd5 \u6240\u4ee5\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u5728\u7cfb\u6570\u8868\u793a\u6cd5\u548c\u6837\u672c\u8868\u793a\u6cd5\u4e4b\u95f4\u8f6c\u6362\u7684\u7b97\u6cd5\u3002","title":"\u591a\u9879\u5f0f\u7684\u8868\u793a\uff08Representation\uff09"},{"location":"algorithm/polynomial/#fft","text":"","title":"\u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362\uff08FFT\uff09"},{"location":"algorithm/polynomial/#dft","text":"","title":"\u79bb\u6563\u5085\u91cc\u53f6\u53d8\u6362\uff08DFT\uff09"},{"location":"algorithm/polynomial/#idft","text":"","title":"\u79bb\u6563\u5085\u91cc\u53f6\u9006\u53d8\u6362\uff08IDFT\uff09"},{"location":"algorithm/recurrence_relation/","text":"\u9012\u63a8\u65b9\u7a0b\uff08\u9012\u63a8\u5173\u7cfb\uff09 \u5f53\u4e00\u4e2a\u6216\u591a\u4e2a\u521d\u59cb\u9879\u88ab\u7ed9\u51fa\u65f6\uff0c\u9012\u5f52\u5730\u5b9a\u4e49\u4e00\u5e8f\u5217\u6216\u4e00\u4e2a\u591a\u7ef4\u6570\u7ec4\u7684\u503c\u7684\u65b9\u7a0b\u3002 \u5e8f\u5217\u6216\u6570\u7ec4\u7684\u65b0\u9879\u88ab\u5b9a\u4e49\u4e3a\u4e4b\u524d\u9879\u7684\u4e00\u4e2a\u65b9\u7a0b\u3002 \u9012\u63a8\u5173\u7cfb\u5728\u7b97\u6cd5\u5f53\u4e2d\u975e\u5e38\u5e38\u89c1\u3002\u6211\u4eec\u901a\u5e38\u5c06\u9012\u63a8\u5173\u7cfb\u7684\u7b97\u6cd5\u79f0\u4f5c\u9012\u5f52\u7b97\u6cd5\u3002\u5728\u672c\u7ae0\u7684 \u6811 \u4e00\u6587\u4e2d\uff0c\u6211\u4eec\u7684\u9ad8\u5ea6\u3001\u63d2\u5165\u548c\u5220\u9664\u90fd\u662f\u901a\u8fc7\u9012\u5f52\u6765\u5b9e\u73b0\u7684\u3002\u4e3a\u4e86\u4fbf\u4e8e\u66f4\u597d\u7684\u63cf\u8ff0\uff0c\u5728\u672c\u6587\u5f53\u4e2d\uff0c\u6211\u4eec\u5c06\u4ee5Karatsuba\u7b97\u6cd5\u4f5c\u4e3a\u4f8b\u5b50: Karatsuba\u7b97\u6cd5 Karatsuba def karatsuba ( x , y ): x_len = len ( str ( x )) y_len = len ( str ( y )) if x_len == 1 or y_len == 1 : return x * y else : n = ceil ( max ( len_x , len_y ) / 2 ) a = floor ( x / 10 ** n ) b = x % 10 ** n c = floor ( y / 10 ** n ) d = y % 10 ** n ac = karatsuba ( a , c ) bd = karatsuba ( b , d ) e = karatsuba ( a + b , c + d ) - ac - bd return ac * 10 ** ( n * 2 ) + ( e * 10 ** n ) + bd \u901a\u8fc7\u89c2\u5bdf,\u5bf9\u4e8e\u4e24\u4e2a n n \u4f4d\u6570\u7684\u76f8\u4e58\u95ee\u9898\uff0c\u6211\u4eec\u901a\u8fc7\u4e0a\u8ff0\u64cd\u4f5c\u5c06\u5176\u8f6c\u6362\u4e3a\u4e09\u4e2a \\frac{n}{2} \\frac{n}{2} \u4f4d\u6570\u7684\u76f8\u4e58\u95ee\u9898\u3002\u5176\u9012\u63a8\u65b9\u7a0b\u5373\u4e3a T(n) = \\left\\{\\begin{array}{lr}3T(n/2) + f(n), & n > 1 \\\\ 1, & n = 1\\end{array}\\right. T(n) = \\left\\{\\begin{array}{lr}3T(n/2) + f(n), & n > 1 \\\\ 1, & n = 1\\end{array}\\right. \u3002 \u5bf9\u9012\u63a8\u65b9\u7a0b\u6c42\u89e3\u6709\u5f88\u591a\u529e\u6cd5\uff0c\u5305\u62ec\uff1a \u8fed\u4ee3\u6cd5 \u5dee\u6d88\u6cd5 \u8fed\u4ee3\u6811 \u4e3b\u5b9a\u7406 \u8fed\u4ee3\u6cd5 # \u8fed\u4ee3\u6cd5 \u4e0d\u65ad\u7528\u9012\u63a8\u65b9\u7a0b\u7684\u53f3\u90e8\u66ff\u4ee3\u5de6\u90e8\uff0c\u76f4\u5230\u51fa\u73b0\u521d\u503c\u505c\u6b62\u8fed\u4ee3\u3002 \u5bf9\u4e8eKaratsuba\u7b97\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u8fdb\u884c\u5982\u4e0b\u8fed\u4ee3\uff1a \\begin{split} T(n) &= 3T(n/2) + f(n) \\\\ &= 3[3T(n/4) + f(\\frac{n}{2})] + f(n) \\\\ &= 3^2 T(n/2^2) + f(\\frac{3n}{2}) \\\\ & \\quad \\vdots \\\\ &= 3^{\\log_2 n} \\times T(1) + \\sum_{i=2}^{n} f(n + \\frac{\\log_2 i \\cdot n}{2^{\\log_2 i}})) \\\\ &= 3^{\\log_2 n} + \\sum_{i=2}^{n} f(n + \\frac{\\log_2 i \\cdot n}{2^{\\log_2 i}}) \\\\ &= n^{\\log_2 3} + O(n) \\\\ &= O(n^{\\log 3})\\end{split} \\begin{split} T(n) &= 3T(n/2) + f(n) \\\\ &= 3[3T(n/4) + f(\\frac{n}{2})] + f(n) \\\\ &= 3^2 T(n/2^2) + f(\\frac{3n}{2}) \\\\ & \\quad \\vdots \\\\ &= 3^{\\log_2 n} \\times T(1) + \\sum_{i=2}^{n} f(n + \\frac{\\log_2 i \\cdot n}{2^{\\log_2 i}})) \\\\ &= 3^{\\log_2 n} + \\sum_{i=2}^{n} f(n + \\frac{\\log_2 i \\cdot n}{2^{\\log_2 i}}) \\\\ &= n^{\\log_2 3} + O(n) \\\\ &= O(n^{\\log 3})\\end{split} \u5dee\u6d88\u6cd5 # \u5bf9\u4e8e\u9ad8\u9636\u9012\u63a8\u65b9\u7a0b\u6765\u8bf4\uff0c\u8fed\u4ee3\u4f1a\u53d8\u5f97\u975e\u5e38\u56f0\u96be\u3002\u6211\u4eec\u901a\u5e38\u4f1a\u901a\u8fc7\u5dee\u6d88\u6cd5\u5c06\u95ee\u9898\u8fdb\u884c\u5316\u7b80\uff0c\u968f\u540e\u518d\u901a\u8fc7\u8fed\u4ee3\u6cd5\u6c42\u89e3\u3002 \u8fed\u4ee3\u6811 # \u8fed\u4ee3\u6811\u987e\u540d\u601d\u4e49\u4e5f\u8ddf\u8fed\u4ee3\u6cd5\u6709\u5f88\u5927\u5173\u7cfb\u3002\u5176\u901a\u8fc7\u6811\u7684\u5f62\u5f0f\u5c06\u8fed\u4ee3\u6cd5\u5c55\u5f00\uff0c\u66f4\u4e3b\u8981\u7528\u4e8e\u53ef\u89c6\u5316\u3002\u6b64\u5904\u4e0d\u518d\u8d58\u8ff0\u3002 \u4e3b\u5b9a\u7406(Master Theorem) # \u5018\u82e5\u4e00\u4e2a\u9012\u63a8\u65b9\u7a0b\u7b26\u5408\u5982\u4e0b\u5f62\u5f0f\uff1a T(n) = aT(\\frac{n}{b}) + f(n), (a \\geq 1, b \\ge 1) T(n) = aT(\\frac{n}{b}) + f(n), (a \\geq 1, b \\ge 1) \u5176\u4e2d\uff0c a a \u8868\u793a\u89c4\u7ea6\u540e\u5b50\u95ee\u9898\u7684\u4e2a\u6570\uff0c \\frac{n}{b} \\frac{n}{b} \u8868\u793a\u89c4\u7ea6\u540e\u5b50\u95ee\u9898\u7684\u89c4\u6a21\uff0c f(n) f(n) \u8868\u793a\u5c06\u95ee\u9898\u89c4\u7ea6\u4e3a\u5b50\u95ee\u9898\u53ca\u5c06\u89c4\u7ea6\u540e\u5b50\u95ee\u9898\u7684\u7b54\u6848\u91cd\u7ec4\u6210\u539f\u95ee\u9898\u7684\u7b54\u6848\u7684\u8fc7\u7a0b\u3002\u5219\u8fd9\u4e2a\u9012\u63a8\u65b9\u7a0b\u53ef\u901a\u8fc7\u4e3b\u5b9a\u7406\u6c42\u89e3\u3002 \u4e3b\u5b9a\u7406 T(n) = \\left\\{\\begin{array}{clr}\\Theta(n^{log_b a}), & f(n) = O(n^{log_b a - \\epsilon}), & \\epsilon > 0 \\\\ \\Theta(n^{\\log_b a} \\log^{k+1} n), & f(n) = \\Theta(n^{\\log_b a} \\log^k n), & k \\geq 0 \\\\ \\Theta(f(n)), & f(n) = \\Omega(n^{\\log_b a + \\epsilon}), & \\epsilon > 0\\end{array}\\right. T(n) = \\left\\{\\begin{array}{clr}\\Theta(n^{log_b a}), & f(n) = O(n^{log_b a - \\epsilon}), & \\epsilon > 0 \\\\ \\Theta(n^{\\log_b a} \\log^{k+1} n), & f(n) = \\Theta(n^{\\log_b a} \\log^k n), & k \\geq 0 \\\\ \\Theta(f(n)), & f(n) = \\Omega(n^{\\log_b a + \\epsilon}), & \\epsilon > 0\\end{array}\\right. \u5bf9\u4e8eKaratsuba\u7b97\u6cd5\uff0c f(n) = O(n) = O(n^{log_b a - (log_b a - 1))}, \\ \\text{i.e.} \\ \\epsilon = log_b a - 1 f(n) = O(n) = O(n^{log_b a - (log_b a - 1))}, \\ \\text{i.e.} \\ \\epsilon = log_b a - 1 \u3002 \u6545Karatsuba\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u4e3a \\Theta(n^{log_b a}) \\Theta(n^{log_b a}) \uff0c\u4e5f\u5373 \\Theta(n^{log_2 3}) \\Theta(n^{log_2 3}) \u3002","title":"\u9012\u63a8\u65b9\u7a0b\uff08Recurrence Relation\uff09"},{"location":"algorithm/recurrence_relation/#_1","text":"\u8fed\u4ee3\u6cd5 \u4e0d\u65ad\u7528\u9012\u63a8\u65b9\u7a0b\u7684\u53f3\u90e8\u66ff\u4ee3\u5de6\u90e8\uff0c\u76f4\u5230\u51fa\u73b0\u521d\u503c\u505c\u6b62\u8fed\u4ee3\u3002 \u5bf9\u4e8eKaratsuba\u7b97\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u8fdb\u884c\u5982\u4e0b\u8fed\u4ee3\uff1a \\begin{split} T(n) &= 3T(n/2) + f(n) \\\\ &= 3[3T(n/4) + f(\\frac{n}{2})] + f(n) \\\\ &= 3^2 T(n/2^2) + f(\\frac{3n}{2}) \\\\ & \\quad \\vdots \\\\ &= 3^{\\log_2 n} \\times T(1) + \\sum_{i=2}^{n} f(n + \\frac{\\log_2 i \\cdot n}{2^{\\log_2 i}})) \\\\ &= 3^{\\log_2 n} + \\sum_{i=2}^{n} f(n + \\frac{\\log_2 i \\cdot n}{2^{\\log_2 i}}) \\\\ &= n^{\\log_2 3} + O(n) \\\\ &= O(n^{\\log 3})\\end{split} \\begin{split} T(n) &= 3T(n/2) + f(n) \\\\ &= 3[3T(n/4) + f(\\frac{n}{2})] + f(n) \\\\ &= 3^2 T(n/2^2) + f(\\frac{3n}{2}) \\\\ & \\quad \\vdots \\\\ &= 3^{\\log_2 n} \\times T(1) + \\sum_{i=2}^{n} f(n + \\frac{\\log_2 i \\cdot n}{2^{\\log_2 i}})) \\\\ &= 3^{\\log_2 n} + \\sum_{i=2}^{n} f(n + \\frac{\\log_2 i \\cdot n}{2^{\\log_2 i}}) \\\\ &= n^{\\log_2 3} + O(n) \\\\ &= O(n^{\\log 3})\\end{split}","title":"\u8fed\u4ee3\u6cd5"},{"location":"algorithm/recurrence_relation/#_2","text":"\u5bf9\u4e8e\u9ad8\u9636\u9012\u63a8\u65b9\u7a0b\u6765\u8bf4\uff0c\u8fed\u4ee3\u4f1a\u53d8\u5f97\u975e\u5e38\u56f0\u96be\u3002\u6211\u4eec\u901a\u5e38\u4f1a\u901a\u8fc7\u5dee\u6d88\u6cd5\u5c06\u95ee\u9898\u8fdb\u884c\u5316\u7b80\uff0c\u968f\u540e\u518d\u901a\u8fc7\u8fed\u4ee3\u6cd5\u6c42\u89e3\u3002","title":"\u5dee\u6d88\u6cd5"},{"location":"algorithm/recurrence_relation/#_3","text":"\u8fed\u4ee3\u6811\u987e\u540d\u601d\u4e49\u4e5f\u8ddf\u8fed\u4ee3\u6cd5\u6709\u5f88\u5927\u5173\u7cfb\u3002\u5176\u901a\u8fc7\u6811\u7684\u5f62\u5f0f\u5c06\u8fed\u4ee3\u6cd5\u5c55\u5f00\uff0c\u66f4\u4e3b\u8981\u7528\u4e8e\u53ef\u89c6\u5316\u3002\u6b64\u5904\u4e0d\u518d\u8d58\u8ff0\u3002","title":"\u8fed\u4ee3\u6811"},{"location":"algorithm/recurrence_relation/#master-theorem","text":"\u5018\u82e5\u4e00\u4e2a\u9012\u63a8\u65b9\u7a0b\u7b26\u5408\u5982\u4e0b\u5f62\u5f0f\uff1a T(n) = aT(\\frac{n}{b}) + f(n), (a \\geq 1, b \\ge 1) T(n) = aT(\\frac{n}{b}) + f(n), (a \\geq 1, b \\ge 1) \u5176\u4e2d\uff0c a a \u8868\u793a\u89c4\u7ea6\u540e\u5b50\u95ee\u9898\u7684\u4e2a\u6570\uff0c \\frac{n}{b} \\frac{n}{b} \u8868\u793a\u89c4\u7ea6\u540e\u5b50\u95ee\u9898\u7684\u89c4\u6a21\uff0c f(n) f(n) \u8868\u793a\u5c06\u95ee\u9898\u89c4\u7ea6\u4e3a\u5b50\u95ee\u9898\u53ca\u5c06\u89c4\u7ea6\u540e\u5b50\u95ee\u9898\u7684\u7b54\u6848\u91cd\u7ec4\u6210\u539f\u95ee\u9898\u7684\u7b54\u6848\u7684\u8fc7\u7a0b\u3002\u5219\u8fd9\u4e2a\u9012\u63a8\u65b9\u7a0b\u53ef\u901a\u8fc7\u4e3b\u5b9a\u7406\u6c42\u89e3\u3002 \u4e3b\u5b9a\u7406 T(n) = \\left\\{\\begin{array}{clr}\\Theta(n^{log_b a}), & f(n) = O(n^{log_b a - \\epsilon}), & \\epsilon > 0 \\\\ \\Theta(n^{\\log_b a} \\log^{k+1} n), & f(n) = \\Theta(n^{\\log_b a} \\log^k n), & k \\geq 0 \\\\ \\Theta(f(n)), & f(n) = \\Omega(n^{\\log_b a + \\epsilon}), & \\epsilon > 0\\end{array}\\right. T(n) = \\left\\{\\begin{array}{clr}\\Theta(n^{log_b a}), & f(n) = O(n^{log_b a - \\epsilon}), & \\epsilon > 0 \\\\ \\Theta(n^{\\log_b a} \\log^{k+1} n), & f(n) = \\Theta(n^{\\log_b a} \\log^k n), & k \\geq 0 \\\\ \\Theta(f(n)), & f(n) = \\Omega(n^{\\log_b a + \\epsilon}), & \\epsilon > 0\\end{array}\\right. \u5bf9\u4e8eKaratsuba\u7b97\u6cd5\uff0c f(n) = O(n) = O(n^{log_b a - (log_b a - 1))}, \\ \\text{i.e.} \\ \\epsilon = log_b a - 1 f(n) = O(n) = O(n^{log_b a - (log_b a - 1))}, \\ \\text{i.e.} \\ \\epsilon = log_b a - 1 \u3002 \u6545Karatsuba\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u4e3a \\Theta(n^{log_b a}) \\Theta(n^{log_b a}) \uff0c\u4e5f\u5373 \\Theta(n^{log_2 3}) \\Theta(n^{log_2 3}) \u3002","title":"\u4e3b\u5b9a\u7406(Master Theorem)"},{"location":"algorithm/transform%26conquer/","text":"\u53d8\u6cbb\u6cd5(Transform and Conquer)) # \u987e\u540d\u601d\u4e49\uff0c\u53d8\u6cbb\u6cd5\u7531\u4e24\u4e2a\u6b65\u9aa4\u6784\u6210\u3002 \u53d8\u6362\u95ee\u9898 \u89e3\u51b3\u53d8\u6362\u540e\u7684\u95ee\u9898 \u7406\u6240\u5f53\u7136\u7684\uff0c\u53d8\u6362\u540e\u7684\u95ee\u9898\u5e94\u8be5\u66f4\u5bb9\u6613\u88ab\u89e3\u51b3\u3002\u90a3\uff0c\u6709\u54ea\u4e9b\u53d8\u6362\u5462\uff1f \u5b9e\u4f8b\u5316\u7b80\uff08Instance simplification\uff09 \u8868\u73b0\u6539\u53d8\uff08Representation Change\uff09 \u95ee\u9898\u5316\u7b80\uff08Problem reduction\uff09","title":"\u53d8\u6cbb\u6cd5"},{"location":"algorithm/transform%26conquer/#transform-and-conquer","text":"\u987e\u540d\u601d\u4e49\uff0c\u53d8\u6cbb\u6cd5\u7531\u4e24\u4e2a\u6b65\u9aa4\u6784\u6210\u3002 \u53d8\u6362\u95ee\u9898 \u89e3\u51b3\u53d8\u6362\u540e\u7684\u95ee\u9898 \u7406\u6240\u5f53\u7136\u7684\uff0c\u53d8\u6362\u540e\u7684\u95ee\u9898\u5e94\u8be5\u66f4\u5bb9\u6613\u88ab\u89e3\u51b3\u3002\u90a3\uff0c\u6709\u54ea\u4e9b\u53d8\u6362\u5462\uff1f \u5b9e\u4f8b\u5316\u7b80\uff08Instance simplification\uff09 \u8868\u73b0\u6539\u53d8\uff08Representation Change\uff09 \u95ee\u9898\u5316\u7b80\uff08Problem reduction\uff09","title":"\u53d8\u6cbb\u6cd5(Transform and Conquer))"},{"location":"algorithm/tree/","text":"\u6811 \u6811\u662f\u4e00\u79cd\u7531n\u4e2a\u8282\u70b9\u6784\u6210\u7684\u6811\u5f62\u7ed3\u6784\u3002 \u4e0e\u751f\u7269\u5b66\u610f\u4e49\u4e0a\u7684\u6811\u4e0d\u592a\u76f8\u540c\uff0c\u5bf9\u4e8e\u6570\u636e\u7ed3\u6784\u610f\u4e49\u4e0a\u7684\u6811\u6765\u8bf4\uff0c\u6811\u7684\u6839\u5728\u9876\u90e8\uff0c\u53f6\u5b50\u5219\u5728\u5e95\u90e8\u3002\u6570\u636e\u90fd\u5b58\u50a8\u5728\u6811\u7684\u8282\u70b9\u5f53\u4e2d\uff0c\u8282\u70b9\u9664\u4e86\u6570\u636e\u4e4b\u5916\u8fd8\u5b58\u50a8\u6307\u5411\u5176\u7236\u8282\u70b9\u548c\u5b50\u8282\u70b9\u7684\u6307\u9488\u2013\u8fd9\u548c\u53cc\u5411\u94fe\u8868\u975e\u5e38\u76f8\u4f3c\u3002\u901a\u5e38\uff0c\u4e00\u4e2a\u6811\u53ea\u6709\u4e00\u4e2a\u7236\u8282\u70b9\uff0c\u4f46\u53ef\u80fd\u6709\u591a\u4e2a\u5b50\u8282\u70b9\u3002\u6211\u4eec\u5c06\u6bcf\u4e2a\u8282\u70b9\u90fd\u6709\u4e0d\u8d85\u8fc7m\u4e2a\u5b50\u7ed3\u70b9\u7684\u6811\u79f0\u4e4b\u4e3am\u53c9\u6811\u3002\u6b64\u5916\uff0c\u5018\u82e5\u4e00\u4e2a\u6811\u7684\u8282\u70b9\u4e4b\u95f4\u5b58\u5728\u987a\u5e8f\u5173\u7cfb\uff0c\u6211\u4eec\u79f0\u5176\u4e3a\u6709\u5e8f\u6811\uff0c\u53cd\u4e4b\u5219\u79f0\u5176\u4e3a\u65e0\u5e8f\u6811\u3002\u5bf9\u4e8e\u4e00\u4e2a\u6811\u800c\u8a00\uff0c\u6211\u4eec\u5c06\u5176\u7b2c\u4e00\u4e2a\u8282\u70b9\u79f0\u4f5c\u6839\u8282\u70b9\uff08root node\uff09\uff1b\u5c06\u6ca1\u6709\u4efb\u4f55\u5b50\u8282\u70b9\u7684\u8282\u70b9\u6210\u4e3a\u53f6\u8282\u70b9\uff08leaf node\uff09\uff1b\u5c06\u7531\u6839\u8282\u70b9\u5230\u53f6\u8282\u70b9\u7684\u6700\u957f\u8ddd\u79bb\u79f0\u4e3a\u6811\u7684\u9ad8\u5ea6h\u3002\u4e0b\u56fe\u662f\u4e00\u4e2a\u5178\u578b\u7684\u9ad8\u5ea6\u4e3a4\u7684\u4e8c\u53c9\u641c\u7d22\u6811\uff1a \u4e8c\u53c9\u641c\u7d22\u6811\uff08Binary Search Tree, BST\uff09 # \u901a\u5e38\uff0c\u6211\u4eec\u63d0\u5230\u6811\u6216\u8005\u4e8c\u53c9\u6811\u65f6\uff0c\u6211\u4eec\u6307\u7684\u5176\u5b9e\u662f\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u5176\u5f71\u54cd\u529b\u4e4b\u5927\u53ef\u89c1\u4e00\u6591\u3002\u5728\u672c\u7ae0\u5f53\u4e2d\uff0c\u9664\u975e\u7279\u522b\u58f0\u660e\uff0c\u5426\u5219\u5f53\u6211\u4eec\u63d0\u5230\u6811\u65f6\uff0c\u6211\u4eec\u6307\u7684\u4e5f\u662f\u4e8c\u53c9\u641c\u7d22\u6811\u3002\u4e8c\u53c9\u641c\u7d22\u6811\u662f\u4e00\u79cd\u4e8c\u53c9\uff08\u5373\u6bcf\u4e2a\u8282\u70b9\u90fd\u6709\u6700\u591a\u4e24\u4e2a\u5b50\u8282\u70b9\uff09\u7684\u6709\u5e8f\u6811\u3002\u4ed6\u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u5355\uff1a \u4e8c\u53c9\u641c\u7d22\u6811 @functools . total_ordering class Data ( object ): def __init__ ( self , value = None ): self . value = value def __eq__ ( self , other ): return self . value == other . value def __lt__ ( self , other ): return self . value < other . value class Node ( object ): def __init__ ( self , parent = None , value = None , left_child = None , right_child = None ): self . parent = parent self . data = Data ( value ) self . left_child = left_child self . right_child = right_child class Tree ( object ): def __init__ ( self ): self . root = Node () def insert ( self , curr , value ): self . insert_node ( root , value ) def delete ( self , value ): self . delete_node ( root , value ) def height ( self ): reutrn height_node ( root ) def height_node ( node ): return 0 if not node else max ( height_node ( node . left_child ), height_node ( node . right_child )) + 1 \u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u6df1\u5ea6\u5e94\u5f53\u662f \\log n \\log n \u3002\u7531\u4ee5\u4e0a\u7684\u5b9e\u73b0\u6211\u4eec\u53ef\u4ee5\u5f97\u77e5\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u67e5\u627e\u3001\u63d2\u5165\u3001\u5220\u9664\u7684\u590d\u6742\u5ea6\u5747\u4e3a O(h) O(h) \uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u7406\u60f3\u590d\u6742\u5ea6\u662f\u5f88\u51fa\u8272\u7684\u3002\u4f46\u662f\uff0c\u4e8b\u60c5\u901a\u5e38\u4e0d\u4f1a\u6309\u7167\u9884\u6599\u4e4b\u4e2d\u53d1\u5c55\u3002\u5728\u6781\u7aef\u60c5\u51b5\u4e4b\u4e0b\uff08\u6bcf\u4e00\u4e2a\u65b0\u63d2\u5165\u7684\u5143\u7d20\u90fd\u6bd4\u4e4b\u524d\u7684\u5143\u7d20\u66f4\u5c0f\u6216\u66f4\u5927\uff09\uff0c\u4e8c\u53c9\u641c\u7d22\u6811\u5373\u9000\u5316\u6210\u4e86\u94fe\u8868\u3002\u6211\u4eec\u77e5\u9053\uff0c\u94fe\u8868\u7684\u590d\u6742\u5ea6\u4e3a O(n) O(n) \uff0c\u8fd9\u5f88\u660e\u663e\u5e76\u4e0d\u662f\u6211\u4eec\u60f3\u8981\u7684\uff0c\u4e8e\u662f\uff0c\u81ea\u5e73\u8861\u4e8c\u53c9\u6811\uff08Self-balacing Binary Search Tree\uff09\u8bde\u751f\u4e86\u3002 \u63d2\u5165 # \u63d2\u5165 \u63d2\u5165\u5bf9\u4e8e\u4e00\u68f5\u81ea\u5e73\u8861\u4e8c\u53c9\u6811\u6765\u8bf4\u633a\u96be\uff0c\u4f46\u5bf9\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\u6765\u8bf4\u8fd8\u662f\u5f88\u7b80\u5355\u7684\u3002\u6211\u4eec\u53ea\u9700\u8981\u6839\u636e\u65b0\u503c\u7684\u5927\u5c0f\u627e\u5230\u4e00\u4e2a\u5408\u9002\u7684\u4f4d\u7f6e\u5373\u53ef\u3002 @staticmethod def insert_node ( node , value , parent = None ): if not node : node = Node ( parent , value ) else : insert_node ( node . left_child , value , node ) if value < node . data . value else insert_node ( node . right_child , value , node ) if value > node . data . value else raise Exception ( 'Element already exists' ) \u904d\u5386 # \u6811\u7684\u904d\u5386 \u4f5c\u4e3a\u4e00\u79cd\u975e\u7ebf\u6027\u6570\u636e\u7ed3\u6784\uff0c\u4ece\u6811\u7684\u4efb\u4e00\u8282\u70b9\u51fa\u53d1\u90fd\u6709\u591a\u4e2a\u53ef\u4ee5\u524d\u5f80\u7684\u4e0b\u4e00\u8282\u70b9\uff0c\u56e0\u6b64\uff0c\u6811\u7684\u904d\u5386\u81ea\u7136\u4e5f\u6bd4\u7ebf\u6027\u6570\u636e\u7ed3\u6784\u7684\u904d\u5386\u8981\u9ad8\u5927\u4e0a\u8bb8\u591a\u3002 \u901a\u5e38\u6765\u8bf4\uff0c\u6211\u4eec\u6709\u4e24\u79cd\u904d\u5386\u601d\u60f3\u2013\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u548c\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\u3002 \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\uff08Depth-First Search, DFS\uff09 # \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u5148\u8bbf\u95ee\u5b50\u8282\u70b9\uff0c\u518d\u8bbf\u95ee\u7236\u8282\u70b9\uff0c\u968f\u540e\u518d\u8bbf\u95ee\u4e0b\u4e00\u4e2a\u5b50\u8282\u70b9\u3002 \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\u7684\u65b9\u5f0f \u7531\u4e8e\u6df1\u5ea6\u4f18\u5148\u904d\u5386\u65e2\u53ef\u4ee5\u5148\u8bbf\u95ee\u6839\uff0c\u53c8\u53ef\u4ee5\u5148\u8bbf\u95ee\u5b50\u8282\u70b9\u3002\u6240\u4ee5\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u4e5f\u6709\u4e0d\u540c\u7684\u5206\u652f\uff0c\u4ed6\u4eec\u662f\uff1a \u524d\u5e8f\u904d\u5386 \u4e2d\u5e8f\u904d\u5386 \u540e\u5e8f\u904d\u5386 \u524d\u5e8f\u904d\u5386\uff08Pre-Order Traversal\uff09 # \u524d\u5e8f\u904d\u5386 \u524d\u5e8f\u904d\u5386\u5148\u8bbf\u95ee\u6839\uff0c\u518d\u8bbf\u95ee\u5b50\u6811\u3002 @staticmethod def pre_order ( node ): # Do something with root if node . left_child : pre_order ( node . left_child ) if node . right_child : pre_order ( node . right_child ) \u4e2d\u5e8f\u904d\u5386\uff08In-Order Traversal\uff09 # \u4e2d\u5e8f\u904d\u5386 \u524d\u5e8f\u904d\u5386\u5148\u8bbf\u95ee\u5de6\uff08\u53f3\uff09\u5b50\u6811\uff0c\u518d\u8bbf\u95ee\u6839\uff0c\u6700\u540e\u8bbf\u95ee\u53f3\uff08\u5de6\uff09\u5b50\u6811\u3002 @staticmethod def in_order ( node ): if node . left_child : in_order ( node . left_child ) # Do something with root if node . right_child : in_order ( node . right_child ) \u540e\u5e8f\u904d\u5386\uff08Post-Order Traversal\uff09 # \u524d\u5e8f\u904d\u5386 \u524d\u5e8f\u904d\u5386\u5148\u8bbf\u95ee\u5b50\u6811\uff0c\u518d\u8bbf\u95ee\u6839\u3002 @staticmethod def post_order ( node ): if node . left_child : post_order ( node . left_child ) if node . right_child : post_order ( node . right_child ) # Do something with root \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\uff08Breadth-First Search, BFS\uff09 # \u4e0e\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u7684\u82b1\u54e8\u65b9\u5f0f\u4e0d\u540c\uff0c\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\u81ea\u9876\u5411\u4e0b\u5b8c\u6210\u904d\u5386\uff0c\u81ea\u7136\u6709\u4e14\u53ea\u6709\u4e00\u79cd\u53ef\u80fd\u3002 \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22 def bredth_first (): if not self . root : return False queue = [] queue . append ( self . root ) while ( len ( queue ) > 0 ): # Do something with root node = queue . pop ( 0 ) if node . left_child : queue . append ( node . left_child ) if node . right_child : queue . append ( node . right_child ) \u5220\u9664 # \u5220\u9664 \u5220\u9664\u76f8\u5bf9\u6765\u8bf4\u8981\u6bd4\u63d2\u5165\u66f4\u4e3a\u590d\u6742\u4e00\u4e9b\u3002\u5bf9\u4e8e\u53f6\u8282\u70b9\u6765\u8bf4\u7b80\u5355\u79fb\u53bb\u5373\u53ef\uff0c\u5bf9\u4e8e\u53ea\u6709\u4e00\u4e2a\u5b50\u8282\u70b9\u7684\u8282\u70b9\u6765\u8bf4\uff0c\u5c06\u6307\u9488\u8f6c\u4e00\u4e0b\u4e5f\u5f88\u7b80\u5355\u3002\u4f46\u5bf9\u4e8e\u6709\u4e24\u4e2a\u5b50\u8282\u70b9\u7684\u8282\u70b9\u6765\u8bf4\uff0c\u6211\u4eec\u9700\u8981\u5728\u6811\u4e2d\u627e\u5230\u4e00\u4e2a\u65b0\u7684\u65e2\u5927\u4e8e\u5de6\u5b50\u8282\u70b9\u800c\u53c8\u5c0f\u4e8e\u53f3\u5b50\u8282\u70b9\u7684\u503c\u3002\u4e4d\u770b\u4e4b\u4e0b\u5f88\u96be\uff0c\u5b9e\u9645\u4e0a\u6211\u4eec\u53ea\u9700\u627e\u5230\u8fd9\u4e2a\u503c\u4ee5\u5de6\uff08\u53f3\uff09\u5b50\u8282\u70b9\u6784\u6210\u7684\u5b50\u6811\u4e2d\u6700\u5927\uff08\u5c0f\uff09\u7684\u503c\u3002 @staticmethod def minimum_node ( node ): curr = node while curr . left_child : curr = curr . left_child return curr @staticmethod def delete_node ( node , value ): if not node : raise Exception ( 'Element does not exist' ) if value < node . data . value : delete_node ( node . left_child , value ) elif value > node . data . value : delete_node ( node . right_child , value ) else : if not node . left_child : node = node . right_child if node . right_child else None elif not node . right_child : node = node . left_child else : right_minimum = self . minumum_node ( node . right_child ) node . data . value = right_minimum . data . value right_minimum = None \u904d\u5386\u7ec3\u4e60 \u56de\u5fc6\u4f8b\u56fe\u4e2d\u7684\u4e8c\u53c9\u641c\u7d22\u6811\uff1a \u5176\u5148\u5e8f\u904d\u5386\u3001\u4e2d\u5e8f\u904d\u5386\u4ee5\u53ca\u540e\u5e8f\u904d\u5386\u7684\u8f93\u51fa\u5206\u522b\u662f\u591a\u5c11\uff1f \u7b54\u6848 \u524d\u5e8f\u904d\u5386 2 7 2 6 5 11 5 9 4 \u4e2d\u5e8f\u904d\u5386 2 7 5 6 11 2 5 4 9 \u540e\u5e8f\u904d\u5386 2 5 11 6 7 4 9 5 2","title":"\u6811\uff08Tree\uff09"},{"location":"algorithm/tree/#binary-search-tree-bst","text":"\u901a\u5e38\uff0c\u6211\u4eec\u63d0\u5230\u6811\u6216\u8005\u4e8c\u53c9\u6811\u65f6\uff0c\u6211\u4eec\u6307\u7684\u5176\u5b9e\u662f\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u5176\u5f71\u54cd\u529b\u4e4b\u5927\u53ef\u89c1\u4e00\u6591\u3002\u5728\u672c\u7ae0\u5f53\u4e2d\uff0c\u9664\u975e\u7279\u522b\u58f0\u660e\uff0c\u5426\u5219\u5f53\u6211\u4eec\u63d0\u5230\u6811\u65f6\uff0c\u6211\u4eec\u6307\u7684\u4e5f\u662f\u4e8c\u53c9\u641c\u7d22\u6811\u3002\u4e8c\u53c9\u641c\u7d22\u6811\u662f\u4e00\u79cd\u4e8c\u53c9\uff08\u5373\u6bcf\u4e2a\u8282\u70b9\u90fd\u6709\u6700\u591a\u4e24\u4e2a\u5b50\u8282\u70b9\uff09\u7684\u6709\u5e8f\u6811\u3002\u4ed6\u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u5355\uff1a \u4e8c\u53c9\u641c\u7d22\u6811 @functools . total_ordering class Data ( object ): def __init__ ( self , value = None ): self . value = value def __eq__ ( self , other ): return self . value == other . value def __lt__ ( self , other ): return self . value < other . value class Node ( object ): def __init__ ( self , parent = None , value = None , left_child = None , right_child = None ): self . parent = parent self . data = Data ( value ) self . left_child = left_child self . right_child = right_child class Tree ( object ): def __init__ ( self ): self . root = Node () def insert ( self , curr , value ): self . insert_node ( root , value ) def delete ( self , value ): self . delete_node ( root , value ) def height ( self ): reutrn height_node ( root ) def height_node ( node ): return 0 if not node else max ( height_node ( node . left_child ), height_node ( node . right_child )) + 1 \u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u6df1\u5ea6\u5e94\u5f53\u662f \\log n \\log n \u3002\u7531\u4ee5\u4e0a\u7684\u5b9e\u73b0\u6211\u4eec\u53ef\u4ee5\u5f97\u77e5\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u67e5\u627e\u3001\u63d2\u5165\u3001\u5220\u9664\u7684\u590d\u6742\u5ea6\u5747\u4e3a O(h) O(h) \uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u7406\u60f3\u590d\u6742\u5ea6\u662f\u5f88\u51fa\u8272\u7684\u3002\u4f46\u662f\uff0c\u4e8b\u60c5\u901a\u5e38\u4e0d\u4f1a\u6309\u7167\u9884\u6599\u4e4b\u4e2d\u53d1\u5c55\u3002\u5728\u6781\u7aef\u60c5\u51b5\u4e4b\u4e0b\uff08\u6bcf\u4e00\u4e2a\u65b0\u63d2\u5165\u7684\u5143\u7d20\u90fd\u6bd4\u4e4b\u524d\u7684\u5143\u7d20\u66f4\u5c0f\u6216\u66f4\u5927\uff09\uff0c\u4e8c\u53c9\u641c\u7d22\u6811\u5373\u9000\u5316\u6210\u4e86\u94fe\u8868\u3002\u6211\u4eec\u77e5\u9053\uff0c\u94fe\u8868\u7684\u590d\u6742\u5ea6\u4e3a O(n) O(n) \uff0c\u8fd9\u5f88\u660e\u663e\u5e76\u4e0d\u662f\u6211\u4eec\u60f3\u8981\u7684\uff0c\u4e8e\u662f\uff0c\u81ea\u5e73\u8861\u4e8c\u53c9\u6811\uff08Self-balacing Binary Search Tree\uff09\u8bde\u751f\u4e86\u3002","title":"\u4e8c\u53c9\u641c\u7d22\u6811\uff08Binary Search Tree, BST\uff09"},{"location":"algorithm/tree/#_1","text":"\u63d2\u5165 \u63d2\u5165\u5bf9\u4e8e\u4e00\u68f5\u81ea\u5e73\u8861\u4e8c\u53c9\u6811\u6765\u8bf4\u633a\u96be\uff0c\u4f46\u5bf9\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\u6765\u8bf4\u8fd8\u662f\u5f88\u7b80\u5355\u7684\u3002\u6211\u4eec\u53ea\u9700\u8981\u6839\u636e\u65b0\u503c\u7684\u5927\u5c0f\u627e\u5230\u4e00\u4e2a\u5408\u9002\u7684\u4f4d\u7f6e\u5373\u53ef\u3002 @staticmethod def insert_node ( node , value , parent = None ): if not node : node = Node ( parent , value ) else : insert_node ( node . left_child , value , node ) if value < node . data . value else insert_node ( node . right_child , value , node ) if value > node . data . value else raise Exception ( 'Element already exists' )","title":"\u63d2\u5165"},{"location":"algorithm/tree/#_2","text":"\u6811\u7684\u904d\u5386 \u4f5c\u4e3a\u4e00\u79cd\u975e\u7ebf\u6027\u6570\u636e\u7ed3\u6784\uff0c\u4ece\u6811\u7684\u4efb\u4e00\u8282\u70b9\u51fa\u53d1\u90fd\u6709\u591a\u4e2a\u53ef\u4ee5\u524d\u5f80\u7684\u4e0b\u4e00\u8282\u70b9\uff0c\u56e0\u6b64\uff0c\u6811\u7684\u904d\u5386\u81ea\u7136\u4e5f\u6bd4\u7ebf\u6027\u6570\u636e\u7ed3\u6784\u7684\u904d\u5386\u8981\u9ad8\u5927\u4e0a\u8bb8\u591a\u3002 \u901a\u5e38\u6765\u8bf4\uff0c\u6211\u4eec\u6709\u4e24\u79cd\u904d\u5386\u601d\u60f3\u2013\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u548c\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\u3002","title":"\u904d\u5386"},{"location":"algorithm/tree/#depth-first-search-dfs","text":"\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u5148\u8bbf\u95ee\u5b50\u8282\u70b9\uff0c\u518d\u8bbf\u95ee\u7236\u8282\u70b9\uff0c\u968f\u540e\u518d\u8bbf\u95ee\u4e0b\u4e00\u4e2a\u5b50\u8282\u70b9\u3002 \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\u7684\u65b9\u5f0f \u7531\u4e8e\u6df1\u5ea6\u4f18\u5148\u904d\u5386\u65e2\u53ef\u4ee5\u5148\u8bbf\u95ee\u6839\uff0c\u53c8\u53ef\u4ee5\u5148\u8bbf\u95ee\u5b50\u8282\u70b9\u3002\u6240\u4ee5\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u4e5f\u6709\u4e0d\u540c\u7684\u5206\u652f\uff0c\u4ed6\u4eec\u662f\uff1a \u524d\u5e8f\u904d\u5386 \u4e2d\u5e8f\u904d\u5386 \u540e\u5e8f\u904d\u5386","title":"\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\uff08Depth-First Search, DFS\uff09"},{"location":"algorithm/tree/#pre-order-traversal","text":"\u524d\u5e8f\u904d\u5386 \u524d\u5e8f\u904d\u5386\u5148\u8bbf\u95ee\u6839\uff0c\u518d\u8bbf\u95ee\u5b50\u6811\u3002 @staticmethod def pre_order ( node ): # Do something with root if node . left_child : pre_order ( node . left_child ) if node . right_child : pre_order ( node . right_child )","title":"\u524d\u5e8f\u904d\u5386\uff08Pre-Order Traversal\uff09"},{"location":"algorithm/tree/#in-order-traversal","text":"\u4e2d\u5e8f\u904d\u5386 \u524d\u5e8f\u904d\u5386\u5148\u8bbf\u95ee\u5de6\uff08\u53f3\uff09\u5b50\u6811\uff0c\u518d\u8bbf\u95ee\u6839\uff0c\u6700\u540e\u8bbf\u95ee\u53f3\uff08\u5de6\uff09\u5b50\u6811\u3002 @staticmethod def in_order ( node ): if node . left_child : in_order ( node . left_child ) # Do something with root if node . right_child : in_order ( node . right_child )","title":"\u4e2d\u5e8f\u904d\u5386\uff08In-Order Traversal\uff09"},{"location":"algorithm/tree/#post-order-traversal","text":"\u524d\u5e8f\u904d\u5386 \u524d\u5e8f\u904d\u5386\u5148\u8bbf\u95ee\u5b50\u6811\uff0c\u518d\u8bbf\u95ee\u6839\u3002 @staticmethod def post_order ( node ): if node . left_child : post_order ( node . left_child ) if node . right_child : post_order ( node . right_child ) # Do something with root","title":"\u540e\u5e8f\u904d\u5386\uff08Post-Order Traversal\uff09"},{"location":"algorithm/tree/#breadth-first-search-bfs","text":"\u4e0e\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u7684\u82b1\u54e8\u65b9\u5f0f\u4e0d\u540c\uff0c\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\u81ea\u9876\u5411\u4e0b\u5b8c\u6210\u904d\u5386\uff0c\u81ea\u7136\u6709\u4e14\u53ea\u6709\u4e00\u79cd\u53ef\u80fd\u3002 \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22 def bredth_first (): if not self . root : return False queue = [] queue . append ( self . root ) while ( len ( queue ) > 0 ): # Do something with root node = queue . pop ( 0 ) if node . left_child : queue . append ( node . left_child ) if node . right_child : queue . append ( node . right_child )","title":"\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\uff08Breadth-First Search, BFS\uff09"},{"location":"algorithm/tree/#_3","text":"\u5220\u9664 \u5220\u9664\u76f8\u5bf9\u6765\u8bf4\u8981\u6bd4\u63d2\u5165\u66f4\u4e3a\u590d\u6742\u4e00\u4e9b\u3002\u5bf9\u4e8e\u53f6\u8282\u70b9\u6765\u8bf4\u7b80\u5355\u79fb\u53bb\u5373\u53ef\uff0c\u5bf9\u4e8e\u53ea\u6709\u4e00\u4e2a\u5b50\u8282\u70b9\u7684\u8282\u70b9\u6765\u8bf4\uff0c\u5c06\u6307\u9488\u8f6c\u4e00\u4e0b\u4e5f\u5f88\u7b80\u5355\u3002\u4f46\u5bf9\u4e8e\u6709\u4e24\u4e2a\u5b50\u8282\u70b9\u7684\u8282\u70b9\u6765\u8bf4\uff0c\u6211\u4eec\u9700\u8981\u5728\u6811\u4e2d\u627e\u5230\u4e00\u4e2a\u65b0\u7684\u65e2\u5927\u4e8e\u5de6\u5b50\u8282\u70b9\u800c\u53c8\u5c0f\u4e8e\u53f3\u5b50\u8282\u70b9\u7684\u503c\u3002\u4e4d\u770b\u4e4b\u4e0b\u5f88\u96be\uff0c\u5b9e\u9645\u4e0a\u6211\u4eec\u53ea\u9700\u627e\u5230\u8fd9\u4e2a\u503c\u4ee5\u5de6\uff08\u53f3\uff09\u5b50\u8282\u70b9\u6784\u6210\u7684\u5b50\u6811\u4e2d\u6700\u5927\uff08\u5c0f\uff09\u7684\u503c\u3002 @staticmethod def minimum_node ( node ): curr = node while curr . left_child : curr = curr . left_child return curr @staticmethod def delete_node ( node , value ): if not node : raise Exception ( 'Element does not exist' ) if value < node . data . value : delete_node ( node . left_child , value ) elif value > node . data . value : delete_node ( node . right_child , value ) else : if not node . left_child : node = node . right_child if node . right_child else None elif not node . right_child : node = node . left_child else : right_minimum = self . minumum_node ( node . right_child ) node . data . value = right_minimum . data . value right_minimum = None \u904d\u5386\u7ec3\u4e60 \u56de\u5fc6\u4f8b\u56fe\u4e2d\u7684\u4e8c\u53c9\u641c\u7d22\u6811\uff1a \u5176\u5148\u5e8f\u904d\u5386\u3001\u4e2d\u5e8f\u904d\u5386\u4ee5\u53ca\u540e\u5e8f\u904d\u5386\u7684\u8f93\u51fa\u5206\u522b\u662f\u591a\u5c11\uff1f \u7b54\u6848 \u524d\u5e8f\u904d\u5386 2 7 2 6 5 11 5 9 4 \u4e2d\u5e8f\u904d\u5386 2 7 5 6 11 2 5 4 9 \u540e\u5e8f\u904d\u5386 2 5 11 6 7 4 9 5 2","title":"\u5220\u9664"},{"location":"bmi/MRI/","text":"\u4e0e\u5176\u4ed6\u6210\u50cf\u624b\u6bb5\u76f8\u6bd4\uff0c \u9002\u7528\u8303\u56f4 # \u78c1\u5171\u632f\u6210\u50cf\u5bf9\u591a\u4e2a\u53c2\u6570\u654f\u611f\uff0c\u8fd9\u5305\u62ec\uff1a \u8d28\u5b50\u5bc6\u5ea6 \u5f1b\u8c6b\u65f6\u95f4 \u5316\u5b66\u79cd\u7c7b \u8fd0\u52a8 \u9020\u5f71\u5242","title":"\u78c1\u5171\u632f\u6210\u50cf"},{"location":"bmi/MRI/#_1","text":"\u78c1\u5171\u632f\u6210\u50cf\u5bf9\u591a\u4e2a\u53c2\u6570\u654f\u611f\uff0c\u8fd9\u5305\u62ec\uff1a \u8d28\u5b50\u5bc6\u5ea6 \u5f1b\u8c6b\u65f6\u95f4 \u5316\u5b66\u79cd\u7c7b \u8fd0\u52a8 \u9020\u5f71\u5242","title":"\u9002\u7528\u8303\u56f4"},{"location":"bmi/ultrasound/","text":"\u8d85\u58f0\u5f71\u50cf\u8bbe\u5907\u7531\u4e8e\u5176\u6210\u672c\u4f4e\u5ec9\u3001\u5b89\u5168\u5feb\u901f\u3001\u4f53\u7626\u8eab\u8f7b\u7b49\u8bf8\u591a\u4f18\u70b9\uff0c\u662f\u56db\u5927\u533b\u5b66\u5f71\u50cf\u8bbe\u5907\u5f53\u4e2d\u88c5\u673a\u91cf\u6700\u5927\u3001\u4f7f\u7528\u6700\u5e7f\u6cdb\u7684\u3002 \u8d85\u58f0\u5f71\u50cf\u8bbe\u5907\u7684\u57fa\u672c\u539f\u7406\u4e0e\u8d85\u58f0\u6ce2\u7684\u7269\u7406\u7279\u6027\u53ca\u4eba\u4f53\u7ec4\u7ec7\u5bf9\u5165\u5c04\u8d85\u58f0\u6ce2\u6240\u4ea7\u751f\u7684\u591a\u79cd\u7269\u7406\u73b0\u8c61\u6709\u5173\u3002 \u8d85\u58f0\u6ce2 # \u4f17\u6240\u5468\u77e5\uff0c\u58f0\u97f3\u662f\u4e00\u79cd\u538b\u529b\u6ce2\uff0c\u6240\u4ee5\u5176\u4e5f\u88ab\u79f0\u4e3a\u58f0\u6ce2\u3002\u58f0\u97f3\u7684\u9891\u7387\u5373\u4e3a\u538b\u529b\u6ce2\u53d8\u5316\u7684\u5468\u671f\u3002\u7531\u4e8e\u6d41\u4f53\u4e2d\u4e0d\u5b58\u5728\u526a\u5207\u6a21\u91cf\uff0c\u56e0\u6b64\u8d85\u58f0\u5f71\u50cf\u8bbe\u5907\u4e3b\u8981\u4f9d\u9760\u7eb5\u6ce2\u3002 \u4e00\u822c\u800c\u8a00\uff0c\u9891\u7387\u4ecb\u4e8e20Hz\u4e0e20kHz\u4e4b\u95f4\u7684\u58f0\u97f3\u53ef\u4ee5\u88ab\u4eba\u7c7b\u6240\u542c\u5230\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u5c06\u9891\u7387\u4f4e\u4e8e20Hz\u7684\u58f0\u6ce2\u79f0\u4e3a\u6b21\u58f0\u6ce2\uff0c\u5c06\u9891\u7387\u8d85\u8fc720kHz\u7684\u58f0\u6ce2\u79f0\u4e3a\u8d85\u58f0\u6ce2\u3002 \u7269\u7406\u7279\u6027 # \u8d85\u58f0\u6ce2\u5177\u6709\u6240\u6709\u6ce2\u6240\u5177\u6709\u7684\u7269\u7406\u7279\u6027\uff0c\u8fd9\u5305\u62ec\uff1a \u53cd\u5c04 \u8d85\u58f0\u6ce2\u5165\u5c04\u5230\u6bd4\u81ea\u8eab\u6ce2\u957f\u66f4\u5927\u7684\u754c\u9762\u65f6\uff0c\u58f0\u6ce2\u7684\u8f83\u5927\u90e8\u5206\u80fd\u91cf\u88ab\u8be5\u754c\u9762\u963b\u6321\u800c\u8fd4\u56de\u3002 \u6298\u5c04 \u7531\u4e8e\u4eba\u4f53\u5404\u7ec4\u7ec7\u810f\u5668\u4e2d\u7684\u58f0\u901f\u4e0d\u540c\uff0c\u58f0\u675f\u5728\u7ecf\u8fc7\u8fd9\u4e9b\u7ec4\u7ec7\u95f4\u7684\u5927\u754c\u9762\u65f6\u4f1a\u4ea7\u751f\u58f0\u675f\u524d\u8fdb\u65b9\u5411\u7684\u6539\u53d8\u3002\u6298\u5c04\u53ef\u662f\u6d4b\u91cf\u53ca\u5bfc\u5411\u4e24\u4e2a\u65b9\u9762\u4ea7\u751f\u8bef\u5dee\u3002 \u6563\u5c04 \u5c0f\u754c\u9762\u5bf9\u5165\u5c04\u8d85\u58f0\u4ea7\u751f\u6563\u5c04\u73b0\u8c61\uff0c\u4f7f\u5165\u5c04\u8d85\u58f0\u7684\u90e8\u5206\u80fd\u91cf\u5411\u5404\u4e2a\u7a7a\u95f4\u65b9\u5411\u5206\u6563\u8f90\u5c04\u3002\u6563\u5c04\u56de\u58f0\u6765\u81ea\u810f\u5668\u5185\u90e8\u7684\u7ec6\u5c0f\u7ed3\u6784\uff0c\u5176\u4e34\u5e8a\u610f\u4e49\u5341\u5206\u91cd\u8981\u3002 \u884d\u5c04 \u58f0\u675f\u5728\u754c\u9762\u8fb9\u7f18\u7ecf\u8fc7\u65f6\u53ef\u5411\u754c\u9762\u8fb9\u7f18\u9760\u8fd1\u513f\u7ed5\u884c\uff0c\u4ea7\u751f\u58f0\u8f74\u7684\u5f27\u5f62\u8f6c\u5411\u3002 \u76f8\u5e72 \u4e24\u675f\u58f0\u6ce2\u5728\u540c\u4e00\u7a7a\u95f4\u4f20\u64ad\u65f6\u4f1a\u4ea7\u751f\u53e0\u52a0\u3002 \u591a\u666e\u52d2\u6548\u5e94 \u5f53\u4e00\u5b9a\u9891\u7387\u7684\u8d85\u58f0\u6ce2\u5728\u4ecb\u8d28\u4e2d\u4f20\u64ad\u65f6\uff0c\u5982\u9047\u5230\u4e0e\u58f0\u6e90\u505a\u76f8\u5bf9\u8fd0\u52a8\u7684\u754c\u9762\uff0c\u5219\u5176\u53cd\u5c04\u7684\u8d85\u58f0\u6ce2\u9891\u7387\u968f\u754c\u9762\u8fd0\u52a8\u7684\u60c5\u51b5\u800c\u53d1\u751f\u6539\u53d8\u3002\u754c\u9762\u671d\u5411\u63a2\u5934\u8fd0\u52a8\u65f6\u53cd\u5c04\u9891\u7387\u589e\u9ad8\uff0c\u80cc\u79bb\u754c\u9762\u8fd0\u52a8\u65f6\u53cd\u5c04\u9891\u7387\u964d\u4f4e\u3002 \u8870\u51cf \u8d85\u58f0\u6ce2\u5728\u4ecb\u8d28\u4e2d\u4f20\u64ad\u65f6\uff0c\u7531\u4e8e\u4ee5\u4e0a\u63d0\u5230\u7684\u53cd\u5c04\u3001\u6563\u5c04\u7b49\u5176\u4ed6\u7279\u6027\u4ee5\u53ca\u58f0\u675f\u7684\u6269\u6563\u548c\u4ecb\u8d28\u5bf9\u80fd\u91cf\u7684\u5438\u6536\u7b49\u56e0\u7d20\uff0c\u58f0\u80fd\u9010\u6e10\u51cf\u5c11\u3002\u4e0d\u540c\u7ec4\u7ec7\u5bf9\u8d85\u58f0\u80fd\u91cf\u7684\u5438\u6536\u80fd\u529b\u4e0d\u540c\uff0c\u8fd9\u4e3b\u8981\u4e0e\u5176\u6240\u542b\u7684\u86cb\u767d\u8d28\u548c\u6c34\u6709\u5173\u3002\u5728\u4eba\u4f53\u7ec4\u7ec7\u4e2d\uff0c\u58f0\u80fd\u8870\u51cf\u7a0b\u5ea6\u4f9d\u6b21\u5e8f\u9012\u51cf\u4e3a\uff1a\u9aa8\u8d28\u4e0e\u9499\u8d28\u3001\u809d\u813e\u7b49\u5b9e\u8d28\u7ec4\u7ec7\u3001\u8102\u80aa\u7ec4\u7ec7\u3001\u6db2\u4f53\u3002\u8d85\u58f0\u901a\u8fc7\u9aa8\u8d28\u4e0e\u9499\u8d28\u65f6\u660e\u663e\u8870\u51cf\u5bfc\u81f4\u5176\u540e\u65b9\u56de\u58f0\u51cf\u5f31\u4e43\u81f3\u6d88\u5931\uff0c\u4ece\u800c\u5f62\u6210\u58f0\u5f71\uff08acoustic shadow\uff09\uff0c\u4f46\u5728\u901a\u8fc7\u6db2\u4f53\u65f6\u51e0\u4e4e\u4e0d\u8870\u51cf\u3002 \u6b64\u5916\uff0c\u4e0e\u666e\u901a\u7684\u58f0\u6ce2\u4e0d\u540c\uff0c\u8d85\u58f0\u6ce2\u8fd8\u5177\u6709\u5982\u4e0b\u6027\u8d28\uff1a \u6307\u5411\u6027 \u7531\u4e8e\u8d85\u58f0\u6ce2\u9891\u7387\u9ad8\u6ce2\u957f\u77ed\uff0c\u56e0\u6b64\u5176\u5177\u6709\u826f\u597d\u7684\u6307\u5411\u6027\u3002\u8fd9\u662f\u8d85\u58f0\u68c0\u67e5\u5bf9\u4eba\u4f53\u5668\u5b98\u7ed3\u6784\u8fdb\u884c\u63a2\u6d4b\u7684\u57fa\u7840\u3002 \u5b9e\u7528\u7279\u6027 # \u975e\u4fb5\u5165\u6027 \u5b89\u5168 \u5feb\u901f \u504f\u79fb \u4f4e\u5206\u8fa8\u7387 \u7ec4\u7ec7 # \u80ce\u513f \u5fc3\u810f \u52a8\u8109 \u6210\u50cf\u539f\u7406 # \u5165\u5c04\u8d85\u58f0\u6ce2\u5728\u4eba\u4f53\u7ec4\u7ec7\u4e2d\u4f20\u64ad\uff0c\u5f53\u5176\u7ecf\u8fc7\u4e0d\u540c\u7684\u7ec4\u7ec7\u3001\u5668\u5b98\uff0c\u5305\u62ec\u6b63\u5e38\u4e0e\u75c5\u53d8\u7ec4\u7ec7\u7684\u591a\u5c42\u754c\u9762\u65f6\uff0c\u6bcf\u4e00\u754c\u9762\u7531\u4e8e\u4e24\u4fa7\u4ecb\u8d28\u7684\u58f0\u963b\u6297\u4e0d\u540c\u800c\u53d1\u751f\u4e0d\u540c\u7a0b\u5ea6\u7684\u53cd\u5c04\u548c/\u6216\u6563\u5c04\u3002\u8fd9\u4e9b\u53cd\u5c04\u548c/\u6216\u6563\u5c04\u5f62\u6210\u7684\u56de\u58f0\uff0c\u4ee5\u53ca\u8d85\u58f0\u5728\u4f20\u64ad\u8fc7\u7a0b\u4e2d\u6240\u7ecf\u8fc7\u4e0d\u540c\u7ec4\u7ec7\u7684\u8870\u51cf\u4fe1\u606f\uff0c\u7ecf\u63a5\u53d7\u3001\u653e\u5927\u548c\u4fe1\u606f\u5904\u7406\u800c\u5f62\u6210\u58f0\u50cf\u56fe\uff08ultrasonogram/echogram\uff09\u3002 \u8d85\u58f0\u6ce2\u5047\u8bbe\u7269\u4f53\u4e00\u5b9a\u4e0d\u4f1a\u5438\u6536\u5168\u90e8\u7684\u58f0\u6ce2\uff0c\u4e5f\u5373\u7269\u4f53\u4e00\u5b9a\u4f1a\u53cd\u5c04\u4e00\u5b9a\u91cf\u7684\u58f0\u6ce2\u3002 impedance must match without the matching impedance at the tissue layer, not enough acoustic wave frequency transmitted into the tissue all tissue have certain amount of compressibility leads to density \u58f0\u538b # \u5bf9\u4e8e\u58f0\u538b p p \uff0c\u7279\u6027\u963b\u6297 Z Z \u4e0e\u7c92\u5b50\u901f\u5ea6 c c \uff0c\u6211\u4eec\u6709\u3002 p = Zv p = Zv \u8fd9\u4e2a\u5f0f\u5b50\u4e0e\u521d\u4e2d\u7535\u5b66\u6b27\u59c6\u5b9a\u5f8b\u7684\u5185\u5bb9\u5f88\u76f8\u4f3c\u2013\u7535\u538b=\u7535\u963b*\u7535\u6d41\u3002\u5176\u4e2d\uff0c Z = \\rho c Z = \\rho c \\rho \\rho \u4e3a\u5bc6\u5ea6\u3002\u53c8\u56e0\u4e3a\u5bf9\u4e8e\u538b\u7f29\u7cfb\u6570 k k \uff0c\u6211\u4eec\u6709 c = \\sqrt{\\frac{1}{k \\rho}} c = \\sqrt{\\frac{1}{k \\rho}} \uff0c\u4e0a\u5f0f\u4e5f\u53ef\u4ee5\u7b80\u5316\u4e3a Z = \\sqrt{\\frac{\\rho}{k}} Z = \\sqrt{\\frac{\\rho}{k}} \u7c7b\u578b # \u8d85\u58f0\u6210\u50cf\u6839\u636e\u539f\u7406\u53ef\u4ee5\u5206\u4e3aA\u3001B\u3001M\u3001D\u56db\u79cd\u578b\u53f7\uff0c\u5176\u4e2dD\u578b\u53c8\u6709\u591a\u79cd\u5b50\u578b\u53f7\u7528\u4ee5\u89c2\u5bdf\u8840\u6d41\u72b6\u51b5\u4e0e\u7ec4\u7ec7\u8fd0\u52a8\u3002 A\u578b\u8d85\u58f0 # A\u578b\u8d85\u58f0\u7684\u58f0\u50cf\u56fe\u4e3a\u4e00\u7ef4\u6ce2\u5f62\u56fe\u3002\u5176\u4e2d\uff0c\u6a2a\u5750\u6807\u4e3a\u8d85\u58f0\u7684\u4f20\u64ad\u548c\u53cd\u5c04\u65f6\u95f4\uff0c\u7eb5\u5750\u6807\u5219\u4e3a\u53cd\u5c04\u6ce2\u5e45\u3002\u754c\u9762\u4e24\u4fa7\u4ecb\u8d28\u7684\u58f0\u963b\u6297\u4e4b\u5dee\u8d8a\u5927\uff0c\u56de\u58f0\u7684\u6ce2\u5e45\u8d8a\u5927\u3002 \u73b0\u65f6\uff0cA\u578b\u8d85\u58f0\u5df2\u7ecf\u57fa\u672c\u6ca1\u6709\u5e94\u7528\u3002 B\u578b\u8d85\u58f0 # B\u578b\u8d85\u58f0\u91c7\u7528\u591a\u4e2a\u58f0\u675f\u5bf9\u9009\u5b9a\u5207\u9762\u8fdb\u884c\u68c0\u67e5\uff0c\u5e76\u5c06\u6bcf\u6761\u58f0\u675f\u7684\u6240\u6709\u56de\u58f0\u4f9d\u5404\u81ea\u7684\u56de\u58f0\u65f6\u95f4\uff08\u4ee3\u8868\u56de\u58f0\u6df1\u5ea6\uff09\u548c\u5f3a\u5f31\uff0c\u91cd\u65b0\u7ec4\u6210\u68c0\u67e5\u5207\u9762\u7684\u4e8c\u7ef4\u56fe\u50cf\u3002\u5176\u4e2d\uff0c\u56fe\u50cf\u4e0a\u7684\u7eb5\u5750\u6807\u4ee3\u8868\u56de\u58f0\u65f6\u95f4\uff0c\u800c\u56de\u58f0\u7684\u5f3a\u5f31\u5219\u7528\u4e0d\u540c\u8f89\u5ea6\u7684\u5149\u70b9\u6765\u8868\u793a\u3002 M\u578b\u8d85\u58f0 # M\u578b\u8d85\u58f0\u91c7\u7528\u5355\u4e2a\u58f0\u675f\u5bf9\u9009\u5b9a\u5207\u9762\u8fdb\u884c\u68c0\u67e5\uff0c\u4f46\u5176\u5728\u6a2a\u5750\u6807\u65b9\u5411\u52a0\u5165\u4e00\u5bf9\u6162\u626b\u63cf\u6ce2\uff0c\u4f7f\u56de\u58f0\u5149\u70b9\u6cbf\u6c34\u5e73\u65b9\u5411\u79fb\u52a8\u4ece\u800c\u5f97\u5230\u9009\u5b9a\u5207\u9762\u4e0d\u540c\u6df1\u5ea6\u7ec4\u7ec7\u56de\u58f0\u968f\u65f6\u95f4\u53d8\u5316\u7684\u66f2\u7ebf\u3002M\u578b\u8d85\u58f0\u4e0eB\u578b\u8d85\u58f0\u7684\u58f0\u50cf\u56fe\u6ca1\u6709\u672c\u8d28\u533a\u522b\uff0c\u4ed6\u4eec\u7684\u533a\u522b\u5728\u4e8e\u4f7f\u7528\u4e0d\u540c\u7684\u65b9\u5f0f\u4ee5\u5f97\u5230\u56de\u58f0\u65f6\u95f4\u3002 Info B\u578b\u8d85\u58f0\u4e0eM\u578b\u8d85\u58f0\u7684\u58f0\u50cf\u56fe\u90fd\u4e3a\u4e8c\u7ef4\u58f0\u50cf\u56fe\u3002\u5728\u4e8c\u7ef4\u58f0\u50cf\u56fe\u4e0a\uff0c\u4f9d\u636e\u7ec4\u7ec7\u5185\u90e8\u58f0\u963b\u6297\u53ca\u58f0\u963b\u6297\u5dee\u7684\u5927\u5c0f\uff0c\u53ef\u4ee5\u5c06\u4eba\u4f53\u7ec4\u7ec7\u5668\u5b98\u5206\u4e3a\u56db\u79cd\u7c7b\u578b\uff1a \u53cd\u5c04\u7c7b\u578b \u4e8c\u7ef4\u8d85\u58f0 \u56fe\u50cf\u8868\u73b0 \u7ec4\u7ec7\u5668\u5b98 \u65e0\u53cd\u5c04 \u6db2\u6027\u6697\u533a \u65e0\u56de\u58f0 \u8840\u6db2\u3001\u5c3f\u6db2\u3001\u80c6\u6c41\u3001\u56ca\u6db2\u7b49\u6db2\u4f53 \u5c11\u53cd\u5c04 \u4f4e\u4eae\u5ea6 \u4f4e\u56de\u58f0 \u5fc3\u3001\u809d\u3001\u80f0\u3001\u813e\u7b49\u5b9e\u8d28\u5668\u5b98 \u591a\u53cd\u5c04 \u9ad8\u4eae\u5ea6 \u9ad8\u56de\u58f0 \u8840\u7ba1\u58c1\u3001\u5fc3\u74e3\u819c\u3001\u810f\u5668\u5305\u819c\u3001\u7ec4\u7ec7\u7ea4\u7ef4\u5316 \u5168\u53cd\u5c04 \u6781\u9ad8\u4eae\u5ea6 \u5f3a\u56de\u58f0\uff0c\u540e\u65b9\u6709\u58f0\u5f71 \u9aa8\u9abc\u3001\u9499\u6591\u3001\u7ed3\u77f3\u3001\u542b\u6c14\u80ba\u3001\u542b\u6c14\u80a0\u7ba1 D\u578b\u8d85\u58f0 # D\u578b\u8d85\u58f0\u53ca\u591a\u666e\u52d2\u8d85\u58f0\uff0c\u8fd9\u5305\u62ec\u9891\u8c31\u591a\u666e\u52d2\u8d85\u58f0\u3001\u5f69\u8272\u591a\u666e\u52d2\u8840\u6d41\u6210\u50cf\uff08Doppler Color Flow Imaging, DCFI\uff09\u7b49\uff0c\u53ef\u4ee5\u5bf9\u4eba\u4f53\u7684\u8840\u6d41\u53ca\u7ec4\u7ec7\u8fd0\u52a8\u7684\u65b9\u5411\u3001\u901f\u5ea6\u7b49\u8fdb\u884c\u89c2\u5bdf\u3002 \u591a\u666e\u52d2\u6548\u5e94\u662f\u6307\u5982\u679c\u7269\u4f53\u53d1\u751f\u8fd0\u52a8\uff0c\u5219\u9891\u7387\u4f1a\u53d1\u751f\u53d8\u5316\u3002 \u7ea2\u7ec6\u80de\u6709\u5f88\u5f3a\u7684\u7c98\u6027\uff0c\u5e76\u4e14\u5bf9\u58f0\u97f3\u6709\u5f88\u597d\u7684\u53cd\u5c04\u3002\u5982\u679c\u8840\u6db2\u5411\u6362\u80fd\u5668\u79fb\u52a8\uff0c\u90a3\u4e48\u53cd\u5c04\u9891\u7387\u5c06\u4f1a\u5347\u9ad8\uff0c\u53cd\u4e4b\u5219\u4f1a\u964d\u4f4e\u3002 \u9891\u8c31\u591a\u666e\u52d2\u8d85\u58f0 # \u9891\u8c31\u591a\u666e\u52d2\u8d85\u58f0\u662f\u6839\u636e\u591a\u666e\u52d2\u6548\u5e94\uff0c\u63d0\u53d6\u8d85\u58f0\u58f0\u675f\u5728\u4f20\u64ad\u9014\u5f84\u4e2d\u5404\u4e2a\u6d3b\u52a8\u754c\u9762\u6240\u4ea7\u751f\u7684\u9891\u79fb\u5373\u5dee\u9891\u56de\u58f0\u3002\u56fe\u50cf\u4ee5\u9891\u8c31\u65b9\u5f0f\u663e\u793a\uff0c\u5176\u4e2d\u7eb5\u5750\u6807\u8868\u793a\u5dee\u9891\u7684\u6570\u503c\uff08\u4ee5\u901f\u5ea6\u8868\u793a\uff09\uff0c\u6a2a\u5750\u6807\u4ee3\u8868\u65f6\u95f4\u3002\u671d\u5411\u63a2\u5934\u4fa7\u7684\u5dee\u9891\u4fe1\u53f7\u4f4d\u4e8e\u57fa\u7ebf\u4e0a\u65b9\uff0c\u800c\u80cc\u5411\u63a2\u5934\u8005\u5219\u5728\u57fa\u7ebf\u4e0b\u65b9\u3002\u9891\u8c31\u591a\u666e\u52d2\u5305\u62ec\u8109\u51b2\u591a\u666e\u52d2\u3001\u8fde\u7eed\u591a\u666e\u52d2\u548c\u9ad8\u8109\u51b2\u91cd\u590d\u9891\u7387\u591a\u666e\u52d2\uff0c\u4ee5\u524d\u4e24\u8005\u5e38\u7528\u3002\u8109\u51b2\u591a\u666e\u52d2\u91c7\u7528\u5355\u4e2a\u6362\u80fd\u5668\uff0c\u5229\u7528\u53d1\u5c04\u4e0e\u53cd\u5c04\u7684\u95f4\u9699\u63a5\u6536\u9891\u79fb\u4fe1\u53f7\uff0c\u5177\u6709\u8ddd\u79bb\u9009\u901a\u529f\u80fd\uff0c\u53ef\u5b9a\u4f4d\u5206\u6790\uff0c\u4f46\u4e0d\u80fd\u51c6\u786e\u6d4b\u91cf\u9ad8\u901f\u8840\u6d41\u3002\u8fde\u7eed\u591a\u666e\u52d2\u91c7\u7528\u4e24\u7ec4\u6362\u80fd\u5668\uff0c\u5206\u522b\u53d1\u5c04\u8d85\u58f0\u6ce2\u548c\u63a5\u6536\u5176\u53cd\u5c04\u6ce2\uff0c\u53ef\u7528\u4e8e\u9ad8\u901f\u8840\u6d41\u7684\u5b9a\u91cf\u5206\u6790\uff0c\u4f46\u65e0\u8ddd\u79bb\u9009\u901a\u529f\u80fd\u3002 \u9891\u8c31\u578b\u591a\u666e\u52d2\u8d85\u58f0\u68c0\u67e5\u80fd\u591f\u83b7\u53d6\u7ec4\u7ec7\u548c\u5668\u5b98\u7ed3\u6784\u53ca\u75c5\u53d8\u7684\u8840\u6d41\u4fe1\u606f\uff0c\u5305\u62ec\u8840\u6d41\u65b9\u5411\u3001\u901f\u5ea6\u3001\u6027\u8d28\u3001\u538b\u529b\u9636\u5dee\u7b49\uff0c\u53ef\u5bf9\u5fc3\u810f\u3001\u8840\u7ba1\u548c\u810f\u5668\u75c5\u53d8\u7684\u8840\u6d41\u8fdb\u884c\u5b9a\u6027\u548c\u5b9a\u91cf\u5206\u6790\u3002 \u5f69\u8272\u591a\u666e\u52d2\u8840\u6d41\u6210\u50cf(DCFI) # \u5f69\u8272\u591a\u666e\u52d2\u8840\u6d41\u6210\u50cf\u662f\u5229\u7528\u591a\u666e\u52d2\u6548\u5e94\uff0c\u63d0\u53d6\u4e8c\u7ef4\u5207\u9762\u5185\u6240\u6709\u5dee\u9891\u56de\u58f0\uff0c\u4ee5\u5f69\u8272\u65b9\u5f0f\u663e\u793a\uff0c\u5e76\u53e0\u52a0\u5728\u76f8\u5339\u914d\u7684\u4e8c\u7ef4\u58f0\u50cf\u56fe\u4e0a\u3002\u5728DCFI\u56fe\u50cf\u4e0a\uff0c\u4ee5\u7ea2\u3001\u84dd\u3001\u7eff\u4e09\u8272\u8868\u793a\u8840\u6d41\u591a\u666e\u52d2\u5dee\u9891\u56de\u58f0\uff0c\u5176\u4e2d\u671d\u5411\u63a2\u5934\u7684\u8840\u6d41\u4ee5\u7ea2\u8272\u8868\u793a\uff0c\u80cc\u5411\u63a2\u5934\u8005\u4ee5\u84dd\u8272\u8868\u793a\uff0c\u6e4d\u6d41\u65b9\u5411\u590d\u6742\u3001\u591a\u53d8\uff0c\u5448\u4e94\u5f69\u9576\u5d4c\u6216\u7eff \u8272\u3002\u8840\u6d41\u901f\u5ea6\u5feb\u8005\uff0c\u8272\u5f69\u9c9c\u4eae\uff0c\u6162\u8005\u5219\u6697\u6de1\u3002 \u5f69\u8272\u591a\u666e\u52d2\u8840\u6d41\u6210\u50cf\u591f\u76f4\u89c2\u663e\u793a\u5fc3\u810f\u3001\u8840\u7ba1\u548c\u810f\u5668\u7684\u8840\u6d41\u72b6\u51b5\uff0c\u901a\u8fc7\u8272\u5f69\u6539\u53d8\u53ef\u654f\u611f\u5730\u53d1\u73b0\u5f02\u5e38\u8840\u6d41\uff0c\u4f46\u4e0d\u80fd\u8fdb\u884c\u7cbe\u786e\u7684\u5b9a\u91cf\u5206\u6790\u3002 \u5f69\u8272\u591a\u666e\u52d2\u80fd\u91cf\u56fe(COE) # DCFI\u80fd\u53cd\u6620\u8840\u6d41\u901f\u5ea6\u3001\u52a0\u901f\u5ea6\u548c\u65b9\u5411\u53d8\u5316\uff0c\u4f46\u8fd9\u4e9b\u4fe1\u606f\u53d7\u63a2\u6d4b\u89d2\u5ea6\u7684\u5f71\u54cd\u8f83\u5927\uff0c\u4e14\u68c0\u6d4b\u4f4e\u901f\u8840\u6d41\u7684\u80fd\u529b\u53d7\u9650\u3002\u800c\u5f69\u8272\u591a\u666e\u52d2\u80fd\u91cf\u56fe(color Doppler energy , CDE)\u63d0\u53d6\u548c\u663e\u793a\u591a\u666e\u52d2\u4fe1\u53f7\u7684\u80fd\u91cf\u4fe1\u53f7\u5f3a\u5ea6\uff0c\u6210\u50cf\u53c2\u6570\u4e3a\u8840\u6d41\u4e2d\u4e0e\u6563\u5c04\u76f8\u5bf9\u5e94\u7684\u80fd\u91cf\u4fe1\u53f7\uff0c\u4e3b\u8981\u53d6\u51b3\u4e8e\u53d6\u6837\u4e2d\u7ea2\u7ec6\u80de\u76f8\u5bf9\u6570\u91cf\u7684\u591a\u5c11\u3002\u80fd\u663e\u793a\u4f4e\u901f\u8840\u6d41\u800c\u4e0d\u53d7\u63a2\u6d4b\u89d2\u5ea6\u56e0\u7d20\u7684\u5f71\u54cd\uff0c\u4e5f\u4e0d\u5b58\u5728\u5f69\u8272\u6df7\u53e0\u73b0\u8c61\u3002\u7ec4\u7ec7\u591a\u666e\u52d2\u6210\u50cf(tissue Doppler ima\u00adging , TDI)\u662f\u4ee5\u591a\u666e\u52d2\u539f\u7406\u4e3a\u57fa\u7840\uff0c\u5229\u7528\u8840\u6d41\u6ee4\u6ce2\u5668\u6ee4\u53bb\u4f4e\u5e45\u9ad8\u9891\uff08\u8840\u6d41\uff09\u4fe1\u606f\uff0c\u4ec5\u68c0\u6d4b\u5fc3\u5ba4\u58c1\u53cd\u5c04\u56de \u6765\u7684\u4f4e\u9891\u9ad8\u632f\u5e45\u9891\u79fb\u4fe1\u53f7\uff0c\u4ece\u800c\u663e\u793a\u5fc3\u808c\u7ec4\u7ec7\u7684\u8fd0\u52a8\u60c5\u51b5\u3002 \u5f69\u8272\u591a\u666e\u52d2\u80fd\u91cf\u56fe\u663e\u793a\u4fe1\u53f7\u7684\u52a8\u6001\u8303\u56f4\u5e7f\uff0c\u80fd\u6709\u6548\u663e\u793a\u4f4e\u901f\u8840\u6d41\uff0c\u5bf9\u672b\u68a2\u8840\u6d41\u3001\u80bf\u7624\u6ecb\u517b\u8840\u7ba1\u548c\u67d0\u4e9b\u90e8\u4f4d\u8840\u6d41\u704c\u6ce8\u63d0\u4f9b\u91cd\u8981\u4fe1\u606f\u3002 4\u7ec4\u7ec7\u591a\u666e\u52d2\u6210\u50cf(TOI)\u901a\u8fc7\u7279\u6b8a\u65b9\u6cd5\u63d0\u53d6\u5fc3\u808c\u8fd0\u52a8\u6240\u4ea7\u751f\u7684\u591a\u666e\u52d2\u9891\u79fb\u4fe1\u53f7\u8fdb\u884c\u5206\u6790\u3001\u5904\u7406\u548c\u6210\u50cf \uff0c\u53ef\u5bf9\u5fc3\u808c\u8fd0\u52a8\u8fdb\u884c\u5b9a\u6027\u548c\u5b9a\u91cf\u5206\u6790\u3002","title":"\u8d85\u58f0\u6210\u50cf"},{"location":"bmi/ultrasound/#_1","text":"\u4f17\u6240\u5468\u77e5\uff0c\u58f0\u97f3\u662f\u4e00\u79cd\u538b\u529b\u6ce2\uff0c\u6240\u4ee5\u5176\u4e5f\u88ab\u79f0\u4e3a\u58f0\u6ce2\u3002\u58f0\u97f3\u7684\u9891\u7387\u5373\u4e3a\u538b\u529b\u6ce2\u53d8\u5316\u7684\u5468\u671f\u3002\u7531\u4e8e\u6d41\u4f53\u4e2d\u4e0d\u5b58\u5728\u526a\u5207\u6a21\u91cf\uff0c\u56e0\u6b64\u8d85\u58f0\u5f71\u50cf\u8bbe\u5907\u4e3b\u8981\u4f9d\u9760\u7eb5\u6ce2\u3002 \u4e00\u822c\u800c\u8a00\uff0c\u9891\u7387\u4ecb\u4e8e20Hz\u4e0e20kHz\u4e4b\u95f4\u7684\u58f0\u97f3\u53ef\u4ee5\u88ab\u4eba\u7c7b\u6240\u542c\u5230\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u5c06\u9891\u7387\u4f4e\u4e8e20Hz\u7684\u58f0\u6ce2\u79f0\u4e3a\u6b21\u58f0\u6ce2\uff0c\u5c06\u9891\u7387\u8d85\u8fc720kHz\u7684\u58f0\u6ce2\u79f0\u4e3a\u8d85\u58f0\u6ce2\u3002","title":"\u8d85\u58f0\u6ce2"},{"location":"bmi/ultrasound/#_2","text":"\u8d85\u58f0\u6ce2\u5177\u6709\u6240\u6709\u6ce2\u6240\u5177\u6709\u7684\u7269\u7406\u7279\u6027\uff0c\u8fd9\u5305\u62ec\uff1a \u53cd\u5c04 \u8d85\u58f0\u6ce2\u5165\u5c04\u5230\u6bd4\u81ea\u8eab\u6ce2\u957f\u66f4\u5927\u7684\u754c\u9762\u65f6\uff0c\u58f0\u6ce2\u7684\u8f83\u5927\u90e8\u5206\u80fd\u91cf\u88ab\u8be5\u754c\u9762\u963b\u6321\u800c\u8fd4\u56de\u3002 \u6298\u5c04 \u7531\u4e8e\u4eba\u4f53\u5404\u7ec4\u7ec7\u810f\u5668\u4e2d\u7684\u58f0\u901f\u4e0d\u540c\uff0c\u58f0\u675f\u5728\u7ecf\u8fc7\u8fd9\u4e9b\u7ec4\u7ec7\u95f4\u7684\u5927\u754c\u9762\u65f6\u4f1a\u4ea7\u751f\u58f0\u675f\u524d\u8fdb\u65b9\u5411\u7684\u6539\u53d8\u3002\u6298\u5c04\u53ef\u662f\u6d4b\u91cf\u53ca\u5bfc\u5411\u4e24\u4e2a\u65b9\u9762\u4ea7\u751f\u8bef\u5dee\u3002 \u6563\u5c04 \u5c0f\u754c\u9762\u5bf9\u5165\u5c04\u8d85\u58f0\u4ea7\u751f\u6563\u5c04\u73b0\u8c61\uff0c\u4f7f\u5165\u5c04\u8d85\u58f0\u7684\u90e8\u5206\u80fd\u91cf\u5411\u5404\u4e2a\u7a7a\u95f4\u65b9\u5411\u5206\u6563\u8f90\u5c04\u3002\u6563\u5c04\u56de\u58f0\u6765\u81ea\u810f\u5668\u5185\u90e8\u7684\u7ec6\u5c0f\u7ed3\u6784\uff0c\u5176\u4e34\u5e8a\u610f\u4e49\u5341\u5206\u91cd\u8981\u3002 \u884d\u5c04 \u58f0\u675f\u5728\u754c\u9762\u8fb9\u7f18\u7ecf\u8fc7\u65f6\u53ef\u5411\u754c\u9762\u8fb9\u7f18\u9760\u8fd1\u513f\u7ed5\u884c\uff0c\u4ea7\u751f\u58f0\u8f74\u7684\u5f27\u5f62\u8f6c\u5411\u3002 \u76f8\u5e72 \u4e24\u675f\u58f0\u6ce2\u5728\u540c\u4e00\u7a7a\u95f4\u4f20\u64ad\u65f6\u4f1a\u4ea7\u751f\u53e0\u52a0\u3002 \u591a\u666e\u52d2\u6548\u5e94 \u5f53\u4e00\u5b9a\u9891\u7387\u7684\u8d85\u58f0\u6ce2\u5728\u4ecb\u8d28\u4e2d\u4f20\u64ad\u65f6\uff0c\u5982\u9047\u5230\u4e0e\u58f0\u6e90\u505a\u76f8\u5bf9\u8fd0\u52a8\u7684\u754c\u9762\uff0c\u5219\u5176\u53cd\u5c04\u7684\u8d85\u58f0\u6ce2\u9891\u7387\u968f\u754c\u9762\u8fd0\u52a8\u7684\u60c5\u51b5\u800c\u53d1\u751f\u6539\u53d8\u3002\u754c\u9762\u671d\u5411\u63a2\u5934\u8fd0\u52a8\u65f6\u53cd\u5c04\u9891\u7387\u589e\u9ad8\uff0c\u80cc\u79bb\u754c\u9762\u8fd0\u52a8\u65f6\u53cd\u5c04\u9891\u7387\u964d\u4f4e\u3002 \u8870\u51cf \u8d85\u58f0\u6ce2\u5728\u4ecb\u8d28\u4e2d\u4f20\u64ad\u65f6\uff0c\u7531\u4e8e\u4ee5\u4e0a\u63d0\u5230\u7684\u53cd\u5c04\u3001\u6563\u5c04\u7b49\u5176\u4ed6\u7279\u6027\u4ee5\u53ca\u58f0\u675f\u7684\u6269\u6563\u548c\u4ecb\u8d28\u5bf9\u80fd\u91cf\u7684\u5438\u6536\u7b49\u56e0\u7d20\uff0c\u58f0\u80fd\u9010\u6e10\u51cf\u5c11\u3002\u4e0d\u540c\u7ec4\u7ec7\u5bf9\u8d85\u58f0\u80fd\u91cf\u7684\u5438\u6536\u80fd\u529b\u4e0d\u540c\uff0c\u8fd9\u4e3b\u8981\u4e0e\u5176\u6240\u542b\u7684\u86cb\u767d\u8d28\u548c\u6c34\u6709\u5173\u3002\u5728\u4eba\u4f53\u7ec4\u7ec7\u4e2d\uff0c\u58f0\u80fd\u8870\u51cf\u7a0b\u5ea6\u4f9d\u6b21\u5e8f\u9012\u51cf\u4e3a\uff1a\u9aa8\u8d28\u4e0e\u9499\u8d28\u3001\u809d\u813e\u7b49\u5b9e\u8d28\u7ec4\u7ec7\u3001\u8102\u80aa\u7ec4\u7ec7\u3001\u6db2\u4f53\u3002\u8d85\u58f0\u901a\u8fc7\u9aa8\u8d28\u4e0e\u9499\u8d28\u65f6\u660e\u663e\u8870\u51cf\u5bfc\u81f4\u5176\u540e\u65b9\u56de\u58f0\u51cf\u5f31\u4e43\u81f3\u6d88\u5931\uff0c\u4ece\u800c\u5f62\u6210\u58f0\u5f71\uff08acoustic shadow\uff09\uff0c\u4f46\u5728\u901a\u8fc7\u6db2\u4f53\u65f6\u51e0\u4e4e\u4e0d\u8870\u51cf\u3002 \u6b64\u5916\uff0c\u4e0e\u666e\u901a\u7684\u58f0\u6ce2\u4e0d\u540c\uff0c\u8d85\u58f0\u6ce2\u8fd8\u5177\u6709\u5982\u4e0b\u6027\u8d28\uff1a \u6307\u5411\u6027 \u7531\u4e8e\u8d85\u58f0\u6ce2\u9891\u7387\u9ad8\u6ce2\u957f\u77ed\uff0c\u56e0\u6b64\u5176\u5177\u6709\u826f\u597d\u7684\u6307\u5411\u6027\u3002\u8fd9\u662f\u8d85\u58f0\u68c0\u67e5\u5bf9\u4eba\u4f53\u5668\u5b98\u7ed3\u6784\u8fdb\u884c\u63a2\u6d4b\u7684\u57fa\u7840\u3002","title":"\u7269\u7406\u7279\u6027"},{"location":"bmi/ultrasound/#_3","text":"\u975e\u4fb5\u5165\u6027 \u5b89\u5168 \u5feb\u901f \u504f\u79fb \u4f4e\u5206\u8fa8\u7387","title":"\u5b9e\u7528\u7279\u6027"},{"location":"bmi/ultrasound/#_4","text":"\u80ce\u513f \u5fc3\u810f \u52a8\u8109","title":"\u7ec4\u7ec7"},{"location":"bmi/ultrasound/#_5","text":"\u5165\u5c04\u8d85\u58f0\u6ce2\u5728\u4eba\u4f53\u7ec4\u7ec7\u4e2d\u4f20\u64ad\uff0c\u5f53\u5176\u7ecf\u8fc7\u4e0d\u540c\u7684\u7ec4\u7ec7\u3001\u5668\u5b98\uff0c\u5305\u62ec\u6b63\u5e38\u4e0e\u75c5\u53d8\u7ec4\u7ec7\u7684\u591a\u5c42\u754c\u9762\u65f6\uff0c\u6bcf\u4e00\u754c\u9762\u7531\u4e8e\u4e24\u4fa7\u4ecb\u8d28\u7684\u58f0\u963b\u6297\u4e0d\u540c\u800c\u53d1\u751f\u4e0d\u540c\u7a0b\u5ea6\u7684\u53cd\u5c04\u548c/\u6216\u6563\u5c04\u3002\u8fd9\u4e9b\u53cd\u5c04\u548c/\u6216\u6563\u5c04\u5f62\u6210\u7684\u56de\u58f0\uff0c\u4ee5\u53ca\u8d85\u58f0\u5728\u4f20\u64ad\u8fc7\u7a0b\u4e2d\u6240\u7ecf\u8fc7\u4e0d\u540c\u7ec4\u7ec7\u7684\u8870\u51cf\u4fe1\u606f\uff0c\u7ecf\u63a5\u53d7\u3001\u653e\u5927\u548c\u4fe1\u606f\u5904\u7406\u800c\u5f62\u6210\u58f0\u50cf\u56fe\uff08ultrasonogram/echogram\uff09\u3002 \u8d85\u58f0\u6ce2\u5047\u8bbe\u7269\u4f53\u4e00\u5b9a\u4e0d\u4f1a\u5438\u6536\u5168\u90e8\u7684\u58f0\u6ce2\uff0c\u4e5f\u5373\u7269\u4f53\u4e00\u5b9a\u4f1a\u53cd\u5c04\u4e00\u5b9a\u91cf\u7684\u58f0\u6ce2\u3002 impedance must match without the matching impedance at the tissue layer, not enough acoustic wave frequency transmitted into the tissue all tissue have certain amount of compressibility leads to density","title":"\u6210\u50cf\u539f\u7406"},{"location":"bmi/ultrasound/#_6","text":"\u5bf9\u4e8e\u58f0\u538b p p \uff0c\u7279\u6027\u963b\u6297 Z Z \u4e0e\u7c92\u5b50\u901f\u5ea6 c c \uff0c\u6211\u4eec\u6709\u3002 p = Zv p = Zv \u8fd9\u4e2a\u5f0f\u5b50\u4e0e\u521d\u4e2d\u7535\u5b66\u6b27\u59c6\u5b9a\u5f8b\u7684\u5185\u5bb9\u5f88\u76f8\u4f3c\u2013\u7535\u538b=\u7535\u963b*\u7535\u6d41\u3002\u5176\u4e2d\uff0c Z = \\rho c Z = \\rho c \\rho \\rho \u4e3a\u5bc6\u5ea6\u3002\u53c8\u56e0\u4e3a\u5bf9\u4e8e\u538b\u7f29\u7cfb\u6570 k k \uff0c\u6211\u4eec\u6709 c = \\sqrt{\\frac{1}{k \\rho}} c = \\sqrt{\\frac{1}{k \\rho}} \uff0c\u4e0a\u5f0f\u4e5f\u53ef\u4ee5\u7b80\u5316\u4e3a Z = \\sqrt{\\frac{\\rho}{k}} Z = \\sqrt{\\frac{\\rho}{k}}","title":"\u58f0\u538b"},{"location":"bmi/ultrasound/#_7","text":"\u8d85\u58f0\u6210\u50cf\u6839\u636e\u539f\u7406\u53ef\u4ee5\u5206\u4e3aA\u3001B\u3001M\u3001D\u56db\u79cd\u578b\u53f7\uff0c\u5176\u4e2dD\u578b\u53c8\u6709\u591a\u79cd\u5b50\u578b\u53f7\u7528\u4ee5\u89c2\u5bdf\u8840\u6d41\u72b6\u51b5\u4e0e\u7ec4\u7ec7\u8fd0\u52a8\u3002","title":"\u7c7b\u578b"},{"location":"bmi/ultrasound/#a","text":"A\u578b\u8d85\u58f0\u7684\u58f0\u50cf\u56fe\u4e3a\u4e00\u7ef4\u6ce2\u5f62\u56fe\u3002\u5176\u4e2d\uff0c\u6a2a\u5750\u6807\u4e3a\u8d85\u58f0\u7684\u4f20\u64ad\u548c\u53cd\u5c04\u65f6\u95f4\uff0c\u7eb5\u5750\u6807\u5219\u4e3a\u53cd\u5c04\u6ce2\u5e45\u3002\u754c\u9762\u4e24\u4fa7\u4ecb\u8d28\u7684\u58f0\u963b\u6297\u4e4b\u5dee\u8d8a\u5927\uff0c\u56de\u58f0\u7684\u6ce2\u5e45\u8d8a\u5927\u3002 \u73b0\u65f6\uff0cA\u578b\u8d85\u58f0\u5df2\u7ecf\u57fa\u672c\u6ca1\u6709\u5e94\u7528\u3002","title":"A\u578b\u8d85\u58f0"},{"location":"bmi/ultrasound/#b","text":"B\u578b\u8d85\u58f0\u91c7\u7528\u591a\u4e2a\u58f0\u675f\u5bf9\u9009\u5b9a\u5207\u9762\u8fdb\u884c\u68c0\u67e5\uff0c\u5e76\u5c06\u6bcf\u6761\u58f0\u675f\u7684\u6240\u6709\u56de\u58f0\u4f9d\u5404\u81ea\u7684\u56de\u58f0\u65f6\u95f4\uff08\u4ee3\u8868\u56de\u58f0\u6df1\u5ea6\uff09\u548c\u5f3a\u5f31\uff0c\u91cd\u65b0\u7ec4\u6210\u68c0\u67e5\u5207\u9762\u7684\u4e8c\u7ef4\u56fe\u50cf\u3002\u5176\u4e2d\uff0c\u56fe\u50cf\u4e0a\u7684\u7eb5\u5750\u6807\u4ee3\u8868\u56de\u58f0\u65f6\u95f4\uff0c\u800c\u56de\u58f0\u7684\u5f3a\u5f31\u5219\u7528\u4e0d\u540c\u8f89\u5ea6\u7684\u5149\u70b9\u6765\u8868\u793a\u3002","title":"B\u578b\u8d85\u58f0"},{"location":"bmi/ultrasound/#m","text":"M\u578b\u8d85\u58f0\u91c7\u7528\u5355\u4e2a\u58f0\u675f\u5bf9\u9009\u5b9a\u5207\u9762\u8fdb\u884c\u68c0\u67e5\uff0c\u4f46\u5176\u5728\u6a2a\u5750\u6807\u65b9\u5411\u52a0\u5165\u4e00\u5bf9\u6162\u626b\u63cf\u6ce2\uff0c\u4f7f\u56de\u58f0\u5149\u70b9\u6cbf\u6c34\u5e73\u65b9\u5411\u79fb\u52a8\u4ece\u800c\u5f97\u5230\u9009\u5b9a\u5207\u9762\u4e0d\u540c\u6df1\u5ea6\u7ec4\u7ec7\u56de\u58f0\u968f\u65f6\u95f4\u53d8\u5316\u7684\u66f2\u7ebf\u3002M\u578b\u8d85\u58f0\u4e0eB\u578b\u8d85\u58f0\u7684\u58f0\u50cf\u56fe\u6ca1\u6709\u672c\u8d28\u533a\u522b\uff0c\u4ed6\u4eec\u7684\u533a\u522b\u5728\u4e8e\u4f7f\u7528\u4e0d\u540c\u7684\u65b9\u5f0f\u4ee5\u5f97\u5230\u56de\u58f0\u65f6\u95f4\u3002 Info B\u578b\u8d85\u58f0\u4e0eM\u578b\u8d85\u58f0\u7684\u58f0\u50cf\u56fe\u90fd\u4e3a\u4e8c\u7ef4\u58f0\u50cf\u56fe\u3002\u5728\u4e8c\u7ef4\u58f0\u50cf\u56fe\u4e0a\uff0c\u4f9d\u636e\u7ec4\u7ec7\u5185\u90e8\u58f0\u963b\u6297\u53ca\u58f0\u963b\u6297\u5dee\u7684\u5927\u5c0f\uff0c\u53ef\u4ee5\u5c06\u4eba\u4f53\u7ec4\u7ec7\u5668\u5b98\u5206\u4e3a\u56db\u79cd\u7c7b\u578b\uff1a \u53cd\u5c04\u7c7b\u578b \u4e8c\u7ef4\u8d85\u58f0 \u56fe\u50cf\u8868\u73b0 \u7ec4\u7ec7\u5668\u5b98 \u65e0\u53cd\u5c04 \u6db2\u6027\u6697\u533a \u65e0\u56de\u58f0 \u8840\u6db2\u3001\u5c3f\u6db2\u3001\u80c6\u6c41\u3001\u56ca\u6db2\u7b49\u6db2\u4f53 \u5c11\u53cd\u5c04 \u4f4e\u4eae\u5ea6 \u4f4e\u56de\u58f0 \u5fc3\u3001\u809d\u3001\u80f0\u3001\u813e\u7b49\u5b9e\u8d28\u5668\u5b98 \u591a\u53cd\u5c04 \u9ad8\u4eae\u5ea6 \u9ad8\u56de\u58f0 \u8840\u7ba1\u58c1\u3001\u5fc3\u74e3\u819c\u3001\u810f\u5668\u5305\u819c\u3001\u7ec4\u7ec7\u7ea4\u7ef4\u5316 \u5168\u53cd\u5c04 \u6781\u9ad8\u4eae\u5ea6 \u5f3a\u56de\u58f0\uff0c\u540e\u65b9\u6709\u58f0\u5f71 \u9aa8\u9abc\u3001\u9499\u6591\u3001\u7ed3\u77f3\u3001\u542b\u6c14\u80ba\u3001\u542b\u6c14\u80a0\u7ba1","title":"M\u578b\u8d85\u58f0"},{"location":"bmi/ultrasound/#d","text":"D\u578b\u8d85\u58f0\u53ca\u591a\u666e\u52d2\u8d85\u58f0\uff0c\u8fd9\u5305\u62ec\u9891\u8c31\u591a\u666e\u52d2\u8d85\u58f0\u3001\u5f69\u8272\u591a\u666e\u52d2\u8840\u6d41\u6210\u50cf\uff08Doppler Color Flow Imaging, DCFI\uff09\u7b49\uff0c\u53ef\u4ee5\u5bf9\u4eba\u4f53\u7684\u8840\u6d41\u53ca\u7ec4\u7ec7\u8fd0\u52a8\u7684\u65b9\u5411\u3001\u901f\u5ea6\u7b49\u8fdb\u884c\u89c2\u5bdf\u3002 \u591a\u666e\u52d2\u6548\u5e94\u662f\u6307\u5982\u679c\u7269\u4f53\u53d1\u751f\u8fd0\u52a8\uff0c\u5219\u9891\u7387\u4f1a\u53d1\u751f\u53d8\u5316\u3002 \u7ea2\u7ec6\u80de\u6709\u5f88\u5f3a\u7684\u7c98\u6027\uff0c\u5e76\u4e14\u5bf9\u58f0\u97f3\u6709\u5f88\u597d\u7684\u53cd\u5c04\u3002\u5982\u679c\u8840\u6db2\u5411\u6362\u80fd\u5668\u79fb\u52a8\uff0c\u90a3\u4e48\u53cd\u5c04\u9891\u7387\u5c06\u4f1a\u5347\u9ad8\uff0c\u53cd\u4e4b\u5219\u4f1a\u964d\u4f4e\u3002","title":"D\u578b\u8d85\u58f0"},{"location":"bmi/ultrasound/#_8","text":"\u9891\u8c31\u591a\u666e\u52d2\u8d85\u58f0\u662f\u6839\u636e\u591a\u666e\u52d2\u6548\u5e94\uff0c\u63d0\u53d6\u8d85\u58f0\u58f0\u675f\u5728\u4f20\u64ad\u9014\u5f84\u4e2d\u5404\u4e2a\u6d3b\u52a8\u754c\u9762\u6240\u4ea7\u751f\u7684\u9891\u79fb\u5373\u5dee\u9891\u56de\u58f0\u3002\u56fe\u50cf\u4ee5\u9891\u8c31\u65b9\u5f0f\u663e\u793a\uff0c\u5176\u4e2d\u7eb5\u5750\u6807\u8868\u793a\u5dee\u9891\u7684\u6570\u503c\uff08\u4ee5\u901f\u5ea6\u8868\u793a\uff09\uff0c\u6a2a\u5750\u6807\u4ee3\u8868\u65f6\u95f4\u3002\u671d\u5411\u63a2\u5934\u4fa7\u7684\u5dee\u9891\u4fe1\u53f7\u4f4d\u4e8e\u57fa\u7ebf\u4e0a\u65b9\uff0c\u800c\u80cc\u5411\u63a2\u5934\u8005\u5219\u5728\u57fa\u7ebf\u4e0b\u65b9\u3002\u9891\u8c31\u591a\u666e\u52d2\u5305\u62ec\u8109\u51b2\u591a\u666e\u52d2\u3001\u8fde\u7eed\u591a\u666e\u52d2\u548c\u9ad8\u8109\u51b2\u91cd\u590d\u9891\u7387\u591a\u666e\u52d2\uff0c\u4ee5\u524d\u4e24\u8005\u5e38\u7528\u3002\u8109\u51b2\u591a\u666e\u52d2\u91c7\u7528\u5355\u4e2a\u6362\u80fd\u5668\uff0c\u5229\u7528\u53d1\u5c04\u4e0e\u53cd\u5c04\u7684\u95f4\u9699\u63a5\u6536\u9891\u79fb\u4fe1\u53f7\uff0c\u5177\u6709\u8ddd\u79bb\u9009\u901a\u529f\u80fd\uff0c\u53ef\u5b9a\u4f4d\u5206\u6790\uff0c\u4f46\u4e0d\u80fd\u51c6\u786e\u6d4b\u91cf\u9ad8\u901f\u8840\u6d41\u3002\u8fde\u7eed\u591a\u666e\u52d2\u91c7\u7528\u4e24\u7ec4\u6362\u80fd\u5668\uff0c\u5206\u522b\u53d1\u5c04\u8d85\u58f0\u6ce2\u548c\u63a5\u6536\u5176\u53cd\u5c04\u6ce2\uff0c\u53ef\u7528\u4e8e\u9ad8\u901f\u8840\u6d41\u7684\u5b9a\u91cf\u5206\u6790\uff0c\u4f46\u65e0\u8ddd\u79bb\u9009\u901a\u529f\u80fd\u3002 \u9891\u8c31\u578b\u591a\u666e\u52d2\u8d85\u58f0\u68c0\u67e5\u80fd\u591f\u83b7\u53d6\u7ec4\u7ec7\u548c\u5668\u5b98\u7ed3\u6784\u53ca\u75c5\u53d8\u7684\u8840\u6d41\u4fe1\u606f\uff0c\u5305\u62ec\u8840\u6d41\u65b9\u5411\u3001\u901f\u5ea6\u3001\u6027\u8d28\u3001\u538b\u529b\u9636\u5dee\u7b49\uff0c\u53ef\u5bf9\u5fc3\u810f\u3001\u8840\u7ba1\u548c\u810f\u5668\u75c5\u53d8\u7684\u8840\u6d41\u8fdb\u884c\u5b9a\u6027\u548c\u5b9a\u91cf\u5206\u6790\u3002","title":"\u9891\u8c31\u591a\u666e\u52d2\u8d85\u58f0"},{"location":"bmi/ultrasound/#dcfi","text":"\u5f69\u8272\u591a\u666e\u52d2\u8840\u6d41\u6210\u50cf\u662f\u5229\u7528\u591a\u666e\u52d2\u6548\u5e94\uff0c\u63d0\u53d6\u4e8c\u7ef4\u5207\u9762\u5185\u6240\u6709\u5dee\u9891\u56de\u58f0\uff0c\u4ee5\u5f69\u8272\u65b9\u5f0f\u663e\u793a\uff0c\u5e76\u53e0\u52a0\u5728\u76f8\u5339\u914d\u7684\u4e8c\u7ef4\u58f0\u50cf\u56fe\u4e0a\u3002\u5728DCFI\u56fe\u50cf\u4e0a\uff0c\u4ee5\u7ea2\u3001\u84dd\u3001\u7eff\u4e09\u8272\u8868\u793a\u8840\u6d41\u591a\u666e\u52d2\u5dee\u9891\u56de\u58f0\uff0c\u5176\u4e2d\u671d\u5411\u63a2\u5934\u7684\u8840\u6d41\u4ee5\u7ea2\u8272\u8868\u793a\uff0c\u80cc\u5411\u63a2\u5934\u8005\u4ee5\u84dd\u8272\u8868\u793a\uff0c\u6e4d\u6d41\u65b9\u5411\u590d\u6742\u3001\u591a\u53d8\uff0c\u5448\u4e94\u5f69\u9576\u5d4c\u6216\u7eff \u8272\u3002\u8840\u6d41\u901f\u5ea6\u5feb\u8005\uff0c\u8272\u5f69\u9c9c\u4eae\uff0c\u6162\u8005\u5219\u6697\u6de1\u3002 \u5f69\u8272\u591a\u666e\u52d2\u8840\u6d41\u6210\u50cf\u591f\u76f4\u89c2\u663e\u793a\u5fc3\u810f\u3001\u8840\u7ba1\u548c\u810f\u5668\u7684\u8840\u6d41\u72b6\u51b5\uff0c\u901a\u8fc7\u8272\u5f69\u6539\u53d8\u53ef\u654f\u611f\u5730\u53d1\u73b0\u5f02\u5e38\u8840\u6d41\uff0c\u4f46\u4e0d\u80fd\u8fdb\u884c\u7cbe\u786e\u7684\u5b9a\u91cf\u5206\u6790\u3002","title":"\u5f69\u8272\u591a\u666e\u52d2\u8840\u6d41\u6210\u50cf(DCFI)"},{"location":"bmi/ultrasound/#coe","text":"DCFI\u80fd\u53cd\u6620\u8840\u6d41\u901f\u5ea6\u3001\u52a0\u901f\u5ea6\u548c\u65b9\u5411\u53d8\u5316\uff0c\u4f46\u8fd9\u4e9b\u4fe1\u606f\u53d7\u63a2\u6d4b\u89d2\u5ea6\u7684\u5f71\u54cd\u8f83\u5927\uff0c\u4e14\u68c0\u6d4b\u4f4e\u901f\u8840\u6d41\u7684\u80fd\u529b\u53d7\u9650\u3002\u800c\u5f69\u8272\u591a\u666e\u52d2\u80fd\u91cf\u56fe(color Doppler energy , CDE)\u63d0\u53d6\u548c\u663e\u793a\u591a\u666e\u52d2\u4fe1\u53f7\u7684\u80fd\u91cf\u4fe1\u53f7\u5f3a\u5ea6\uff0c\u6210\u50cf\u53c2\u6570\u4e3a\u8840\u6d41\u4e2d\u4e0e\u6563\u5c04\u76f8\u5bf9\u5e94\u7684\u80fd\u91cf\u4fe1\u53f7\uff0c\u4e3b\u8981\u53d6\u51b3\u4e8e\u53d6\u6837\u4e2d\u7ea2\u7ec6\u80de\u76f8\u5bf9\u6570\u91cf\u7684\u591a\u5c11\u3002\u80fd\u663e\u793a\u4f4e\u901f\u8840\u6d41\u800c\u4e0d\u53d7\u63a2\u6d4b\u89d2\u5ea6\u56e0\u7d20\u7684\u5f71\u54cd\uff0c\u4e5f\u4e0d\u5b58\u5728\u5f69\u8272\u6df7\u53e0\u73b0\u8c61\u3002\u7ec4\u7ec7\u591a\u666e\u52d2\u6210\u50cf(tissue Doppler ima\u00adging , TDI)\u662f\u4ee5\u591a\u666e\u52d2\u539f\u7406\u4e3a\u57fa\u7840\uff0c\u5229\u7528\u8840\u6d41\u6ee4\u6ce2\u5668\u6ee4\u53bb\u4f4e\u5e45\u9ad8\u9891\uff08\u8840\u6d41\uff09\u4fe1\u606f\uff0c\u4ec5\u68c0\u6d4b\u5fc3\u5ba4\u58c1\u53cd\u5c04\u56de \u6765\u7684\u4f4e\u9891\u9ad8\u632f\u5e45\u9891\u79fb\u4fe1\u53f7\uff0c\u4ece\u800c\u663e\u793a\u5fc3\u808c\u7ec4\u7ec7\u7684\u8fd0\u52a8\u60c5\u51b5\u3002 \u5f69\u8272\u591a\u666e\u52d2\u80fd\u91cf\u56fe\u663e\u793a\u4fe1\u53f7\u7684\u52a8\u6001\u8303\u56f4\u5e7f\uff0c\u80fd\u6709\u6548\u663e\u793a\u4f4e\u901f\u8840\u6d41\uff0c\u5bf9\u672b\u68a2\u8840\u6d41\u3001\u80bf\u7624\u6ecb\u517b\u8840\u7ba1\u548c\u67d0\u4e9b\u90e8\u4f4d\u8840\u6d41\u704c\u6ce8\u63d0\u4f9b\u91cd\u8981\u4fe1\u606f\u3002 4\u7ec4\u7ec7\u591a\u666e\u52d2\u6210\u50cf(TOI)\u901a\u8fc7\u7279\u6b8a\u65b9\u6cd5\u63d0\u53d6\u5fc3\u808c\u8fd0\u52a8\u6240\u4ea7\u751f\u7684\u591a\u666e\u52d2\u9891\u79fb\u4fe1\u53f7\u8fdb\u884c\u5206\u6790\u3001\u5904\u7406\u548c\u6210\u50cf \uff0c\u53ef\u5bf9\u5fc3\u808c\u8fd0\u52a8\u8fdb\u884c\u5b9a\u6027\u548c\u5b9a\u91cf\u5206\u6790\u3002","title":"\u5f69\u8272\u591a\u666e\u52d2\u80fd\u91cf\u56fe(COE)"},{"location":"cg/affine_convex/","text":"\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u7b80\u8981\u4ecb\u7ecd\u4eff\u5c04\u548c\u51f8\u7684\u6982\u5ff5\u3002 \u4eff\u5c04 # \u76f4\u7ebf\u7684\u5b9a\u4e49\u60f3\u5fc5\u521d\u4e2d\u90fd\u5df2\u7ecf\u5b66\u8fc7\uff0c\u8fd9\u91cc\u6211\u4eec\u7b80\u5355\u590d\u4e60\u4e00\u4e0b\uff1a \u76f4\u7ebf\uff08line\uff09 \u7a7a\u95f4 \\mathbb{R}^n \\mathbb{R}^n \u4e2d\u7684\u4e24\u4e2a\u70b9 x_1, x_2, x_1 \\neq x_2 x_1, x_2, x_1 \\neq x_2 \u53ef\u4ee5\u552f\u4e00\u786e\u5b9a\u4e00\u6761\u76f4\u7ebf\u3002\u8fd9\u6761\u76f4\u7ebf\u53ef\u4ee5\u88ab\u53c2\u6570\u5316\u7684\u63cf\u8ff0\u4e3a x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ \\theta \\in \\mathbb{R} x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ \\theta \\in \\mathbb{R} \u6211\u4eec\u5f88\u5bb9\u6613\u53d1\u73b0\uff0c x = x_1 x = x_1 \u65f6\uff0c \\theta = 1 \\theta = 1 \uff1b x = x_2 x = x_2 \u65f6\uff0c \\theta = 0 \\theta = 0 \u3002\u7531\u6b64\uff0c\u6211\u4eec\u77e5\u9053\u4e86\u7ebf\u6bb5\u88ab\u5982\u4f55\u63cf\u8ff0\uff1a \u7ebf\u6bb5\uff08line segment\uff09 \u7a7f\u8fc7\u4e24\u70b9 x_1, x_2 \\in \\mathbb{R}^n, x_1 \\neq x_2 x_1, x_2 \\in \\mathbb{R}^n, x_1 \\neq x_2 \u7684\u7ebf\u6bb5\u53ef\u4ee5\u88ab\u53c2\u6570\u5316\u7684\u63cf\u8ff0\u4e3a x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ 0 \\leq \\theta \\leq 1 x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ 0 \\leq \\theta \\leq 1 \u901a\u8fc7\u53d8\u5316\uff0c\u76f4\u7ebf\u8fd8\u53ef\u4ee5\u88ab\u8868\u8fbe\u4e3a x = x_2 + \\theta (x_1 - x_2) \\ s.t. \\ \\theta \\in \\mathbb{R} x = x_2 + \\theta (x_1 - x_2) \\ s.t. \\ \\theta \\in \\mathbb{R} \u3002\u8fd9\u7ed9\u4e86\u6211\u4eec\u53e6\u4e00\u79cd\u89e3\u8bfb\u2013 x x \u662f \u57fa\u70b9 x_2 x_2 \u4e0e \u65b9\u5411 x_1 - x_2 x_1 - x_2 \u6309\u53c2\u6570 \\theta \\theta \u7f29\u653e\u4e4b\u548c\u3002 \u56e0\u6b64\uff0c \\theta \\theta \u7ed9\u51fa\u4e86\u4ece x_2 x_2 \u5230 x_1 x_1 \u7684\u5206\u6570\u3002\u5f53 \\theta \\theta \u4ece0\u589e\u5927\u52301\u65f6\uff0c\u70b9 x x \u4ece x_2 x_2 \u79fb\u52a8\u5230 x_1 x_1 \uff1b\u5f53 \\theta \\theta \u5728\u6b64\u533a\u95f4\u4ee5\u5916\u65f6\uff0c\u70b9 x x \u4f4d\u4e8e x_1 x_1 \u5230 x_2 x_2 \u4ee5\u5916\u7684\u7ebf\u4e0a\u3002 \u5728\u590d\u4e60\u4e86\u76f4\u7ebf\u4e4b\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u7ed9\u4eff\u5c04\u96c6\u505a\u4e00\u4e2a\u5b9a\u4e49\uff1a \u4eff\u5c04\u96c6 \u5bf9\u4e8e\u96c6\u5408 C \\subseteq \\mathbb{R} C \\subseteq \\mathbb{R} \uff0c\u82e5\u7ecf\u8fc7\u8be5\u96c6\u5408\u4e0a\u4efb\u610f\u4e24\u70b9 x_1, x_2 \\in C, x_1 \\neq x_2 x_1, x_2 \\in C, x_1 \\neq x_2 \u7684\u76f4\u7ebf\u4e0a\u7684\u70b9\u90fd\u5728\u8be5\u96c6\u5408\u4e2d\uff0c\u90a3\u4e48\u6211\u4eec\u79f0\u96c6\u5408 C C \u4e3a\u4e00\u4e2a\u4eff\u5c04\u96c6\u3002 \u7ebf\u6027\u65b9\u7a0b \\{x \\mid Ax = b\\} \\{x \\mid Ax = b\\} \u7684\u89e3\u5373\u662f\u4e00\u4e2a\u4eff\u5c04\u96c6\uff0c\u53cd\u8fc7\u6765\u6bcf\u4e00\u4e2a\u4eff\u5c04\u96c6\u4e5f\u90fd\u53ef\u4ee5\u8868\u793a\u4e3a\u4e00\u4e2a\u7ebf\u6027\u65b9\u7a0b\u7cfb\u7edf\u7684\u89e3\u96c6\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u6709\u65f6\u5019\u5c06\u4eff\u5c04\u96c6\u6210\u4e3a\u7ebf\u6027\uff08linear\uff09\u3002 \u6709\u540c\u5b66\u53ef\u4ee5\u53d1\u73b0\uff0c\u4eff\u5c04\u96c6\u4e0e\u7ebf\u6027\u5b50\u7a7a\u95f4\u975e\u5e38\u76f8\u4f3c\u3002\u4e8b\u5b9e\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u4e00\u4e2a\u4eff\u5c04\u96c6\u770b\u4f5c\u662f\u4e00\u4e2a\u7ebf\u6027\u5b50\u7a7a\u95f4\u6839\u636e\u4e00\u4e2a\u56fa\u5b9a\u5411\u91cf\u5e73\u79fb\u800c\u5f97\u5230\u7684\u3002\u5bf9\u4e8e\u4eff\u5c04\u96c6 C C \u4e0e\u5176\u4e0a\u4e00\u70b9 x_0 x_0 \uff0c\u96c6\u5408 V = C - x_0 = \\{x - x_0 \\mid x \\in C\\} V = C - x_0 = \\{x - x_0 \\mid x \\in C\\} \u662f\u4e00\u4e2a\u5b50\u7a7a\u95f4\u3002 \u8bc1\u660e V = C - x_0 V = C - x_0 \u5bf9\u4e8e\u5411\u91cf\u52a0\u6cd5\u4e0e\u6807\u91cf\u4e58\u6cd5\u95ed\u5408 \u5bf9\u4e8e v_1, v_2 \\in V, \\alpha, \\beta \\in \\mathbb{R} v_1, v_2 \\in V, \\alpha, \\beta \\in \\mathbb{R} \uff0c\u6211\u4eec\u6709 v_1 + x_0, v_2 + x_0 \\in C v_1 + x_0, v_2 + x_0 \\in C \uff0c\u6240\u4ee5 \\alpha v_1 + \\beta v_2 + x_0 = \\alpha (v_1 + x_0) + \\beta (v_2 + x_0) + (1 -\\alpha - \\beta) x_0 \\in C \\alpha v_1 + \\beta v_2 + x_0 = \\alpha (v_1 + x_0) + \\beta (v_2 + x_0) + (1 -\\alpha - \\beta) x_0 \\in C \uff0c\u7531\u4e8e C C \u662f\u4eff\u5c04\u96c6\u3001 \\alpha + \\beta + (1 -\\alpha - \\beta) = 1, \\alpha v_1 + \\beta v_2 + x_0 \\in C \\alpha + \\beta + (1 -\\alpha - \\beta) = 1, \\alpha v_1 + \\beta v_2 + x_0 \\in C \uff0c\u6613\u5f97 \\alpha v_1 + \\beta v_2 \\in V \\alpha v_1 + \\beta v_2 \\in V \u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u4eff\u5c04\u96c6 C C \u8868\u8ff0\u4e3a C = V + x_0 = \\{v + x_0 \\mid v \\in V\\} C = V + x_0 = \\{v + x_0 \\mid v \\in V\\} \uff0c x_0 x_0 \u4e3a C C \u4e0a\u4efb\u610f\u4e00\u70b9\u3002\u6211\u4eec\u5c06\u5b50\u7a7a\u95f4 V V \u79f0\u4f5c\u4eff\u5c04\u96c6 C C \u76f8\u5173\u7684\u5b50\u7a7a\u95f4\uff0c\u5c06\u5b50\u7a7a\u95f4 V V \u7684\u7ef4\u5ea6\u79f0\u4f5c\u4eff\u5c04\u96c6 C C \u7684\u7ef4\u5ea6\u3002 \u7b80\u5355\u4e86\u89e3\u4e86\u76f4\u7ebf\u4e0e\u4eff\u5c04\u96c6\u4e4b\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u5ef6\u4f38\u51fa\u4eff\u5c04\u7ec4\u5408\uff1a \u4eff\u5c04\u7ec4\u5408\uff08affine combination\uff09 \u5bf9\u4e8e\u7ebf\u6027\u7ec4\u5408 \\sum_{i=1}^n \\theta_i x_i \\sum_{i=1}^n \\theta_i x_i \uff0c\u82e5\u5176\u6ee1\u8db3 \\sum_{i=1}^n \\theta_i = 1 \\sum_{i=1}^n \\theta_i = 1 \u5219\u6211\u4eec\u79f0\u5176\u4e3a\u4eff\u5c04\u7ec4\u5408\u3002 \u4eff\u5c04\u96c6 C C \u5305\u542b\u4e86\u8be5\u96c6\u5408\u4e2d\u4efb\u610f\u70b9\u7684\u4eff\u5c04\u7ec4\u5408\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u5bf9\u4e8e x_1, x_2, x_n \\in C, \\sum_{i=1}^n \\theta_i = 1 x_1, x_2, x_n \\in C, \\sum_{i=1}^n \\theta_i = 1 \uff0c \\sum_{i=1}^n \\theta_i x_i \\in C \\sum_{i=1}^n \\theta_i x_i \\in C \u3002 \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u4eff\u5c04\u7ec4\u5408\u5176\u5b9e\u53ef\u4ee5\u88ab\u770b\u6210\u4e00\u4e2a\u6240\u6709\u7cfb\u6570\u4e4b\u548c\u4e3a1\u7684\u7279\u6b8a\u7684\u7ebf\u6027\u7ec4\u5408\u3002\u8fd9\u6837\u7684\u7279\u6027\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u629b\u5f03\u539f\u70b9\uff0c\u800c\u5c06\u4efb\u610f\u7684\u70b9\u89c6\u4e3a\u539f\u70b9\uff0c\u6211\u4eec\u90fd\u53ef\u4ee5\u4f7f\u7528\u540c\u6837\u7684\u7ebf\u6027\u7ec4\u5408\u53bb\u63cf\u8ff0\u540c\u4e00\u4e2a\u70b9\u3002 \ud83c\udf30 \u5bf9\u4e8e\u539f\u70b9\u4ee5\u53ca\u7a7a\u95f4\u4e0a\u4efb\u610f\u4e00\u70b9 p p \uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5411\u91cf a,\\ b a,\\ b \u5206\u522b\u8868\u8ff0\u4e3a a + b a + b \u4e0e p + (a - p) + (b - p) p + (a - p) + (b - p) \u3002\u7531\u6b64\uff0c\u6211\u4eec\u901a\u8fc7\u4eff\u5c04\u7ec4\u5408\u53bb\u63cf\u8ff0\u53e6\u4e00\u70b9\u65f6\uff0c\u4e24\u4e2a\u63cf\u8ff0\u5206\u522b\u4e3a \\theta a + (1 - \\theta) b \\theta a + (1 - \\theta) b \u4e0e p + \\theta (a - p) + (1 - \\theta) (b - p) = p + \\theta a - \\theta p + (1 - \\theta) b - (1 - \\theta) p = \\theta a + (1 - \\theta) b p + \\theta (a - p) + (1 - \\theta) (b - p) = p + \\theta a - \\theta p + (1 - \\theta) b - (1 - \\theta) p = \\theta a + (1 - \\theta) b \uff1b\u6211\u4eec\u5f88\u5bb9\u6613\u53d1\u73b0\u4e24\u4e2a\u63cf\u8ff0\u4e0e\u5176\u8d77\u59cb\u70b9\u6ca1\u6709\u5173\u7cfb\u3002 \u96c6\u5408 S S \u7684\u4eff\u5c04\u5305 aff(S) aff(S) \u6307\u7684\u662f\u5305\u542b\u96c6\u5408 S S \u7684\u6700\u5c0f\u4eff\u5c04\u96c6\uff0c\u5b83\u88ab\u5b9a\u4e49\u4e3a: \u4eff\u5c04\u5305\uff08affine hull\uff09 aff(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, x_i \\in S, \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} aff(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, x_i \\in S, \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} \u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u4eff\u5c04\u96c6 C C \u6709 S \\subseteq C S \\subseteq C \uff0c\u90a3\u4e48 aff(S) \\subseteq C aff(S) \\subseteq C \u3002 \u51f8 # \u6211\u4eec\u6ce8\u610f\u5230\u5230\u73b0\u5728\u4e3a\u6b62\u6211\u4eec\u4e00\u76f4\u5728\u8ba8\u8bba\u4eff\u5c04\uff0c\u800c\u6ca1\u6709\u8fdb\u5165\u771f\u6b63\u7684\u4e3b\u9898\u2013\u51f8\u3002\u4e8b\u5b9e\u4e0a\uff0c\u6211\u4eec\u5df2\u7ecf\u5dee\u4e0d\u591a\u5b66\u4e60\u4e86\u51f8\u7684\u6240\u6709\u6982\u5ff5\u4e86\u2013\u4ec5\u4ec5\u5c06\u4eff\u5c04\u7684\u76f4\u7ebf\u6362\u6210\u7ebf\u6bb5\uff0c\u6211\u4eec\u5c31\u80fd\u5f97\u5230\u51f8\u3002 \u51f8\u96c6 \u5bf9\u4e8e\u96c6\u5408 C \\subseteq \\mathbb{R} C \\subseteq \\mathbb{R} \uff0c\u82e5\u7ecf\u8fc7\u8be5\u96c6\u5408\u4e0a\u4efb\u610f\u4e24\u70b9 x_1, x_2 \\in C, x_1 \\neq x_2 x_1, x_2 \\in C, x_1 \\neq x_2 \u7684 \u7ebf\u6bb5 \u4e0a\u7684\u70b9\u90fd\u5728\u8be5\u96c6\u5408\u4e2d\uff0c\u90a3\u4e48\u6211\u4eec\u79f0\u96c6\u5408 C C \u4e3a\u4e00\u4e2a\u51f8\u96c6\u3002 \u51f8\u7ec4\u5408\uff08convex combination\uff09 \u5bf9\u4e8e\u7ebf\u6027\u7ec4\u5408 \\sum_{i=1}^n \\theta_i x_i \\sum_{i=1}^n \\theta_i x_i \uff0c\u82e5\u5176\u6ee1\u8db3 \\sum_{i=1}^n \\theta_i = 1 \\sum_{i=1}^n \\theta_i = 1 \u5e76\u4e14 \\forall \\theta_i, \\theta_i \\geq 0 \\forall \\theta_i, \\theta_i \\geq 0 \u5219\u6211\u4eec\u79f0\u5176\u4e3a\u51f8\u7ec4\u5408\u3002 \u51f8\u5305\uff08convex hull\uff09 conv(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, conv(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, x_i \\geq 0 x_i \\geq 0 , \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} , \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} | \u6211\u4eec\u5f88\u5bb9\u6613\u60f3\u5230\uff0c\u5e38\u89c1\u7684\u4e09\u89d2\u5f62\u3001\u65b9\u5f62\u3001\u5706\u5f62\u90fd\u662f\u51f8\u7684\uff1b\u800c\u661f\u5f62\u5219\u662f\u975e\u51f8\u7684\uff0c\u56e0\u4e3a\u4efb\u610f\u4e24\u70b9\u4e4b\u95f4\u5b58\u5728\u6709\u4e9b\u70b9\u4e0d\u5728\u96c6\u5408\u4e4b\u5185\u3002 \u975e\u51f8\u96c6\u4e94\u89d2\u661f\u7684\u51f8\u5305\u662f \u51f8\u96c6\u4e94\u8fb9\u5f62\u3002 \u5982\u4f55\u5224\u65ad\u4e00\u4e2a\u51fd\u6570\u662f\u5426\u662f\u51f8\u7684 \u8fd9\u4e2a\u95ee\u9898\u770b\u4f3c\u5341\u5206\u7b80\u5355\u3002\u6211\u4eec\u53ea\u9700\u8981\u6839\u636e\u51f8\u96c6\u7684\u5b9a\u4e49\uff0c\u9009\u53d6\u96c6\u5408\u4e2d\u7684\u6bcf\u4e00\u4e2a\u70b9\u5bf9\u7136\u540e\u5224\u65ad\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u7ebf\u6bb5\u4e0a\u7684\u70b9\u662f\u5426\u662f\u51f8\u7684\u5373\u53ef\u3002\u5bf9\u4e8e\u4e00\u4e2a\u6709\u7740 n n \u4e2a\u70b9\u7684\u96c6\u5408\uff0c\u4e0a\u8ff0\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4ec5\u4ec5\u4e3a O(n?n) O(n?n) \uff0c\u8fd9\u751a\u81f3\u662f\u4e00\u4e2a\u591a\u9879\u5f0f\u65f6\u95f4\u7684\u7b97\u6cd5\u3002\u4f46\u662f\u8fd9\u660e\u663e\u8fd8\u6709\u5f88\u5927\u7684\u6539\u8fdb\u7a7a\u95f4\u3002 \u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u4ecb\u7ecd\u4fdd\u7559\u51f8\u6027\u7684\u8fd0\u7b97\uff0c\u8fd9\u4e9b\u8fd0\u7b97\u6709\u52a9\u4e8e\u5224\u5b9a\u4e00\u4e2a\u96c6\u5408\u662f\u5426\u51f8\u4ee5\u53ca\u6784\u5efa\u4e00\u4e2a\u51f8\u96c6\u3002 \u4fdd\u51f8\u8fd0\u7b97 # \u4ea4\u96c6 \u5bf9\u4e8e\u96c6\u5408 S_1, S_2 S_1, S_2 \uff0c\u5982\u679c\u4ed6\u4eec\u662f\u51f8\u96c6\uff0c\u90a3\u4e48 S_1 \\cap S_2 S_1 \\cap S_2 \u4e5f\u662f\u51f8\u96c6\u3002 \u4eff\u5c04\u51fd\u6570 \u5982\u679c\u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m \u662f\u4e00\u4e2a\u653e\u5c04\u51fd\u6570\uff0c\u90a3\u4e48\uff1a f f \u4e0b\u7684\u51f8\u96c6\u7684\u50cf\u4e5f\u662f\u51f8\u7684: S \\subseteq \\mathbb{R}^n \\text{is convex} \\Rightarrow f(S) = \\{f(x) \\mid x \\in S\\} \\text{is convex} S \\subseteq \\mathbb{R}^n \\text{is convex} \\Rightarrow f(S) = \\{f(x) \\mid x \\in S\\} \\text{is convex} f f \u4e0b\u7684\u51f8\u96c6\u7684\u9006\u50cf\u4e5f\u662f\u51f8\u7684: C \\subseteq \\mathbb{R}^m \\text{is convex} \\Rightarrow f^{-1}(C) = \\{x \\mid f(x) \\in C\\} \\text{is convex} C \\subseteq \\mathbb{R}^m \\text{is convex} \\Rightarrow f^{-1}(C) = \\{x \\mid f(x) \\in C\\} \\text{is convex} \u900f\u89c6\u548c\u7ebf\u6027\u5206\u6570\u51fd\u6570 \u900f\u89c6\u51fd\u6570 P: \\mathbb{R}^{n+1} \\rightarrow \\mathbb{R}^n P: \\mathbb{R}^{n+1} \\rightarrow \\mathbb{R}^n \uff1a P(x, t) = x / t, \\quad dom(P) = \\{(x, t) \\mid t > 0\\} P(x, t) = x / t, \\quad dom(P) = \\{(x, t) \\mid t > 0\\} \u7ebf\u6027\u5206\u6570\u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m \uff1a f(x) = \\frac{Ax + b}{c^T + d}, \\quad dom(f) = \\{x \\mid c^Tx + d > 0\\} f(x) = \\frac{Ax + b}{c^T + d}, \\quad dom(f) = \\{x \\mid c^Tx + d > 0\\} \u900f\u89c6\u51fd\u6570\u4e0e\u7ebf\u6027\u5206\u6570\u51fd\u6570\u4e0b\u7684\u51f8\u96c6\u7684\u50cf\u548c\u9006\u50cf\u4e5f\u662f\u51f8\u7684 \u8fd9\u4e9b\u5c5e\u6027\u6269\u5c55\u5230\u65e0\u9650\u4e2a\u96c6\u5408\u7684\u4ea4\u96c6\u4e2d\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c S_\\alpha S_\\alpha \u662f\u51f8\u96c6\u5bf9\u4e8e\u6bcf\u4e00\u4e2a \\alpha \\in A \\alpha \\in A \u90fd\u6210\u7acb\uff0c\u90a3\u4e48 \\cap_{\\alpha \\in A}S_\\alpha \\cap_{\\alpha \\in A}S_\\alpha \u4e5f\u662f\u4e00\u4e2a\u51f8\u96c6\u3002","title":"\u4eff\u5c04\u4e0e\u51f8"},{"location":"cg/affine_convex/#_1","text":"\u76f4\u7ebf\u7684\u5b9a\u4e49\u60f3\u5fc5\u521d\u4e2d\u90fd\u5df2\u7ecf\u5b66\u8fc7\uff0c\u8fd9\u91cc\u6211\u4eec\u7b80\u5355\u590d\u4e60\u4e00\u4e0b\uff1a \u76f4\u7ebf\uff08line\uff09 \u7a7a\u95f4 \\mathbb{R}^n \\mathbb{R}^n \u4e2d\u7684\u4e24\u4e2a\u70b9 x_1, x_2, x_1 \\neq x_2 x_1, x_2, x_1 \\neq x_2 \u53ef\u4ee5\u552f\u4e00\u786e\u5b9a\u4e00\u6761\u76f4\u7ebf\u3002\u8fd9\u6761\u76f4\u7ebf\u53ef\u4ee5\u88ab\u53c2\u6570\u5316\u7684\u63cf\u8ff0\u4e3a x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ \\theta \\in \\mathbb{R} x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ \\theta \\in \\mathbb{R} \u6211\u4eec\u5f88\u5bb9\u6613\u53d1\u73b0\uff0c x = x_1 x = x_1 \u65f6\uff0c \\theta = 1 \\theta = 1 \uff1b x = x_2 x = x_2 \u65f6\uff0c \\theta = 0 \\theta = 0 \u3002\u7531\u6b64\uff0c\u6211\u4eec\u77e5\u9053\u4e86\u7ebf\u6bb5\u88ab\u5982\u4f55\u63cf\u8ff0\uff1a \u7ebf\u6bb5\uff08line segment\uff09 \u7a7f\u8fc7\u4e24\u70b9 x_1, x_2 \\in \\mathbb{R}^n, x_1 \\neq x_2 x_1, x_2 \\in \\mathbb{R}^n, x_1 \\neq x_2 \u7684\u7ebf\u6bb5\u53ef\u4ee5\u88ab\u53c2\u6570\u5316\u7684\u63cf\u8ff0\u4e3a x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ 0 \\leq \\theta \\leq 1 x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ 0 \\leq \\theta \\leq 1 \u901a\u8fc7\u53d8\u5316\uff0c\u76f4\u7ebf\u8fd8\u53ef\u4ee5\u88ab\u8868\u8fbe\u4e3a x = x_2 + \\theta (x_1 - x_2) \\ s.t. \\ \\theta \\in \\mathbb{R} x = x_2 + \\theta (x_1 - x_2) \\ s.t. \\ \\theta \\in \\mathbb{R} \u3002\u8fd9\u7ed9\u4e86\u6211\u4eec\u53e6\u4e00\u79cd\u89e3\u8bfb\u2013 x x \u662f \u57fa\u70b9 x_2 x_2 \u4e0e \u65b9\u5411 x_1 - x_2 x_1 - x_2 \u6309\u53c2\u6570 \\theta \\theta \u7f29\u653e\u4e4b\u548c\u3002 \u56e0\u6b64\uff0c \\theta \\theta \u7ed9\u51fa\u4e86\u4ece x_2 x_2 \u5230 x_1 x_1 \u7684\u5206\u6570\u3002\u5f53 \\theta \\theta \u4ece0\u589e\u5927\u52301\u65f6\uff0c\u70b9 x x \u4ece x_2 x_2 \u79fb\u52a8\u5230 x_1 x_1 \uff1b\u5f53 \\theta \\theta \u5728\u6b64\u533a\u95f4\u4ee5\u5916\u65f6\uff0c\u70b9 x x \u4f4d\u4e8e x_1 x_1 \u5230 x_2 x_2 \u4ee5\u5916\u7684\u7ebf\u4e0a\u3002 \u5728\u590d\u4e60\u4e86\u76f4\u7ebf\u4e4b\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u7ed9\u4eff\u5c04\u96c6\u505a\u4e00\u4e2a\u5b9a\u4e49\uff1a \u4eff\u5c04\u96c6 \u5bf9\u4e8e\u96c6\u5408 C \\subseteq \\mathbb{R} C \\subseteq \\mathbb{R} \uff0c\u82e5\u7ecf\u8fc7\u8be5\u96c6\u5408\u4e0a\u4efb\u610f\u4e24\u70b9 x_1, x_2 \\in C, x_1 \\neq x_2 x_1, x_2 \\in C, x_1 \\neq x_2 \u7684\u76f4\u7ebf\u4e0a\u7684\u70b9\u90fd\u5728\u8be5\u96c6\u5408\u4e2d\uff0c\u90a3\u4e48\u6211\u4eec\u79f0\u96c6\u5408 C C \u4e3a\u4e00\u4e2a\u4eff\u5c04\u96c6\u3002 \u7ebf\u6027\u65b9\u7a0b \\{x \\mid Ax = b\\} \\{x \\mid Ax = b\\} \u7684\u89e3\u5373\u662f\u4e00\u4e2a\u4eff\u5c04\u96c6\uff0c\u53cd\u8fc7\u6765\u6bcf\u4e00\u4e2a\u4eff\u5c04\u96c6\u4e5f\u90fd\u53ef\u4ee5\u8868\u793a\u4e3a\u4e00\u4e2a\u7ebf\u6027\u65b9\u7a0b\u7cfb\u7edf\u7684\u89e3\u96c6\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u6709\u65f6\u5019\u5c06\u4eff\u5c04\u96c6\u6210\u4e3a\u7ebf\u6027\uff08linear\uff09\u3002 \u6709\u540c\u5b66\u53ef\u4ee5\u53d1\u73b0\uff0c\u4eff\u5c04\u96c6\u4e0e\u7ebf\u6027\u5b50\u7a7a\u95f4\u975e\u5e38\u76f8\u4f3c\u3002\u4e8b\u5b9e\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u4e00\u4e2a\u4eff\u5c04\u96c6\u770b\u4f5c\u662f\u4e00\u4e2a\u7ebf\u6027\u5b50\u7a7a\u95f4\u6839\u636e\u4e00\u4e2a\u56fa\u5b9a\u5411\u91cf\u5e73\u79fb\u800c\u5f97\u5230\u7684\u3002\u5bf9\u4e8e\u4eff\u5c04\u96c6 C C \u4e0e\u5176\u4e0a\u4e00\u70b9 x_0 x_0 \uff0c\u96c6\u5408 V = C - x_0 = \\{x - x_0 \\mid x \\in C\\} V = C - x_0 = \\{x - x_0 \\mid x \\in C\\} \u662f\u4e00\u4e2a\u5b50\u7a7a\u95f4\u3002 \u8bc1\u660e V = C - x_0 V = C - x_0 \u5bf9\u4e8e\u5411\u91cf\u52a0\u6cd5\u4e0e\u6807\u91cf\u4e58\u6cd5\u95ed\u5408 \u5bf9\u4e8e v_1, v_2 \\in V, \\alpha, \\beta \\in \\mathbb{R} v_1, v_2 \\in V, \\alpha, \\beta \\in \\mathbb{R} \uff0c\u6211\u4eec\u6709 v_1 + x_0, v_2 + x_0 \\in C v_1 + x_0, v_2 + x_0 \\in C \uff0c\u6240\u4ee5 \\alpha v_1 + \\beta v_2 + x_0 = \\alpha (v_1 + x_0) + \\beta (v_2 + x_0) + (1 -\\alpha - \\beta) x_0 \\in C \\alpha v_1 + \\beta v_2 + x_0 = \\alpha (v_1 + x_0) + \\beta (v_2 + x_0) + (1 -\\alpha - \\beta) x_0 \\in C \uff0c\u7531\u4e8e C C \u662f\u4eff\u5c04\u96c6\u3001 \\alpha + \\beta + (1 -\\alpha - \\beta) = 1, \\alpha v_1 + \\beta v_2 + x_0 \\in C \\alpha + \\beta + (1 -\\alpha - \\beta) = 1, \\alpha v_1 + \\beta v_2 + x_0 \\in C \uff0c\u6613\u5f97 \\alpha v_1 + \\beta v_2 \\in V \\alpha v_1 + \\beta v_2 \\in V \u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u4eff\u5c04\u96c6 C C \u8868\u8ff0\u4e3a C = V + x_0 = \\{v + x_0 \\mid v \\in V\\} C = V + x_0 = \\{v + x_0 \\mid v \\in V\\} \uff0c x_0 x_0 \u4e3a C C \u4e0a\u4efb\u610f\u4e00\u70b9\u3002\u6211\u4eec\u5c06\u5b50\u7a7a\u95f4 V V \u79f0\u4f5c\u4eff\u5c04\u96c6 C C \u76f8\u5173\u7684\u5b50\u7a7a\u95f4\uff0c\u5c06\u5b50\u7a7a\u95f4 V V \u7684\u7ef4\u5ea6\u79f0\u4f5c\u4eff\u5c04\u96c6 C C \u7684\u7ef4\u5ea6\u3002 \u7b80\u5355\u4e86\u89e3\u4e86\u76f4\u7ebf\u4e0e\u4eff\u5c04\u96c6\u4e4b\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u5ef6\u4f38\u51fa\u4eff\u5c04\u7ec4\u5408\uff1a \u4eff\u5c04\u7ec4\u5408\uff08affine combination\uff09 \u5bf9\u4e8e\u7ebf\u6027\u7ec4\u5408 \\sum_{i=1}^n \\theta_i x_i \\sum_{i=1}^n \\theta_i x_i \uff0c\u82e5\u5176\u6ee1\u8db3 \\sum_{i=1}^n \\theta_i = 1 \\sum_{i=1}^n \\theta_i = 1 \u5219\u6211\u4eec\u79f0\u5176\u4e3a\u4eff\u5c04\u7ec4\u5408\u3002 \u4eff\u5c04\u96c6 C C \u5305\u542b\u4e86\u8be5\u96c6\u5408\u4e2d\u4efb\u610f\u70b9\u7684\u4eff\u5c04\u7ec4\u5408\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u5bf9\u4e8e x_1, x_2, x_n \\in C, \\sum_{i=1}^n \\theta_i = 1 x_1, x_2, x_n \\in C, \\sum_{i=1}^n \\theta_i = 1 \uff0c \\sum_{i=1}^n \\theta_i x_i \\in C \\sum_{i=1}^n \\theta_i x_i \\in C \u3002 \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u4eff\u5c04\u7ec4\u5408\u5176\u5b9e\u53ef\u4ee5\u88ab\u770b\u6210\u4e00\u4e2a\u6240\u6709\u7cfb\u6570\u4e4b\u548c\u4e3a1\u7684\u7279\u6b8a\u7684\u7ebf\u6027\u7ec4\u5408\u3002\u8fd9\u6837\u7684\u7279\u6027\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u629b\u5f03\u539f\u70b9\uff0c\u800c\u5c06\u4efb\u610f\u7684\u70b9\u89c6\u4e3a\u539f\u70b9\uff0c\u6211\u4eec\u90fd\u53ef\u4ee5\u4f7f\u7528\u540c\u6837\u7684\u7ebf\u6027\u7ec4\u5408\u53bb\u63cf\u8ff0\u540c\u4e00\u4e2a\u70b9\u3002 \ud83c\udf30 \u5bf9\u4e8e\u539f\u70b9\u4ee5\u53ca\u7a7a\u95f4\u4e0a\u4efb\u610f\u4e00\u70b9 p p \uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5411\u91cf a,\\ b a,\\ b \u5206\u522b\u8868\u8ff0\u4e3a a + b a + b \u4e0e p + (a - p) + (b - p) p + (a - p) + (b - p) \u3002\u7531\u6b64\uff0c\u6211\u4eec\u901a\u8fc7\u4eff\u5c04\u7ec4\u5408\u53bb\u63cf\u8ff0\u53e6\u4e00\u70b9\u65f6\uff0c\u4e24\u4e2a\u63cf\u8ff0\u5206\u522b\u4e3a \\theta a + (1 - \\theta) b \\theta a + (1 - \\theta) b \u4e0e p + \\theta (a - p) + (1 - \\theta) (b - p) = p + \\theta a - \\theta p + (1 - \\theta) b - (1 - \\theta) p = \\theta a + (1 - \\theta) b p + \\theta (a - p) + (1 - \\theta) (b - p) = p + \\theta a - \\theta p + (1 - \\theta) b - (1 - \\theta) p = \\theta a + (1 - \\theta) b \uff1b\u6211\u4eec\u5f88\u5bb9\u6613\u53d1\u73b0\u4e24\u4e2a\u63cf\u8ff0\u4e0e\u5176\u8d77\u59cb\u70b9\u6ca1\u6709\u5173\u7cfb\u3002 \u96c6\u5408 S S \u7684\u4eff\u5c04\u5305 aff(S) aff(S) \u6307\u7684\u662f\u5305\u542b\u96c6\u5408 S S \u7684\u6700\u5c0f\u4eff\u5c04\u96c6\uff0c\u5b83\u88ab\u5b9a\u4e49\u4e3a: \u4eff\u5c04\u5305\uff08affine hull\uff09 aff(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, x_i \\in S, \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} aff(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, x_i \\in S, \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} \u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u4eff\u5c04\u96c6 C C \u6709 S \\subseteq C S \\subseteq C \uff0c\u90a3\u4e48 aff(S) \\subseteq C aff(S) \\subseteq C \u3002","title":"\u4eff\u5c04"},{"location":"cg/affine_convex/#_2","text":"\u6211\u4eec\u6ce8\u610f\u5230\u5230\u73b0\u5728\u4e3a\u6b62\u6211\u4eec\u4e00\u76f4\u5728\u8ba8\u8bba\u4eff\u5c04\uff0c\u800c\u6ca1\u6709\u8fdb\u5165\u771f\u6b63\u7684\u4e3b\u9898\u2013\u51f8\u3002\u4e8b\u5b9e\u4e0a\uff0c\u6211\u4eec\u5df2\u7ecf\u5dee\u4e0d\u591a\u5b66\u4e60\u4e86\u51f8\u7684\u6240\u6709\u6982\u5ff5\u4e86\u2013\u4ec5\u4ec5\u5c06\u4eff\u5c04\u7684\u76f4\u7ebf\u6362\u6210\u7ebf\u6bb5\uff0c\u6211\u4eec\u5c31\u80fd\u5f97\u5230\u51f8\u3002 \u51f8\u96c6 \u5bf9\u4e8e\u96c6\u5408 C \\subseteq \\mathbb{R} C \\subseteq \\mathbb{R} \uff0c\u82e5\u7ecf\u8fc7\u8be5\u96c6\u5408\u4e0a\u4efb\u610f\u4e24\u70b9 x_1, x_2 \\in C, x_1 \\neq x_2 x_1, x_2 \\in C, x_1 \\neq x_2 \u7684 \u7ebf\u6bb5 \u4e0a\u7684\u70b9\u90fd\u5728\u8be5\u96c6\u5408\u4e2d\uff0c\u90a3\u4e48\u6211\u4eec\u79f0\u96c6\u5408 C C \u4e3a\u4e00\u4e2a\u51f8\u96c6\u3002 \u51f8\u7ec4\u5408\uff08convex combination\uff09 \u5bf9\u4e8e\u7ebf\u6027\u7ec4\u5408 \\sum_{i=1}^n \\theta_i x_i \\sum_{i=1}^n \\theta_i x_i \uff0c\u82e5\u5176\u6ee1\u8db3 \\sum_{i=1}^n \\theta_i = 1 \\sum_{i=1}^n \\theta_i = 1 \u5e76\u4e14 \\forall \\theta_i, \\theta_i \\geq 0 \\forall \\theta_i, \\theta_i \\geq 0 \u5219\u6211\u4eec\u79f0\u5176\u4e3a\u51f8\u7ec4\u5408\u3002 \u51f8\u5305\uff08convex hull\uff09 conv(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, conv(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, x_i \\geq 0 x_i \\geq 0 , \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} , \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} | \u6211\u4eec\u5f88\u5bb9\u6613\u60f3\u5230\uff0c\u5e38\u89c1\u7684\u4e09\u89d2\u5f62\u3001\u65b9\u5f62\u3001\u5706\u5f62\u90fd\u662f\u51f8\u7684\uff1b\u800c\u661f\u5f62\u5219\u662f\u975e\u51f8\u7684\uff0c\u56e0\u4e3a\u4efb\u610f\u4e24\u70b9\u4e4b\u95f4\u5b58\u5728\u6709\u4e9b\u70b9\u4e0d\u5728\u96c6\u5408\u4e4b\u5185\u3002 \u975e\u51f8\u96c6\u4e94\u89d2\u661f\u7684\u51f8\u5305\u662f \u51f8\u96c6\u4e94\u8fb9\u5f62\u3002 \u5982\u4f55\u5224\u65ad\u4e00\u4e2a\u51fd\u6570\u662f\u5426\u662f\u51f8\u7684 \u8fd9\u4e2a\u95ee\u9898\u770b\u4f3c\u5341\u5206\u7b80\u5355\u3002\u6211\u4eec\u53ea\u9700\u8981\u6839\u636e\u51f8\u96c6\u7684\u5b9a\u4e49\uff0c\u9009\u53d6\u96c6\u5408\u4e2d\u7684\u6bcf\u4e00\u4e2a\u70b9\u5bf9\u7136\u540e\u5224\u65ad\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u7ebf\u6bb5\u4e0a\u7684\u70b9\u662f\u5426\u662f\u51f8\u7684\u5373\u53ef\u3002\u5bf9\u4e8e\u4e00\u4e2a\u6709\u7740 n n \u4e2a\u70b9\u7684\u96c6\u5408\uff0c\u4e0a\u8ff0\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4ec5\u4ec5\u4e3a O(n?n) O(n?n) \uff0c\u8fd9\u751a\u81f3\u662f\u4e00\u4e2a\u591a\u9879\u5f0f\u65f6\u95f4\u7684\u7b97\u6cd5\u3002\u4f46\u662f\u8fd9\u660e\u663e\u8fd8\u6709\u5f88\u5927\u7684\u6539\u8fdb\u7a7a\u95f4\u3002 \u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u4ecb\u7ecd\u4fdd\u7559\u51f8\u6027\u7684\u8fd0\u7b97\uff0c\u8fd9\u4e9b\u8fd0\u7b97\u6709\u52a9\u4e8e\u5224\u5b9a\u4e00\u4e2a\u96c6\u5408\u662f\u5426\u51f8\u4ee5\u53ca\u6784\u5efa\u4e00\u4e2a\u51f8\u96c6\u3002","title":"\u51f8"},{"location":"cg/affine_convex/#_3","text":"\u4ea4\u96c6 \u5bf9\u4e8e\u96c6\u5408 S_1, S_2 S_1, S_2 \uff0c\u5982\u679c\u4ed6\u4eec\u662f\u51f8\u96c6\uff0c\u90a3\u4e48 S_1 \\cap S_2 S_1 \\cap S_2 \u4e5f\u662f\u51f8\u96c6\u3002 \u4eff\u5c04\u51fd\u6570 \u5982\u679c\u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m \u662f\u4e00\u4e2a\u653e\u5c04\u51fd\u6570\uff0c\u90a3\u4e48\uff1a f f \u4e0b\u7684\u51f8\u96c6\u7684\u50cf\u4e5f\u662f\u51f8\u7684: S \\subseteq \\mathbb{R}^n \\text{is convex} \\Rightarrow f(S) = \\{f(x) \\mid x \\in S\\} \\text{is convex} S \\subseteq \\mathbb{R}^n \\text{is convex} \\Rightarrow f(S) = \\{f(x) \\mid x \\in S\\} \\text{is convex} f f \u4e0b\u7684\u51f8\u96c6\u7684\u9006\u50cf\u4e5f\u662f\u51f8\u7684: C \\subseteq \\mathbb{R}^m \\text{is convex} \\Rightarrow f^{-1}(C) = \\{x \\mid f(x) \\in C\\} \\text{is convex} C \\subseteq \\mathbb{R}^m \\text{is convex} \\Rightarrow f^{-1}(C) = \\{x \\mid f(x) \\in C\\} \\text{is convex} \u900f\u89c6\u548c\u7ebf\u6027\u5206\u6570\u51fd\u6570 \u900f\u89c6\u51fd\u6570 P: \\mathbb{R}^{n+1} \\rightarrow \\mathbb{R}^n P: \\mathbb{R}^{n+1} \\rightarrow \\mathbb{R}^n \uff1a P(x, t) = x / t, \\quad dom(P) = \\{(x, t) \\mid t > 0\\} P(x, t) = x / t, \\quad dom(P) = \\{(x, t) \\mid t > 0\\} \u7ebf\u6027\u5206\u6570\u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m \uff1a f(x) = \\frac{Ax + b}{c^T + d}, \\quad dom(f) = \\{x \\mid c^Tx + d > 0\\} f(x) = \\frac{Ax + b}{c^T + d}, \\quad dom(f) = \\{x \\mid c^Tx + d > 0\\} \u900f\u89c6\u51fd\u6570\u4e0e\u7ebf\u6027\u5206\u6570\u51fd\u6570\u4e0b\u7684\u51f8\u96c6\u7684\u50cf\u548c\u9006\u50cf\u4e5f\u662f\u51f8\u7684 \u8fd9\u4e9b\u5c5e\u6027\u6269\u5c55\u5230\u65e0\u9650\u4e2a\u96c6\u5408\u7684\u4ea4\u96c6\u4e2d\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c S_\\alpha S_\\alpha \u662f\u51f8\u96c6\u5bf9\u4e8e\u6bcf\u4e00\u4e2a \\alpha \\in A \\alpha \\in A \u90fd\u6210\u7acb\uff0c\u90a3\u4e48 \\cap_{\\alpha \\in A}S_\\alpha \\cap_{\\alpha \\in A}S_\\alpha \u4e5f\u662f\u4e00\u4e2a\u51f8\u96c6\u3002","title":"\u4fdd\u51f8\u8fd0\u7b97"},{"location":"cppcg/CppCoreGuidelines/","text":"C++ Core Guidelines # June 16, 2019 Editors: Bjarne Stroustrup Herb Sutter This is a living document under continuous improvement. Had it been an open-source (code) project, this would have been release 0.8. Copying, use, modification, and creation of derivative works from this project is licensed under an MIT-style license. Contributing to this project requires agreeing to a Contributor License. See the accompanying LICENSE file for details. We make this project available to \u201cfriendly users\u201d to use, copy, modify, and derive from, hoping for constructive input. Comments and suggestions for improvements are most welcome. We plan to modify and extend this document as our understanding improves and the language and the set of available libraries improve. When commenting, please note the introduction that outlines our aims and general approach. The list of contributors is here . Problems: The sets of rules have not been completely checked for completeness, consistency, or enforceability. Triple question marks (???) mark known missing information Update reference sections; many pre-C++11 sources are too old. For a more-or-less up-to-date to-do list see: To-do: Unclassified proto-rules You can read an explanation of the scope and structure of this Guide or just jump straight in: In: Introduction P: Philosophy I: Interfaces F: Functions C: Classes and class hierarchies Enum: Enumerations R: Resource management ES: Expressions and statements Per: Performance CP: Concurrency and parallelism E: Error handling Con: Constants and immutability T: Templates and generic programming CPL: C-style programming SF: Source files SL: The Standard Library Supporting sections: A: Architectural ideas NR: Non-Rules and myths RF: References Pro: Profiles GSL: Guidelines support library NL: Naming and layout rules FAQ: Answers to frequently asked questions Appendix A: Libraries Appendix B: Modernizing code Appendix C: Discussion Appendix D: Supporting tools Glossary To-do: Unclassified proto-rules You can sample rules for specific language features: assignment: regular types \u2013 prefer initialization \u2013 copy \u2013 move \u2013 other operations \u2013 default class : data \u2013 invariant \u2013 members \u2013 helpers \u2013 concrete types \u2013 ctors, =, and dtors \u2013 hierarchy \u2013 operators concept : rules \u2013 in generic programming \u2013 template arguments \u2013 semantics constructor: invariant \u2013 establish invariant \u2013 throw \u2013 default \u2013 not needed \u2013 explicit \u2013 delegating \u2013 virtual derived class : when to use \u2013 as interface \u2013 destructors \u2013 copy \u2013 getters and setters \u2013 multiple inheritance \u2013 overloading \u2013 slicing \u2013 dynamic_cast destructor: and constructors \u2013 when needed? \u2013 may not fail exception: errors \u2013 throw \u2013 for errors only \u2013 noexcept \u2013 minimize try \u2013 what if no exceptions? for : range-for and for \u2013 for and while \u2013 for-initializer \u2013 empty body \u2013 loop variable \u2013 loop variable type ??? function: naming \u2013 single operation \u2013 no throw \u2013 arguments \u2013 argument passing \u2013 multiple return values \u2013 pointers \u2013 lambdas inline : small functions \u2013 in headers initialization: always \u2013 prefer {} \u2013 lambdas \u2013 in-class initializers \u2013 class members \u2013 factory functions lambda expression: when to use operator: conventional \u2013 avoid conversion operators \u2013 and lambdas public , private , and protected : information hiding \u2013 consistency \u2013 protected static_assert : compile-time checking \u2013 and concepts struct : for organizing data \u2013 use if no invariant \u2013 no private members template : abstraction \u2013 containers \u2013 concepts unsigned : and signed \u2013 bit manipulation virtual : interfaces \u2013 not virtual \u2013 destructor \u2013 never fail You can look at design concepts used to express the rules: assertion: ??? error: ??? exception: exception guarantee (???) failure: ??? invariant: ??? leak: ??? library: ??? precondition: ??? postcondition: ??? resource: ??? Abstract # This document is a set of guidelines for using C++ well. The aim of this document is to help people to use modern C++ effectively. By \u201cmodern C++\u201d we mean effective use of the ISO C++ standard (currently C++17, but almost all of our recommendations also apply to C++14 and C++11). In other words, what would you like your code to look like in 5 years\u2019 time, given that you can start now? In 10 years\u2019 time? The guidelines are focused on relatively high-level issues, such as interfaces, resource management, memory management, and concurrency. Such rules affect application architecture and library design. Following the rules will lead to code that is statically type safe, has no resource leaks, and catches many more programming logic errors than is common in code today. And it will run fast \u2013 you can afford to do things right. We are less concerned with low-level issues, such as naming conventions and indentation style. However, no topic that can help a programmer is out of bounds. Our initial set of rules emphasizes safety (of various forms) and simplicity. They may very well be too strict. We expect to have to introduce more exceptions to better accommodate real-world needs. We also need more rules. You will find some of the rules contrary to your expectations or even contrary to your experience. If we haven\u2019t suggested you change your coding style in any way, we have failed! Please try to verify or disprove rules! In particular, we\u2019d really like to have some of our rules backed up with measurements or better examples. You will find some of the rules obvious or even trivial. Please remember that one purpose of a guideline is to help someone who is less experienced or coming from a different background or language to get up to speed. Many of the rules are designed to be supported by an analysis tool. Violations of rules will be flagged with references (or links) to the relevant rule. We do not expect you to memorize all the rules before trying to write code. One way of thinking about these guidelines is as a specification for tools that happens to be readable by humans. The rules are meant for gradual introduction into a code base. We plan to build tools for that and hope others will too. Comments and suggestions for improvements are most welcome. We plan to modify and extend this document as our understanding improves and the language and the set of available libraries improve. In: Introduction # This is a set of core guidelines for modern C++ (currently C++17) taking likely future enhancements and ISO Technical Specifications (TSs) into account. The aim is to help C++ programmers to write simpler, more efficient, more maintainable code. Introduction summary: In.target: Target readership In.aims: Aims In.not: Non-aims In.force: Enforcement In.struct: The structure of this document In.sec: Major sections In.target: Target readership # All C++ programmers. This includes programmers who might consider C . In.aims: Aims # The purpose of this document is to help developers to adopt modern C++ (currently C++17) and to achieve a more uniform style across code bases. We do not suffer the delusion that every one of these rules can be effectively applied to every code base. Upgrading old systems is hard. However, we do believe that a program that uses a rule is less error-prone and more maintainable than one that does not. Often, rules also lead to faster/easier initial development. As far as we can tell, these rules lead to code that performs as well or better than older, more conventional techniques; they are meant to follow the zero-overhead principle (\u201cwhat you don\u2019t use, you don\u2019t pay for\u201d or \u201cwhen you use an abstraction mechanism appropriately, you get at least as good performance as if you had handcoded using lower-level language constructs\u201d). Consider these rules ideals for new code, opportunities to exploit when working on older code, and try to approximate these ideals as closely as feasible. Remember: In.0: Don\u2019t panic! # Take the time to understand the implications of a guideline rule on your program. These guidelines are designed according to the \u201csubset of superset\u201d principle ( Stroustrup05 ). They do not simply define a subset of C++ to be used (for reliability, safety, performance, or whatever). Instead, they strongly recommend the use of a few simple \u201cextensions\u201d ( library components ) that make the use of the most error-prone features of C++ redundant, so that they can be banned (in our set of rules). The rules emphasize static type safety and resource safety. For that reason, they emphasize possibilities for range checking, for avoiding dereferencing nullptr , for avoiding dangling pointers, and the systematic use of exceptions (via RAII). Partly to achieve that and partly to minimize obscure code as a source of errors, the rules also emphasize simplicity and the hiding of necessary complexity behind well-specified interfaces. Many of the rules are prescriptive. We are uncomfortable with rules that simply state \u201cdon\u2019t do that!\u201d without offering an alternative. One consequence of that is that some rules can be supported only by heuristics, rather than precise and mechanically verifiable checks. Other rules articulate general principles. For these more general rules, more detailed and specific rules provide partial checking. These guidelines address the core of C++ and its use. We expect that most large organizations, specific application areas, and even large projects will need further rules, possibly further restrictions, and further library support. For example, hard-real-time programmers typically can\u2019t use free store (dynamic memory) freely and will be restricted in their choice of libraries. We encourage the development of such more specific rules as addenda to these core guidelines. Build your ideal small foundation library and use that, rather than lowering your level of programming to glorified assembly code. The rules are designed to allow gradual adoption . Some rules aim to increase various forms of safety while others aim to reduce the likelihood of accidents, many do both. The guidelines aimed at preventing accidents often ban perfectly legal C++. However, when there are two ways of expressing an idea and one has shown itself a common source of errors and the other has not, we try to guide programmers towards the latter. In.not: Non-aims # The rules are not intended to be minimal or orthogonal. In particular, general rules can be simple, but unenforceable. Also, it is often hard to understand the implications of a general rule. More specialized rules are often easier to understand and to enforce, but without general rules, they would just be a long list of special cases. We provide rules aimed at helping novices as well as rules supporting expert use. Some rules can be completely enforced, but others are based on heuristics. These rules are not meant to be read serially, like a book. You can browse through them using the links. However, their main intended use is to be targets for tools. That is, a tool looks for violations and the tool returns links to violated rules. The rules then provide reasons, examples of potential consequences of the violation, and suggested remedies. These guidelines are not intended to be a substitute for a tutorial treatment of C++. If you need a tutorial for some given level of experience, see the references . This is not a guide on how to convert old C++ code to more modern code. It is meant to articulate ideas for new code in a concrete fashion. However, see the modernization section for some possible approaches to modernizing/rejuvenating/upgrading. Importantly, the rules support gradual adoption: It is typically infeasible to completely convert a large code base all at once. These guidelines are not meant to be complete or exact in every language-technical detail. For the final word on language definition issues, including every exception to general rules and every feature, see the ISO C++ standard. The rules are not intended to force you to write in an impoverished subset of C++. They are emphatically not meant to define a, say, Java-like subset of C++. They are not meant to define a single \u201cone true C++\u201d language. We value expressiveness and uncompromised performance. The rules are not value-neutral. They are meant to make code simpler and more correct/safer than most existing C++ code, without loss of performance. They are meant to inhibit perfectly valid C++ code that correlates with errors, spurious complexity, and poor performance. The rules are not precise to the point where a person (or machine) can follow them blindly. The enforcement parts try to be that, but we would rather leave a rule or a definition a bit vague and open to interpretation than specify something precisely and wrong. Sometimes, precision comes only with time and experience. Design is not (yet) a form of Math. The rules are not perfect. A rule can do harm by prohibiting something that is useful in a given situation. A rule can do harm by failing to prohibit something that enables a serious error in a given situation. A rule can do a lot of harm by being vague, ambiguous, unenforceable, or by enabling every solution to a problem. It is impossible to completely meet the \u201cdo no harm\u201d criteria. Instead, our aim is the less ambitious: \u201cDo the most good for most programmers\u201d; if you cannot live with a rule, object to it, ignore it, but don\u2019t water it down until it becomes meaningless. Also, suggest an improvement. In.force: Enforcement # Rules with no enforcement are unmanageable for large code bases. Enforcement of all rules is possible only for a small weak set of rules or for a specific user community. But we want lots of rules, and we want rules that everybody can use. But different people have different needs. But people don\u2019t like to read lots of rules. But people can\u2019t remember many rules. So, we need subsetting to meet a variety of needs. But arbitrary subsetting leads to chaos. We want guidelines that help a lot of people, make code more uniform, and strongly encourage people to modernize their code. We want to encourage best practices, rather than leave all to individual choices and management pressures. The ideal is to use all rules; that gives the greatest benefits. This adds up to quite a few dilemmas. We try to resolve those using tools. Each rule has an Enforcement section listing ideas for enforcement. Enforcement might be done by code review, by static analysis, by compiler, or by run-time checks. Wherever possible, we prefer \u201cmechanical\u201d checking (humans are slow, inaccurate, and bore easily) and static checking. Run-time checks are suggested only rarely where no alternative exists; we do not want to introduce \u201cdistributed fat\u201d. Where appropriate, we label a rule (in the Enforcement sections) with the name of groups of related rules (called \u201cprofiles\u201d). A rule can be part of several profiles, or none. For a start, we have a few profiles corresponding to common needs (desires, ideals): type : No type violations (reinterpreting a T as a U through casts, unions, or varargs) bounds : No bounds violations (accessing beyond the range of an array) lifetime : No leaks (failing to delete or multiple delete ) and no access to invalid objects (dereferencing nullptr , using a dangling reference). The profiles are intended to be used by tools, but also serve as an aid to the human reader. We do not limit our comment in the Enforcement sections to things we know how to enforce; some comments are mere wishes that might inspire some tool builder. Tools that implement these rules shall respect the following syntax to explicitly suppress a rule: [[gsl::suppress(tag)]] where \u201ctag\u201d is the anchor name of the item where the Enforcement rule appears (e.g., for C.134 it is \u201cRh-public\u201d), the name of a profile group-of-rules (\u201ctype\u201d, \u201cbounds\u201d, or \u201clifetime\u201d), or a specific rule in a profile ( type.4 , or bounds.2 ). In.struct: The structure of this document # Each rule (guideline, suggestion) can have several parts: The rule itself \u2013 e.g., no naked new A rule reference number \u2013 e.g., C.7 (the 7 th rule related to classes). Since the major sections are not inherently ordered, we use letters as the first part of a rule reference \u201cnumber\u201d. We leave gaps in the numbering to minimize \u201cdisruption\u201d when we add or remove rules. **Reason**s (rationales) \u2013 because programmers find it hard to follow rules they don\u2019t understand **Example**s \u2013 because rules are hard to understand in the abstract; can be positive or negative **Alternative**s \u2013 for \u201cdon\u2019t do this\u201d rules **Exception**s \u2013 we prefer simple general rules. However, many rules apply widely, but not universally, so exceptions must be listed Enforcement \u2013 ideas about how the rule might be checked \u201cmechanically\u201d **See also**s \u2013 references to related rules and/or further discussion (in this document or elsewhere) **Note**s (comments) \u2013 something that needs saying that doesn\u2019t fit the other classifications Discussion \u2013 references to more extensive rationale and/or examples placed outside the main lists of rules Some rules are hard to check mechanically, but they all meet the minimal criteria that an expert programmer can spot many violations without too much trouble. We hope that \u201cmechanical\u201d tools will improve with time to approximate what such an expert programmer notices. Also, we assume that the rules will be refined over time to make them more precise and checkable. A rule is aimed at being simple, rather than carefully phrased to mention every alternative and special case. Such information is found in the Alternative paragraphs and the Discussion sections. If you don\u2019t understand a rule or disagree with it, please visit its Discussion . If you feel that a discussion is missing or incomplete, enter an Issue explaining your concerns and possibly a corresponding PR. This is not a language manual. It is meant to be helpful, rather than complete, fully accurate on technical details, or a guide to existing code. Recommended information sources can be found in the references . In.sec: Major sections # In: Introduction P: Philosophy I: Interfaces F: Functions C: Classes and class hierarchies Enum: Enumerations R: Resource management ES: Expressions and statements Per: Performance CP: Concurrency and parallelism E: Error handling Con: Constants and immutability T: Templates and generic programming CPL: C-style programming SF: Source files SL: The Standard Library Supporting sections: A: Architectural ideas NR: Non-Rules and myths RF: References Pro: Profiles GSL: Guidelines support library NL: Naming and layout rules FAQ: Answers to frequently asked questions Appendix A: Libraries Appendix B: Modernizing code Appendix C: Discussion Appendix D: Supporting tools Glossary To-do: Unclassified proto-rules These sections are not orthogonal. Each section (e.g., \u201cP\u201d for \u201cPhilosophy\u201d) and each subsection (e.g., \u201cC.hier\u201d for \u201cClass Hierarchies (OOP)\u201d) have an abbreviation for ease of searching and reference. The main section abbreviations are also used in rule numbers (e.g., \u201cC.11\u201d for \u201cMake concrete types regular\u201d). P: Philosophy # The rules in this section are very general. Philosophy rules summary: P.1: Express ideas directly in code P.2: Write in ISO Standard C++ P.3: Express intent P.4: Ideally, a program should be statically type safe P.5: Prefer compile-time checking to run-time checking P.6: What cannot be checked at compile time should be checkable at run time P.7: Catch run-time errors early P.8: Don\u2019t leak any resources P.9: Don\u2019t waste time or space P.10: Prefer immutable data to mutable data P.11: Encapsulate messy constructs, rather than spreading through the code P.12: Use supporting tools as appropriate P.13: Use support libraries as appropriate Philosophical rules are generally not mechanically checkable. However, individual rules reflecting these philosophical themes are. Without a philosophical basis, the more concrete/specific/checkable rules lack rationale. P.1: Express ideas directly in code # Reason # Compilers don\u2019t read comments (or design documents) and neither do many programmers (consistently). What is expressed in code has defined semantics and can (in principle) be checked by compilers and other tools. Example # class Date { // ... public: Month month() const; // do int month(); // don't // ... }; The first declaration of month is explicit about returning a Month and about not modifying the state of the Date object. The second version leaves the reader guessing and opens more possibilities for uncaught bugs. Example, bad # This loop is a restricted form of std::find : void f(vector<string>& v) { string val; cin >> val; // ... int index = -1; // bad, plus should use gsl::index for (int i = 0; i < v.size(); ++i) { if (v[i] == val) { index = i; break; } } // ... } Example, good # A much clearer expression of intent would be: void f(vector<string>& v) { string val; cin >> val; // ... auto p = find(begin(v), end(v), val); // better // ... } A well-designed library expresses intent (what is to be done, rather than just how something is being done) far better than direct use of language features. A C++ programmer should know the basics of the standard library, and use it where appropriate. Any programmer should know the basics of the foundation libraries of the project being worked on, and use them appropriately. Any programmer using these guidelines should know the guidelines support library , and use it appropriately. Example # change_speed(double s); // bad: what does s signify? // ... change_speed(2.3); A better approach is to be explicit about the meaning of the double (new speed or delta on old speed?) and the unit used: change_speed(Speed s); // better: the meaning of s is specified // ... change_speed(2.3); // error: no unit change_speed(23m / 10s); // meters per second We could have accepted a plain (unit-less) double as a delta, but that would have been error-prone. If we wanted both absolute speed and deltas, we would have defined a Delta type. Enforcement # Very hard in general. use const consistently (check if member functions modify their object; check if functions modify arguments passed by pointer or reference) flag uses of casts (casts neuter the type system) detect code that mimics the standard library (hard) P.2: Write in ISO Standard C++ # Reason # This is a set of guidelines for writing ISO Standard C++. Note # There are environments where extensions are necessary, e.g., to access system resources. In such cases, localize the use of necessary extensions and control their use with non-core Coding Guidelines. If possible, build interfaces that encapsulate the extensions so they can be turned off or compiled away on systems that do not support those extensions. Extensions often do not have rigorously defined semantics. Even extensions that are common and implemented by multiple compilers may have slightly different behaviors and edge case behavior as a direct result of not having a rigorous standard definition. With sufficient use of any such extension, expected portability will be impacted. Note # Using valid ISO C++ does not guarantee portability (let alone correctness). Avoid dependence on undefined behavior (e.g., undefined order of evaluation ) and be aware of constructs with implementation defined meaning (e.g., sizeof(int) ). Note # There are environments where restrictions on use of standard C++ language or library features are necessary, e.g., to avoid dynamic memory allocation as required by aircraft control software standards. In such cases, control their (dis)use with an extension of these Coding Guidelines customized to the specific environment. Enforcement # Use an up-to-date C++ compiler (currently C++17, C++14, or C++11) with a set of options that do not accept extensions. P.3: Express intent # Reason # Unless the intent of some code is stated (e.g., in names or comments), it is impossible to tell whether the code does what it is supposed to do. Example # gsl::index i = 0; while (i < v.size()) { // ... do something with v[i] ... } The intent of \u201cjust\u201d looping over the elements of v is not expressed here. The implementation detail of an index is exposed (so that it might be misused), and i outlives the scope of the loop, which may or may not be intended. The reader cannot know from just this section of code. Better: for (const auto& x : v) { /* do something with the value of x */ } Now, there is no explicit mention of the iteration mechanism, and the loop operates on a reference to const elements so that accidental modification cannot happen. If modification is desired, say so: for (auto& x : v) { /* modify x */ } For more details about for-statements, see ES.71 . Sometimes better still, use a named algorithm. This example uses the for_each from the Ranges TS because it directly expresses the intent: for_each(v, [](int x) { /* do something with the value of x */ }); for_each(par, v, [](int x) { /* do something with the value of x */ }); The last variant makes it clear that we are not interested in the order in which the elements of v are handled. A programmer should be familiar with The guidelines support library The ISO C++ Standard Library Whatever foundation libraries are used for the current project(s) Note # Alternative formulation: Say what should be done, rather than just how it should be done. Note # Some language constructs express intent better than others. Example # If two int s are meant to be the coordinates of a 2D point, say so: draw_line(int, int, int, int); // obscure draw_line(Point, Point); // clearer Enforcement # Look for common patterns for which there are better alternatives simple for loops vs. range- for loops f(T*, int) interfaces vs. f(span<T>) interfaces loop variables in too large a scope naked new and delete functions with many parameters of built-in types There is a huge scope for cleverness and semi-automated program transformation. P.4: Ideally, a program should be statically type safe # Reason # Ideally, a program would be completely statically (compile-time) type safe. Unfortunately, that is not possible. Problem areas: unions casts array decay range errors narrowing conversions Note # These areas are sources of serious problems (e.g., crashes and security violations). We try to provide alternative techniques. Enforcement # We can ban, restrain, or detect the individual problem categories separately, as required and feasible for individual programs. Always suggest an alternative. For example: unions \u2013 use variant (in C++17) casts \u2013 minimize their use; templates can help array decay \u2013 use span (from the GSL) range errors \u2013 use span narrowing conversions \u2013 minimize their use and use narrow or narrow_cast (from the GSL) where they are necessary P.5: Prefer compile-time checking to run-time checking # Reason # Code clarity and performance. You don\u2019t need to write error handlers for errors caught at compile time. Example # // Int is an alias used for integers int bits = 0; // don't: avoidable code for (Int i = 1; i; i <<= 1) ++bits; if (bits < 32) cerr << \"Int too small\\n\"; This example fails to achieve what it is trying to achieve (because overflow is undefined) and should be replaced with a simple static_assert : // Int is an alias used for integers static_assert(sizeof(Int) >= 4); // do: compile-time check Or better still just use the type system and replace Int with int32_t . Example # void read(int* p, int n); // read max n integers into *p int a[100]; read(a, 1000); // bad, off the end better void read(span<int> r); // read into the range of integers r int a[100]; read(a); // better: let the compiler figure out the number of elements Alternative formulation : Don\u2019t postpone to run time what can be done well at compile time. Enforcement # Look for pointer arguments. Look for run-time checks for range violations. P.6: What cannot be checked at compile time should be checkable at run time # Reason # Leaving hard-to-detect errors in a program is asking for crashes and bad results. Note # Ideally, we catch all errors (that are not errors in the programmer\u2019s logic) at either compile time or run time. It is impossible to catch all errors at compile time and often not affordable to catch all remaining errors at run time. However, we should endeavor to write programs that in principle can be checked, given sufficient resources (analysis programs, run-time checks, machine resources, time). Example, bad # // separately compiled, possibly dynamically loaded extern void f(int* p); void g(int n) { // bad: the number of elements is not passed to f() f(new int[n]); } Here, a crucial bit of information (the number of elements) has been so thoroughly \u201cobscured\u201d that static analysis is probably rendered infeasible and dynamic checking can be very difficult when f() is part of an ABI so that we cannot \u201cinstrument\u201d that pointer. We could embed helpful information into the free store, but that requires global changes to a system and maybe to the compiler. What we have here is a design that makes error detection very hard. Example, bad # We can of course pass the number of elements along with the pointer: // separately compiled, possibly dynamically loaded extern void f2(int* p, int n); void g2(int n) { f2(new int[n], m); // bad: a wrong number of elements can be passed to f() } Passing the number of elements as an argument is better (and far more common) than just passing the pointer and relying on some (unstated) convention for knowing or discovering the number of elements. However (as shown), a simple typo can introduce a serious error. The connection between the two arguments of f2() is conventional, rather than explicit. Also, it is implicit that f2() is supposed to delete its argument (or did the caller make a second mistake?). Example, bad # The standard library resource management pointers fail to pass the size when they point to an object: // separately compiled, possibly dynamically loaded // NB: this assumes the calling code is ABI-compatible, using a // compatible C++ compiler and the same stdlib implementation extern void f3(unique_ptr<int[]>, int n); void g3(int n) { f3(make_unique<int[]>(n), m); // bad: pass ownership and size separately } Example # We need to pass the pointer and the number of elements as an integral object: extern void f4(vector<int>&); // separately compiled, possibly dynamically loaded extern void f4(span<int>); // separately compiled, possibly dynamically loaded // NB: this assumes the calling code is ABI-compatible, using a // compatible C++ compiler and the same stdlib implementation void g3(int n) { vector<int> v(n); f4(v); // pass a reference, retain ownership f4(span<int>{v}); // pass a view, retain ownership } This design carries the number of elements along as an integral part of an object, so that errors are unlikely and dynamic (run-time) checking is always feasible, if not always affordable. Example # How do we transfer both ownership and all information needed for validating use? vector<int> f5(int n) // OK: move { vector<int> v(n); // ... initialize v ... return v; } unique_ptr<int[]> f6(int n) // bad: loses n { auto p = make_unique<int[]>(n); // ... initialize *p ... return p; } owner<int*> f7(int n) // bad: loses n and we might forget to delete { owner<int*> p = new int[n]; // ... initialize *p ... return p; } Example # ??? show how possible checks are avoided by interfaces that pass polymorphic base classes around, when they actually know what they need? Or strings as \u201cfree-style\u201d options Enforcement # Flag (pointer, count)-style interfaces (this will flag a lot of examples that can\u2019t be fixed for compatibility reasons) ??? P.7: Catch run-time errors early # Reason # Avoid \u201cmysterious\u201d crashes. Avoid errors leading to (possibly unrecognized) wrong results. Example # void increment1(int* p, int n) // bad: error-prone { for (int i = 0; i < n; ++i) ++p[i]; } void use1(int m) { const int n = 10; int a[n] = {}; // ... increment1(a, m); // maybe typo, maybe m <= n is supposed // but assume that m == 20 // ... } Here we made a small error in use1 that will lead to corrupted data or a crash. The (pointer, count)-style interface leaves increment1() with no realistic way of defending itself against out-of-range errors. If we could check subscripts for out of range access, then the error would not be discovered until p[10] was accessed. We could check earlier and improve the code: void increment2(span<int> p) { for (int& x : p) ++x; } void use2(int m) { const int n = 10; int a[n] = {}; // ... increment2({a, m}); // maybe typo, maybe m <= n is supposed // ... } Now, m <= n can be checked at the point of call (early) rather than later. If all we had was a typo so that we meant to use n as the bound, the code could be further simplified (eliminating the possibility of an error): void use3(int m) { const int n = 10; int a[n] = {}; // ... increment2(a); // the number of elements of a need not be repeated // ... } Example, bad # Don\u2019t repeatedly check the same value. Don\u2019t pass structured data as strings: Date read_date(istream& is); // read date from istream Date extract_date(const string& s); // extract date from string void user1(const string& date) // manipulate date { auto d = extract_date(date); // ... } void user2() { Date d = read_date(cin); // ... user1(d.to_string()); // ... } The date is validated twice (by the Date constructor) and passed as a character string (unstructured data). Example # Excess checking can be costly. There are cases where checking early is dumb because you may not ever need the value, or may only need part of the value that is more easily checked than the whole. Similarly, don\u2019t add validity checks that change the asymptotic behavior of your interface (e.g., don\u2019t add a O(n) check to an interface with an average complexity of O(1) ). class Jet { // Physics says: e * e < x * x + y * y + z * z float x; float y; float z; float e; public: Jet(float x, float y, float z, float e) :x(x), y(y), z(z), e(e) { // Should I check here that the values are physically meaningful? } float m() const { // Should I handle the degenerate case here? return sqrt(x * x + y * y + z * z - e * e); } ??? }; The physical law for a jet ( e * e < x * x + y * y + z * z ) is not an invariant because of the possibility for measurement errors. ??? Enforcement # Look at pointers and arrays: Do range-checking early and not repeatedly Look at conversions: Eliminate or mark narrowing conversions Look for unchecked values coming from input Look for structured data (objects of classes with invariants) being converted into strings ??? P.8: Don\u2019t leak any resources # Reason # Even a slow growth in resources will, over time, exhaust the availability of those resources. This is particularly important for long-running programs, but is an essential piece of responsible programming behavior. Example, bad # void f(char* name) { FILE* input = fopen(name, \"r\"); // ... if (something) return; // bad: if something == true, a file handle is leaked // ... fclose(input); } Prefer RAII : void f(char* name) { ifstream input {name}; // ... if (something) return; // OK: no leak // ... } See also : The resource management section Note # A leak is colloquially \u201canything that isn\u2019t cleaned up.\u201d The more important classification is \u201canything that can no longer be cleaned up.\u201d For example, allocating an object on the heap and then losing the last pointer that points to that allocation. This rule should not be taken as requiring that allocations within long-lived objects must be returned during program shutdown. For example, relying on system guaranteed cleanup such as file closing and memory deallocation upon process shutdown can simplify code. However, relying on abstractions that implicitly clean up can be as simple, and often safer. Note # Enforcing the lifetime safety profile eliminates leaks. When combined with resource safety provided by RAII , it eliminates the need for \u201cgarbage collection\u201d (by generating no garbage). Combine this with enforcement of the type and bounds profiles and you get complete type- and resource-safety, guaranteed by tools. Enforcement # Look at pointers: Classify them into non-owners (the default) and owners. Where feasible, replace owners with standard-library resource handles (as in the example above). Alternatively, mark an owner as such using owner from the GSL . Look for naked new and delete Look for known resource allocating functions returning raw pointers (such as fopen , malloc , and strdup ) P.9: Don\u2019t waste time or space # Reason # This is C++. Note # Time and space that you spend well to achieve a goal (e.g., speed of development, resource safety, or simplification of testing) is not wasted. \u201cAnother benefit of striving for efficiency is that the process forces you to understand the problem in more depth.\u201d - Alex Stepanov Example, bad # struct X { char ch; int i; string s; char ch2; X& operator=(const X& a); X(const X&); }; X waste(const char* p) { if (!p) throw Nullptr_error{}; int n = strlen(p); auto buf = new char[n]; if (!buf) throw Allocation_error{}; for (int i = 0; i < n; ++i) buf[i] = p[i]; // ... manipulate buffer ... X x; x.ch = 'a'; x.s = string(n); // give x.s space for *p for (gsl::index i = 0; i < x.s.size(); ++i) x.s[i] = buf[i]; // copy buf into x.s delete[] buf; return x; } void driver() { X x = waste(\"Typical argument\"); // ... } Yes, this is a caricature, but we have seen every individual mistake in production code, and worse. Note that the layout of X guarantees that at least 6 bytes (and most likely more) are wasted. The spurious definition of copy operations disables move semantics so that the return operation is slow (please note that the Return Value Optimization, RVO, is not guaranteed here). The use of new and delete for buf is redundant; if we really needed a local string, we should use a local string . There are several more performance bugs and gratuitous complication. Example, bad # void lower(zstring s) { for (int i = 0; i < strlen(s); ++i) s[i] = tolower(s[i]); } This is actually an example from production code. We can see that in our condition we have i < strlen(s) . This expression will be evaluated on every iteration of the loop, which means that strlen must walk through string every loop to discover its length. While the string contents are changing, it\u2019s assumed that toLower will not affect the length of the string, so it\u2019s better to cache the length outside the loop and not incur that cost each iteration. Note # An individual example of waste is rarely significant, and where it is significant, it is typically easily eliminated by an expert. However, waste spread liberally across a code base can easily be significant and experts are not always as available as we would like. The aim of this rule (and the more specific rules that support it) is to eliminate most waste related to the use of C++ before it happens. After that, we can look at waste related to algorithms and requirements, but that is beyond the scope of these guidelines. Enforcement # Many more specific rules aim at the overall goals of simplicity and elimination of gratuitous waste. Flag an unused return value from a user-defined non-defaulted postfix operator++ or operator-- function. Prefer using the prefix form instead. (Note: \u201cUser-defined non-defaulted\u201d is intended to reduce noise. Review this enforcement if it\u2019s still too noisy in practice.) P.10: Prefer immutable data to mutable data # Reason # It is easier to reason about constants than about variables. Something immutable cannot change unexpectedly. Sometimes immutability enables better optimization. You can\u2019t have a data race on a constant. See Con: Constants and immutability P.11: Encapsulate messy constructs, rather than spreading through the code # Reason # Messy code is more likely to hide bugs and harder to write. A good interface is easier and safer to use. Messy, low-level code breeds more such code. Example # int sz = 100; int* p = (int*) malloc(sizeof(int) * sz); int count = 0; // ... for (;;) { // ... read an int into x, exit loop if end of file is reached ... // ... check that x is valid ... if (count == sz) p = (int*) realloc(p, sizeof(int) * sz * 2); p[count++] = x; // ... } This is low-level, verbose, and error-prone. For example, we \u201cforgot\u201d to test for memory exhaustion. Instead, we could use vector : vector<int> v; v.reserve(100); // ... for (int x; cin >> x; ) { // ... check that x is valid ... v.push_back(x); } Note # The standards library and the GSL are examples of this philosophy. For example, instead of messing with the arrays, unions, cast, tricky lifetime issues, gsl::owner , etc., that are needed to implement key abstractions, such as vector , span , lock_guard , and future , we use the libraries designed and implemented by people with more time and expertise than we usually have. Similarly, we can and should design and implement more specialized libraries, rather than leaving the users (often ourselves) with the challenge of repeatedly getting low-level code well. This is a variant of the subset of superset principle that underlies these guidelines. Enforcement # Look for \u201cmessy code\u201d such as complex pointer manipulation and casting outside the implementation of abstractions. P.12: Use supporting tools as appropriate # Reason # There are many things that are done better \u201cby machine\u201d. Computers don\u2019t tire or get bored by repetitive tasks. We typically have better things to do than repeatedly do routine tasks. Example # Run a static analyzer to verify that your code follows the guidelines you want it to follow. Note # See Static analysis tools Concurrency tools Testing tools There are many other kinds of tools, such as source code repositories, build tools, etc., but those are beyond the scope of these guidelines. Note # Be careful not to become dependent on over-elaborate or over-specialized tool chains. Those can make your otherwise portable code non-portable. P.13: Use support libraries as appropriate # Reason # Using a well-designed, well-documented, and well-supported library saves time and effort; its quality and documentation are likely to be greater than what you could do if the majority of your time must be spent on an implementation. The cost (time, effort, money, etc.) of a library can be shared over many users. A widely used library is more likely to be kept up-to-date and ported to new systems than an individual application. Knowledge of a widely-used library can save time on other/future projects. So, if a suitable library exists for your application domain, use it. Example # std::sort(begin(v), end(v), std::greater<>()); Unless you are an expert in sorting algorithms and have plenty of time, this is more likely to be correct and to run faster than anything you write for a specific application. You need a reason not to use the standard library (or whatever foundational libraries your application uses) rather than a reason to use it. Note # By default use The ISO C++ Standard Library The Guidelines Support Library Note # If no well-designed, well-documented, and well-supported library exists for an important domain, maybe you should design and implement it, and then use it. I: Interfaces # An interface is a contract between two parts of a program. Precisely stating what is expected of a supplier of a service and a user of that service is essential. Having good (easy-to-understand, encouraging efficient use, not error-prone, supporting testing, etc.) interfaces is probably the most important single aspect of code organization. Interface rule summary: I.1: Make interfaces explicit I.2: Avoid non- const global variables I.3: Avoid singletons I.4: Make interfaces precisely and strongly typed I.5: State preconditions (if any) I.6: Prefer Expects() for expressing preconditions I.7: State postconditions I.8: Prefer Ensures() for expressing postconditions I.9: If an interface is a template, document its parameters using concepts I.10: Use exceptions to signal a failure to perform a required task I.11: Never transfer ownership by a raw pointer ( T* ) or reference ( T& ) I.12: Declare a pointer that must not be null as not_null I.13: Do not pass an array as a single pointer I.22: Avoid complex initialization of global objects I.23: Keep the number of function arguments low I.24: Avoid adjacent unrelated parameters of the same type I.25: Prefer abstract classes as interfaces to class hierarchies I.26: If you want a cross-compiler ABI, use a C-style subset I.27: For stable library ABI, consider the Pimpl idiom I.30: Encapsulate rule violations See also : F: Functions C.concrete: Concrete types C.hier: Class hierarchies C.over: Overloading and overloaded operators C.con: Containers and other resource handles E: Error handling T: Templates and generic programming I.1: Make interfaces explicit # Reason # Correctness. Assumptions not stated in an interface are easily overlooked and hard to test. Example, bad # Controlling the behavior of a function through a global (namespace scope) variable (a call mode) is implicit and potentially confusing. For example: int round(double d) { return (round_up) ? ceil(d) : d; // don't: \"invisible\" dependency } It will not be obvious to a caller that the meaning of two calls of round(7.2) might give different results. Exception # Sometimes we control the details of a set of operations by an environment variable, e.g., normal vs. verbose output or debug vs. optimized. The use of a non-local control is potentially confusing, but controls only implementation details of otherwise fixed semantics. Example, bad # Reporting through non-local variables (e.g., errno ) is easily ignored. For example: // don't: no test of printf's return value fprintf(connection, \"logging: %d %d %d\\n\", x, y, s); What if the connection goes down so that no logging output is produced? See I.???. Alternative : Throw an exception. An exception cannot be ignored. Alternative formulation : Avoid passing information across an interface through non-local or implicit state. Note that non- const member functions pass information to other member functions through their object\u2019s state. Alternative formulation : An interface should be a function or a set of functions. Functions can be template functions and sets of functions can be classes or class templates. Enforcement # (Simple) A function should not make control-flow decisions based on the values of variables declared at namespace scope. (Simple) A function should not write to variables declared at namespace scope. I.2: Avoid non- const global variables # Reason # Non- const global variables hide dependencies and make the dependencies subject to unpredictable changes. Example # struct Data { // ... lots of stuff ... } data; // non-const data void compute() // don't { // ... use data ... } void output() // don't { // ... use data ... } Who else might modify data ? Note # Global constants are useful. Note # The rule against global variables applies to namespace scope variables as well. Alternative : If you use global (more generally namespace scope) data to avoid copying, consider passing the data as an object by reference to const . Another solution is to define the data as the state of some object and the operations as member functions. Warning : Beware of data races: If one thread can access nonlocal data (or data passed by reference) while another thread executes the callee, we can have a data race. Every pointer or reference to mutable data is a potential data race. Note # You cannot have a race condition on immutable data. References : See the rules for calling functions . Note # The rule is \u201cavoid\u201d, not \u201cdon\u2019t use.\u201d Of course there will be (rare) exceptions, such as cin , cout , and cerr . Enforcement # (Simple) Report all non- const variables declared at namespace scope. I.3: Avoid singletons # Reason # Singletons are basically complicated global objects in disguise. Example # class Singleton { // ... lots of stuff to ensure that only one Singleton object is created, // that it is initialized properly, etc. }; There are many variants of the singleton idea. That\u2019s part of the problem. Note # If you don\u2019t want a global object to change, declare it const or constexpr . Exception # You can use the simplest \u201csingleton\u201d (so simple that it is often not considered a singleton) to get initialization on first use, if any: X& myX() { static X my_x {3}; return my_x; } This is one of the most effective solutions to problems related to initialization order. In a multi-threaded environment, the initialization of the static object does not introduce a race condition (unless you carelessly access a shared object from within its constructor). Note that the initialization of a local static does not imply a race condition. However, if the destruction of X involves an operation that needs to be synchronized we must use a less simple solution. For example: X& myX() { static auto p = new X {3}; return *p; // potential leak } Now someone must delete that object in some suitably thread-safe way. That\u2019s error-prone, so we don\u2019t use that technique unless myX is in multi-threaded code, that X object needs to be destroyed (e.g., because it releases a resource), and X \u2018s destructor\u2019s code needs to be synchronized. If you, as many do, define a singleton as a class for which only one object is created, functions like myX are not singletons, and this useful technique is not an exception to the no-singleton rule. Enforcement # Very hard in general. Look for classes with names that include singleton . Look for classes for which only a single object is created (by counting objects or by examining constructors). If a class X has a public static function that contains a function-local static of the class\u2019 type X and returns a pointer or reference to it, ban that. I.4: Make interfaces precisely and strongly typed # Reason # Types are the simplest and best documentation, improve legibility due to their well-defined meaning, and are checked at compile time. Also, precisely typed code is often optimized better. Example, don\u2019t # Consider: void pass(void* data); // weak and under qualified type void* is suspicious Callers are unsure what types are allowed and if the data may be mutated as const is not specified. Note all pointer types implicitly convert to void*, so it is easy for callers to provide this value. The callee must static_cast data to an unverified type to use it. That is error-prone and verbose. Only use const void* for passing in data in designs that are indescribable in C++. Consider using a variant or a pointer to base instead. Alternative : Often, a template parameter can eliminate the void* turning it into a T* or T& . For generic code these T s can be general or concept constrained template parameters. Example, bad # Consider: draw_rect(100, 200, 100, 500); // what do the numbers specify? draw_rect(p.x, p.y, 10, 20); // what units are 10 and 20 in? It is clear that the caller is describing a rectangle, but it is unclear what parts they relate to. Also, an int can carry arbitrary forms of information, including values of many units, so we must guess about the meaning of the four int s. Most likely, the first two are an x , y coordinate pair, but what are the last two? Comments and parameter names can help, but we could be explicit: void draw_rectangle(Point top_left, Point bottom_right); void draw_rectangle(Point top_left, Size height_width); draw_rectangle(p, Point{10, 20}); // two corners draw_rectangle(p, Size{10, 20}); // one corner and a (height, width) pair Obviously, we cannot catch all errors through the static type system (e.g., the fact that a first argument is supposed to be a top-left point is left to convention (naming and comments)). Example, bad # Consider: set_settings(true, false, 42); // what do the numbers specify? The parameter types and their values do not communicate what settings are being specified or what those values mean. This design is more explicit, safe and legible: alarm_settings s{}; s.enabled = true; s.displayMode = alarm_settings::mode::spinning_light; s.frequency = alarm_settings::every_10_seconds; set_settings(s); For the case of a set of boolean values consider using a flags enum; a pattern that expresses a set of boolean values. enable_lamp_options(lamp_option::on | lamp_option::animate_state_transitions); Example, bad # In the following example, it is not clear from the interface what time_to_blink means: Seconds? Milliseconds? void blink_led(int time_to_blink) // bad -- the unit is ambiguous { // ... // do something with time_to_blink // ... } void use() { blink_led(2); } Example, good # std::chrono::duration types (C++11) helps making the unit of time duration explicit. void blink_led(milliseconds time_to_blink) // good -- the unit is explicit { // ... // do something with time_to_blink // ... } void use() { blink_led(1500ms); } The function can also be written in such a way that it will accept any time duration unit. template<class rep, class period> void blink_led(duration<rep, period> time_to_blink) // good -- accepts any unit { // assuming that millisecond is the smallest relevant unit auto milliseconds_to_blink = duration_cast<milliseconds>(time_to_blink); // ... // do something with milliseconds_to_blink // ... } void use() { blink_led(2s); blink_led(1500ms); } Enforcement # (Simple) Report the use of void* as a parameter or return type. (Simple) Report the use of more than one bool parameter. (Hard to do well) Look for functions that use too many primitive type arguments. I.5: State preconditions (if any) # Reason # Arguments have meaning that may constrain their proper use in the callee. Example # Consider: double sqrt(double x); Here x must be nonnegative. The type system cannot (easily and naturally) express that, so we must use other means. For example: double sqrt(double x); // x must be nonnegative Some preconditions can be expressed as assertions. For example: double sqrt(double x) { Expects(x >= 0); /* ... */ } Ideally, that Expects(x >= 0) should be part of the interface of sqrt() but that\u2019s not easily done. For now, we place it in the definition (function body). References : Expects() is described in GSL . Note # Prefer a formal specification of requirements, such as Expects(p); . If that is infeasible, use English text in comments, such as // the sequence [p:q) is ordered using < . Note # Most member functions have as a precondition that some class invariant holds. That invariant is established by a constructor and must be reestablished upon exit by every member function called from outside the class. We don\u2019t need to mention it for each member function. Enforcement # (Not enforceable) See also : The rules for passing pointers. ??? I.6: Prefer Expects() for expressing preconditions # Reason # To make it clear that the condition is a precondition and to enable tool use. Example # int area(int height, int width) { Expects(height > 0 && width > 0); // good if (height <= 0 || width <= 0) my_error(); // obscure // ... } Note # Preconditions can be stated in many ways, including comments, if -statements, and assert() . This can make them hard to distinguish from ordinary code, hard to update, hard to manipulate by tools, and may have the wrong semantics (do you always want to abort in debug mode and check nothing in productions runs?). Note # Preconditions should be part of the interface rather than part of the implementation, but we don\u2019t yet have the language facilities to do that. Once language support becomes available (e.g., see the contract proposal ) we will adopt the standard version of preconditions, postconditions, and assertions. Note # Expects() can also be used to check a condition in the middle of an algorithm. Note # No, using unsigned is not a good way to sidestep the problem of ensuring that a value is nonnegative . Enforcement # (Not enforceable) Finding the variety of ways preconditions can be asserted is not feasible. Warning about those that can be easily identified ( assert() ) has questionable value in the absence of a language facility. I.7: State postconditions # Reason # To detect misunderstandings about the result and possibly catch erroneous implementations. Example, bad # Consider: int area(int height, int width) { return height * width; } // bad Here, we (incautiously) left out the precondition specification, so it is not explicit that height and width must be positive. We also left out the postcondition specification, so it is not obvious that the algorithm ( height * width ) is wrong for areas larger than the largest integer. Overflow can happen. Consider using: int area(int height, int width) { auto res = height * width; Ensures(res > 0); return res; } Example, bad # Consider a famous security bug: void f() // problematic { char buffer[MAX]; // ... memset(buffer, 0, sizeof(buffer)); } There was no postcondition stating that the buffer should be cleared and the optimizer eliminated the apparently redundant memset() call: void f() // better { char buffer[MAX]; // ... memset(buffer, 0, sizeof(buffer)); Ensures(buffer[0] == 0); } Note # Postconditions are often informally stated in a comment that states the purpose of a function; Ensures() can be used to make this more systematic, visible, and checkable. Note # Postconditions are especially important when they relate to something that is not directly reflected in a returned result, such as a state of a data structure used. Example # Consider a function that manipulates a Record , using a mutex to avoid race conditions: mutex m; void manipulate(Record& r) // don't { m.lock(); // ... no m.unlock() ... } Here, we \u201cforgot\u201d to state that the mutex should be released, so we don\u2019t know if the failure to ensure release of the mutex was a bug or a feature. Stating the postcondition would have made it clear: void manipulate(Record& r) // postcondition: m is unlocked upon exit { m.lock(); // ... no m.unlock() ... } The bug is now obvious (but only to a human reading comments). Better still, use RAII to ensure that the postcondition (\u201cthe lock must be released\u201d) is enforced in code: void manipulate(Record& r) // best { lock_guard<mutex> _ {m}; // ... } Note # Ideally, postconditions are stated in the interface/declaration so that users can easily see them. Only postconditions related to the users can be stated in the interface. Postconditions related only to internal state belongs in the definition/implementation. Enforcement # (Not enforceable) This is a philosophical guideline that is infeasible to check directly in the general case. Domain specific checkers (like lock-holding checkers) exist for many toolchains. I.8: Prefer Ensures() for expressing postconditions # Reason # To make it clear that the condition is a postcondition and to enable tool use. Example # void f() { char buffer[MAX]; // ... memset(buffer, 0, MAX); Ensures(buffer[0] == 0); } Note # Postconditions can be stated in many ways, including comments, if -statements, and assert() . This can make them hard to distinguish from ordinary code, hard to update, hard to manipulate by tools, and may have the wrong semantics. Alternative : Postconditions of the form \u201cthis resource must be released\u201d are best expressed by RAII . Note # Ideally, that Ensures should be part of the interface, but that\u2019s not easily done. For now, we place it in the definition (function body). Once language support becomes available (e.g., see the contract proposal ) we will adopt the standard version of preconditions, postconditions, and assertions. Enforcement # (Not enforceable) Finding the variety of ways postconditions can be asserted is not feasible. Warning about those that can be easily identified ( assert() ) has questionable value in the absence of a language facility. I.9: If an interface is a template, document its parameters using concepts # Reason # Make the interface precisely specified and compile-time checkable in the (not so distant) future. Example # Use the ISO Concepts TS style of requirements specification. For example: template<typename Iter, typename Val> // requires InputIterator<Iter> && EqualityComparable<ValueType<Iter>>, Val> Iter find(Iter first, Iter last, Val v) { // ... } Note # Soon (maybe in 2018), most compilers will be able to check requires clauses once the // is removed. Concepts are supported in GCC 6.1 and later. See also : Generic programming and concepts . Enforcement # (Not yet enforceable) A language facility is under specification. When the language facility is available, warn if any non-variadic template parameter is not constrained by a concept (in its declaration or mentioned in a requires clause). I.10: Use exceptions to signal a failure to perform a required task # Reason # It should not be possible to ignore an error because that could leave the system or a computation in an undefined (or unexpected) state. This is a major source of errors. Example # int printf(const char* ...); // bad: return negative number if output fails template <class F, class ...Args> // good: throw system_error if unable to start the new thread explicit thread(F&& f, Args&&... args); Note # What is an error? An error means that the function cannot achieve its advertised purpose (including establishing postconditions). Calling code that ignores an error could lead to wrong results or undefined systems state. For example, not being able to connect to a remote server is not by itself an error: the server can refuse a connection for all kinds of reasons, so the natural thing is to return a result that the caller should always check. However, if failing to make a connection is considered an error, then a failure should throw an exception. Exception # Many traditional interface functions (e.g., UNIX signal handlers) use error codes (e.g., errno ) to report what are really status codes, rather than errors. You don\u2019t have a good alternative to using such, so calling these does not violate the rule. Alternative # If you can\u2019t use exceptions (e.g., because your code is full of old-style raw-pointer use or because there are hard-real-time constraints), consider using a style that returns a pair of values: int val; int error_code; tie(val, error_code) = do_something(); if (error_code) { // ... handle the error or exit ... } // ... use val ... This style unfortunately leads to uninitialized variables. Since C++17 the \u201cstructured bindings\u201d feature can be used to initialize variables directly from the return value: auto [val, error_code] = do_something(); if (error_code) { // ... handle the error or exit ... } // ... use val ... Note # We don\u2019t consider \u201cperformance\u201d a valid reason not to use exceptions. Often, explicit error checking and handling consume as much time and space as exception handling. Often, cleaner code yields better performance with exceptions (simplifying the tracing of paths through the program and their optimization). A good rule for performance critical code is to move checking outside the critical part of the code ( checking ). In the longer term, more regular code gets better optimized. Always carefully measure before making performance claims. See also : I.5 and I.7 for reporting precondition and postcondition violations. Enforcement # (Not enforceable) This is a philosophical guideline that is infeasible to check directly. Look for errno . I.11: Never transfer ownership by a raw pointer ( T* ) or reference ( T& ) # Reason # If there is any doubt whether the caller or the callee owns an object, leaks or premature destruction will occur. Example # Consider: X* compute(args) // don't { X* res = new X{}; // ... return res; } Who deletes the returned X ? The problem would be harder to spot if compute returned a reference. Consider returning the result by value (use move semantics if the result is large): vector<double> compute(args) // good { vector<double> res(10000); // ... return res; } Alternative : Pass ownership using a \u201csmart pointer\u201d, such as unique_ptr (for exclusive ownership) and shared_ptr (for shared ownership). However, that is less elegant and often less efficient than returning the object itself, so use smart pointers only if reference semantics are needed. Alternative : Sometimes older code can\u2019t be modified because of ABI compatibility requirements or lack of resources. In that case, mark owning pointers using owner from the guidelines support library : owner<X*> compute(args) // It is now clear that ownership is transferred { owner<X*> res = new X{}; // ... return res; } This tells analysis tools that res is an owner. That is, its value must be delete d or transferred to another owner, as is done here by the return . owner is used similarly in the implementation of resource handles. Note # Every object passed as a raw pointer (or iterator) is assumed to be owned by the caller, so that its lifetime is handled by the caller. Viewed another way: ownership transferring APIs are relatively rare compared to pointer-passing APIs, so the default is \u201cno ownership transfer.\u201d See also : Argument passing , use of smart pointer arguments , and value return . Enforcement # (Simple) Warn on delete of a raw pointer that is not an owner<T> . Suggest use of standard-library resource handle or use of owner<T> . (Simple) Warn on failure to either reset or explicitly delete an owner pointer on every code path. (Simple) Warn if the return value of new or a function call with an owner return value is assigned to a raw pointer or non- owner reference. I.12: Declare a pointer that must not be null as not_null # Reason # To help avoid dereferencing nullptr errors. To improve performance by avoiding redundant checks for nullptr . Example # int length(const char* p); // it is not clear whether length(nullptr) is valid length(nullptr); // OK? int length(not_null<const char*> p); // better: we can assume that p cannot be nullptr int length(const char* p); // we must assume that p can be nullptr By stating the intent in source, implementers and tools can provide better diagnostics, such as finding some classes of errors through static analysis, and perform optimizations, such as removing branches and null tests. Note # not_null is defined in the guidelines support library . Note # The assumption that the pointer to char pointed to a C-style string (a zero-terminated string of characters) was still implicit, and a potential source of confusion and errors. Use czstring in preference to const char* . // we can assume that p cannot be nullptr // we can assume that p points to a zero-terminated array of characters int length(not_null<zstring> p); Note: length() is, of course, std::strlen() in disguise. Enforcement # (Simple) ((Foundation)) If a function checks a pointer parameter against nullptr before access, on all control-flow paths, then warn it should be declared not_null . (Complex) If a function with pointer return value ensures it is not nullptr on all return paths, then warn the return type should be declared not_null . I.13: Do not pass an array as a single pointer # Reason # (pointer, size)-style interfaces are error-prone. Also, a plain pointer (to array) must rely on some convention to allow the callee to determine the size. Example # Consider: void copy_n(const T* p, T* q, int n); // copy from [p:p+n) to [q:q+n) What if there are fewer than n elements in the array pointed to by q ? Then, we overwrite some probably unrelated memory. What if there are fewer than n elements in the array pointed to by p ? Then, we read some probably unrelated memory. Either is undefined behavior and a potentially very nasty bug. Alternative # Consider using explicit spans: void copy(span<const T> r, span<T> r2); // copy r to r2 Example, bad # Consider: void draw(Shape* p, int n); // poor interface; poor code Circle arr[10]; // ... draw(arr, 10); Passing 10 as the n argument may be a mistake: the most common convention is to assume [0:n) but that is nowhere stated. Worse is that the call of draw() compiled at all: there was an implicit conversion from array to pointer (array decay) and then another implicit conversion from Circle to Shape . There is no way that draw() can safely iterate through that array: it has no way of knowing the size of the elements. Alternative : Use a support class that ensures that the number of elements is correct and prevents dangerous implicit conversions. For example: void draw2(span<Circle>); Circle arr[10]; // ... draw2(span<Circle>(arr)); // deduce the number of elements draw2(arr); // deduce the element type and array size void draw3(span<Shape>); draw3(arr); // error: cannot convert Circle[10] to span<Shape> This draw2() passes the same amount of information to draw() , but makes the fact that it is supposed to be a range of Circle s explicit. See ???. Exception # Use zstring and czstring to represent C-style, zero-terminated strings. But when doing so, use std::string_view or string_span from the GSL to prevent range errors. Enforcement # (Simple) ((Bounds)) Warn for any expression that would rely on implicit conversion of an array type to a pointer type. Allow exception for zstring/czstring pointer types. (Simple) ((Bounds)) Warn for any arithmetic operation on an expression of pointer type that results in a value of pointer type. Allow exception for zstring/czstring pointer types. I.22: Avoid complex initialization of global objects # Reason # Complex initialization can lead to undefined order of execution. Example # // file1.c extern const X x; const Y y = f(x); // read x; write y // file2.c extern const Y y; const X x = g(y); // read y; write x Since x and y are in different translation units the order of calls to f() and g() is undefined; one will access an uninitialized const . This shows that the order-of-initialization problem for global (namespace scope) objects is not limited to global variables . Note # Order of initialization problems become particularly difficult to handle in concurrent code. It is usually best to avoid global (namespace scope) objects altogether. Enforcement # Flag initializers of globals that call non- constexpr functions Flag initializers of globals that access extern objects I.23: Keep the number of function arguments low # Reason # Having many arguments opens opportunities for confusion. Passing lots of arguments is often costly compared to alternatives. Discussion # The two most common reasons why functions have too many parameters are: Missing an abstraction. There is an abstraction missing, so that a compound value is being passed as individual elements instead of as a single object that enforces an invariant. This not only expands the parameter list, but it leads to errors because the component values are no longer protected by an enforced invariant. Violating \u201cone function, one responsibility.\u201d The function is trying to do more than one job and should probably be refactored. Example # The standard-library merge() is at the limit of what we can comfortably handle: template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare> OutputIterator merge(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp); Note that this is because of problem 1 above \u2013 missing abstraction. Instead of passing a range (abstraction), STL passed iterator pairs (unencapsulated component values). Here, we have four template arguments and six function arguments. To simplify the most frequent and simplest uses, the comparison argument can be defaulted to < : template<class InputIterator1, class InputIterator2, class OutputIterator> OutputIterator merge(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result); This doesn\u2019t reduce the total complexity, but it reduces the surface complexity presented to many users. To really reduce the number of arguments, we need to bundle the arguments into higher-level abstractions: template<class InputRange1, class InputRange2, class OutputIterator> OutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result); Grouping arguments into \u201cbundles\u201d is a general technique to reduce the number of arguments and to increase the opportunities for checking. Alternatively, we could use concepts (as defined by the ISO TS) to define the notion of three types that must be usable for merging: Mergeable{In1, In2, Out} OutputIterator merge(In1 r1, In2 r2, Out result); Example # The safety Profiles recommend replacing void f(int* some_ints, int some_ints_length); // BAD: C style, unsafe with void f(gsl::span<int> some_ints); // GOOD: safe, bounds-checked Here, using an abstraction has safety and robustness benefits, and naturally also reduces the number of parameters. Note # How many parameters are too many? Try to use fewer than four (4) parameters. There are functions that are best expressed with four individual parameters, but not many. Alternative : Use better abstraction: Group arguments into meaningful objects and pass the objects (by value or by reference). Alternative : Use default arguments or overloads to allow the most common forms of calls to be done with fewer arguments. Enforcement # Warn when a function declares two iterators (including pointers) of the same type instead of a range or a view. (Not enforceable) This is a philosophical guideline that is infeasible to check directly. I.24: Avoid adjacent unrelated parameters of the same type # Reason # Adjacent arguments of the same type are easily swapped by mistake. Example, bad # Consider: void copy_n(T* p, T* q, int n); // copy from [p:p + n) to [q:q + n) This is a nasty variant of a K&R C-style interface. It is easy to reverse the \u201cto\u201d and \u201cfrom\u201d arguments. Use const for the \u201cfrom\u201d argument: void copy_n(const T* p, T* q, int n); // copy from [p:p + n) to [q:q + n) Exception # If the order of the parameters is not important, there is no problem: int max(int a, int b); Alternative # Don\u2019t pass arrays as pointers, pass an object representing a range (e.g., a span ): void copy_n(span<const T> p, span<T> q); // copy from p to q Alternative # Define a struct as the parameter type and name the fields for those parameters accordingly: struct SystemParams { string config_file; string output_path; seconds timeout; }; void initialize(SystemParams p); This tends to make invocations of this clear to future readers, as the parameters are often filled in by name at the call site. Enforcement # (Simple) Warn if two consecutive parameters share the same type. I.25: Prefer abstract classes as interfaces to class hierarchies # Reason # Abstract classes are more likely to be stable than base classes with state. Example, bad # You just knew that Shape would turn up somewhere :-) class Shape { // bad: interface class loaded with data public: Point center() const { return c; } virtual void draw() const; virtual void rotate(int); // ... private: Point c; vector<Point> outline; Color col; }; This will force every derived class to compute a center \u2013 even if that\u2019s non-trivial and the center is never used. Similarly, not every Shape has a Color , and many Shape s are best represented without an outline defined as a sequence of Point s. Abstract classes were invented to discourage users from writing such classes: class Shape { // better: Shape is a pure interface public: virtual Point center() const = 0; // pure virtual functions virtual void draw() const = 0; virtual void rotate(int) = 0; // ... // ... no data members ... // ... virtual ~Shape() = default; }; Enforcement # (Simple) Warn if a pointer/reference to a class C is assigned to a pointer/reference to a base of C and the base class contains data members. I.26: If you want a cross-compiler ABI, use a C-style subset # Reason # Different compilers implement different binary layouts for classes, exception handling, function names, and other implementation details. Exception # Common ABIs are emerging on some platforms freeing you from the more draconian restrictions. Note # If you use a single compiler, you can use full C++ in interfaces. That may require recompilation after an upgrade to a new compiler version. Enforcement # (Not enforceable) It is difficult to reliably identify where an interface forms part of an ABI. I.27: For stable library ABI, consider the Pimpl idiom # Reason # Because private data members participate in class layout and private member functions participate in overload resolution, changes to those implementation details require recompilation of all users of a class that uses them. A non-polymorphic interface class holding a pointer to implementation (Pimpl) can isolate the users of a class from changes in its implementation at the cost of an indirection. Example # interface (widget.h) class widget { class impl; std::unique_ptr<impl> pimpl; public: void draw(); // public API that will be forwarded to the implementation widget(int); // defined in the implementation file ~widget(); // defined in the implementation file, where impl is a complete type widget(widget&&) = default; widget(const widget&) = delete; widget& operator=(widget&&); // defined in the implementation file widget& operator=(const widget&) = delete; }; implementation (widget.cpp) class widget::impl { int n; // private data public: void draw(const widget& w) { /* ... */ } impl(int n) : n(n) {} }; void widget::draw() { pimpl->draw(*this); } widget::widget(int n) : pimpl{std::make_unique<impl>(n)} {} widget::~widget() = default; widget& widget::operator=(widget&&) = default; Notes # See GOTW #100 and cppreference for the trade-offs and additional implementation details associated with this idiom. Enforcement # (Not enforceable) It is difficult to reliably identify where an interface forms part of an ABI. I.30: Encapsulate rule violations # Reason # To keep code simple and safe. Sometimes, ugly, unsafe, or error-prone techniques are necessary for logical or performance reasons. If so, keep them local, rather than \u201cinfecting\u201d interfaces so that larger groups of programmers have to be aware of the subtleties. Implementation complexity should, if at all possible, not leak through interfaces into user code. Example # Consider a program that, depending on some form of input (e.g., arguments to main ), should consume input from a file, from the command line, or from standard input. We might write bool owned; owner<istream*> inp; switch (source) { case std_in: owned = false; inp = &cin; break; case command_line: owned = true; inp = new istringstream{argv[2]}; break; case file: owned = true; inp = new ifstream{argv[2]}; break; } istream& in = *inp; This violated the rule against uninitialized variables , the rule against ignoring ownership , and the rule against magic constants . In particular, someone has to remember to somewhere write if (owned) delete inp; We could handle this particular example by using unique_ptr with a special deleter that does nothing for cin , but that\u2019s complicated for novices (who can easily encounter this problem) and the example is an example of a more general problem where a property that we would like to consider static (here, ownership) needs infrequently be addressed at run time. The common, most frequent, and safest examples can be handled statically, so we don\u2019t want to add cost and complexity to those. But we must also cope with the uncommon, less-safe, and necessarily more expensive cases. Such examples are discussed in [Str15] . So, we write a class class Istream { [[gsl::suppress(lifetime)]] public: enum Opt { from_line = 1 }; Istream() { } Istream(zstring p) :owned{true}, inp{new ifstream{p}} {} // read from file Istream(zstring p, Opt) :owned{true}, inp{new istringstream{p}} {} // read from command line ~Istream() { if (owned) delete inp; } operator istream& () { return *inp; } private: bool owned = false; istream* inp = &cin; }; Now, the dynamic nature of istream ownership has been encapsulated. Presumably, a bit of checking for potential errors would be added in real code. Enforcement # Hard, it is hard to decide what rule-breaking code is essential Flag rule suppression that enable rule-violations to cross interfaces F: Functions # A function specifies an action or a computation that takes the system from one consistent state to the next. It is the fundamental building block of programs. It should be possible to name a function meaningfully, to specify the requirements of its argument, and clearly state the relationship between the arguments and the result. An implementation is not a specification. Try to think about what a function does as well as about how it does it. Functions are the most critical part in most interfaces, so see the interface rules. Function rule summary: Function definition rules: F.1: \u201cPackage\u201d meaningful operations as carefully named functions F.2: A function should perform a single logical operation F.3: Keep functions short and simple F.4: If a function may have to be evaluated at compile time, declare it constexpr F.5: If a function is very small and time-critical, declare it inline F.6: If your function may not throw, declare it noexcept F.7: For general use, take T* or T& arguments rather than smart pointers F.8: Prefer pure functions F.9: Unused parameters should be unnamed Parameter passing expression rules: F.15: Prefer simple and conventional ways of passing information F.16: For \u201cin\u201d parameters, pass cheaply-copied types by value and others by reference to const F.17: For \u201cin-out\u201d parameters, pass by reference to non- const F.18: For \u201cwill-move-from\u201d parameters, pass by X&& and std::move the parameter F.19: For \u201cforward\u201d parameters, pass by TP&& and only std::forward the parameter F.20: For \u201cout\u201d output values, prefer return values to output parameters F.21: To return multiple \u201cout\u201d values, prefer returning a struct or tuple F.60: Prefer T* over T& when \u201cno argument\u201d is a valid option Parameter passing semantic rules: F.22: Use T* or owner<T*> to designate a single object F.23: Use a not_null<T> to indicate that \u201cnull\u201d is not a valid value F.24: Use a span<T> or a span_p<T> to designate a half-open sequence F.25: Use a zstring or a not_null<zstring> to designate a C-style string F.26: Use a unique_ptr<T> to transfer ownership where a pointer is needed F.27: Use a shared_ptr<T> to share ownership Value return semantic rules: F.42: Return a T* to indicate a position (only) F.43: Never (directly or indirectly) return a pointer or a reference to a local object F.44: Return a T& when copy is undesirable and \u201creturning no object\u201d isn\u2019t needed F.45: Don\u2019t return a T&& F.46: int is the return type for main() F.47: Return T& from assignment operators F.48: Don\u2019t return std::move(local) Other function rules: F.50: Use a lambda when a function won\u2019t do (to capture local variables, or to write a local function) F.51: Where there is a choice, prefer default arguments over overloading F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread F.54: If you capture this , capture all variables explicitly (no default capture) F.55: Don\u2019t use va_arg arguments Functions have strong similarities to lambdas and function objects. See also : C.lambdas: Function objects and lambdas F.def: Function definitions # A function definition is a function declaration that also specifies the function\u2019s implementation, the function body. F.1: \u201cPackage\u201d meaningful operations as carefully named functions # Reason # Factoring out common code makes code more readable, more likely to be reused, and limit errors from complex code. If something is a well-specified action, separate it out from its surrounding code and give it a name. Example, don\u2019t # void read_and_print(istream& is) // read and print an int { int x; if (is >> x) cout << \"the int is \" << x << '\\n'; else cerr << \"no int on input\\n\"; } Almost everything is wrong with read_and_print . It reads, it writes (to a fixed ostream ), it writes error messages (to a fixed ostream ), it handles only int s. There is nothing to reuse, logically separate operations are intermingled and local variables are in scope after the end of their logical use. For a tiny example, this looks OK, but if the input operation, the output operation, and the error handling had been more complicated the tangled mess could become hard to understand. Note # If you write a non-trivial lambda that potentially can be used in more than one place, give it a name by assigning it to a (usually non-local) variable. Example # sort(a, b, [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); }); Naming that lambda breaks up the expression into its logical parts and provides a strong hint to the meaning of the lambda. auto lessT = [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); }; sort(a, b, lessT); find_if(a, b, lessT); The shortest code is not always the best for performance or maintainability. Exception # Loop bodies, including lambdas used as loop bodies, rarely need to be named. However, large loop bodies (e.g., dozens of lines or dozens of pages) can be a problem. The rule Keep functions short and simple implies \u201cKeep loop bodies short.\u201d Similarly, lambdas used as callback arguments are sometimes non-trivial, yet unlikely to be reusable. Enforcement # See Keep functions short and simple Flag identical and very similar lambdas used in different places. F.2: A function should perform a single logical operation # Reason # A function that performs a single operation is simpler to understand, test, and reuse. Example # Consider: void read_and_print() // bad { int x; cin >> x; // check for errors cout << x << \"\\n\"; } This is a monolith that is tied to a specific input and will never find another (different) use. Instead, break functions up into suitable logical parts and parameterize: int read(istream& is) // better { int x; is >> x; // check for errors return x; } void print(ostream& os, int x) { os << x << \"\\n\"; } These can now be combined where needed: void read_and_print() { auto x = read(cin); print(cout, x); } If there was a need, we could further templatize read() and print() on the data type, the I/O mechanism, the response to errors, etc. Example: auto read = [](auto& input, auto& value) // better { input >> value; // check for errors }; auto print(auto& output, const auto& value) { output << value << \"\\n\"; } Enforcement # Consider functions with more than one \u201cout\u201d parameter suspicious. Use return values instead, including tuple for multiple return values. Consider \u201clarge\u201d functions that don\u2019t fit on one editor screen suspicious. Consider factoring such a function into smaller well-named suboperations. Consider functions with 7 or more parameters suspicious. F.3: Keep functions short and simple # Reason # Large functions are hard to read, more likely to contain complex code, and more likely to have variables in larger than minimal scopes. Functions with complex control structures are more likely to be long and more likely to hide logical errors Example # Consider: double simple_func(double val, int flag1, int flag2) // simple_func: takes a value and calculates the expected ASIC output, // given the two mode flags. { double intermediate; if (flag1 > 0) { intermediate = func1(val); if (flag2 % 2) intermediate = sqrt(intermediate); } else if (flag1 == -1) { intermediate = func1(-val); if (flag2 % 2) intermediate = sqrt(-intermediate); flag1 = -flag1; } if (abs(flag2) > 10) { intermediate = func2(intermediate); } switch (flag2 / 10) { case 1: if (flag1 == -1) return finalize(intermediate, 1.171); break; case 2: return finalize(intermediate, 13.1); default: break; } return finalize(intermediate, 0.); } This is too complex. How would you know if all possible alternatives have been correctly handled? Yes, it breaks other rules also. We can refactor: double func1_muon(double val, int flag) { // ??? } double func1_tau(double val, int flag1, int flag2) { // ??? } double simple_func(double val, int flag1, int flag2) // simple_func: takes a value and calculates the expected ASIC output, // given the two mode flags. { if (flag1 > 0) return func1_muon(val, flag2); if (flag1 == -1) // handled by func1_tau: flag1 = -flag1; return func1_tau(-val, flag1, flag2); return 0.; } Note # \u201cIt doesn\u2019t fit on a screen\u201d is often a good practical definition of \u201cfar too large.\u201d One-to-five-line functions should be considered normal. Note # Break large functions up into smaller cohesive and named functions. Small simple functions are easily inlined where the cost of a function call is significant. Enforcement # Flag functions that do not \u201cfit on a screen.\u201d How big is a screen? Try 60 lines by 140 characters; that\u2019s roughly the maximum that\u2019s comfortable for a book page. Flag functions that are too complex. How complex is too complex? You could use cyclomatic complexity. Try \u201cmore than 10 logical path through.\u201d Count a simple switch as one path. F.4: If a function may have to be evaluated at compile time, declare it constexpr # Reason # constexpr is needed to tell the compiler to allow compile-time evaluation. Example # The (in)famous factorial: constexpr int fac(int n) { constexpr int max_exp = 17; // constexpr enables max_exp to be used in Expects Expects(0 <= n && n < max_exp); // prevent silliness and overflow int x = 1; for (int i = 2; i <= n; ++i) x *= i; return x; } This is C++14. For C++11, use a recursive formulation of fac() . Note # constexpr does not guarantee compile-time evaluation; it just guarantees that the function can be evaluated at compile time for constant expression arguments if the programmer requires it or the compiler decides to do so to optimize. constexpr int min(int x, int y) { return x < y ? x : y; } void test(int v) { int m1 = min(-1, 2); // probably compile-time evaluation constexpr int m2 = min(-1, 2); // compile-time evaluation int m3 = min(-1, v); // run-time evaluation constexpr int m4 = min(-1, v); // error: cannot evaluate at compile time } Note # Don\u2019t try to make all functions constexpr . Most computation is best done at run time. Note # Any API that may eventually depend on high-level run-time configuration or business logic should not be made constexpr . Such customization can not be evaluated by the compiler, and any constexpr functions that depended upon that API would have to be refactored or drop constexpr . Enforcement # Impossible and unnecessary. The compiler gives an error if a non- constexpr function is called where a constant is required. F.5: If a function is very small and time-critical, declare it inline # Reason # Some optimizers are good at inlining without hints from the programmer, but don\u2019t rely on it. Measure! Over the last 40 years or so, we have been promised compilers that can inline better than humans without hints from humans. We are still waiting. Specifying inline encourages the compiler to do a better job. Example # inline string cat(const string& s, const string& s2) { return s + s2; } Exception # Do not put an inline function in what is meant to be a stable interface unless you are certain that it will not change. An inline function is part of the ABI. Note # constexpr implies inline . Note # Member functions defined in-class are inline by default. Exception # Template functions (incl. template member functions) are normally defined in headers and therefore inline. Enforcement # Flag inline functions that are more than three statements and could have been declared out of line (such as class member functions). F.6: If your function may not throw, declare it noexcept # Reason # If an exception is not supposed to be thrown, the program cannot be assumed to cope with the error and should be terminated as soon as possible. Declaring a function noexcept helps optimizers by reducing the number of alternative execution paths. It also speeds up the exit after failure. Example # Put noexcept on every function written completely in C or in any other language without exceptions. The C++ Standard Library does that implicitly for all functions in the C Standard Library. Note # constexpr functions can throw when evaluated at run time, so you may need noexcept for some of those. Example # You can use noexcept even on functions that can throw: vector<string> collect(istream& is) noexcept { vector<string> res; for (string s; is >> s;) res.push_back(s); return res; } If collect() runs out of memory, the program crashes. Unless the program is crafted to survive memory exhaustion, that may be just the right thing to do; terminate() may generate suitable error log information (but after memory runs out it is hard to do anything clever). Note # You must be aware of the execution environment that your code is running when deciding whether to tag a function noexcept , especially because of the issue of throwing and allocation. Code that is intended to be perfectly general (like the standard library and other utility code of that sort) needs to support environments where a bad_alloc exception may be handled meaningfully. However, most programs and execution environments cannot meaningfully handle a failure to allocate, and aborting the program is the cleanest and simplest response to an allocation failure in those cases. If you know that your application code cannot respond to an allocation failure, it may be appropriate to add noexcept even on functions that allocate. Put another way: In most programs, most functions can throw (e.g., because they use new , call functions that do, or use library functions that reports failure by throwing), so don\u2019t just sprinkle noexcept all over the place without considering whether the possible exceptions can be handled. noexcept is most useful (and most clearly correct) for frequently used, low-level functions. Note # Destructors, swap functions, move operations, and default constructors should never throw. See also C.44 . Enforcement # Flag functions that are not noexcept , yet cannot throw. Flag throwing swap , move , destructors, and default constructors. F.7: For general use, take T* or T& arguments rather than smart pointers # Reason # Passing a smart pointer transfers or shares ownership and should only be used when ownership semantics are intended (see R.30 ). Passing by smart pointer restricts the use of a function to callers that use smart pointers. Passing a shared smart pointer (e.g., std::shared_ptr ) implies a run-time cost. Example # // accepts any int* void f(int*); // can only accept ints for which you want to transfer ownership void g(unique_ptr<int>); // can only accept ints for which you are willing to share ownership void g(shared_ptr<int>); // doesn't change ownership, but requires a particular ownership of the caller void h(const unique_ptr<int>&); // accepts any int void h(int&); Example, bad # // callee void f(shared_ptr<widget>& w) { // ... use(*w); // only use of w -- the lifetime is not used at all // ... }; See further in R.30 . Note # We can catch dangling pointers statically, so we don\u2019t need to rely on resource management to avoid violations from dangling pointers. See also : Prefer T* over T& when \u201cno argument\u201d is a valid option Smart pointer rule summary Enforcement # Flag a parameter of a smart pointer type (a type that overloads operator-> or operator* ) for which the ownership semantics are not used; that is copyable but never copied/moved from or movable but never moved and that is never modified or passed along to another function that could do so. F.8: Prefer pure functions # Reason # Pure functions are easier to reason about, sometimes easier to optimize (and even parallelize), and sometimes can be memoized. Example # template<class T> auto square(T t) { return t * t; } Enforcement # Not possible. F.9: Unused parameters should be unnamed # Reason # Readability. Suppression of unused parameter warnings. Example # X* find(map<Blob>& m, const string& s, Hint); // once upon a time, a hint was used Note # Allowing parameters to be unnamed was introduced in the early 1980 to address this problem. Enforcement # Flag named unused parameters. F.call: Parameter passing # There are a variety of ways to pass parameters to a function and to return values. F.15: Prefer simple and conventional ways of passing information # Reason # Using \u201cunusual and clever\u201d techniques causes surprises, slows understanding by other programmers, and encourages bugs. If you really feel the need for an optimization beyond the common techniques, measure to ensure that it really is an improvement, and document/comment because the improvement may not be portable. The following tables summarize the advice in the following Guidelines, F.16-21. Normal parameter passing: Advanced parameter passing: Use the advanced techniques only after demonstrating need, and document that need in a comment. F.16: For \u201cin\u201d parameters, pass cheaply-copied types by value and others by reference to const # Reason # Both let the caller know that a function will not modify the argument, and both allow initialization by rvalues. What is \u201ccheap to copy\u201d depends on the machine architecture, but two or three words (doubles, pointers, references) are usually best passed by value. When copying is cheap, nothing beats the simplicity and safety of copying, and for small objects (up to two or three words) it is also faster than passing by reference because it does not require an extra indirection to access from the function. Example # void f1(const string& s); // OK: pass by reference to const; always cheap void f2(string s); // bad: potentially expensive void f3(int x); // OK: Unbeatable void f4(const int& x); // bad: overhead on access in f4() For advanced uses (only), where you really need to optimize for rvalues passed to \u201cinput-only\u201d parameters: If the function is going to unconditionally move from the argument, take it by && . See F.18 . If the function is going to keep a copy of the argument, in addition to passing by const& (for lvalues), add an overload that passes the parameter by && (for rvalues) and in the body std::move s it to its destination. Essentially this overloads a \u201cwill-move-from\u201d; see F.18 . In special cases, such as multiple \u201cinput + copy\u201d parameters, consider using perfect forwarding. See F.19 . Example # int multiply(int, int); // just input ints, pass by value // suffix is input-only but not as cheap as an int, pass by const& string& concatenate(string&, const string& suffix); void sink(unique_ptr<widget>); // input only, and moves ownership of the widget Avoid \u201cesoteric techniques\u201d such as: Passing arguments as T&& \u201cfor efficiency\u201d. Most rumors about performance advantages from passing by && are false or brittle (but see F.18 and F.19 ). Returning const T& from assignments and similar operations (see F.47 .) Example # Assuming that Matrix has move operations (possibly by keeping its elements in a std::vector ): Matrix operator+(const Matrix& a, const Matrix& b) { Matrix res; // ... fill res with the sum ... return res; } Matrix x = m1 + m2; // move constructor y = m3 + m3; // move assignment Notes # The return value optimization doesn\u2019t handle the assignment case, but the move assignment does. A reference may be assumed to refer to a valid object (language rule). There is no (legitimate) \u201cnull reference.\u201d If you need the notion of an optional value, use a pointer, std::optional , or a special value used to denote \u201cno value.\u201d Enforcement # (Simple) ((Foundation)) Warn when a parameter being passed by value has a size greater than 2 * sizeof(void*) . Suggest using a reference to const instead. (Simple) ((Foundation)) Warn when a parameter passed by reference to const has a size less than 2 * sizeof(void*) . Suggest passing by value instead. (Simple) ((Foundation)) Warn when a parameter passed by reference to const is move d. F.17: For \u201cin-out\u201d parameters, pass by reference to non- const # Reason # This makes it clear to callers that the object is assumed to be modified. Example # void update(Record& r); // assume that update writes to r Note # A T& argument can pass information into a function as well as out of it. Thus T& could be an in-out-parameter. That can in itself be a problem and a source of errors: void f(string& s) { s = \"New York\"; // non-obvious error } void g() { string buffer = \".................................\"; f(buffer); // ... } Here, the writer of g() is supplying a buffer for f() to fill, but f() simply replaces it (at a somewhat higher cost than a simple copy of the characters). A bad logic error can happen if the writer of g() incorrectly assumes the size of the buffer . Enforcement # (Moderate) ((Foundation)) Warn about functions regarding reference to non- const parameters that do not write to them. (Simple) ((Foundation)) Warn when a non- const parameter being passed by reference is move d. F.18: For \u201cwill-move-from\u201d parameters, pass by X&& and std::move the parameter # Reason # It\u2019s efficient and eliminates bugs at the call site: X&& binds to rvalues, which requires an explicit std::move at the call site if passing an lvalue. Example # void sink(vector<int>&& v) { // sink takes ownership of whatever the argument owned // usually there might be const accesses of v here store_somewhere(std::move(v)); // usually no more use of v here; it is moved-from } Note that the std::move(v) makes it possible for store_somewhere() to leave v in a moved-from state. That could be dangerous . Exception # Unique owner types that are move-only and cheap-to-move, such as unique_ptr , can also be passed by value which is simpler to write and achieves the same effect. Passing by value does generate one extra (cheap) move operation, but prefer simplicity and clarity first. For example: template <class T> void sink(std::unique_ptr<T> p) { // use p ... possibly std::move(p) onward somewhere else } // p gets destroyed Enforcement # Flag all X&& parameters (where X is not a template type parameter name) where the function body uses them without std::move . Flag access to moved-from objects. Don\u2019t conditionally move from objects F.19: For \u201cforward\u201d parameters, pass by TP&& and only std::forward the parameter # Reason # If the object is to be passed onward to other code and not directly used by this function, we want to make this function agnostic to the argument const -ness and rvalue-ness. In that case, and only that case, make the parameter TP&& where TP is a template type parameter \u2013 it both ignores and preserves const -ness and rvalue-ness. Therefore any code that uses a TP&& is implicitly declaring that it itself doesn\u2019t care about the variable\u2019s const -ness and rvalue-ness (because it is ignored), but that intends to pass the value onward to other code that does care about const -ness and rvalue-ness (because it is preserved). When used as a parameter TP&& is safe because any temporary objects passed from the caller will live for the duration of the function call. A parameter of type TP&& should essentially always be passed onward via std::forward in the body of the function. Example # template <class F, class... Args> inline auto invoke(F f, Args&&... args) { return f(forward<Args>(args)...); } ??? calls ??? Enforcement # Flag a function that takes a TP&& parameter (where TP is a template type parameter name) and does anything with it other than std::forward ing it exactly once on every static path. F.20: For \u201cout\u201d output values, prefer return values to output parameters # Reason # A return value is self-documenting, whereas a & could be either in-out or out-only and is liable to be misused. This includes large objects like standard containers that use implicit move operations for performance and to avoid explicit memory management. If you have multiple values to return, use a tuple or similar multi-member type. Example # // OK: return pointers to elements with the value x vector<const int*> find_all(const vector<int>&, int x); // Bad: place pointers to elements with value x in-out void find_all(const vector<int>&, vector<const int*>& out, int x); Note # A struct of many (individually cheap-to-move) elements may be in aggregate expensive to move. It is not recommended to return a const value. Such older advice is now obsolete; it does not add value, and it interferes with move semantics. const vector<int> fct(); // bad: that \"const\" is more trouble than it is worth vector<int> g(const vector<int>& vx) { // ... fct() = vx; // prevented by the \"const\" // ... return fct(); // expensive copy: move semantics suppressed by the \"const\" } The argument for adding const to a return value is that it prevents (very rare) accidental access to a temporary. The argument against is prevents (very frequent) use of move semantics. Exceptions # For non-value types, such as types in an inheritance hierarchy, return the object by unique_ptr or shared_ptr . If a type is expensive to move (e.g., array<BigPOD> ), consider allocating it on the free store and return a handle (e.g., unique_ptr ), or passing it in a reference to non- const target object to fill (to be used as an out-parameter). To reuse an object that carries capacity (e.g., std::string , std::vector ) across multiple calls to the function in an inner loop: treat it as an in/out parameter and pass by reference . Example # struct Package { // exceptional case: expensive-to-move object char header[16]; char load[2024 - 16]; }; Package fill(); // Bad: large return value void fill(Package&); // OK int val(); // OK void val(int&); // Bad: Is val reading its argument Enforcement # Flag reference to non- const parameters that are not read before being written to and are a type that could be cheaply returned; they should be \u201cout\u201d return values. Flag returning a const value. To fix: Remove const to return a non- const value instead. F.21: To return multiple \u201cout\u201d values, prefer returning a struct or tuple # Reason # A return value is self-documenting as an \u201coutput-only\u201d value. Note that C++ does have multiple return values, by convention of using a tuple (including pair ), possibly with the extra convenience of tie at the call site. Prefer using a named struct where there are semantics to the returned value. Otherwise, a nameless tuple is useful in generic code. Example # // BAD: output-only parameter documented in a comment int f(const string& input, /*output only*/ string& output_data) { // ... output_data = something(); return status; } // GOOD: self-documenting tuple<int, string> f(const string& input) { // ... return make_tuple(status, something()); } C++98\u2019s standard library already used this style, because a pair is like a two-element tuple . For example, given a set<string> my_set , consider: // C++98 result = my_set.insert(\"Hello\"); if (result.second) do_something_with(result.first); // workaround With C++11 we can write this, putting the results directly in existing local variables: Sometype iter; // default initialize if we haven't already Someothertype success; // used these variables for some other purpose tie(iter, success) = my_set.insert(\"Hello\"); // normal return value if (success) do_something_with(iter); With C++17 we are able to use \u201cstructured bindings\u201d to declare and initialize the multiple variables: if (auto [ iter, success ] = my_set.insert(\"Hello\"); success) do_something_with(iter); Exception # Sometimes, we need to pass an object to a function to manipulate its state. In such cases, passing the object by reference T& is usually the right technique. Explicitly passing an in-out parameter back out again as a return value is often not necessary. For example: istream& operator>>(istream& is, string& s); // much like std::operator>>() for (string s; cin >> s; ) { // do something with line } Here, both s and cin are used as in-out parameters. We pass cin by (non- const ) reference to be able to manipulate its state. We pass s to avoid repeated allocations. By reusing s (passed by reference), we allocate new memory only when we need to expand s \u2018s capacity. This technique is sometimes called the \u201ccaller-allocated out\u201d pattern and is particularly useful for types, such as string and vector , that needs to do free store allocations. To compare, if we passed out all values as return values, we would something like this: pair<istream&, string> get_string(istream& is); // not recommended { string s; is >> s; return {is, s}; } for (auto p = get_string(cin); p.first; ) { // do something with p.second } We consider that significantly less elegant with significantly less performance. For a truly strict reading of this rule (F.21), the exception isn\u2019t really an exception because it relies on in-out parameters, rather than the plain out parameters mentioned in the rule. However, we prefer to be explicit, rather than subtle. Note # In many cases, it may be useful to return a specific, user-defined type. For example: struct Distance { int value; int unit = 1; // 1 means meters }; Distance d1 = measure(obj1); // access d1.value and d1.unit auto d2 = measure(obj2); // access d2.value and d2.unit auto [value, unit] = measure(obj3); // access value and unit; somewhat redundant // to people who know measure() auto [x, y] = measure(obj4); // don't; it's likely to be confusing The overly-generic pair and tuple should be used only when the value returned represents independent entities rather than an abstraction. Another example, use a specific type along the lines of variant<T, error_code> , rather than using the generic tuple . Enforcement # Output parameters should be replaced by return values. An output parameter is one that the function writes to, invokes a non- const member function, or passes on as a non- const . F.22: Use T* or owner<T*> to designate a single object # Reason # Readability: it makes the meaning of a plain pointer clear. Enables significant tool support. Note # In traditional C and C++ code, plain T* is used for many weakly-related purposes, such as: Identify a (single) object (not to be deleted by this function) Point to an object allocated on the free store (and delete it later) Hold the nullptr Identify a C-style string (zero-terminated array of characters) Identify an array with a length specified separately Identify a location in an array This makes it hard to understand what the code does and is supposed to do. It complicates checking and tool support. Example # void use(int* p, int n, char* s, int* q) { p[n - 1] = 666; // Bad: we don't know if p points to n elements; // assume it does not or use span<int> cout << s; // Bad: we don't know if that s points to a zero-terminated array of char; // assume it does not or use zstring delete q; // Bad: we don't know if *q is allocated on the free store; // assume it does not or use owner } better void use2(span<int> p, zstring s, owner<int*> q) { p[p.size() - 1] = 666; // OK, a range error can be caught cout << s; // OK delete q; // OK } Note # owner<T*> represents ownership, zstring represents a C-style string. Also : Assume that a T* obtained from a smart pointer to T (e.g., unique_ptr<T> ) points to a single element. See also : Support library See also : Do not pass an array as a single pointer Enforcement # (Simple) ((Bounds)) Warn for any arithmetic operation on an expression of pointer type that results in a value of pointer type. F.23: Use a not_null<T> to indicate that \u201cnull\u201d is not a valid value # Reason # Clarity. A function with a not_null<T> parameter makes it clear that the caller of the function is responsible for any nullptr checks that may be necessary. Similarly, a function with a return value of not_null<T> makes it clear that the caller of the function does not need to check for nullptr . Example # not_null<T*> makes it obvious to a reader (human or machine) that a test for nullptr is not necessary before dereference. Additionally, when debugging, owner<T*> and not_null<T> can be instrumented to check for correctness. Consider: int length(Record* p); When I call length(p) should I check if p is nullptr first? Should the implementation of length() check if p is nullptr ? // it is the caller's job to make sure p != nullptr int length(not_null<Record*> p); // the implementor of length() must assume that p == nullptr is possible int length(Record* p); Note # A not_null<T*> is assumed not to be the nullptr ; a T* may be the nullptr ; both can be represented in memory as a T* (so no run-time overhead is implied). Note # not_null is not just for built-in pointers. It works for unique_ptr , shared_ptr , and other pointer-like types. Enforcement # (Simple) Warn if a raw pointer is dereferenced without being tested against nullptr (or equivalent) within a function, suggest it is declared not_null instead. (Simple) Error if a raw pointer is sometimes dereferenced after first being tested against nullptr (or equivalent) within the function and sometimes is not. (Simple) Warn if a not_null pointer is tested against nullptr within a function. F.24: Use a span<T> or a span_p<T> to designate a half-open sequence # Reason # Informal/non-explicit ranges are a source of errors. Example # X* find(span<X> r, const X& v); // find v in r vector<X> vec; // ... auto p = find({vec.begin(), vec.end()}, X{}); // find X{} in vec Note # Ranges are extremely common in C++ code. Typically, they are implicit and their correct use is very hard to ensure. In particular, given a pair of arguments (p, n) designating an array [p:p+n) , it is in general impossible to know if there really are n elements to access following *p . span<T> and span_p<T> are simple helper classes designating a [p:q) range and a range starting with p and ending with the first element for which a predicate is true, respectively. Example # A span represents a range of elements, but how do we manipulate elements of that range? void f(span<int> s) { // range traversal (guaranteed correct) for (int x : s) cout << x << '\\n'; // C-style traversal (potentially checked) for (gsl::index i = 0; i < s.size(); ++i) cout << s[i] << '\\n'; // random access (potentially checked) s[7] = 9; // extract pointers (potentially checked) std::sort(&s[0], &s[s.size() / 2]); } Note # A span<T> object does not own its elements and is so small that it can be passed by value. Passing a span object as an argument is exactly as efficient as passing a pair of pointer arguments or passing a pointer and an integer count. See also : Support library Enforcement # (Complex) Warn where accesses to pointer parameters are bounded by other parameters that are integral types and suggest they could use span instead. F.25: Use a zstring or a not_null<zstring> to designate a C-style string # Reason # C-style strings are ubiquitous. They are defined by convention: zero-terminated arrays of characters. We must distinguish C-style strings from a pointer to a single character or an old-fashioned pointer to an array of characters. If you don\u2019t need null termination, use string_view . Example # Consider: int length(const char* p); When I call length(s) should I check if s is nullptr first? Should the implementation of length() check if p is nullptr ? // the implementor of length() must assume that p == nullptr is possible int length(zstring p); // it is the caller's job to make sure p != nullptr int length(not_null<zstring> p); Note # zstring does not represent ownership. See also : Support library F.26: Use a unique_ptr<T> to transfer ownership where a pointer is needed # Reason # Using unique_ptr is the cheapest way to pass a pointer safely. See also : C.50 regarding when to return a shared_ptr from a factory. Example # unique_ptr<Shape> get_shape(istream& is) // assemble shape from input stream { auto kind = read_header(is); // read header and identify the next shape on input switch (kind) { case kCircle: return make_unique<Circle>(is); case kTriangle: return make_unique<Triangle>(is); // ... } } Note # You need to pass a pointer rather than an object if what you are transferring is an object from a class hierarchy that is to be used through an interface (base class). Enforcement # (Simple) Warn if a function returns a locally allocated raw pointer. Suggest using either unique_ptr or shared_ptr instead. F.27: Use a shared_ptr<T> to share ownership # Reason # Using std::shared_ptr is the standard way to represent shared ownership. That is, the last owner deletes the object. Example # shared_ptr<const Image> im { read_image(somewhere) }; std::thread t0 {shade, args0, top_left, im}; std::thread t1 {shade, args1, top_right, im}; std::thread t2 {shade, args2, bottom_left, im}; std::thread t3 {shade, args3, bottom_right, im}; // detach threads // last thread to finish deletes the image Note # Prefer a unique_ptr over a shared_ptr if there is never more than one owner at a time. shared_ptr is for shared ownership. Note that pervasive use of shared_ptr has a cost (atomic operations on the shared_ptr \u2018s reference count have a measurable aggregate cost). Alternative # Have a single object own the shared object (e.g. a scoped object) and destroy that (preferably implicitly) when all users have completed. Enforcement # (Not enforceable) This is a too complex pattern to reliably detect. F.60: Prefer T* over T& when \u201cno argument\u201d is a valid option # Reason # A pointer ( T* ) can be a nullptr and a reference ( T& ) cannot, there is no valid \u201cnull reference\u201d. Sometimes having nullptr as an alternative to indicated \u201cno object\u201d is useful, but if it is not, a reference is notationally simpler and might yield better code. Example # string zstring_to_string(zstring p) // zstring is a char*; that is a C-style string { if (!p) return string{}; // p might be nullptr; remember to check return string{p}; } void print(const vector<int>& r) { // r refers to a vector<int>; no check needed } Note # It is possible, but not valid C++ to construct a reference that is essentially a nullptr (e.g., T* p = nullptr; T& r = (T&)*p; ). That error is very uncommon. Note # If you prefer the pointer notation ( -> and/or * vs. . ), not_null<T*> provides the same guarantee as T& . Enforcement # Flag ??? F.42: Return a T* to indicate a position (only) # Reason # That\u2019s what pointers are good for. Returning a T* to transfer ownership is a misuse. Example # Node* find(Node* t, const string& s) // find s in a binary tree of Nodes { if (!t || t->name == s) return t; if ((auto p = find(t->left, s))) return p; if ((auto p = find(t->right, s))) return p; return nullptr; } If it isn\u2019t the nullptr , the pointer returned by find indicates a Node holding s . Importantly, that does not imply a transfer of ownership of the pointed-to object to the caller. Note # Positions can also be transferred by iterators, indices, and references. A reference is often a superior alternative to a pointer if there is no need to use nullptr or if the object referred to should not change . Note # Do not return a pointer to something that is not in the caller\u2019s scope; see F.43 . See also : discussion of dangling pointer prevention Enforcement # Flag delete , std::free() , etc. applied to a plain T* . Only owners should be deleted. Flag new , malloc() , etc. assigned to a plain T* . Only owners should be responsible for deletion. F.43: Never (directly or indirectly) return a pointer or a reference to a local object # Reason # To avoid the crashes and data corruption that can result from the use of such a dangling pointer. Example, bad # After the return from a function its local objects no longer exist: int* f() { int fx = 9; return &fx; // BAD } void g(int* p) // looks innocent enough { int gx; cout << \"*p == \" << *p << '\\n'; *p = 999; cout << \"gx == \" << gx << '\\n'; } void h() { int* p = f(); int z = *p; // read from abandoned stack frame (bad) g(p); // pass pointer to abandoned stack frame to function (bad) } Here on one popular implementation I got the output: *p == 999 gx == 999 I expected that because the call of g() reuses the stack space abandoned by the call of f() so *p refers to the space now occupied by gx . Imagine what would happen if fx and gx were of different types. Imagine what would happen if fx or gx was a type with an invariant. Imagine what would happen if more that dangling pointer was passed around among a larger set of functions. Imagine what a cracker could do with that dangling pointer. Fortunately, most (all?) modern compilers catch and warn against this simple case. Note # This applies to references as well: int& f() { int x = 7; // ... return x; // Bad: returns reference to object that is about to be destroyed } Note # This applies only to non- static local variables. All static variables are (as their name indicates) statically allocated, so that pointers to them cannot dangle. Example, bad # Not all examples of leaking a pointer to a local variable are that obvious: int* glob; // global variables are bad in so many ways template<class T> void steal(T x) { glob = x(); // BAD } void f() { int i = 99; steal([&] { return &i; }); } int main() { f(); cout << *glob << '\\n'; } Here I managed to read the location abandoned by the call of f . The pointer stored in glob could be used much later and cause trouble in unpredictable ways. Note # The address of a local variable can be \u201creturned\u201d/leaked by a return statement, by a T& out-parameter, as a member of a returned object, as an element of a returned array, and more. Note # Similar examples can be constructed \u201cleaking\u201d a pointer from an inner scope to an outer one; such examples are handled equivalently to leaks of pointers out of a function. A slightly different variant of the problem is placing pointers in a container that outlives the objects pointed to. See also : Another way of getting dangling pointers is pointer invalidation . It can be detected/prevented with similar techniques. Enforcement # Compilers tend to catch return of reference to locals and could in many cases catch return of pointers to locals. Static analysis can catch many common patterns of the use of pointers indicating positions (thus eliminating dangling pointers) F.44: Return a T& when copy is undesirable and \u201creturning no object\u201d isn\u2019t needed # Reason # The language guarantees that a T& refers to an object, so that testing for nullptr isn\u2019t necessary. See also : The return of a reference must not imply transfer of ownership: discussion of dangling pointer prevention and discussion of ownership . Example # class Car { array<wheel, 4> w; // ... public: wheel& get_wheel(int i) { Expects(i < w.size()); return w[i]; } // ... }; void use() { Car c; wheel& w0 = c.get_wheel(0); // w0 has the same lifetime as c } Enforcement # Flag functions where no return expression could yield nullptr F.45: Don\u2019t return a T&& # Reason # It\u2019s asking to return a reference to a destroyed temporary object. A && is a magnet for temporary objects. Example # A returned rvalue reference goes out of scope at the end of the full expression to which it is returned: auto&& x = max(0, 1); // OK, so far foo(x); // Undefined behavior This kind of use is a frequent source of bugs, often incorrectly reported as a compiler bug. An implementer of a function should avoid setting such traps for users. The lifetime safety profile will (when completely implemented) catch such problems. Example # Returning an rvalue reference is fine when the reference to the temporary is being passed \u201cdownward\u201d to a callee; then, the temporary is guaranteed to outlive the function call (see F.18 and F.19 ). However, it\u2019s not fine when passing such a reference \u201cupward\u201d to a larger caller scope. For passthrough functions that pass in parameters (by ordinary reference or by perfect forwarding) and want to return values, use simple auto return type deduction (not auto&& ). Assume that F returns by value: template<class F> auto&& wrapper(F f) { log_call(typeid(f)); // or whatever instrumentation return f(); // BAD: returns a reference to a temporary } Better: template<class F> auto wrapper(F f) { log_call(typeid(f)); // or whatever instrumentation return f(); // OK } Exception # std::move and std::forward do return && , but they are just casts \u2013 used by convention only in expression contexts where a reference to a temporary object is passed along within the same expression before the temporary is destroyed. We don\u2019t know of any other good examples of returning && . Enforcement # Flag any use of && as a return type, except in std::move and std::forward . F.46: int is the return type for main() # Reason # It\u2019s a language rule, but violated through \u201clanguage extensions\u201d so often that it is worth mentioning. Declaring main (the one global main of a program) void limits portability. Example # void main() { /* ... */ }; // bad, not C++ int main() { std::cout << \"This is the way to do it\\n\"; } Note # We mention this only because of the persistence of this error in the community. Enforcement # The compiler should do it If the compiler doesn\u2019t do it, let tools flag it F.47: Return T& from assignment operators # Reason # The convention for operator overloads (especially on value types) is for operator=(const T&) to perform the assignment and then return (non- const ) *this . This ensures consistency with standard-library types and follows the principle of \u201cdo as the ints do.\u201d Note # Historically there was some guidance to make the assignment operator return const T& . This was primarily to avoid code of the form (a = b) = c \u2013 such code is not common enough to warrant violating consistency with standard types. Example # class Foo { public: ... Foo& operator=(const Foo& rhs) { // Copy members. ... return *this; } }; Enforcement # This should be enforced by tooling by checking the return type (and return value) of any assignment operator. F.48: Don\u2019t return std::move(local) # Reason # With guaranteed copy elision, it is now almost always a pessimization to expressly use std::move in a return statement. Example, bad # S f() { S result; return std::move(result); } Example, good # S f() { S result; return result; } Enforcement # This should be enforced by tooling by checking the return expression . F.50: Use a lambda when a function won\u2019t do (to capture local variables, or to write a local function) # Reason # Functions can\u2019t capture local variables or be defined at local scope; if you need those things, prefer a lambda where possible, and a handwritten function object where not. On the other hand, lambdas and function objects don\u2019t overload; if you need to overload, prefer a function (the workarounds to make lambdas overload are ornate). If either will work, prefer writing a function; use the simplest tool necessary. Example # // writing a function that should only take an int or a string // -- overloading is natural void f(int); void f(const string&); // writing a function object that needs to capture local state and appear // at statement or expression scope -- a lambda is natural vector<work> v = lots_of_work(); for (int tasknum = 0; tasknum < max; ++tasknum) { pool.run([=, &v]{ /* ... ... process 1 / max - th of v, the tasknum - th chunk ... */ }); } pool.join(); Exception # Generic lambdas offer a concise way to write function templates and so can be useful even when a normal function template would do equally well with a little more syntax. This advantage will probably disappear in the future once all functions gain the ability to have Concept parameters. Enforcement # Warn on use of a named non-generic lambda (e.g., auto x = [](int i){ /*...*/; }; ) that captures nothing and appears at global scope. Write an ordinary function instead. F.51: Where there is a choice, prefer default arguments over overloading # Reason # Default arguments simply provide alternative interfaces to a single implementation. There is no guarantee that a set of overloaded functions all implement the same semantics. The use of default arguments can avoid code replication. Note # There is a choice between using default argument and overloading when the alternatives are from a set of arguments of the same types. For example: void print(const string& s, format f = {}); as opposed to void print(const string& s); // use default format void print(const string& s, format f); There is not a choice when a set of functions are used to do a semantically equivalent operation to a set of types. For example: void print(const char&); void print(int); void print(zstring); See also # Default arguments for virtual functions Enforcement # Warn on an overload set where the overloads have a common prefix of parameters (e.g., f(int) , f(int, const string&) , f(int, const string&, double) ). (Note: Review this enforcement if it\u2019s too noisy in practice.) F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms # Reason # For efficiency and correctness, you nearly always want to capture by reference when using the lambda locally. This includes when writing or calling parallel algorithms that are local because they join before returning. Discussion # The efficiency consideration is that most types are cheaper to pass by reference than by value. The correctness consideration is that many calls want to perform side effects on the original object at the call site (see example below). Passing by value prevents this. Note # Unfortunately, there is no simple way to capture by reference to const to get the efficiency for a local call but also prevent side effects. Example # Here, a large object (a network message) is passed to an iterative algorithm, and is it not efficient or correct to copy the message (which may not be copyable): std::for_each(begin(sockets), end(sockets), [&message](auto& socket) { socket.send(message); }); Example # This is a simple three-stage parallel pipeline. Each stage object encapsulates a worker thread and a queue, has a process function to enqueue work, and in its destructor automatically blocks waiting for the queue to empty before ending the thread. void send_packets(buffers& bufs) { stage encryptor([] (buffer& b){ encrypt(b); }); stage compressor([&](buffer& b){ compress(b); encryptor.process(b); }); stage decorator([&](buffer& b){ decorate(b); compressor.process(b); }); for (auto& b : bufs) { decorator.process(b); } } // automatically blocks waiting for pipeline to finish Enforcement # Flag a lambda that captures by reference, but is used other than locally within the function scope or passed to a function by reference. (Note: This rule is an approximation, but does flag passing by pointer as those are more likely to be stored by the callee, writing to a heap location accessed via a parameter, returning the lambda, etc. The Lifetime rules will also provide general rules that flag escaping pointers and references including via lambdas.) F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread # Reason # Pointers and references to locals shouldn\u2019t outlive their scope. Lambdas that capture by reference are just another place to store a reference to a local object, and shouldn\u2019t do so if they (or a copy) outlive the scope. Example, bad # int local = 42; // Want a reference to local. // Note, that after program exits this scope, // local no longer exists, therefore // process() call will have undefined behavior! thread_pool.queue_work([&]{ process(local); }); Example, good # int local = 42; // Want a copy of local. // Since a copy of local is made, it will // always be available for the call. thread_pool.queue_work([=]{ process(local); }); Enforcement # (Simple) Warn when capture-list contains a reference to a locally declared variable (Complex) Flag when capture-list contains a reference to a locally declared variable and the lambda is passed to a non- const and non-local context F.54: If you capture this , capture all variables explicitly (no default capture) # Reason # It\u2019s confusing. Writing [=] in a member function appears to capture by value, but actually captures data members by reference because it actually captures the invisible this pointer by value. If you meant to do that, write this explicitly. Example # class My_class { int x = 0; // ... void f() { int i = 0; // ... auto lambda = [=]{ use(i, x); }; // BAD: \"looks like\" copy/value capture // [&] has identical semantics and copies the this pointer under the current rules // [=,this] and [&,this] are not much better, and confusing x = 42; lambda(); // calls use(0, 42); x = 43; lambda(); // calls use(0, 43); // ... auto lambda2 = [i, this]{ use(i, x); }; // ok, most explicit and least confusing // ... } }; Note # This is under active discussion in standardization, and may be addressed in a future version of the standard by adding a new capture mode or possibly adjusting the meaning of [=] . For now, just be explicit. Enforcement # Flag any lambda capture-list that specifies a default capture and also captures this (whether explicitly or via default capture) F.55: Don\u2019t use va_arg arguments # Reason # Reading from a va_arg assumes that the correct type was actually passed. Passing to varargs assumes the correct type will be read. This is fragile because it cannot generally be enforced to be safe in the language and so relies on programmer discipline to get it right. Example # int sum(...) { // ... while (/*...*/) result += va_arg(list, int); // BAD, assumes it will be passed ints // ... } sum(3, 2); // ok sum(3.14159, 2.71828); // BAD, undefined template<class ...Args> auto sum(Args... args) { // GOOD, and much more flexible return (... + args); // note: C++17 \"fold expression\" } sum(3, 2); // ok: 5 sum(3.14159, 2.71828); // ok: ~5.85987 Alternatives # overloading variadic templates variant arguments initializer_list (homogeneous) Note # Declaring a ... parameter is sometimes useful for techniques that don\u2019t involve actual argument passing, notably to declare \u201ctake-anything\u201d functions so as to disable \u201ceverything else\u201d in an overload set or express a catchall case in a template metaprogram. Enforcement # Issue a diagnostic for using va_list , va_start , or va_arg . Issue a diagnostic for passing an argument to a vararg parameter of a function that does not offer an overload for a more specific type in the position of the vararg. To fix: Use a different function, or [[suppress(types)]] . C: Classes and class hierarchies # A class is a user-defined type, for which a programmer can define the representation, operations, and interfaces. Class hierarchies are used to organize related classes into hierarchical structures. Class rule summary: C.1: Organize related data into structures ( struct s or class es) C.2: Use class if the class has an invariant; use struct if the data members can vary independently C.3: Represent the distinction between an interface and an implementation using a class C.4: Make a function a member only if it needs direct access to the representation of a class C.5: Place helper functions in the same namespace as the class they support C.7: Don\u2019t define a class or enum and declare a variable of its type in the same statement C.8: Use class rather than struct if any member is non-public C.9: Minimize exposure of members Subsections: C.concrete: Concrete types C.ctor: Constructors, assignments, and destructors C.con: Containers and other resource handles C.lambdas: Function objects and lambdas C.hier: Class hierarchies (OOP) C.over: Overloading and overloaded operators C.union: Unions C.1: Organize related data into structures ( struct s or class es) # Reason # Ease of comprehension. If data is related (for fundamental reasons), that fact should be reflected in code. Example # void draw(int x, int y, int x2, int y2); // BAD: unnecessary implicit relationships void draw(Point from, Point to); // better Note # A simple class without virtual functions implies no space or time overhead. Note # From a language perspective class and struct differ only in the default visibility of their members. Enforcement # Probably impossible. Maybe a heuristic looking for data items used together is possible. C.2: Use class if the class has an invariant; use struct if the data members can vary independently # Reason # Readability. Ease of comprehension. The use of class alerts the programmer to the need for an invariant. This is a useful convention. Note # An invariant is a logical condition for the members of an object that a constructor must establish for the public member functions to assume. After the invariant is established (typically by a constructor) every member function can be called for the object. An invariant can be stated informally (e.g., in a comment) or more formally using Expects . If all data members can vary independently of each other, no invariant is possible. Example # struct Pair { // the members can vary independently string name; int volume; }; but: class Date { public: // validate that {yy, mm, dd} is a valid date and initialize Date(int yy, Month mm, char dd); // ... private: int y; Month m; char d; // day }; Note # If a class has any private data, a user cannot completely initialize an object without the use of a constructor. Hence, the class definer will provide a constructor and must specify its meaning. This effectively means the definer need to define an invariant. See also : define a class with private data as class Prefer to place the interface first in a class minimize exposure of members Avoid protected data Enforcement # Look for struct s with all data private and class es with public members. C.3: Represent the distinction between an interface and an implementation using a class # Reason # An explicit distinction between interface and implementation improves readability and simplifies maintenance. Example # class Date { // ... some representation ... public: Date(); // validate that {yy, mm, dd} is a valid date and initialize Date(int yy, Month mm, char dd); int day() const; Month month() const; // ... }; For example, we can now change the representation of a Date without affecting its users (recompilation is likely, though). Note # Using a class in this way to represent the distinction between interface and implementation is of course not the only way. For example, we can use a set of declarations of freestanding functions in a namespace, an abstract base class, or a template function with concepts to represent an interface. The most important issue is to explicitly distinguish between an interface and its implementation \u201cdetails.\u201d Ideally, and typically, an interface is far more stable than its implementation(s). Enforcement # ??? C.4: Make a function a member only if it needs direct access to the representation of a class # Reason # Less coupling than with member functions, fewer functions that can cause trouble by modifying object state, reduces the number of functions that needs to be modified after a change in representation. Example # class Date { // ... relatively small interface ... }; // helper functions: Date next_weekday(Date); bool operator==(Date, Date); The \u201chelper functions\u201d have no need for direct access to the representation of a Date . Note # This rule becomes even better if C++ gets \u201cuniform function call\u201d . Exception # The language requires virtual functions to be members, and not all virtual functions directly access data. In particular, members of an abstract class rarely do. Note multi-methods . Exception # The language requires operators = , () , [] , and -> to be members. Exception # An overload set may have some members that do not directly access private data: class Foobar { public: void foo(long x) { /* manipulate private data */ } void foo(double x) { foo(std::lround(x)); } // ... private: // ... }; Exception # Similarly, a set of functions may be designed to be used in a chain: x.scale(0.5).rotate(45).set_color(Color::red); Typically, some but not all of such functions directly access private data. Enforcement # Look for non- virtual member functions that do not touch data members directly. The snag is that many member functions that do not need to touch data members directly do. Ignore virtual functions. Ignore functions that are part of an overload set out of which at least one function accesses private members. Ignore functions returning this . C.5: Place helper functions in the same namespace as the class they support # Reason # A helper function is a function (usually supplied by the writer of a class) that does not need direct access to the representation of the class, yet is seen as part of the useful interface to the class. Placing them in the same namespace as the class makes their relationship to the class obvious and allows them to be found by argument dependent lookup. Example # namespace Chrono { // here we keep time-related services class Time { /* ... */ }; class Date { /* ... */ }; // helper functions: bool operator==(Date, Date); Date next_weekday(Date); // ... } Note # This is especially important for overloaded operators . Enforcement # Flag global functions taking argument types from a single namespace. C.7: Don\u2019t define a class or enum and declare a variable of its type in the same statement # Reason # Mixing a type definition and the definition of another entity in the same declaration is confusing and unnecessary. Example, bad # struct Data { /*...*/ } data{ /*...*/ }; Example, good # struct Data { /*...*/ }; Data data{ /*...*/ }; Enforcement # Flag if the } of a class or enumeration definition is not followed by a ; . The ; is missing. C.8: Use class rather than struct if any member is non-public # Reason # Readability. To make it clear that something is being hidden/abstracted. This is a useful convention. Example, bad # struct Date { int d, m; Date(int i, Month m); // ... lots of functions ... private: int y; // year }; There is nothing wrong with this code as far as the C++ language rules are concerned, but nearly everything is wrong from a design perspective. The private data is hidden far from the public data. The data is split in different parts of the class declaration. Different parts of the data have different access. All of this decreases readability and complicates maintenance. Note # Prefer to place the interface first in a class, see NL.16 . Enforcement # Flag classes declared with struct if there is a private or protected member. C.9: Minimize exposure of members # Reason # Encapsulation. Information hiding. Minimize the chance of unintended access. This simplifies maintenance. Example # template<typename T, typename U> struct pair { T a; U b; // ... }; Whatever we do in the // -part, an arbitrary user of a pair can arbitrarily and independently change its a and b . In a large code base, we cannot easily find which code does what to the members of pair . This may be exactly what we want, but if we want to enforce a relation among members, we need to make them private and enforce that relation (invariant) through constructors and member functions. For example: class Distance { public: // ... double meters() const { return magnitude*unit; } void set_unit(double u) { // ... check that u is a factor of 10 ... // ... change magnitude appropriately ... unit = u; } // ... private: double magnitude; double unit; // 1 is meters, 1000 is kilometers, 0.001 is millimeters, etc. }; Note # If the set of direct users of a set of variables cannot be easily determined, the type or usage of that set cannot be (easily) changed/improved. For public and protected data, that\u2019s usually the case. Example # A class can provide two interfaces to its users. One for derived classes ( protected ) and one for general users ( public ). For example, a derived class might be allowed to skip a run-time check because it has already guaranteed correctness: class Foo { public: int bar(int x) { check(x); return do_bar(x); } // ... protected: int do_bar(int x); // do some operation on the data // ... private: // ... data ... }; class Dir : public Foo { //... int mem(int x, int y) { /* ... do something ... */ return do_bar(x + y); // OK: derived class can bypass check } }; void user(Foo& x) { int r1 = x.bar(1); // OK, will check int r2 = x.do_bar(2); // error: would bypass check // ... } Note # protected data is a bad idea . Note # Prefer the order public members before protected members before private members see . Enforcement # Flag protected data . Flag mixtures of public and private data C.concrete: Concrete types # One ideal for a class is to be a regular type. That means roughly \u201cbehaves like an int .\u201d A concrete type is the simplest kind of class. A value of regular type can be copied and the result of a copy is an independent object with the same value as the original. If a concrete type has both = and == , a = b should result in a == b being true . Concrete classes without assignment and equality can be defined, but they are (and should be) rare. The C++ built-in types are regular, and so are standard-library classes, such as string , vector , and map . Concrete types are also often referred to as value types to distinguish them from types used as part of a hierarchy. Concrete type rule summary: C.10: Prefer concrete types over class hierarchies C.11: Make concrete types regular C.10: Prefer concrete types over class hierarchies # Reason # A concrete type is fundamentally simpler than a hierarchy: easier to design, easier to implement, easier to use, easier to reason about, smaller, and faster. You need a reason (use cases) for using a hierarchy. Example # class Point1 { int x, y; // ... operations ... // ... no virtual functions ... }; class Point2 { int x, y; // ... operations, some virtual ... virtual ~Point2(); }; void use() { Point1 p11 {1, 2}; // make an object on the stack Point1 p12 {p11}; // a copy auto p21 = make_unique<Point2>(1, 2); // make an object on the free store auto p22 = p21->clone(); // make a copy // ... } If a class can be part of a hierarchy, we (in real code if not necessarily in small examples) must manipulate its objects through pointers or references. That implies more memory overhead, more allocations and deallocations, and more run-time overhead to perform the resulting indirections. Note # Concrete types can be stack-allocated and be members of other classes. Note # The use of indirection is fundamental for run-time polymorphic interfaces. The allocation/deallocation overhead is not (that\u2019s just the most common case). We can use a base class as the interface of a scoped object of a derived class. This is done where dynamic allocation is prohibited (e.g. hard-real-time) and to provide a stable interface to some kinds of plug-ins. Enforcement # ??? C.11: Make concrete types regular # Reason # Regular types are easier to understand and reason about than types that are not regular (irregularities requires extra effort to understand and use). Example # struct Bundle { string name; vector<Record> vr; }; bool operator==(const Bundle& a, const Bundle& b) { return a.name == b.name && a.vr == b.vr; } Bundle b1 { \"my bundle\", {r1, r2, r3}}; Bundle b2 = b1; if (!(b1 == b2)) error(\"impossible!\"); b2.name = \"the other bundle\"; if (b1 == b2) error(\"No!\"); In particular, if a concrete type has an assignment also give it an equals operator so that a = b implies a == b . Note # Handles for resources that cannot be cloned, e.g., a scoped_lock for a mutex , resemble concrete types in that they most often are stack-allocated. However, objects of such types typically cannot be copied (instead, they can usually be moved), so they can\u2019t be regular ; instead, they tend to be semiregular . Often, such types are referred to as \u201cmove-only types\u201d. Enforcement # ??? C.ctor: Constructors, assignments, and destructors # These functions control the lifecycle of objects: creation, copy, move, and destruction. Define constructors to guarantee and simplify initialization of classes. These are default operations : a default constructor: X() a copy constructor: X(const X&) a copy assignment: operator=(const X&) a move constructor: X(X&&) a move assignment: operator=(X&&) a destructor: ~X() By default, the compiler defines each of these operations if it is used, but the default can be suppressed. The default operations are a set of related operations that together implement the lifecycle semantics of an object. By default, C++ treats classes as value-like types, but not all types are value-like. Set of default operations rules: C.20: If you can avoid defining any default operations, do C.21: If you define or =delete any default operation, define or =delete them all C.22: Make default operations consistent Destructor rules: C.30: Define a destructor if a class needs an explicit action at object destruction C.31: All resources acquired by a class must be released by the class\u2019s destructor C.32: If a class has a raw pointer ( T* ) or reference ( T& ), consider whether it might be owning C.33: If a class has an owning pointer member, define or =delete a destructor C.35: A base class destructor should be either public and virtual, or protected and nonvirtual C.36: A destructor may not fail C.37: Make destructors noexcept Constructor rules: C.40: Define a constructor if a class has an invariant C.41: A constructor should create a fully initialized object C.42: If a constructor cannot construct a valid object, throw an exception C.43: Ensure that a copyable (value type) class has a default constructor C.44: Prefer default constructors to be simple and non-throwing C.45: Don\u2019t define a default constructor that only initializes data members; use member initializers instead C.46: By default, declare single-argument constructors explicit C.47: Define and initialize member variables in the order of member declaration C.48: Prefer in-class initializers to member initializers in constructors for constant initializers C.49: Prefer initialization to assignment in constructors C.50: Use a factory function if you need \u201cvirtual behavior\u201d during initialization C.51: Use delegating constructors to represent common actions for all constructors of a class C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization Copy and move rules: C.60: Make copy assignment non- virtual , take the parameter by const& , and return by non- const& C.61: A copy operation should copy C.62: Make copy assignment safe for self-assignment C.63: Make move assignment non- virtual , take the parameter by && , and return by non- const& C.64: A move operation should move and leave its source in a valid state C.65: Make move assignment safe for self-assignment C.66: Make move operations noexcept C.67: A polymorphic class should suppress copying Other default operations rules: C.80: Use =default if you have to be explicit about using the default semantics C.81: Use =delete when you want to disable default behavior (without wanting an alternative) C.82: Don\u2019t call virtual functions in constructors and destructors C.83: For value-like types, consider providing a noexcept swap function C.84: A swap may not fail C.85: Make swap noexcept C.86: Make == symmetric with respect of operand types and noexcept C.87: Beware of == on base classes C.89: Make a hash noexcept C.defop: Default Operations # By default, the language supplies the default operations with their default semantics. However, a programmer can disable or replace these defaults. C.20: If you can avoid defining default operations, do # Reason # It\u2019s the simplest and gives the cleanest semantics. Example # struct Named_map { public: // ... no default operations declared ... private: string name; map<int, int> rep; }; Named_map nm; // default construct Named_map nm2 {nm}; // copy construct Since std::map and string have all the special functions, no further work is needed. Note # This is known as \u201cthe rule of zero\u201d. Enforcement # (Not enforceable) While not enforceable, a good static analyzer can detect patterns that indicate a possible improvement to meet this rule. For example, a class with a (pointer, size) pair of member and a destructor that delete s the pointer could probably be converted to a vector . C.21: If you define or =delete any default operation, define or =delete them all # Reason # The special member functions are the default constructor, copy constructor, copy assignment operator, move constructor, move assignment operator, and destructor. The semantics of the special functions are closely related, so if one needs to be declared, the odds are that others need consideration too. Declaring any special member function except a default constructor, even as =default or =delete , will suppress the implicit declaration of a move constructor and move assignment operator. Declaring a move constructor or move assignment operator, even as =default or =delete , will cause an implicitly generated copy constructor or implicitly generated copy assignment operator to be defined as deleted. So as soon as any of the special functions is declared, the others should all be declared to avoid unwanted effects like turning all potential moves into more expensive copies, or making a class move-only. Example, bad # struct M2 { // bad: incomplete set of default operations public: // ... // ... no copy or move operations ... ~M2() { delete[] rep; } private: pair<int, int>* rep; // zero-terminated set of pairs }; void use() { M2 x; M2 y; // ... x = y; // the default assignment // ... } Given that \u201cspecial attention\u201d was needed for the destructor (here, to deallocate), the likelihood that copy and move assignment (both will implicitly destroy an object) are correct is low (here, we would get double deletion). Note # This is known as \u201cthe rule of five\u201d or \u201cthe rule of six\u201d, depending on whether you count the default constructor. Note # If you want a default implementation of a default operation (while defining another), write =default to show you\u2019re doing so intentionally for that function. If you don\u2019t want a default operation, suppress it with =delete . Example, good # When a destructor needs to be declared just to make it virtual , it can be defined as defaulted. To avoid suppressing the implicit move operations they must also be declared, and then to avoid the class becoming move-only (and not copyable) the copy operations must be declared: class AbstractBase { public: virtual ~AbstractBase() = default; AbstractBase(const AbstractBase&) = default; AbstractBase& operator=(const AbstractBase&) = default; AbstractBase(AbstractBase&&) = default; AbstractBase& operator=(AbstractBase&&) = default; }; Alternatively to prevent slicing as per C.67 , the copy and move operations can all be deleted: class ClonableBase { public: virtual unique_ptr<ClonableBase> clone() const; virtual ~ClonableBase() = default; ClonableBase(const ClonableBase&) = delete; ClonableBase& operator=(const ClonableBase&) = delete; ClonableBase(ClonableBase&&) = delete; ClonableBase& operator=(ClonableBase&&) = delete; }; Defining only the move operations or only the copy operations would have the same effect here, but stating the intent explicitly for each special member makes it more obvious to the reader. Note # Compilers enforce much of this rule and ideally warn about any violation. Note # Relying on an implicitly generated copy operation in a class with a destructor is deprecated. Note # Writing the six special member functions can be error prone. Note their argument types: class X { public: // ... virtual ~X() = default; // destructor (virtual if X is meant to be a base class) X(const X&) = default; // copy constructor X& operator=(const X&) = default; // copy assignment X(X&&) = default; // move constructor X& operator=(X&&) = default; // move assignment }; A minor mistake (such as a misspelling, leaving out a const , using & instead of && , or leaving out a special function) can lead to errors or warnings. To avoid the tedium and the possibility of errors, try to follow the rule of zero . Enforcement # (Simple) A class should have a declaration (even a =delete one) for either all or none of the special functions. C.22: Make default operations consistent # Reason # The default operations are conceptually a matched set. Their semantics are interrelated. Users will be surprised if copy/move construction and copy/move assignment do logically different things. Users will be surprised if constructors and destructors do not provide a consistent view of resource management. Users will be surprised if copy and move don\u2019t reflect the way constructors and destructors work. Example, bad # class Silly { // BAD: Inconsistent copy operations class Impl { // ... }; shared_ptr<Impl> p; public: Silly(const Silly& a) : p{a.p} { *p = *a.p; } // deep copy Silly& operator=(const Silly& a) { p = a.p; } // shallow copy // ... }; These operations disagree about copy semantics. This will lead to confusion and bugs. Enforcement # (Complex) A copy/move constructor and the corresponding copy/move assignment operator should write to the same member variables at the same level of dereference. (Complex) Any member variables written in a copy/move constructor should also be initialized by all other constructors. (Complex) If a copy/move constructor performs a deep copy of a member variable, then the destructor should modify the member variable. (Complex) If a destructor is modifying a member variable, that member variable should be written in any copy/move constructors or assignment operators. C.dtor: Destructors # \u201cDoes this class need a destructor?\u201d is a surprisingly powerful design question. For most classes the answer is \u201cno\u201d either because the class holds no resources or because destruction is handled by the rule of zero ; that is, its members can take care of themselves as concerns destruction. If the answer is \u201cyes\u201d, much of the design of the class follows (see the rule of five ). C.30: Define a destructor if a class needs an explicit action at object destruction # Reason # A destructor is implicitly invoked at the end of an object\u2019s lifetime. If the default destructor is sufficient, use it. Only define a non-default destructor if a class needs to execute code that is not already part of its members\u2019 destructors. Example # template<typename A> struct final_action { // slightly simplified A act; final_action(A a) :act{a} {} ~final_action() { act(); } }; template<typename A> final_action<A> finally(A act) // deduce action type { return final_action<A>{act}; } void test() { auto act = finally([]{ cout << \"Exit test\\n\"; }); // establish exit action // ... if (something) return; // act done here // ... } // act done here The whole purpose of final_action is to get a piece of code (usually a lambda) executed upon destruction. Note # There are two general categories of classes that need a user-defined destructor: A class with a resource that is not already represented as a class with a destructor, e.g., a vector or a transaction class. A class that exists primarily to execute an action upon destruction, such as a tracer or final_action . Example, bad # class Foo { // bad; use the default destructor public: // ... ~Foo() { s = \"\"; i = 0; vi.clear(); } // clean up private: string s; int i; vector<int> vi; }; The default destructor does it better, more efficiently, and can\u2019t get it wrong. Note # If the default destructor is needed, but its generation has been suppressed (e.g., by defining a move constructor), use =default . Enforcement # Look for likely \u201cimplicit resources\u201d, such as pointers and references. Look for classes with destructors even though all their data members have destructors. C.31: All resources acquired by a class must be released by the class\u2019s destructor # Reason # Prevention of resource leaks, especially in error cases. Note # For resources represented as classes with a complete set of default operations, this happens automatically. Example # class X { ifstream f; // may own a file // ... no default operations defined or =deleted ... }; X \u2018s ifstream implicitly closes any file it may have open upon destruction of its X . Example, bad # class X2 { // bad FILE* f; // may own a file // ... no default operations defined or =deleted ... }; X2 may leak a file handle. Note # What about a sockets that won\u2019t close? A destructor, close, or cleanup operation should never fail . If it does nevertheless, we have a problem that has no really good solution. For starters, the writer of a destructor does not know why the destructor is called and cannot \u201crefuse to act\u201d by throwing an exception. See discussion . To make the problem worse, many \u201cclose/release\u201d operations are not retryable. Many have tried to solve this problem, but no general solution is known. If at all possible, consider failure to close/cleanup a fundamental design error and terminate. Note # A class can hold pointers and references to objects that it does not own. Obviously, such objects should not be delete d by the class\u2019s destructor. For example: Preprocessor pp { /* ... */ }; Parser p { pp, /* ... */ }; Type_checker tc { p, /* ... */ }; Here p refers to pp but does not own it. Enforcement # (Simple) If a class has pointer or reference member variables that are owners (e.g., deemed owners by using gsl::owner ), then they should be referenced in its destructor. (Hard) Determine if pointer or reference member variables are owners when there is no explicit statement of ownership (e.g., look into the constructors). C.32: If a class has a raw pointer ( T* ) or reference ( T& ), consider whether it might be owning # Reason # There is a lot of code that is non-specific about ownership. Example # ??? Note # If the T* or T& is owning, mark it owning . If the T* is not owning, consider marking it ptr . This will aid documentation and analysis. Enforcement # Look at the initialization of raw member pointers and member references and see if an allocation is used. C.33: If a class has an owning pointer member, define a destructor # Reason # An owned object must be deleted upon destruction of the object that owns it. Example # A pointer member may represent a resource. A T* should not do so , but in older code, that\u2019s common. Consider a T* a possible owner and therefore suspect. template<typename T> class Smart_ptr { T* p; // BAD: vague about ownership of *p // ... public: // ... no user-defined default operations ... }; void use(Smart_ptr<int> p1) { // error: p2.p leaked (if not nullptr and not owned by some other code) auto p2 = p1; } Note that if you define a destructor, you must define or delete all default operations : template<typename T> class Smart_ptr2 { T* p; // BAD: vague about ownership of *p // ... public: // ... no user-defined copy operations ... ~Smart_ptr2() { delete p; } // p is an owner! }; void use(Smart_ptr2<int> p1) { auto p2 = p1; // error: double deletion } The default copy operation will just copy the p1.p into p2.p leading to a double destruction of p1.p . Be explicit about ownership: template<typename T> class Smart_ptr3 { owner<T*> p; // OK: explicit about ownership of *p // ... public: // ... // ... copy and move operations ... ~Smart_ptr3() { delete p; } }; void use(Smart_ptr3<int> p1) { auto p2 = p1; // OK: no double deletion } Note # Often the simplest way to get a destructor is to replace the pointer with a smart pointer (e.g., std::unique_ptr ) and let the compiler arrange for proper destruction to be done implicitly. Note # Why not just require all owning pointers to be \u201csmart pointers\u201d? That would sometimes require non-trivial code changes and may affect ABIs. Enforcement # A class with a pointer data member is suspect. A class with an owner<T> should define its default operations. C.35: A base class destructor should be either public and virtual, or protected and nonvirtual # Reason # To prevent undefined behavior. If the destructor is public, then calling code can attempt to destroy a derived class object through a base class pointer, and the result is undefined if the base class\u2019s destructor is non-virtual. If the destructor is protected, then calling code cannot destroy through a base class pointer and the destructor does not need to be virtual; it does need to be protected, not private, so that derived destructors can invoke it. In general, the writer of a base class does not know the appropriate action to be done upon destruction. Discussion # See this in the Discussion section . Example, bad # struct Base { // BAD: implicitly has a public nonvirtual destructor virtual void f(); }; struct D : Base { string s {\"a resource needing cleanup\"}; ~D() { /* ... do some cleanup ... */ } // ... }; void use() { unique_ptr<Base> p = make_unique<D>(); // ... } // p's destruction calls ~Base(), not ~D(), which leaks D::s and possibly more Note # A virtual function defines an interface to derived classes that can be used without looking at the derived classes. If the interface allows destroying, it should be safe to do so. Note # A destructor must be nonprivate or it will prevent using the type: class X { ~X(); // private destructor // ... }; void use() { X a; // error: cannot destroy auto p = make_unique<X>(); // error: cannot destroy } Exception # We can imagine one case where you could want a protected virtual destructor: When an object of a derived type (and only of such a type) should be allowed to destroy another object (not itself) through a pointer to base. We haven\u2019t seen such a case in practice, though. Enforcement # A class with any virtual functions should have a destructor that is either public and virtual or else protected and nonvirtual. C.36: A destructor may not fail # Reason # In general we do not know how to write error-free code if a destructor should fail. The standard library requires that all classes it deals with have destructors that do not exit by throwing. Example # class X { public: ~X() noexcept; // ... }; X::~X() noexcept { // ... if (cannot_release_a_resource) terminate(); // ... } Note # Many have tried to devise a fool-proof scheme for dealing with failure in destructors. None have succeeded to come up with a general scheme. This can be a real practical problem: For example, what about a socket that won\u2019t close? The writer of a destructor does not know why the destructor is called and cannot \u201crefuse to act\u201d by throwing an exception. See discussion . To make the problem worse, many \u201cclose/release\u201d operations are not retryable. If at all possible, consider failure to close/cleanup a fundamental design error and terminate. Note # Declare a destructor noexcept . That will ensure that it either completes normally or terminate the program. Note # If a resource cannot be released and the program may not fail, try to signal the failure to the rest of the system somehow (maybe even by modifying some global state and hope something will notice and be able to take care of the problem). Be fully aware that this technique is special-purpose and error-prone. Consider the \u201cmy connection will not close\u201d example. Probably there is a problem at the other end of the connection and only a piece of code responsible for both ends of the connection can properly handle the problem. The destructor could send a message (somehow) to the responsible part of the system, consider that to have closed the connection, and return normally. Note # If a destructor uses operations that may fail, it can catch exceptions and in some cases still complete successfully (e.g., by using a different clean-up mechanism from the one that threw an exception). Enforcement # (Simple) A destructor should be declared noexcept if it could throw. C.37: Make destructors noexcept # Reason # A destructor may not fail . If a destructor tries to exit with an exception, it\u2019s a bad design error and the program had better terminate. Note # A destructor (either user-defined or compiler-generated) is implicitly declared noexcept (independently of what code is in its body) if all of the members of its class have noexcept destructors. By explicitly marking destructors noexcept , an author guards against the destructor becoming implicitly noexcept(false) through the addition or modification of a class member. Example # Not all destructors are noexcept by default; one throwing member poisons the whole class hierarchy struct X { Details x; // happens to have a throwing destructor // ... ~X() { } // implicitly noexcept(false); aka can throw }; So, if in doubt, declare a destructor noexcept. Note # Why not then declare all destructors noexcept? Because that would in many cases \u2013 especially simple cases \u2013 be distracting clutter. Enforcement # (Simple) A destructor should be declared noexcept if it could throw. C.ctor: Constructors # A constructor defines how an object is initialized (constructed). C.40: Define a constructor if a class has an invariant # Reason # That\u2019s what constructors are for. Example # class Date { // a Date represents a valid date // in the January 1, 1900 to December 31, 2100 range Date(int dd, int mm, int yy) :d{dd}, m{mm}, y{yy} { if (!is_valid(d, m, y)) throw Bad_date{}; // enforce invariant } // ... private: int d, m, y; }; It is often a good idea to express the invariant as an Ensures on the constructor. Note # A constructor can be used for convenience even if a class does not have an invariant. For example: struct Rec { string s; int i {0}; Rec(const string& ss) : s{ss} {} Rec(int ii) :i{ii} {} }; Rec r1 {7}; Rec r2 {\"Foo bar\"}; Note # The C++11 initializer list rule eliminates the need for many constructors. For example: struct Rec2{ string s; int i; Rec2(const string& ss, int ii = 0) :s{ss}, i{ii} {} // redundant }; Rec2 r1 {\"Foo\", 7}; Rec2 r2 {\"Bar\"}; The Rec2 constructor is redundant. Also, the default for int would be better done as a member initializer . See also : construct valid object and constructor throws . Enforcement # Flag classes with user-defined copy operations but no constructor (a user-defined copy is a good indicator that the class has an invariant) C.41: A constructor should create a fully initialized object # Reason # A constructor establishes the invariant for a class. A user of a class should be able to assume that a constructed object is usable. Example, bad # class X1 { FILE* f; // call init() before any other function // ... public: X1() {} void init(); // initialize f void read(); // read from f // ... }; void f() { X1 file; file.read(); // crash or bad read! // ... file.init(); // too late // ... } Compilers do not read comments. Exception # If a valid object cannot conveniently be constructed by a constructor, use a factory function . Enforcement # (Simple) Every constructor should initialize every member variable (either explicitly, via a delegating ctor call or via default construction). (Unknown) If a constructor has an Ensures contract, try to see if it holds as a postcondition. Note # If a constructor acquires a resource (to create a valid object), that resource should be released by the destructor . The idiom of having constructors acquire resources and destructors release them is called RAII (\u201cResource Acquisition Is Initialization\u201d). C.42: If a constructor cannot construct a valid object, throw an exception # Reason # Leaving behind an invalid object is asking for trouble. Example # class X2 { FILE* f; // ... public: X2(const string& name) :f{fopen(name.c_str(), \"r\")} { if (!f) throw runtime_error{\"could not open\" + name}; // ... } void read(); // read from f // ... }; void f() { X2 file {\"Zeno\"}; // throws if file isn't open file.read(); // fine // ... } Example, bad # class X3 { // bad: the constructor leaves a non-valid object behind FILE* f; // call is_valid() before any other function bool valid; // ... public: X3(const string& name) :f{fopen(name.c_str(), \"r\")}, valid{false} { if (f) valid = true; // ... } bool is_valid() { return valid; } void read(); // read from f // ... }; void f() { X3 file {\"Heraclides\"}; file.read(); // crash or bad read! // ... if (file.is_valid()) { file.read(); // ... } else { // ... handle error ... } // ... } Note # For a variable definition (e.g., on the stack or as a member of another object) there is no explicit function call from which an error code could be returned. Leaving behind an invalid object and relying on users to consistently check an is_valid() function before use is tedious, error-prone, and inefficient. Exception # There are domains, such as some hard-real-time systems (think airplane controls) where (without additional tool support) exception handling is not sufficiently predictable from a timing perspective. There the is_valid() technique must be used. In such cases, check is_valid() consistently and immediately to simulate RAII . Alternative # If you feel tempted to use some \u201cpost-constructor initialization\u201d or \u201ctwo-stage initialization\u201d idiom, try not to do that. If you really have to, look at factory functions . Note # One reason people have used init() functions rather than doing the initialization work in a constructor has been to avoid code replication. Delegating constructors and default member initialization do that better. Another reason has been to delay initialization until an object is needed; the solution to that is often not to declare a variable until it can be properly initialized Enforcement # ??? C.43: Ensure that a copyable (value type) class has a default constructor # Reason # Many language and library facilities rely on default constructors to initialize their elements, e.g. T a[10] and std::vector<T> v(10) . A default constructor often simplifies the task of defining a suitable moved-from state for a type that is also copyable. Note # A value type is a class that is copyable (and usually also comparable). It is closely related to the notion of Regular type from EoP and the Palo Alto TR . Example # class Date { // BAD: no default constructor public: Date(int dd, int mm, int yyyy); // ... }; vector<Date> vd1(1000); // default Date needed here vector<Date> vd2(1000, Date{Month::October, 7, 1885}); // alternative The default constructor is only auto-generated if there is no user-declared constructor, hence it\u2019s impossible to initialize the vector vd1 in the example above. The absence of a default value can cause surprises for users and complicate its use, so if one can be reasonably defined, it should be. Date is chosen to encourage thought: There is no \u201cnatural\u201d default date (the big bang is too far back in time to be useful for most people), so this example is non-trivial. {0, 0, 0} is not a valid date in most calendar systems, so choosing that would be introducing something like floating-point\u2019s NaN . However, most realistic Date classes have a \u201cfirst date\u201d (e.g. January 1, 1970 is popular), so making that the default is usually trivial. class Date { public: Date(int dd, int mm, int yyyy); Date() = default; // [See also](#Rc-default) // ... private: int dd = 1; int mm = 1; int yyyy = 1970; // ... }; vector<Date> vd1(1000); Note # A class with members that all have default constructors implicitly gets a default constructor: struct X { string s; vector<int> v; }; X x; // means X{{}, {}}; that is the empty string and the empty vector Beware that built-in types are not properly default constructed: struct X { string s; int i; }; void f() { X x; // x.s is initialized to the empty string; x.i is uninitialized cout << x.s << ' ' << x.i << '\\n'; ++x.i; } Statically allocated objects of built-in types are by default initialized to 0 , but local built-in variables are not. Beware that your compiler may default initialize local built-in variables, whereas an optimized build will not. Thus, code like the example above may appear to work, but it relies on undefined behavior. Assuming that you want initialization, an explicit default initialization can help: struct X { string s; int i {}; // default initialize (to 0) }; Notes # Classes that don\u2019t have a reasonable default construction are usually not copyable either, so they don\u2019t fall under this guideline. For example, a base class is not a value type (base classes should not be copyable) and so does not necessarily need a default constructor: // Shape is an abstract base class, not a copyable value type. // It may or may not need a default constructor. struct Shape { virtual void draw() = 0; virtual void rotate(int) = 0; // =delete copy/move functions // ... }; A class that must acquire a caller-provided resource during construction often cannot have a default constructor, but it does not fall under this guideline because such a class is usually not copyable anyway: // std::lock_guard is not a copyable value type. // It does not have a default constructor. lock_guard g {mx}; // guard the mutex mx lock_guard g2; // error: guarding nothing A class that has a \u201cspecial state\u201d that must be handled separately from other states by member functions or users causes extra work (and most likely more errors). Such a type can naturally use the special state as a default constructed value, whether or not it is copyable: // std::ofstream is not a copyable value type. // It does happen to have a default constructor // that goes along with a special \"not open\" state. ofstream out {\"Foobar\"}; // ... out << log(time, transaction); Similar special-state types that are copyable, such as copyable smart pointers that have the special state \u201c==nullptr\u201d, should use the special state as their default constructed value. However, it is preferable to have a default constructor default to a meaningful state such as std::string s \"\" and std::vector s {} . Enforcement # Flag classes that are copyable by = without a default constructor Flag classes that are comparable with == but not copyable C.44: Prefer default constructors to be simple and non-throwing # Reason # Being able to set a value to \u201cthe default\u201d without operations that might fail simplifies error handling and reasoning about move operations. Example, problematic # template<typename T> // elem points to space-elem element allocated using new class Vector0 { public: Vector0() :Vector0{0} {} Vector0(int n) :elem{new T[n]}, space{elem + n}, last{elem} {} // ... private: own<T*> elem; T* space; T* last; }; This is nice and general, but setting a Vector0 to empty after an error involves an allocation, which may fail. Also, having a default Vector represented as {new T[0], 0, 0} seems wasteful. For example, Vector0<int> v[100] costs 100 allocations. Example # template<typename T> // elem is nullptr or elem points to space-elem element allocated using new class Vector1 { public: // sets the representation to {nullptr, nullptr, nullptr}; doesn't throw Vector1() noexcept {} Vector1(int n) :elem{new T[n]}, space{elem + n}, last{elem} {} // ... private: own<T*> elem = nullptr; T* space = nullptr; T* last = nullptr; }; Using {nullptr, nullptr, nullptr} makes Vector1{} cheap, but a special case and implies run-time checks. Setting a Vector1 to empty after detecting an error is trivial. Enforcement # Flag throwing default constructors C.45: Don\u2019t define a default constructor that only initializes data members; use in-class member initializers instead # Reason # Using in-class member initializers lets the compiler generate the function for you. The compiler-generated function can be more efficient. Example, bad # class X1 { // BAD: doesn't use member initializers string s; int i; public: X1() :s{\"default\"}, i{1} { } // ... }; Example # class X2 { string s = \"default\"; int i = 1; public: // use compiler-generated default constructor // ... }; Enforcement # (Simple) A default constructor should do more than just initialize member variables with constants. C.46: By default, declare single-argument constructors explicit # Reason # To avoid unintended conversions. Example, bad # class String { // ... public: String(int); // BAD // ... }; String s = 10; // surprise: string of size 10 Exception # If you really want an implicit conversion from the constructor argument type to the class type, don\u2019t use explicit : class Complex { // ... public: Complex(double d); // OK: we want a conversion from d to {d, 0} // ... }; Complex z = 10.7; // unsurprising conversion See also : Discussion of implicit conversions Note # Copy and move constructors should not be made explicit because they do not perform conversions. Explicit copy/move constructors make passing and returning by value difficult. Enforcement # (Simple) Single-argument constructors should be declared explicit . Good single argument non- explicit constructors are rare in most code bases. Warn for all that are not on a \u201cpositive list\u201d. C.47: Define and initialize member variables in the order of member declaration # Reason # To minimize confusion and errors. That is the order in which the initialization happens (independent of the order of member initializers). Example, bad # class Foo { int m1; int m2; public: Foo(int x) :m2{x}, m1{++x} { } // BAD: misleading initializer order // ... }; Foo x(1); // surprise: x.m1 == x.m2 == 2 Enforcement # (Simple) A member initializer list should mention the members in the same order they are declared. See also : Discussion C.48: Prefer in-class initializers to member initializers in constructors for constant initializers # Reason # Makes it explicit that the same value is expected to be used in all constructors. Avoids repetition. Avoids maintenance problems. It leads to the shortest and most efficient code. Example, bad # class X { // BAD int i; string s; int j; public: X() :i{666}, s{\"qqq\"} { } // j is uninitialized X(int ii) :i{ii} {} // s is \"\" and j is uninitialized // ... }; How would a maintainer know whether j was deliberately uninitialized (probably a poor idea anyway) and whether it was intentional to give s the default value \"\" in one case and qqq in another (almost certainly a bug)? The problem with j (forgetting to initialize a member) often happens when a new member is added to an existing class. Example # class X2 { int i {666}; string s {\"qqq\"}; int j {0}; public: X2() = default; // all members are initialized to their defaults X2(int ii) :i{ii} {} // s and j initialized to their defaults // ... }; Alternative : We can get part of the benefits from default arguments to constructors, and that is not uncommon in older code. However, that is less explicit, causes more arguments to be passed, and is repetitive when there is more than one constructor: class X3 { // BAD: inexplicit, argument passing overhead int i; string s; int j; public: X3(int ii = 666, const string& ss = \"qqq\", int jj = 0) :i{ii}, s{ss}, j{jj} { } // all members are initialized to their defaults // ... }; Enforcement # (Simple) Every constructor should initialize every member variable (either explicitly, via a delegating ctor call or via default construction). (Simple) Default arguments to constructors suggest an in-class initializer may be more appropriate. C.49: Prefer initialization to assignment in constructors # Reason # An initialization explicitly states that initialization, rather than assignment, is done and can be more elegant and efficient. Prevents \u201cuse before set\u201d errors. Example, good # class A { // Good string s1; public: A(czstring p) : s1{p} { } // GOOD: directly construct (and the C-string is explicitly named) // ... }; Example, bad # class B { // BAD string s1; public: B(const char* p) { s1 = p; } // BAD: default constructor followed by assignment // ... }; class C { // UGLY, aka very bad int* p; public: C() { cout << *p; p = new int{10}; } // accidental use before initialized // ... }; Example, better still # Instead of those const char* s we could use gsl::string_span or (in C++17) std::string_view as a more general way to present arguments to a function : class D { // Good string s1; public: A(string_view v) : s1{v} { } // GOOD: directly construct // ... }; C.50: Use a factory function if you need \u201cvirtual behavior\u201d during initialization # Reason # If the state of a base class object must depend on the state of a derived part of the object, we need to use a virtual function (or equivalent) while minimizing the window of opportunity to misuse an imperfectly constructed object. Note # The return type of the factory should normally be unique_ptr by default; if some uses are shared, the caller can move the unique_ptr into a shared_ptr . However, if the factory author knows that all uses of the returned object will be shared uses, return shared_ptr and use make_shared in the body to save an allocation. Example, bad # class B { public: B() { /* ... */ f(); // BAD: C.82: Don't call virtual functions in constructors and destructors /* ... */ } virtual void f() = 0; }; Example # class B { protected: class Token {}; public: explicit B(Token) { /* ... */ } // create an imperfectly initialized object virtual void f() = 0; template<class T> static shared_ptr<T> create() // interface for creating shared objects { auto p = make_shared<T>(typename T::Token{}); p->post_initialize(); return p; } protected: virtual void post_initialize() // called right after construction { /* ... */ f(); /* ... */ } // GOOD: virtual dispatch is safe }; class D : public B { // some derived class protected: class Token {}; public: explicit D(Token) : B{ B::Token{} } {} void f() override { /* ... */ }; protected: template<class T> friend shared_ptr<T> B::create(); }; shared_ptr<D> p = D::create<D>(); // creating a D object make_shared requires that the constructor is public. By requiring a protected Token the constructor cannot be publicly called anymore, so we avoid an incompletely constructed object escaping into the wild. By providing the factory function create() , we make construction (on the free store) convenient. Note # Conventional factory functions allocate on the free store, rather than on the stack or in an enclosing object. See also : Discussion C.51: Use delegating constructors to represent common actions for all constructors of a class # Reason # To avoid repetition and accidental differences. Example, bad # class Date { // BAD: repetitive int d; Month m; int y; public: Date(int dd, Month mm, year yy) :d{dd}, m{mm}, y{yy} { if (!valid(d, m, y)) throw Bad_date{}; } Date(int dd, Month mm) :d{dd}, m{mm} y{current_year()} { if (!valid(d, m, y)) throw Bad_date{}; } // ... }; The common action gets tedious to write and may accidentally not be common. Example # class Date2 { int d; Month m; int y; public: Date2(int dd, Month mm, year yy) :d{dd}, m{mm}, y{yy} { if (!valid(d, m, y)) throw Bad_date{}; } Date2(int dd, Month mm) :Date2{dd, mm, current_year()} {} // ... }; See also : If the \u201crepeated action\u201d is a simple initialization, consider an in-class member initializer . Enforcement # (Moderate) Look for similar constructor bodies. C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization # Reason # If you need those constructors for a derived class, re-implementing them is tedious and error-prone. Example # std::vector has a lot of tricky constructors, so if I want my own vector , I don\u2019t want to reimplement them: class Rec { // ... data and lots of nice constructors ... }; class Oper : public Rec { using Rec::Rec; // ... no data members ... // ... lots of nice utility functions ... }; Example, bad # struct Rec2 : public Rec { int x; using Rec::Rec; }; Rec2 r {\"foo\", 7}; int val = r.x; // uninitialized Enforcement # Make sure that every member of the derived class is initialized. C.copy: Copy and move # Value types should generally be copyable, but interfaces in a class hierarchy should not. Resource handles may or may not be copyable. Types can be defined to move for logical as well as performance reasons. C.60: Make copy assignment non- virtual , take the parameter by const& , and return by non- const& # Reason # It is simple and efficient. If you want to optimize for rvalues, provide an overload that takes a && (see F.18 ). Example # class Foo { public: Foo& operator=(const Foo& x) { // GOOD: no need to check for self-assignment (other than performance) auto tmp = x; swap(tmp); // see C.83 return *this; } // ... }; Foo a; Foo b; Foo f(); a = b; // assign lvalue: copy a = f(); // assign rvalue: potentially move Note # The swap implementation technique offers the strong guarantee . Example # But what if you can get significantly better performance by not making a temporary copy? Consider a simple Vector intended for a domain where assignment of large, equal-sized Vector s is common. In this case, the copy of elements implied by the swap implementation technique could cause an order of magnitude increase in cost: template<typename T> class Vector { public: Vector& operator=(const Vector&); // ... private: T* elem; int sz; }; Vector& Vector::operator=(const Vector& a) { if (a.sz > sz) { // ... use the swap technique, it can't be bettered ... return *this; } // ... copy sz elements from *a.elem to elem ... if (a.sz < sz) { // ... destroy the surplus elements in *this and adjust size ... } return *this; } By writing directly to the target elements, we will get only the basic guarantee rather than the strong guarantee offered by the swap technique. Beware of self-assignment . Alternatives : If you think you need a virtual assignment operator, and understand why that\u2019s deeply problematic, don\u2019t call it operator= . Make it a named function like virtual void assign(const Foo&) . See copy constructor vs. clone() . Enforcement # (Simple) An assignment operator should not be virtual. Here be dragons! (Simple) An assignment operator should return T& to enable chaining, not alternatives like const T& which interfere with composability and putting objects in containers. (Moderate) An assignment operator should (implicitly or explicitly) invoke all base and member assignment operators. Look at the destructor to determine if the type has pointer semantics or value semantics. C.61: A copy operation should copy # Reason # That is the generally assumed semantics. After x = y , we should have x == y . After a copy x and y can be independent objects (value semantics, the way non-pointer built-in types and the standard-library types work) or refer to a shared object (pointer semantics, the way pointers work). Example # class X { // OK: value semantics public: X(); X(const X&); // copy X void modify(); // change the value of X // ... ~X() { delete[] p; } private: T* p; int sz; }; bool operator==(const X& a, const X& b) { return a.sz == b.sz && equal(a.p, a.p + a.sz, b.p, b.p + b.sz); } X::X(const X& a) :p{new T[a.sz]}, sz{a.sz} { copy(a.p, a.p + sz, p); } X x; X y = x; if (x != y) throw Bad{}; x.modify(); if (x == y) throw Bad{}; // assume value semantics Example # class X2 { // OK: pointer semantics public: X2(); X2(const X2&) = default; // shallow copy ~X2() = default; void modify(); // change the pointed-to value // ... private: T* p; int sz; }; bool operator==(const X2& a, const X2& b) { return a.sz == b.sz && a.p == b.p; } X2 x; X2 y = x; if (x != y) throw Bad{}; x.modify(); if (x != y) throw Bad{}; // assume pointer semantics Note # Prefer value semantics unless you are building a \u201csmart pointer\u201d. Value semantics is the simplest to reason about and what the standard-library facilities expect. Enforcement # (Not enforceable) C.62: Make copy assignment safe for self-assignment # Reason # If x = x changes the value of x , people will be surprised and bad errors will occur (often including leaks). Example # The standard-library containers handle self-assignment elegantly and efficiently: std::vector<int> v = {3, 1, 4, 1, 5, 9}; v = v; // the value of v is still {3, 1, 4, 1, 5, 9} Note # The default assignment generated from members that handle self-assignment correctly handles self-assignment. struct Bar { vector<pair<int, int>> v; map<string, int> m; string s; }; Bar b; // ... b = b; // correct and efficient Note # You can handle self-assignment by explicitly testing for self-assignment, but often it is faster and more elegant to cope without such a test (e.g., using swap ). class Foo { string s; int i; public: Foo& operator=(const Foo& a); // ... }; Foo& Foo::operator=(const Foo& a) // OK, but there is a cost { if (this == &a) return *this; s = a.s; i = a.i; return *this; } This is obviously safe and apparently efficient. However, what if we do one self-assignment per million assignments? That\u2019s about a million redundant tests (but since the answer is essentially always the same, the computer\u2019s branch predictor will guess right essentially every time). Consider: Foo& Foo::operator=(const Foo& a) // simpler, and probably much better { s = a.s; i = a.i; return *this; } std::string is safe for self-assignment and so are int . All the cost is carried by the (rare) case of self-assignment. Enforcement # (Simple) Assignment operators should not contain the pattern if (this == &a) return *this; ??? C.63: Make move assignment non- virtual , take the parameter by && , and return by non- const & # Reason # It is simple and efficient. See : The rule for copy-assignment . Enforcement # Equivalent to what is done for copy-assignment . (Simple) An assignment operator should not be virtual. Here be dragons! (Simple) An assignment operator should return T& to enable chaining, not alternatives like const T& which interfere with composability and putting objects in containers. (Moderate) A move assignment operator should (implicitly or explicitly) invoke all base and member move assignment operators. C.64: A move operation should move and leave its source in a valid state # Reason # That is the generally assumed semantics. After y = std::move(x) the value of y should be the value x had and x should be in a valid state. Example # template<typename T> class X { // OK: value semantics public: X(); X(X&& a) noexcept; // move X void modify(); // change the value of X // ... ~X() { delete[] p; } private: T* p; int sz; }; X::X(X&& a) :p{a.p}, sz{a.sz} // steal representation { a.p = nullptr; // set to \"empty\" a.sz = 0; } void use() { X x{}; // ... X y = std::move(x); x = X{}; // OK } // OK: x can be destroyed Note # Ideally, that moved-from should be the default value of the type. Ensure that unless there is an exceptionally good reason not to. However, not all types have a default value and for some types establishing the default value can be expensive. The standard requires only that the moved-from object can be destroyed. Often, we can easily and cheaply do better: The standard library assumes that it is possible to assign to a moved-from object. Always leave the moved-from object in some (necessarily specified) valid state. Note # Unless there is an exceptionally strong reason not to, make x = std::move(y); y = z; work with the conventional semantics. Enforcement # (Not enforceable) Look for assignments to members in the move operation. If there is a default constructor, compare those assignments to the initializations in the default constructor. C.65: Make move assignment safe for self-assignment # Reason # If x = x changes the value of x , people will be surprised and bad errors may occur. However, people don\u2019t usually directly write a self-assignment that turn into a move, but it can occur. However, std::swap is implemented using move operations so if you accidentally do swap(a, b) where a and b refer to the same object, failing to handle self-move could be a serious and subtle error. Example # class Foo { string s; int i; public: Foo& operator=(Foo&& a); // ... }; Foo& Foo::operator=(Foo&& a) noexcept // OK, but there is a cost { if (this == &a) return *this; // this line is redundant s = std::move(a.s); i = a.i; return *this; } The one-in-a-million argument against if (this == &a) return *this; tests from the discussion of self-assignment is even more relevant for self-move. Note # There is no known general way of avoiding an if (this == &a) return *this; test for a move assignment and still get a correct answer (i.e., after x = x the value of x is unchanged). Note # The ISO standard guarantees only a \u201cvalid but unspecified\u201d state for the standard-library containers. Apparently this has not been a problem in about 10 years of experimental and production use. Please contact the editors if you find a counter example. The rule here is more caution and insists on complete safety. Example # Here is a way to move a pointer without a test (imagine it as code in the implementation a move assignment): // move from other.ptr to this->ptr T* temp = other.ptr; other.ptr = nullptr; delete ptr; ptr = temp; Enforcement # (Moderate) In the case of self-assignment, a move assignment operator should not leave the object holding pointer members that have been delete d or set to nullptr . (Not enforceable) Look at the use of standard-library container types (incl. string ) and consider them safe for ordinary (not life-critical) uses. C.66: Make move operations noexcept # Reason # A throwing move violates most people\u2019s reasonably assumptions. A non-throwing move will be used more efficiently by standard-library and language facilities. Example # template<typename T> class Vector { // ... Vector(Vector&& a) noexcept :elem{a.elem}, sz{a.sz} { a.sz = 0; a.elem = nullptr; } Vector& operator=(Vector&& a) noexcept { elem = a.elem; sz = a.sz; a.sz = 0; a.elem = nullptr; } // ... public: T* elem; int sz; }; These operations do not throw. Example, bad # template<typename T> class Vector2 { // ... Vector2(Vector2&& a) { *this = a; } // just use the copy Vector2& operator=(Vector2&& a) { *this = a; } // just use the copy // ... public: T* elem; int sz; }; This Vector2 is not just inefficient, but since a vector copy requires allocation, it can throw. Enforcement # (Simple) A move operation should be marked noexcept . C.67: A polymorphic class should suppress copying # Reason # A polymorphic class is a class that defines or inherits at least one virtual function. It is likely that it will be used as a base class for other derived classes with polymorphic behavior. If it is accidentally passed by value, with the implicitly generated copy constructor and assignment, we risk slicing: only the base portion of a derived object will be copied, and the polymorphic behavior will be corrupted. Example, bad # class B { // BAD: polymorphic base class doesn't suppress copying public: virtual char m() { return 'B'; } // ... nothing about copy operations, so uses default ... }; class D : public B { public: char m() override { return 'D'; } // ... }; void f(B& b) { auto b2 = b; // oops, slices the object; b2.m() will return 'B' } D d; f(d); Example # class B { // GOOD: polymorphic class suppresses copying public: B(const B&) = delete; B& operator=(const B&) = delete; virtual char m() { return 'B'; } // ... }; class D : public B { public: char m() override { return 'D'; } // ... }; void f(B& b) { auto b2 = b; // ok, compiler will detect inadvertent copying, and protest } D d; f(d); Note # If you need to create deep copies of polymorphic objects, use clone() functions: see C.130 . Exception # Classes that represent exception objects need both to be polymorphic and copy-constructible. Enforcement # Flag a polymorphic class with a non-deleted copy operation. Flag an assignment of polymorphic class objects. C.other: Other default operation rules # In addition to the operations for which the language offer default implementations, there are a few operations that are so foundational that it rules for their definition are needed: comparisons, swap , and hash . C.80: Use =default if you have to be explicit about using the default semantics # Reason # The compiler is more likely to get the default semantics right and you cannot implement these functions better than the compiler. Example # class Tracer { string message; public: Tracer(const string& m) : message{m} { cerr << \"entering \" << message << '\\n'; } ~Tracer() { cerr << \"exiting \" << message << '\\n'; } Tracer(const Tracer&) = default; Tracer& operator=(const Tracer&) = default; Tracer(Tracer&&) = default; Tracer& operator=(Tracer&&) = default; }; Because we defined the destructor, we must define the copy and move operations. The = default is the best and simplest way of doing that. Example, bad # class Tracer2 { string message; public: Tracer2(const string& m) : message{m} { cerr << \"entering \" << message << '\\n'; } ~Tracer2() { cerr << \"exiting \" << message << '\\n'; } Tracer2(const Tracer2& a) : message{a.message} {} Tracer2& operator=(const Tracer2& a) { message = a.message; return *this; } Tracer2(Tracer2&& a) :message{a.message} {} Tracer2& operator=(Tracer2&& a) { message = a.message; return *this; } }; Writing out the bodies of the copy and move operations is verbose, tedious, and error-prone. A compiler does it better. Enforcement # (Moderate) The body of a special operation should not have the same accessibility and semantics as the compiler-generated version, because that would be redundant C.81: Use =delete when you want to disable default behavior (without wanting an alternative) # Reason # In a few cases, a default operation is not desirable. Example # class Immortal { public: ~Immortal() = delete; // do not allow destruction // ... }; void use() { Immortal ugh; // error: ugh cannot be destroyed Immortal* p = new Immortal{}; delete p; // error: cannot destroy *p } Example # A unique_ptr can be moved, but not copied. To achieve that its copy operations are deleted. To avoid copying it is necessary to =delete its copy operations from lvalues: template <class T, class D = default_delete<T>> class unique_ptr { public: // ... constexpr unique_ptr() noexcept; explicit unique_ptr(pointer p) noexcept; // ... unique_ptr(unique_ptr&& u) noexcept; // move constructor // ... unique_ptr(const unique_ptr&) = delete; // disable copy from lvalue // ... }; unique_ptr<int> make(); // make \"something\" and return it by moving void f() { unique_ptr<int> pi {}; auto pi2 {pi}; // error: no move constructor from lvalue auto pi3 {make()}; // OK, move: the result of make() is an rvalue } Note that deleted functions should be public. Enforcement # The elimination of a default operation is (should be) based on the desired semantics of the class. Consider such classes suspect, but maintain a \u201cpositive list\u201d of classes where a human has asserted that the semantics is correct. C.82: Don\u2019t call virtual functions in constructors and destructors # Reason # The function called will be that of the object constructed so far, rather than a possibly overriding function in a derived class. This can be most confusing. Worse, a direct or indirect call to an unimplemented pure virtual function from a constructor or destructor results in undefined behavior. Example, bad # class Base { public: virtual void f() = 0; // not implemented virtual void g(); // implemented with Base version virtual void h(); // implemented with Base version virtual ~Base(); // implemented with Base version }; class Derived : public Base { public: void g() override; // provide Derived implementation void h() final; // provide Derived implementation Derived() { // BAD: attempt to call an unimplemented virtual function f(); // BAD: will call Derived::g, not dispatch further virtually g(); // GOOD: explicitly state intent to call only the visible version Derived::g(); // ok, no qualification needed, h is final h(); } }; Note that calling a specific explicitly qualified function is not a virtual call even if the function is virtual . See also factory functions for how to achieve the effect of a call to a derived class function without risking undefined behavior. Note # There is nothing inherently wrong with calling virtual functions from constructors and destructors. The semantics of such calls is type safe. However, experience shows that such calls are rarely needed, easily confuse maintainers, and become a source of errors when used by novices. Enforcement # Flag calls of virtual functions from constructors and destructors. C.83: For value-like types, consider providing a noexcept swap function # Reason # A swap can be handy for implementing a number of idioms, from smoothly moving objects around to implementing assignment easily to providing a guaranteed commit function that enables strongly error-safe calling code. Consider using swap to implement copy assignment in terms of copy construction. See also destructors, deallocation, and swap must never fail . Example, good # class Foo { // ... public: void swap(Foo& rhs) noexcept { m1.swap(rhs.m1); std::swap(m2, rhs.m2); } private: Bar m1; int m2; }; Providing a nonmember swap function in the same namespace as your type for callers\u2019 convenience. void swap(Foo& a, Foo& b) { a.swap(b); } Enforcement # (Simple) A class without virtual functions should have a swap member function declared. (Simple) When a class has a swap member function, it should be declared noexcept . C.84: A swap function may not fail # Reason # swap is widely used in ways that are assumed never to fail and programs cannot easily be written to work correctly in the presence of a failing swap . The standard-library containers and algorithms will not work correctly if a swap of an element type fails. Example, bad # void swap(My_vector& x, My_vector& y) { auto tmp = x; // copy elements x = y; y = tmp; } This is not just slow, but if a memory allocation occurs for the elements in tmp , this swap may throw and would make STL algorithms fail if used with them. Enforcement # (Simple) When a class has a swap member function, it should be declared noexcept . C.85: Make swap noexcept # Reason # A swap may not fail . If a swap tries to exit with an exception, it\u2019s a bad design error and the program had better terminate. Enforcement # (Simple) When a class has a swap member function, it should be declared noexcept . C.86: Make == symmetric with respect to operand types and noexcept # Reason # Asymmetric treatment of operands is surprising and a source of errors where conversions are possible. == is a fundamental operations and programmers should be able to use it without fear of failure. Example # struct X { string name; int number; }; bool operator==(const X& a, const X& b) noexcept { return a.name == b.name && a.number == b.number; } Example, bad # class B { string name; int number; bool operator==(const B& a) const { return name == a.name && number == a.number; } // ... }; B \u2018s comparison accepts conversions for its second operand, but not its first. Note # If a class has a failure state, like double \u2018s NaN , there is a temptation to make a comparison against the failure state throw. The alternative is to make two failure states compare equal and any valid state compare false against the failure state. Note # This rule applies to all the usual comparison operators: != , < , <= , > , and >= . Enforcement # Flag an operator==() for which the argument types differ; same for other comparison operators: != , < , <= , > , and >= . Flag member operator==() s; same for other comparison operators: != , < , <= , > , and >= . C.87: Beware of == on base classes # Reason # It is really hard to write a foolproof and useful == for a hierarchy. Example, bad # class B { string name; int number; virtual bool operator==(const B& a) const { return name == a.name && number == a.number; } // ... }; B \u2018s comparison accepts conversions for its second operand, but not its first. class D :B { char character; virtual bool operator==(const D& a) const { return name == a.name && number == a.number && character == a.character; } // ... }; B b = ... D d = ... b == d; // compares name and number, ignores d's character d == b; // error: no == defined D d2; d == d2; // compares name, number, and character B& b2 = d2; b2 == d; // compares name and number, ignores d2's and d's character Of course there are ways of making == work in a hierarchy, but the naive approaches do not scale Note # This rule applies to all the usual comparison operators: != , < , <= , > , and >= . Enforcement # Flag a virtual operator==() ; same for other comparison operators: != , < , <= , > , and >= . C.89: Make a hash noexcept # Reason # Users of hashed containers use hash indirectly and don\u2019t expect simple access to throw. It\u2019s a standard-library requirement. Example, bad # template<> struct hash<My_type> { // thoroughly bad hash specialization using result_type = size_t; using argument_type = My_type; size_t operator() (const My_type & x) const { size_t xs = x.s.size(); if (xs < 4) throw Bad_My_type{}; // \"Nobody expects the Spanish inquisition!\" return hash<size_t>()(x.s.size()) ^ trim(x.s); } }; int main() { unordered_map<My_type, int> m; My_type mt{ \"asdfg\" }; m[mt] = 7; cout << m[My_type{ \"asdfg\" }] << '\\n'; } If you have to define a hash specialization, try simply to let it combine standard-library hash specializations with ^ (xor). That tends to work better than \u201ccleverness\u201d for non-specialists. Enforcement # Flag throwing hash es. C.con: Containers and other resource handles # A container is an object holding a sequence of objects of some type; std::vector is the archetypical container. A resource handle is a class that owns a resource; std::vector is the typical resource handle; its resource is its sequence of elements. Summary of container rules: C.100: Follow the STL when defining a container C.101: Give a container value semantics C.102: Give a container move operations C.103: Give a container an initializer list constructor C.104: Give a container a default constructor that sets it to empty ??? C.109: If a resource handle has pointer semantics, provide * and -> See also : Resources C.100: Follow the STL when defining a container # Reason # The STL containers are familiar to most C++ programmers and a fundamentally sound design. Note # There are of course other fundamentally sound design styles and sometimes reasons to depart from the style of the standard library, but in the absence of a solid reason to differ, it is simpler and easier for both implementers and users to follow the standard. In particular, std::vector and std::map provide useful relatively simple models. Example # // simplified (e.g., no allocators): template<typename T> class Sorted_vector { using value_type = T; // ... iterator types ... Sorted_vector() = default; Sorted_vector(initializer_list<T>); // initializer-list constructor: sort and store Sorted_vector(const Sorted_vector&) = default; Sorted_vector(Sorted_vector&&) = default; Sorted_vector& operator=(const Sorted_vector&) = default; // copy assignment Sorted_vector& operator=(Sorted_vector&&) = default; // move assignment ~Sorted_vector() = default; Sorted_vector(const std::vector<T>& v); // store and sort Sorted_vector(std::vector<T>&& v); // sort and \"steal representation\" const T& operator[](int i) const { return rep[i]; } // no non-const direct access to preserve order void push_back(const T&); // insert in the right place (not necessarily at back) void push_back(T&&); // insert in the right place (not necessarily at back) // ... cbegin(), cend() ... private: std::vector<T> rep; // use a std::vector to hold elements }; template<typename T> bool operator==(const Sorted_vector<T>&, const Sorted_vector<T>&); template<typename T> bool operator!=(const Sorted_vector<T>&, const Sorted_vector<T>&); // ... Here, the STL style is followed, but incompletely. That\u2019s not uncommon. Provide only as much functionality as makes sense for a specific container. The key is to define the conventional constructors, assignments, destructors, and iterators (as meaningful for the specific container) with their conventional semantics. From that base, the container can be expanded as needed. Here, special constructors from std::vector were added. Enforcement # ??? C.101: Give a container value semantics # Reason # Regular objects are simpler to think and reason about than irregular ones. Familiarity. Note # If meaningful, make a container Regular (the concept). In particular, ensure that an object compares equal to its copy. Example # void f(const Sorted_vector<string>& v) { Sorted_vector<string> v2 {v}; if (v != v2) cout << \"insanity rules!\\n\"; // ... } Enforcement # ??? C.102: Give a container move operations # Reason # Containers tend to get large; without a move constructor and a copy constructor an object can be expensive to move around, thus tempting people to pass pointers to it around and getting into resource management problems. Example # Sorted_vector<int> read_sorted(istream& is) { vector<int> v; cin >> v; // assume we have a read operation for vectors Sorted_vector<int> sv = v; // sorts return sv; } A user can reasonably assume that returning a standard-like container is cheap. Enforcement # ??? C.103: Give a container an initializer list constructor # Reason # People expect to be able to initialize a container with a set of values. Familiarity. Example # Sorted_vector<int> sv {1, 3, -1, 7, 0, 0}; // Sorted_vector sorts elements as needed Enforcement # ??? C.104: Give a container a default constructor that sets it to empty # Reason # To make it Regular . Example # vector<Sorted_sequence<string>> vs(100); // 100 Sorted_sequences each with the value \"\" Enforcement # ??? C.109: If a resource handle has pointer semantics, provide * and -> # Reason # That\u2019s what is expected from pointers. Familiarity. Example # ??? Enforcement # ??? C.lambdas: Function objects and lambdas # A function object is an object supplying an overloaded () so that you can call it. A lambda expression (colloquially often shortened to \u201ca lambda\u201d) is a notation for generating a function object. Function objects should be cheap to copy (and therefore passed by value ). Summary: F.50: Use a lambda when a function won\u2019t do (to capture local variables, or to write a local function) F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread ES.28: Use lambdas for complex initialization, especially of const variables C.hier: Class hierarchies (OOP) # A class hierarchy is constructed to represent a set of hierarchically organized concepts (only). Typically base classes act as interfaces. There are two major uses for hierarchies, often named implementation inheritance and interface inheritance. Class hierarchy rule summary: C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only) C.121: If a base class is used as an interface, make it a pure abstract class C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed Designing rules for classes in a hierarchy summary: C.126: An abstract class typically doesn\u2019t need a constructor C.127: A class with a virtual function should have a virtual or protected destructor C.128: Virtual functions should specify exactly one of virtual , override , or final C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance C.130: For making deep copies of polymorphic classes prefer a virtual clone function instead of copy construction/assignment C.131: Avoid trivial getters and setters C.132: Don\u2019t make a function virtual without reason C.133: Avoid protected data C.134: Ensure all non- const data members have the same access level C.135: Use multiple inheritance to represent multiple distinct interfaces C.136: Use multiple inheritance to represent the union of implementation attributes C.137: Use virtual bases to avoid overly general base classes C.138: Create an overload set for a derived class and its bases with using C.139: Use final sparingly C.140: Do not provide different default arguments for a virtual function and an overrider Accessing objects in a hierarchy rule summary: C.145: Access polymorphic objects through pointers and references C.146: Use dynamic_cast where class hierarchy navigation is unavoidable C.147: Use dynamic_cast to a reference type when failure to find the required class is considered an error C.148: Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative C.149: Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new C.150: Use make_unique() to construct objects owned by unique_ptr s C.151: Use make_shared() to construct objects owned by shared_ptr s C.152: Never assign a pointer to an array of derived class objects to a pointer to its base C.153: Prefer virtual function to casting C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only) # Reason # Direct representation of ideas in code eases comprehension and maintenance. Make sure the idea represented in the base class exactly matches all derived types and there is not a better way to express it than using the tight coupling of inheritance. Do not use inheritance when simply having a data member will do. Usually this means that the derived type needs to override a base virtual function or needs access to a protected member. Example # class DrawableUIElement { public: virtual void render() const = 0; // ... }; class AbstractButton : public DrawableUIElement { public: virtual void onClick() = 0; // ... }; class PushButton : public AbstractButton { void render() const override; void onClick() override; // ... }; class Checkbox : public AbstractButton { // ... }; Example, bad # Do not represent non-hierarchical domain concepts as class hierarchies. template<typename T> class Container { public: // list operations: virtual T& get() = 0; virtual void put(T&) = 0; virtual void insert(Position) = 0; // ... // vector operations: virtual T& operator[](int) = 0; virtual void sort() = 0; // ... // tree operations: virtual void balance() = 0; // ... }; Here most overriding classes cannot implement most of the functions required in the interface well. Thus the base class becomes an implementation burden. Furthermore, the user of Container cannot rely on the member functions actually performing meaningful operations reasonably efficiently; it may throw an exception instead. Thus users have to resort to run-time checking and/or not using this (over)general interface in favor of a particular interface found by a run-time type inquiry (e.g., a dynamic_cast ). Enforcement # Look for classes with lots of members that do nothing but throw. Flag every use of a nonpublic base class B where the derived class D does not override a virtual function or access a protected member in B , and B is not one of the following: empty, a template parameter or parameter pack of D , a class template specialized with D . C.121: If a base class is used as an interface, make it a pure abstract class # Reason # A class is more stable (less brittle) if it does not contain data. Interfaces should normally be composed entirely of public pure virtual functions and a default/empty virtual destructor. Example # class My_interface { public: // ...only pure virtual functions here ... virtual ~My_interface() {} // or =default }; Example, bad # class Goof { public: // ...only pure virtual functions here ... // no virtual destructor }; class Derived : public Goof { string s; // ... }; void use() { unique_ptr<Goof> p {new Derived{\"here we go\"}}; f(p.get()); // use Derived through the Goof interface g(p.get()); // use Derived through the Goof interface } // leak The Derived is delete d through its Goof interface, so its string is leaked. Give Goof a virtual destructor and all is well. Enforcement # Warn on any class that contains data members and also has an overridable (non- final ) virtual function. C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed # Reason # Such as on an ABI (link) boundary. Example # struct Device { virtual ~Device() = default; virtual void write(span<const char> outbuf) = 0; virtual void read(span<char> inbuf) = 0; }; class D1 : public Device { // ... data ... void write(span<const char> outbuf) override; void read(span<char> inbuf) override; }; class D2 : public Device { // ... different data ... void write(span<const char> outbuf) override; void read(span<char> inbuf) override; }; A user can now use D1 s and D2 s interchangeably through the interface provided by Device . Furthermore, we can update D1 and D2 in ways that are not binary compatible with older versions as long as all access goes through Device . Enforcement # ??? C.hierclass: Designing classes in a hierarchy: # C.126: An abstract class typically doesn\u2019t need a constructor # Reason # An abstract class typically does not have any data for a constructor to initialize. Example # ??? Exception # A base class constructor that does work, such as registering an object somewhere, may need a constructor. In extremely rare cases, you might find it reasonable for an abstract class to have a bit of data shared by all derived classes (e.g., use statistics data, debug information, etc.); such classes tend to have constructors. But be warned: Such classes also tend to be prone to requiring virtual inheritance. Enforcement # Flag abstract classes with constructors. C.127: A class with a virtual function should have a virtual or protected destructor # Reason # A class with a virtual function is usually (and in general) used via a pointer to base. Usually, the last user has to call delete on a pointer to base, often via a smart pointer to base, so the destructor should be public and virtual. Less commonly, if deletion through a pointer to base is not intended to be supported, the destructor should be protected and nonvirtual; see C.35 . Example, bad # struct B { virtual int f() = 0; // ... no user-written destructor, defaults to public nonvirtual ... }; // bad: derived from a class without a virtual destructor struct D : B { string s {\"default\"}; }; void use() { unique_ptr<B> p = make_unique<D>(); // ... } // undefined behavior. May call B::~B only and leak the string Note # There are people who don\u2019t follow this rule because they plan to use a class only through a shared_ptr : std::shared_ptr<B> p = std::make_shared<D>(args); Here, the shared pointer will take care of deletion, so no leak will occur from an inappropriate delete of the base. People who do this consistently can get a false positive, but the rule is important \u2013 what if one was allocated using make_unique ? It\u2019s not safe unless the author of B ensures that it can never be misused, such as by making all constructors private and providing a factory function to enforce the allocation with make_shared . Enforcement # A class with any virtual functions should have a destructor that is either public and virtual or else protected and nonvirtual. Flag delete of a class with a virtual function but no virtual destructor. C.128: Virtual functions should specify exactly one of virtual , override , or final # Reason # Readability. Detection of mistakes. Writing explicit virtual , override , or final is self-documenting and enables the compiler to catch mismatch of types and/or names between base and derived classes. However, writing more than one of these three is both redundant and a potential source of errors. It\u2019s simple and clear: virtual means exactly and only \u201cthis is a new virtual function.\u201d override means exactly and only \u201cthis is a non-final overrider.\u201d final means exactly and only \u201cthis is a final overrider.\u201d Example, bad # struct B { void f1(int); virtual void f2(int) const; virtual void f3(int); // ... }; struct D : B { void f1(int); // bad (hope for a warning): D::f1() hides B::f1() void f2(int) const; // bad (but conventional and valid): no explicit override void f3(double); // bad (hope for a warning): D::f3() hides B::f3() // ... }; Example, good # struct Better : B { void f1(int) override; // error (caught): Better::f1() hides B::f1() void f2(int) const override; void f3(double) override; // error (caught): Better::f3() hides B::f3() // ... }; Discussion # We want to eliminate two particular classes of errors: implicit virtual : the programmer intended the function to be implicitly virtual and it is (but readers of the code can\u2019t tell); or the programmer intended the function to be implicitly virtual but it isn\u2019t (e.g., because of a subtle parameter list mismatch); or the programmer did not intend the function to be virtual but it is (because it happens to have the same signature as a virtual in the base class) implicit override : the programmer intended the function to be implicitly an overrider and it is (but readers of the code can\u2019t tell); or the programmer intended the function to be implicitly an overrider but it isn\u2019t (e.g., because of a subtle parameter list mismatch); or the programmer did not intend the function to be an overrider but it is (because it happens to have the same signature as a virtual in the base class \u2013 note this problem arises whether or not the function is explicitly declared virtual, because the programmer may have intended to create either a new virtual function or a new nonvirtual function) Enforcement # Compare virtual function names in base and derived classes and flag uses of the same name that does not override. Flag overrides with neither override nor final . Flag function declarations that use more than one of virtual , override , and final . C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance # Reason # Implementation details in an interface make the interface brittle; that is, make its users vulnerable to having to recompile after changes in the implementation. Data in a base class increases the complexity of implementing the base and can lead to replication of code. Note # Definition: interface inheritance is the use of inheritance to separate users from implementations, in particular to allow derived classes to be added and changed without affecting the users of base classes. implementation inheritance is the use of inheritance to simplify implementation of new facilities by making useful operations available for implementers of related new operations (sometimes called \u201cprogramming by difference\u201d). A pure interface class is simply a set of pure virtual functions; see I.25 . In early OOP (e.g., in the 1980s and 1990s), implementation inheritance and interface inheritance were often mixed and bad habits die hard. Even now, mixtures are not uncommon in old code bases and in old-style teaching material. The importance of keeping the two kinds of inheritance increases with the size of a hierarchy (e.g., dozens of derived classes), with the length of time the hierarchy is used (e.g., decades), and with the number of distinct organizations in which a hierarchy is used (e.g., it can be difficult to distribute an update to a base class) Example, bad # class Shape { // BAD, mixed interface and implementation public: Shape(); Shape(Point ce = {0, 0}, Color co = none): cent{ce}, col {co} { /* ... */} Point center() const { return cent; } Color color() const { return col; } virtual void rotate(int) = 0; virtual void move(Point p) { cent = p; redraw(); } virtual void redraw(); // ... private: Point cent; Color col; }; class Circle : public Shape { public: Circle(Point c, int r) :Shape{c}, rad{r} { /* ... */ } // ... private: int rad; }; class Triangle : public Shape { public: Triangle(Point p1, Point p2, Point p3); // calculate center // ... }; Problems: As the hierarchy grows and more data is added to Shape , the constructors get harder to write and maintain. Why calculate the center for the Triangle ? we may never use it. Add a data member to Shape (e.g., drawing style or canvas) and all classes derived from Shape and all code using Shape will need to be reviewed, possibly changed, and probably recompiled. The implementation of Shape::move() is an example of implementation inheritance: we have defined move() once and for all for all derived classes. The more code there is in such base class member function implementations and the more data is shared by placing it in the base, the more benefits we gain - and the less stable the hierarchy is. Example # This Shape hierarchy can be rewritten using interface inheritance: class Shape { // pure interface public: virtual Point center() const = 0; virtual Color color() const = 0; virtual void rotate(int) = 0; virtual void move(Point p) = 0; virtual void redraw() = 0; // ... }; Note that a pure interface rarely has constructors: there is nothing to construct. class Circle : public Shape { public: Circle(Point c, int r, Color c) :cent{c}, rad{r}, col{c} { /* ... */ } Point center() const override { return cent; } Color color() const override { return col; } // ... private: Point cent; int rad; Color col; }; The interface is now less brittle, but there is more work in implementing the member functions. For example, center has to be implemented by every class derived from Shape . Example, dual hierarchy # How can we gain the benefit of stable hierarchies from implementation hierarchies and the benefit of implementation reuse from implementation inheritance? One popular technique is dual hierarchies. There are many ways of implementing the idea of dual hierarchies; here, we use a multiple-inheritance variant. First we devise a hierarchy of interface classes: class Shape { // pure interface public: virtual Point center() const = 0; virtual Color color() const = 0; virtual void rotate(int) = 0; virtual void move(Point p) = 0; virtual void redraw() = 0; // ... }; class Circle : public virtual Shape { // pure interface public: virtual int radius() = 0; // ... }; To make this interface useful, we must provide its implementation classes (here, named equivalently, but in the Impl namespace): class Impl::Shape : public virtual ::Shape { // implementation public: // constructors, destructor // ... Point center() const override { /* ... */ } Color color() const override { /* ... */ } void rotate(int) override { /* ... */ } void move(Point p) override { /* ... */ } void redraw() override { /* ... */ } // ... }; Now Shape is a poor example of a class with an implementation, but bear with us because this is just a simple example of a technique aimed at more complex hierarchies. class Impl::Circle : public virtual ::Circle, public Impl::Shape { // implementation public: // constructors, destructor int radius() override { /* ... */ } // ... }; And we could extend the hierarchies by adding a Smiley class (:-)): class Smiley : public virtual Circle { // pure interface public: // ... }; class Impl::Smiley : public virtual ::Smiley, public Impl::Circle { // implementation public: // constructors, destructor // ... } There are now two hierarchies: interface: Smiley -> Circle -> Shape implementation: Impl::Smiley -> Impl::Circle -> Impl::Shape Since each implementation is derived from its interface as well as its implementation base class we get a lattice (DAG): Smiley -> Circle -> Shape ^ ^ ^ | | | Impl::Smiley -> Impl::Circle -> Impl::Shape As mentioned, this is just one way to construct a dual hierarchy. The implementation hierarchy can be used directly, rather than through the abstract interface. void work_with_shape(Shape&); int user() { Impl::Smiley my_smiley{ /* args */ }; // create concrete shape // ... my_smiley.some_member(); // use implementation class directly // ... work_with_shape(my_smiley); // use implementation through abstract interface // ... } This can be useful when the implementation class has members that are not offered in the abstract interface or if direct use of a member offers optimization opportunities (e.g., if an implementation member function is final ) Note # Another (related) technique for separating interface and implementation is Pimpl . Note # There is often a choice between offering common functionality as (implemented) base class functions and free-standing functions (in an implementation namespace). Base classes gives a shorter notation and easier access to shared data (in the base) at the cost of the functionality being available only to users of the hierarchy. Enforcement # Flag a derived to base conversion to a base with both data and virtual functions (except for calls from a derived class member to a base class member) ??? C.130: For making deep copies of polymorphic classes prefer a virtual clone function instead of copy construction/assignment # Reason # Copying a polymorphic class is discouraged due to the slicing problem, see C.67 . If you really need copy semantics, copy deeply: Provide a virtual clone function that will copy the actual most-derived type and return an owning pointer to the new object, and then in derived classes return the derived type (use a covariant return type). Example # class B { public: virtual owner<B*> clone() = 0; virtual ~B() = default; B(const B&) = delete; B& operator=(const B&) = delete; }; class D : public B { public: owner<D*> clone() override; ~D() override; }; Generally, it is recommended to use smart pointers to represent ownership (see R.20 ). However, because of language rules, the covariant return type cannot be a smart pointer: D::clone can\u2019t return a unique_ptr<D> while B::clone returns unique_ptr<B> . Therefore, you either need to consistently return unique_ptr<B> in all overrides, or use owner<> utility from the Guidelines Support Library . C.131: Avoid trivial getters and setters # Reason # A trivial getter or setter adds no semantic value; the data item could just as well be public . Example # class Point { // Bad: verbose int x; int y; public: Point(int xx, int yy) : x{xx}, y{yy} { } int get_x() const { return x; } void set_x(int xx) { x = xx; } int get_y() const { return y; } void set_y(int yy) { y = yy; } // no behavioral member functions }; Consider making such a class a struct \u2013 that is, a behaviorless bunch of variables, all public data and no member functions. struct Point { int x {0}; int y {0}; }; Note that we can put default initializers on member variables: C.49: Prefer initialization to assignment in constructors . Note # The key to this rule is whether the semantics of the getter/setter are trivial. While it is not a complete definition of \u201ctrivial\u201d, consider whether there would be any difference beyond syntax if the getter/setter was a public data member instead. Examples of non-trivial semantics would be: maintaining a class invariant or converting between an internal type and an interface type. Enforcement # Flag multiple get and set member functions that simply access a member without additional semantics. C.132: Don\u2019t make a function virtual without reason # Reason # Redundant virtual increases run-time and object-code size. A virtual function can be overridden and is thus open to mistakes in a derived class. A virtual function ensures code replication in a templated hierarchy. Example, bad # template<class T> class Vector { public: // ... virtual int size() const { return sz; } // bad: what good could a derived class do? private: T* elem; // the elements int sz; // number of elements }; This kind of \u201cvector\u201d isn\u2019t meant to be used as a base class at all. Enforcement # Flag a class with virtual functions but no derived classes. Flag a class where all member functions are virtual and have implementations. C.133: Avoid protected data # Reason # protected data is a source of complexity and errors. protected data complicates the statement of invariants. protected data inherently violates the guidance against putting data in base classes, which usually leads to having to deal with virtual inheritance as well. Example, bad # class Shape { public: // ... interface functions ... protected: // data for use in derived classes: Color fill_color; Color edge_color; Style st; }; Now it is up to every derived Shape to manipulate the protected data correctly. This has been popular, but also a major source of maintenance problems. In a large class hierarchy, the consistent use of protected data is hard to maintain because there can be a lot of code, spread over a lot of classes. The set of classes that can touch that data is open: anyone can derive a new class and start manipulating the protected data. Often, it is not possible to examine the complete set of classes, so any change to the representation of the class becomes infeasible. There is no enforced invariant for the protected data; it is much like a set of global variables. The protected data has de facto become global to a large body of code. Note # Protected data often looks tempting to enable arbitrary improvements through derivation. Often, what you get is unprincipled changes and errors. Prefer private data with a well-specified and enforced invariant. Alternative, and often better, keep data out of any class used as an interface . Note # Protected member function can be just fine. Enforcement # Flag classes with protected data. C.134: Ensure all non- const data members have the same access level # Reason # Prevention of logical confusion leading to errors. If the non- const data members don\u2019t have the same access level, the type is confused about what it\u2019s trying to do. Is it a type that maintains an invariant or simply a collection of values? Discussion # The core question is: What code is responsible for maintaining a meaningful/correct value for that variable? There are exactly two kinds of data members: A: Ones that don\u2019t participate in the object\u2019s invariant. Any combination of values for these members is valid. B: Ones that do participate in the object\u2019s invariant. Not every combination of values is meaningful (else there\u2019d be no invariant). Therefore all code that has write access to these variables must know about the invariant, know the semantics, and know (and actively implement and enforce) the rules for keeping the values correct. Data members in category A should just be public (or, more rarely, protected if you only want derived classes to see them). They don\u2019t need encapsulation. All code in the system might as well see and manipulate them. Data members in category B should be private or const . This is because encapsulation is important. To make them non- private and non- const would mean that the object can\u2019t control its own state: An unbounded amount of code beyond the class would need to know about the invariant and participate in maintaining it accurately \u2013 if these data members were public , that would be all calling code that uses the object; if they were protected , it would be all the code in current and future derived classes. This leads to brittle and tightly coupled code that quickly becomes a nightmare to maintain. Any code that inadvertently sets the data members to an invalid or unexpected combination of values would corrupt the object and all subsequent uses of the object. Most classes are either all A or all B: All public : If you\u2019re writing an aggregate bundle-of-variables without an invariant across those variables, then all the variables should be public . By convention, declare such classes struct rather than class All private : If you\u2019re writing a type that maintains an invariant, then all the non- const variables should be private \u2013 it should be encapsulated. Exception # Occasionally classes will mix A and B, usually for debug reasons. An encapsulated object may contain something like non- const debug instrumentation that isn\u2019t part of the invariant and so falls into category A \u2013 it isn\u2019t really part of the object\u2019s value or meaningful observable state either. In that case, the A parts should be treated as A\u2019s (made public , or in rarer cases protected if they should be visible only to derived classes) and the B parts should still be treated like B\u2019s ( private or const ). Enforcement # Flag any class that has non- const data members with different access levels. C.135: Use multiple inheritance to represent multiple distinct interfaces # Reason # Not all classes will necessarily support all interfaces, and not all callers will necessarily want to deal with all operations. Especially to break apart monolithic interfaces into \u201caspects\u201d of behavior supported by a given derived class. Example # class iostream : public istream, public ostream { // very simplified // ... }; istream provides the interface to input operations; ostream provides the interface to output operations. iostream provides the union of the istream and ostream interfaces and the synchronization needed to allow both on a single stream. Note # This is a very common use of inheritance because the need for multiple different interfaces to an implementation is common and such interfaces are often not easily or naturally organized into a single-rooted hierarchy. Note # Such interfaces are typically abstract classes. Enforcement # ??? C.136: Use multiple inheritance to represent the union of implementation attributes # Reason # Some forms of mixins have state and often operations on that state. If the operations are virtual the use of inheritance is necessary, if not using inheritance can avoid boilerplate and forwarding. Example # class iostream : public istream, public ostream { // very simplified // ... }; istream provides the interface to input operations (and some data); ostream provides the interface to output operations (and some data). iostream provides the union of the istream and ostream interfaces and the synchronization needed to allow both on a single stream. Note # This a relatively rare use because implementation can often be organized into a single-rooted hierarchy. Example # Sometimes, an \u201cimplementation attribute\u201d is more like a \u201cmixin\u201d that determine the behavior of an implementation and inject members to enable the implementation of the policies it requires. For example, see std::enable_shared_from_this or various bases from boost.intrusive (e.g. list_base_hook or intrusive_ref_counter ). Enforcement # ??? C.137: Use virtual bases to avoid overly general base classes # Reason # Allow separation of shared data and interface. To avoid all shared data to being put into an ultimate base class. Example # struct Interface { virtual void f(); virtual int g(); // ... no data here ... }; class Utility { // with data void utility1(); virtual void utility2(); // customization point public: int x; int y; }; class Derive1 : public Interface, virtual protected Utility { // override Interface functions // Maybe override Utility virtual functions // ... }; class Derive2 : public Interface, virtual protected Utility { // override Interface functions // Maybe override Utility virtual functions // ... }; Factoring out Utility makes sense if many derived classes share significant \u201cimplementation details.\u201d Note # Obviously, the example is too \u201ctheoretical\u201d, but it is hard to find a small realistic example. Interface is the root of an interface hierarchy and Utility is the root of an implementation hierarchy . Here is a slightly more realistic example with an explanation. Note # Often, linearization of a hierarchy is a better solution. Enforcement # Flag mixed interface and implementation hierarchies. C.138: Create an overload set for a derived class and its bases with using # Reason # Without a using declaration, member functions in the derived class hide the entire inherited overload sets. Example, bad # #include <iostream> class B { public: virtual int f(int i) { std::cout << \"f(int): \"; return i; } virtual double f(double d) { std::cout << \"f(double): \"; return d; } virtual ~B() = default; }; class D: public B { public: int f(int i) override { std::cout << \"f(int): \"; return i + 1; } }; int main() { D d; std::cout << d.f(2) << '\\n'; // prints \"f(int): 3\" std::cout << d.f(2.3) << '\\n'; // prints \"f(int): 3\" } Example, good # class D: public B { public: int f(int i) override { std::cout << \"f(int): \"; return i + 1; } using B::f; // exposes f(double) }; Note # This issue affects both virtual and nonvirtual member functions For variadic bases, C++17 introduced a variadic form of the using-declaration, template <class... Ts> struct Overloader : Ts... { using Ts::operator()...; // exposes operator() from every base }; Enforcement # Diagnose name hiding C.139: Use final sparingly # Reason # Capping a hierarchy with final is rarely needed for logical reasons and can be damaging to the extensibility of a hierarchy. Example, bad # class Widget { /* ... */ }; // nobody will ever want to improve My_widget (or so you thought) class My_widget final : public Widget { /* ... */ }; class My_improved_widget : public My_widget { /* ... */ }; // error: can't do that Note # Not every class is meant to be a base class. Most standard-library classes are examples of that (e.g., std::vector and std::string are not designed to be derived from). This rule is about using final on classes with virtual functions meant to be interfaces for a class hierarchy. Note # Capping an individual virtual function with final is error-prone as final can easily be overlooked when defining/overriding a set of functions. Fortunately, the compiler catches such mistakes: You cannot re-declare/re-open a final member in a derived class. Note # Claims of performance improvements from final should be substantiated. Too often, such claims are based on conjecture or experience with other languages. There are examples where final can be important for both logical and performance reasons. One example is a performance-critical AST hierarchy in a compiler or language analysis tool. New derived classes are not added every year and only by library implementers. However, misuses are (or at least have been) far more common. Enforcement # Flag uses of final . C.140: Do not provide different default arguments for a virtual function and an overrider # Reason # That can cause confusion: An overrider does not inherit default arguments. Example, bad # class Base { public: virtual int multiply(int value, int factor = 2) = 0; virtual ~Base() = default; }; class Derived : public Base { public: int multiply(int value, int factor = 10) override; }; Derived d; Base& b = d; b.multiply(10); // these two calls will call the same function but d.multiply(10); // with different arguments and so different results Enforcement # Flag default arguments on virtual functions if they differ between base and derived declarations. C.hier-access: Accessing objects in a hierarchy # C.145: Access polymorphic objects through pointers and references # Reason # If you have a class with a virtual function, you don\u2019t (in general) know which class provided the function to be used. Example # struct B { int a; virtual int f(); virtual ~B() = default }; struct D : B { int b; int f() override; }; void use(B b) { D d; B b2 = d; // slice B b3 = b; } void use2() { D d; use(d); // slice } Both d s are sliced. Exception # You can safely access a named polymorphic object in the scope of its definition, just don\u2019t slice it. void use3() { D d; d.f(); // OK } See also # A polymorphic class should suppress copying Enforcement # Flag all slicing. C.146: Use dynamic_cast where class hierarchy navigation is unavoidable # Reason # dynamic_cast is checked at run time. Example # struct B { // an interface virtual void f(); virtual void g(); virtual ~B(); }; struct D : B { // a wider interface void f() override; virtual void h(); }; void user(B* pb) { if (D* pd = dynamic_cast<D*>(pb)) { // ... use D's interface ... } else { // ... make do with B's interface ... } } Use of the other casts can violate type safety and cause the program to access a variable that is actually of type X to be accessed as if it were of an unrelated type Z : void user2(B* pb) // bad { D* pd = static_cast<D*>(pb); // I know that pb really points to a D; trust me // ... use D's interface ... } void user3(B* pb) // unsafe { if (some_condition) { D* pd = static_cast<D*>(pb); // I know that pb really points to a D; trust me // ... use D's interface ... } else { // ... make do with B's interface ... } } void f() { B b; user(&b); // OK user2(&b); // bad error user3(&b); // OK *if* the programmer got the some_condition check right } Note # Like other casts, dynamic_cast is overused. Prefer virtual functions to casting . Prefer static polymorphism to hierarchy navigation where it is possible (no run-time resolution necessary) and reasonably convenient. Note # Some people use dynamic_cast where a typeid would have been more appropriate; dynamic_cast is a general \u201cis kind of\u201d operation for discovering the best interface to an object, whereas typeid is a \u201cgive me the exact type of this object\u201d operation to discover the actual type of an object. The latter is an inherently simpler operation that ought to be faster. The latter ( typeid ) is easily hand-crafted if necessary (e.g., if working on a system where RTTI is \u2013 for some reason \u2013 prohibited), the former ( dynamic_cast ) is far harder to implement correctly in general. Consider: struct B { const char* name {\"B\"}; // if pb1->id() == pb2->id() *pb1 is the same type as *pb2 virtual const char* id() const { return name; } // ... }; struct D : B { const char* name {\"D\"}; const char* id() const override { return name; } // ... }; void use() { B* pb1 = new B; B* pb2 = new D; cout << pb1->id(); // \"B\" cout << pb2->id(); // \"D\" if (pb1->id() == \"D\") { // looks innocent D* pd = static_cast<D*>(pb1); // ... } // ... } The result of pb2->id() == \"D\" is actually implementation defined. We added it to warn of the dangers of home-brew RTTI. This code may work as expected for years, just to fail on a new machine, new compiler, or a new linker that does not unify character literals. If you implement your own RTTI, be careful. Exception # If your implementation provided a really slow dynamic_cast , you may have to use a workaround. However, all workarounds that cannot be statically resolved involve explicit casting (typically static_cast ) and are error-prone. You will basically be crafting your own special-purpose dynamic_cast . So, first make sure that your dynamic_cast really is as slow as you think it is (there are a fair number of unsupported rumors about) and that your use of dynamic_cast is really performance critical. We are of the opinion that current implementations of dynamic_cast are unnecessarily slow. For example, under suitable conditions, it is possible to perform a dynamic_cast in fast constant time . However, compatibility makes changes difficult even if all agree that an effort to optimize is worthwhile. In very rare cases, if you have measured that the dynamic_cast overhead is material, you have other means to statically guarantee that a downcast will succeed (e.g., you are using CRTP carefully), and there is no virtual inheritance involved, consider tactically resorting static_cast with a prominent comment and disclaimer summarizing this paragraph and that human attention is needed under maintenance because the type system can\u2019t verify correctness. Even so, in our experience such \u201cI know what I\u2019m doing\u201d situations are still a known bug source. Exception # Consider: template<typename B> class Dx : B { // ... }; Enforcement # Flag all uses of static_cast for downcasts, including C-style casts that perform a static_cast . This rule is part of the type-safety profile . C.147: Use dynamic_cast to a reference type when failure to find the required class is considered an error # Reason # Casting to a reference expresses that you intend to end up with a valid object, so the cast must succeed. dynamic_cast will then throw if it does not succeed. Example # ??? Enforcement # ??? C.148: Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative # Reason # The dynamic_cast conversion allows to test whether a pointer is pointing at a polymorphic object that has a given class in its hierarchy. Since failure to find the class merely returns a null value, it can be tested during run time. This allows writing code that can choose alternative paths depending on the results. Contrast with C.147 , where failure is an error, and should not be used for conditional execution. Example # The example below describes the add function of a Shape_owner that takes ownership of constructed Shape objects. The objects are also sorted into views, according to their geometric attributes. In this example, Shape does not inherit from Geometric_attributes . Only its subclasses do. void add(Shape* const item) { // Ownership is always taken owned_shapes.emplace_back(item); // Check the Geometric_attributes and add the shape to none/one/some/all of the views if (auto even = dynamic_cast<Even_sided*>(item)) { view_of_evens.emplace_back(even); } if (auto trisym = dynamic_cast<Trilaterally_symmetrical*>(item)) { view_of_trisyms.emplace_back(trisym); } } Notes # A failure to find the required class will cause dynamic_cast to return a null value, and de-referencing a null-valued pointer will lead to undefined behavior. Therefore the result of the dynamic_cast should always be treated as if it may contain a null value, and tested. Enforcement # (Complex) Unless there is a null test on the result of a dynamic_cast of a pointer type, warn upon dereference of the pointer. C.149: Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new # Reason # Avoid resource leaks. Example # void use(int i) { auto p = new int {7}; // bad: initialize local pointers with new auto q = make_unique<int>(9); // ok: guarantee the release of the memory-allocated for 9 if (0 < i) return; // maybe return and leak delete p; // too late } Enforcement # Flag initialization of a naked pointer with the result of a new Flag delete of local variable C.150: Use make_unique() to construct objects owned by unique_ptr s # Reason # make_unique gives a more concise statement of the construction. It also ensures exception safety in complex expressions. Example # unique_ptr<Foo> p {new Foo{7}}; // OK: but repetitive auto q = make_unique<Foo>(7); // Better: no repetition of Foo // Not exception-safe: the compiler may interleave the computations of arguments as follows: // // 1. allocate memory for Foo, // 2. construct Foo, // 3. call bar, // 4. construct unique_ptr<Foo>. // // If bar throws, Foo will not be destroyed, and the memory-allocated for it will leak. f(unique_ptr<Foo>(new Foo()), bar()); // Exception-safe: calls to functions are never interleaved. f(make_unique<Foo>(), bar()); Enforcement # Flag the repetitive usage of template specialization list <Foo> Flag variables declared to be unique_ptr<Foo> C.151: Use make_shared() to construct objects owned by shared_ptr s # Reason # make_shared gives a more concise statement of the construction. It also gives an opportunity to eliminate a separate allocation for the reference counts, by placing the shared_ptr \u2018s use counts next to its object. Example # void test() { // OK: but repetitive; and separate allocations for the Bar and shared_ptr's use count shared_ptr<Bar> p {new Bar{7}}; auto q = make_shared<Bar>(7); // Better: no repetition of Bar; one object } Enforcement # Flag the repetitive usage of template specialization list <Bar> Flag variables declared to be shared_ptr<Bar> C.152: Never assign a pointer to an array of derived class objects to a pointer to its base # Reason # Subscripting the resulting base pointer will lead to invalid object access and probably to memory corruption. Example # struct B { int x; }; struct D : B { int y; }; void use(B*); D a[] = {{1, 2}, {3, 4}, {5, 6}}; B* p = a; // bad: a decays to &a[0] which is converted to a B* p[1].x = 7; // overwrite D[0].y use(a); // bad: a decays to &a[0] which is converted to a B* Enforcement # Flag all combinations of array decay and base to derived conversions. Pass an array as a span rather than as a pointer, and don\u2019t let the array name suffer a derived-to-base conversion before getting into the span C.153: Prefer virtual function to casting # Reason # A virtual function call is safe, whereas casting is error-prone. A virtual function call reaches the most derived function, whereas a cast may reach an intermediate class and therefore give a wrong result (especially as a hierarchy is modified during maintenance). Example # ??? Enforcement # See C.146 and ??? C.over: Overloading and overloaded operators # You can overload ordinary functions, template functions, and operators. You cannot overload function objects. Overload rule summary: C.160: Define operators primarily to mimic conventional usage C.161: Use nonmember functions for symmetric operators C.162: Overload operations that are roughly equivalent C.163: Overload only for operations that are roughly equivalent C.164: Avoid implicit conversion operators C.165: Use using for customization points C.166: Overload unary & only as part of a system of smart pointers and references C.167: Use an operator for an operation with its conventional meaning C.168: Define overloaded operators in the namespace of their operands C.170: If you feel like overloading a lambda, use a generic lambda C.160: Define operators primarily to mimic conventional usage # Reason # Minimize surprises. Example # class X { public: // ... X& operator=(const X&); // member function defining assignment friend bool operator==(const X&, const X&); // == needs access to representation // after a = b we have a == b // ... }; Here, the conventional semantics is maintained: Copies compare equal . Example, bad # X operator+(X a, X b) { return a.v - b.v; } // bad: makes + subtract Note # Nonmember operators should be either friends or defined in the same namespace as their operands . Binary operators should treat their operands equivalently . Enforcement # Possibly impossible. C.161: Use nonmember functions for symmetric operators # Reason # If you use member functions, you need two. Unless you use a nonmember function for (say) == , a == b and b == a will be subtly different. Example # bool operator==(Point a, Point b) { return a.x == b.x && a.y == b.y; } Enforcement # Flag member operator functions. C.162: Overload operations that are roughly equivalent # Reason # Having different names for logically equivalent operations on different argument types is confusing, leads to encoding type information in function names, and inhibits generic programming. Example # Consider: void print(int a); void print(int a, int base); void print(const string&); These three functions all print their arguments (appropriately). Conversely: void print_int(int a); void print_based(int a, int base); void print_string(const string&); These three functions all print their arguments (appropriately). Adding to the name just introduced verbosity and inhibits generic code. Enforcement # ??? C.163: Overload only for operations that are roughly equivalent # Reason # Having the same name for logically different functions is confusing and leads to errors when using generic programming. Example # Consider: void open_gate(Gate& g); // remove obstacle from garage exit lane void fopen(const char* name, const char* mode); // open file The two operations are fundamentally different (and unrelated) so it is good that their names differ. Conversely: void open(Gate& g); // remove obstacle from garage exit lane void open(const char* name, const char* mode =\"r\"); // open file The two operations are still fundamentally different (and unrelated) but the names have been reduced to their (common) minimum, opening opportunities for confusion. Fortunately, the type system will catch many such mistakes. Note # Be particularly careful about common and popular names, such as open , move , + , and == . Enforcement # ??? C.164: Avoid implicit conversion operators # Reason # Implicit conversions can be essential (e.g., double to int ) but often cause surprises (e.g., String to C-style string). Note # Prefer explicitly named conversions until a serious need is demonstrated. By \u201cserious need\u201d we mean a reason that is fundamental in the application domain (such as an integer to complex number conversion) and frequently needed. Do not introduce implicit conversions (through conversion operators or non- explicit constructors) just to gain a minor convenience. Example # struct S1 { string s; // ... operator char*() { return s.data(); } // BAD, likely to cause surprises }; struct S2 { string s; // ... explicit operator char*() { return s.data(); } }; void f(S1 s1, S2 s2) { char* x1 = s1; // OK, but can cause surprises in many contexts char* x2 = s2; // error (and that's usually a good thing) char* x3 = static_cast<char*>(s2); // we can be explicit (on your head be it) } The surprising and potentially damaging implicit conversion can occur in arbitrarily hard-to spot contexts, e.g., S1 ff(); char* g() { return ff(); } The string returned by ff() is destroyed before the returned pointer into it can be used. Enforcement # Flag all conversion operators. C.165: Use using for customization points # Reason # To find function objects and functions defined in a separate namespace to \u201ccustomize\u201d a common function. Example # Consider swap . It is a general (standard-library) function with a definition that will work for just about any type. However, it is desirable to define specific swap() s for specific types. For example, the general swap() will copy the elements of two vector s being swapped, whereas a good specific implementation will not copy elements at all. namespace N { My_type X { /* ... */ }; void swap(X&, X&); // optimized swap for N::X // ... } void f1(N::X& a, N::X& b) { std::swap(a, b); // probably not what we wanted: calls std::swap() } The std::swap() in f1() does exactly what we asked it to do: it calls the swap() in namespace std . Unfortunately, that\u2019s probably not what we wanted. How do we get N::X considered? void f2(N::X& a, N::X& b) { swap(a, b); // calls N::swap } But that may not be what we wanted for generic code. There, we typically want the specific function if it exists and the general function if not. This is done by including the general function in the lookup for the function: void f3(N::X& a, N::X& b) { using std::swap; // make std::swap available swap(a, b); // calls N::swap if it exists, otherwise std::swap } Enforcement # Unlikely, except for known customization points, such as swap . The problem is that the unqualified and qualified lookups both have uses. C.166: Overload unary & only as part of a system of smart pointers and references # Reason # The & operator is fundamental in C++. Many parts of the C++ semantics assumes its default meaning. Example # class Ptr { // a somewhat smart pointer Ptr(X* pp) :p(pp) { /* check */ } X* operator->() { /* check */ return p; } X operator[](int i); X operator*(); private: T* p; }; class X { Ptr operator&() { return Ptr{this}; } // ... }; Note # If you \u201cmess with\u201d operator & be sure that its definition has matching meanings for -> , [] , * , and . on the result type. Note that operator . currently cannot be overloaded so a perfect system is impossible. We hope to remedy that: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf . Note that std::addressof() always yields a built-in pointer. Enforcement # Tricky. Warn if & is user-defined without also defining -> for the result type. C.167: Use an operator for an operation with its conventional meaning # Reason # Readability. Convention. Reusability. Support for generic code Example # void cout_my_class(const My_class& c) // confusing, not conventional,not generic { std::cout << /* class members here */; } std::ostream& operator<<(std::ostream& os, const my_class& c) // OK { return os << /* class members here */; } By itself, cout_my_class would be OK, but it is not usable/composable with code that rely on the << convention for output: My_class var { /* ... */ }; // ... cout << \"var = \" << var << '\\n'; Note # There are strong and vigorous conventions for the meaning most operators, such as comparisons ( == , != , < , <= , > , and >= ), arithmetic operations ( + , - , * , / , and % ) access operations ( . , -> , unary * , and [] ) assignment ( = ) Don\u2019t define those unconventionally and don\u2019t invent your own names for them. Enforcement # Tricky. Requires semantic insight. C.168: Define overloaded operators in the namespace of their operands # Reason # Readability. Ability for find operators using ADL. Avoiding inconsistent definition in different namespaces Example # struct S { }; bool operator==(S, S); // OK: in the same namespace as S, and even next to S S s; bool x = (s == s); This is what a default == would do, if we had such defaults. Example # namespace N { struct S { }; bool operator==(S, S); // OK: in the same namespace as S, and even next to S } N::S s; bool x = (s == s); // finds N::operator==() by ADL Example, bad # struct S { }; S s; namespace N { S::operator!(S a) { return true; } S not_s = !s; } namespace M { S::operator!(S a) { return false; } S not_s = !s; } Here, the meaning of !s differs in N and M . This can be most confusing. Remove the definition of namespace M and the confusion is replaced by an opportunity to make the mistake. Note # If a binary operator is defined for two types that are defined in different namespaces, you cannot follow this rule. For example: Vec::Vector operator*(const Vec::Vector&, const Mat::Matrix&); This may be something best avoided. See also # This is a special case of the rule that helper functions should be defined in the same namespace as their class . Enforcement # Flag operator definitions that are not it the namespace of their operands C.170: If you feel like overloading a lambda, use a generic lambda # Reason # You cannot overload by defining two different lambdas with the same name. Example # void f(int); void f(double); auto f = [](char); // error: cannot overload variable and function auto g = [](int) { /* ... */ }; auto g = [](double) { /* ... */ }; // error: cannot overload variables auto h = [](auto) { /* ... */ }; // OK Enforcement # The compiler catches the attempt to overload a lambda. C.union: Unions # A union is a struct where all members start at the same address so that it can hold only one member at a time. A union does not keep track of which member is stored so the programmer has to get it right; this is inherently error-prone, but there are ways to compensate. A type that is a union plus an indicator of which member is currently held is called a tagged union , a discriminated union , or a variant . Union rule summary: C.180: Use union s to save Memory C.181: Avoid \u201cnaked\u201d union s C.182: Use anonymous union s to implement tagged unions C.183: Don\u2019t use a union for type punning ??? C.180: Use union s to save memory # Reason # A union allows a single piece of memory to be used for different types of objects at different times. Consequently, it can be used to save memory when we have several objects that are never used at the same time. Example # union Value { int x; double d; }; Value v = { 123 }; // now v holds an int cout << v.x << '\\n'; // write 123 v.d = 987.654; // now v holds a double cout << v.d << '\\n'; // write 987.654 But heed the warning: Avoid \u201cnaked\u201d union s Example # // Short-string optimization constexpr size_t buffer_size = 16; // Slightly larger than the size of a pointer class Immutable_string { public: Immutable_string(const char* str) : size(strlen(str)) { if (size < buffer_size) strcpy_s(string_buffer, buffer_size, str); else { string_ptr = new char[size + 1]; strcpy_s(string_ptr, size + 1, str); } } ~Immutable_string() { if (size >= buffer_size) delete string_ptr; } const char* get_str() const { return (size < buffer_size) ? string_buffer : string_ptr; } private: // If the string is short enough, we store the string itself // instead of a pointer to the string. union { char* string_ptr; char string_buffer[buffer_size]; }; const size_t size; }; Enforcement # ??? C.181: Avoid \u201cnaked\u201d union s # Reason # A naked union is a union without an associated indicator which member (if any) it holds, so that the programmer has to keep track. Naked unions are a source of type errors. Example, bad # union Value { int x; double d; }; Value v; v.d = 987.654; // v holds a double So far, so good, but we can easily misuse the union : cout << v.x << '\\n'; // BAD, undefined behavior: v holds a double, but we read it as an int Note that the type error happened without any explicit cast. When we tested that program the last value printed was 1683627180 which is the integer value for the bit pattern for 987.654 . What we have here is an \u201cinvisible\u201d type error that happens to give a result that could easily look innocent. And, talking about \u201cinvisible\u201d, this code produced no output: v.x = 123; cout << v.d << '\\n'; // BAD: undefined behavior Alternative # Wrap a union in a class together with a type field. The C++17 variant type (found in <variant> ) does that for you: variant<int, double> v; v = 123; // v holds an int int x = get<int>(v); v = 123.456; // v holds a double w = get<double>(v); Enforcement # ??? C.182: Use anonymous union s to implement tagged unions # Reason # A well-designed tagged union is type safe. An anonymous union simplifies the definition of a class with a (tag, union) pair. Example # This example is mostly borrowed from TC++PL4 pp216-218. You can look there for an explanation. The code is somewhat elaborate. Handling a type with user-defined assignment and destructor is tricky. Saving programmers from having to write such code is one reason for including variant in the standard. class Value { // two alternative representations represented as a union private: enum class Tag { number, text }; Tag type; // discriminant union { // representation (note: anonymous union) int i; string s; // string has default constructor, copy operations, and destructor }; public: struct Bad_entry { }; // used for exceptions ~Value(); Value& operator=(const Value&); // necessary because of the string variant Value(const Value&); // ... int number() const; string text() const; void set_number(int n); void set_text(const string&); // ... }; int Value::number() const { if (type != Tag::number) throw Bad_entry{}; return i; } string Value::text() const { if (type != Tag::text) throw Bad_entry{}; return s; } void Value::set_number(int n) { if (type == Tag::text) { s.~string(); // explicitly destroy string type = Tag::number; } i = n; } void Value::set_text(const string& ss) { if (type == Tag::text) s = ss; else { new(&s) string{ss}; // placement new: explicitly construct string type = Tag::text; } } Value& Value::operator=(const Value& e) // necessary because of the string variant { if (type == Tag::text && e.type == Tag::text) { s = e.s; // usual string assignment return *this; } if (type == Tag::text) s.~string(); // explicit destroy switch (e.type) { case Tag::number: i = e.i; break; case Tag::text: new(&s) string(e.s); // placement new: explicit construct } type = e.type; return *this; } Value::~Value() { if (type == Tag::text) s.~string(); // explicit destroy } Enforcement # ??? C.183: Don\u2019t use a union for type punning # Reason # It is undefined behavior to read a union member with a different type from the one with which it was written. Such punning is invisible, or at least harder to spot than using a named cast. Type punning using a union is a source of errors. Example, bad # union Pun { int x; unsigned char c[sizeof(int)]; }; The idea of Pun is to be able to look at the character representation of an int . void bad(Pun& u) { u.x = 'x'; cout << u.c[0] << '\\n'; // undefined behavior } If you wanted to see the bytes of an int , use a (named) cast: void if_you_must_pun(int& x) { auto p = reinterpret_cast<unsigned char*>(&x); cout << p[0] << '\\n'; // OK; better // ... } Accessing the result of an reinterpret_cast to a different type from the objects declared type is defined behavior (even though reinterpret_cast is discouraged), but at least we can see that something tricky is going on. Note # Unfortunately, union s are commonly used for type punning. We don\u2019t consider \u201csometimes, it works as expected\u201d a strong argument. C++17 introduced a distinct type std::byte to facilitate operations on raw object representation. Use that type instead of unsigned char or char for these operations. Enforcement # ??? Enum: Enumerations # Enumerations are used to define sets of integer values and for defining types for such sets of values. There are two kind of enumerations, \u201cplain\u201d enum s and class enum s. Enumeration rule summary: Enum.1: Prefer enumerations over macros Enum.2: Use enumerations to represent sets of related named constants Enum.3: Prefer enum class es over \u201cplain\u201d enum s Enum.4: Define operations on enumerations for safe and simple use Enum.5: Don\u2019t use ALL_CAPS for enumerators Enum.6: Avoid unnamed enumerations Enum.7: Specify the underlying type of an enumeration only when necessary Enum.8: Specify enumerator values only when necessary Enum.1: Prefer enumerations over macros # Reason # Macros do not obey scope and type rules. Also, macro names are removed during preprocessing and so usually don\u2019t appear in tools like debuggers. Example # First some bad old code: // webcolors.h (third party header) #define RED 0xFF0000 #define GREEN 0x00FF00 #define BLUE 0x0000FF // productinfo.h // The following define product subtypes based on color #define RED 0 #define PURPLE 1 #define BLUE 2 int webby = BLUE; // webby == 2; probably not what was desired Instead use an enum : enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF }; enum class Product_info { red = 0, purple = 1, blue = 2 }; int webby = blue; // error: be specific Web_color webby = Web_color::blue; We used an enum class to avoid name clashes. Enforcement # Flag macros that define integer values. Enum.2: Use enumerations to represent sets of related named constants # Reason # An enumeration shows the enumerators to be related and can be a named type. Example # enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF }; Note # Switching on an enumeration is common and the compiler can warn against unusual patterns of case labels. For example: enum class Product_info { red = 0, purple = 1, blue = 2 }; void print(Product_info inf) { switch (inf) { case Product_info::red: cout << \"red\"; break; case Product_info::purple: cout << \"purple\"; break; } } Such off-by-one switch -statements are often the results of an added enumerator and insufficient testing. Enforcement # Flag switch -statements where the case s cover most but not all enumerators of an enumeration. Flag switch -statements where the case s cover a few enumerators of an enumeration, but has no default . Enum.3: Prefer class enums over \u201cplain\u201d enums # Reason # To minimize surprises: traditional enums convert to int too readily. Example # void Print_color(int color); enum Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF }; enum Product_info { Red = 0, Purple = 1, Blue = 2 }; Web_color webby = Web_color::blue; // Clearly at least one of these calls is buggy. Print_color(webby); Print_color(Product_info::Blue); Instead use an enum class : void Print_color(int color); enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF }; enum class Product_info { red = 0, purple = 1, blue = 2 }; Web_color webby = Web_color::blue; Print_color(webby); // Error: cannot convert Web_color to int. Print_color(Product_info::Red); // Error: cannot convert Product_info to int. Enforcement # (Simple) Warn on any non-class enum definition. Enum.4: Define operations on enumerations for safe and simple use # Reason # Convenience of use and avoidance of errors. Example # enum Day { mon, tue, wed, thu, fri, sat, sun }; Day& operator++(Day& d) { return d = (d == Day::sun) ? Day::mon : static_cast<Day>(static_cast<int>(d)+1); } Day today = Day::sat; Day tomorrow = ++today; The use of a static_cast is not pretty, but Day& operator++(Day& d) { return d = (d == Day::sun) ? Day::mon : Day{++d}; // error } is an infinite recursion, and writing it without a cast, using a switch on all cases is long-winded. Enforcement # Flag repeated expressions cast back into an enumeration. Enum.5: Don\u2019t use ALL_CAPS for enumerators # Reason # Avoid clashes with macros. Example, bad # // webcolors.h (third party header) #define RED 0xFF0000 #define GREEN 0x00FF00 #define BLUE 0x0000FF // productinfo.h // The following define product subtypes based on color enum class Product_info { RED, PURPLE, BLUE }; // syntax error Enforcement # Flag ALL_CAPS enumerators. Enum.6: Avoid unnamed enumerations # Reason # If you can\u2019t name an enumeration, the values are not related Example, bad # enum { red = 0xFF0000, scale = 4, is_signed = 1 }; Such code is not uncommon in code written before there were convenient alternative ways of specifying integer constants. Alternative # Use constexpr values instead. For example: constexpr int red = 0xFF0000; constexpr short scale = 4; constexpr bool is_signed = true; Enforcement # Flag unnamed enumerations. Enum.7: Specify the underlying type of an enumeration only when necessary # Reason # The default is the easiest to read and write. int is the default integer type. int is compatible with C enum s. Example # enum class Direction : char { n, s, e, w, ne, nw, se, sw }; // underlying type saves space enum class Web_color : int32_t { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF }; // underlying type is redundant Note # Specifying the underlying type is necessary in forward declarations of enumerations: enum Flags : char; void f(Flags); // .... enum flags : char { /* ... */ }; Enforcement # ???? Enum.8: Specify enumerator values only when necessary # Reason # It\u2019s the simplest. It avoids duplicate enumerator values. The default gives a consecutive set of values that is good for switch -statement implementations. Example # enum class Col1 { red, yellow, blue }; enum class Col2 { red = 1, yellow = 2, blue = 2 }; // typo enum class Month { jan = 1, feb, mar, apr, may, jun, jul, august, sep, oct, nov, dec }; // starting with 1 is conventional enum class Base_flag { dec = 1, oct = dec << 1, hex = dec << 2 }; // set of bits Specifying values is necessary to match conventional values (e.g., Month ) and where consecutive values are undesirable (e.g., to get separate bits as in Base_flag ). Enforcement # Flag duplicate enumerator values Flag explicitly specified all-consecutive enumerator values R: Resource management # This section contains rules related to resources. A resource is anything that must be acquired and (explicitly or implicitly) released, such as memory, file handles, sockets, and locks. The reason it must be released is typically that it can be in short supply, so even delayed release may do harm. The fundamental aim is to ensure that we don\u2019t leak any resources and that we don\u2019t hold a resource longer than we need to. An entity that is responsible for releasing a resource is called an owner. There are a few cases where leaks can be acceptable or even optimal: If you are writing a program that simply produces an output based on an input and the amount of memory needed is proportional to the size of the input, the optimal strategy (for performance and ease of programming) is sometimes simply never to delete anything. If you have enough memory to handle your largest input, leak away, but be sure to give a good error message if you are wrong. Here, we ignore such cases. Resource management rule summary: R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization) R.2: In interfaces, use raw pointers to denote individual objects (only) R.3: A raw pointer (a T* ) is non-owning R.4: A raw reference (a T& ) is non-owning R.5: Prefer scoped objects, don\u2019t heap-allocate unnecessarily R.6: Avoid non- const global variables Allocation and deallocation rule summary: R.10: Avoid malloc() and free() R.11: Avoid calling new and delete explicitly R.12: Immediately give the result of an explicit resource allocation to a manager object R.13: Perform at most one explicit resource allocation in a single expression statement R.14: Avoid [] parameters, prefer span R.15: Always overload matched allocation/deallocation pairs Smart pointer rule summary: R.20: Use unique_ptr or shared_ptr to represent ownership R.21: Prefer unique_ptr over shared_ptr unless you need to share ownership R.22: Use make_shared() to make shared_ptr s R.23: Use make_unique() to make unique_ptr s R.24: Use std::weak_ptr to break cycles of shared_ptr s R.30: Take smart pointers as parameters only to explicitly express lifetime semantics R.31: If you have non- std smart pointers, follow the basic pattern from std R.32: Take a unique_ptr<widget> parameter to express that a function assumes ownership of a widget R.33: Take a unique_ptr<widget>& parameter to express that a function reseats the widget R.34: Take a shared_ptr<widget> parameter to express that a function is part owner R.35: Take a shared_ptr<widget>& parameter to express that a function might reseat the shared pointer R.36: Take a const shared_ptr<widget>& parameter to express that it might retain a reference count to the object ??? R.37: Do not pass a pointer or reference obtained from an aliased smart pointer R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization) # Reason # To avoid leaks and the complexity of manual resource management. C++\u2019s language-enforced constructor/destructor symmetry mirrors the symmetry inherent in resource acquire/release function pairs such as fopen / fclose , lock / unlock , and new / delete . Whenever you deal with a resource that needs paired acquire/release function calls, encapsulate that resource in an object that enforces pairing for you \u2013 acquire the resource in its constructor, and release it in its destructor. Example, bad # Consider: void send(X* x, cstring_span destination) { auto port = open_port(destination); my_mutex.lock(); // ... send(port, x); // ... my_mutex.unlock(); close_port(port); delete x; } In this code, you have to remember to unlock , close_port , and delete on all paths, and do each exactly once. Further, if any of the code marked ... throws an exception, then x is leaked and my_mutex remains locked. Example # Consider: void send(unique_ptr<X> x, cstring_span destination) // x owns the X { Port port{destination}; // port owns the PortHandle lock_guard<mutex> guard{my_mutex}; // guard owns the lock // ... send(port, x); // ... } // automatically unlocks my_mutex and deletes the pointer in x Now all resource cleanup is automatic, performed once on all paths whether or not there is an exception. As a bonus, the function now advertises that it takes over ownership of the pointer. What is Port ? A handy wrapper that encapsulates the resource: class Port { PortHandle port; public: Port(cstring_span destination) : port{open_port(destination)} { } ~Port() { close_port(port); } operator PortHandle() { return port; } // port handles can't usually be cloned, so disable copying and assignment if necessary Port(const Port&) = delete; Port& operator=(const Port&) = delete; }; Note # Where a resource is \u201cill-behaved\u201d in that it isn\u2019t represented as a class with a destructor, wrap it in a class or use finally See also : RAII R.2: In interfaces, use raw pointers to denote individual objects (only) # Reason # Arrays are best represented by a container type (e.g., vector (owning)) or a span (non-owning). Such containers and views hold sufficient information to do range checking. Example, bad # void f(int* p, int n) // n is the number of elements in p[] { // ... p[2] = 7; // bad: subscript raw pointer // ... } The compiler does not read comments, and without reading other code you do not know whether p really points to n elements. Use a span instead. Example # void g(int* p, int fmt) // print *p using format #fmt { // ... uses *p and p[0] only ... } Exception # C-style strings are passed as single pointers to a zero-terminated sequence of characters. Use zstring rather than char* to indicate that you rely on that convention. Note # Many current uses of pointers to a single element could be references. However, where nullptr is a possible value, a reference may not be a reasonable alternative. Enforcement # Flag pointer arithmetic (including ++ ) on a pointer that is not part of a container, view, or iterator. This rule would generate a huge number of false positives if applied to an older code base. Flag array names passed as simple pointers R.3: A raw pointer (a T* ) is non-owning # Reason # There is nothing (in the C++ standard or in most code) to say otherwise and most raw pointers are non-owning. We want owning pointers identified so that we can reliably and efficiently delete the objects pointed to by owning pointers. Example # void f() { int* p1 = new int{7}; // bad: raw owning pointer auto p2 = make_unique<int>(7); // OK: the int is owned by a unique pointer // ... } The unique_ptr protects against leaks by guaranteeing the deletion of its object (even in the presence of exceptions). The T* does not. Example # template<typename T> class X { // ... public: T* p; // bad: it is unclear whether p is owning or not T* q; // bad: it is unclear whether q is owning or not }; We can fix that problem by making ownership explicit: template<typename T> class X2 { // ... public: owner<T*> p; // OK: p is owning T* q; // OK: q is not owning }; Exception # A major class of exception is legacy code, especially code that must remain compilable as C or interface with C and C-style C++ through ABIs. The fact that there are billions of lines of code that violate this rule against owning T* s cannot be ignored. We\u2019d love to see program transformation tools turning 20-year-old \u201clegacy\u201d code into shiny modern code, we encourage the development, deployment and use of such tools, we hope the guidelines will help the development of such tools, and we even contributed (and contribute) to the research and development in this area. However, it will take time: \u201clegacy code\u201d is generated faster than we can renovate old code, and so it will be for a few years. This code cannot all be rewritten (ever assuming good code transformation software), especially not soon. This problem cannot be solved (at scale) by transforming all owning pointers to unique_ptr s and shared_ptr s, partly because we need/use owning \u201craw pointers\u201d as well as simple pointers in the implementation of our fundamental resource handles. For example, common vector implementations have one owning pointer and two non-owning pointers. Many ABIs (and essentially all interfaces to C code) use T* s, some of them owning. Some interfaces cannot be simply annotated with owner because they need to remain compilable as C (although this would be a rare good use for a macro, that expands to owner in C++ mode only). Note # owner<T*> has no default semantics beyond T* . It can be used without changing any code using it and without affecting ABIs. It is simply an indicator to programmers and analysis tools. For example, if an owner<T*> is a member of a class, that class better have a destructor that delete s it. Example, bad # Returning a (raw) pointer imposes a lifetime management uncertainty on the caller; that is, who deletes the pointed-to object? Gadget* make_gadget(int n) { auto p = new Gadget{n}; // ... return p; } void caller(int n) { auto p = make_gadget(n); // remember to delete p // ... delete p; } In addition to suffering from the problem from leak , this adds a spurious allocation and deallocation operation, and is needlessly verbose. If Gadget is cheap to move out of a function (i.e., is small or has an efficient move operation), just return it \u201cby value\u201d (see \u201cout\u201d return values ): Gadget make_gadget(int n) { Gadget g{n}; // ... return g; } Note # This rule applies to factory functions. Note # If pointer semantics are required (e.g., because the return type needs to refer to a base class of a class hierarchy (an interface)), return a \u201csmart pointer.\u201d Enforcement # (Simple) Warn on delete of a raw pointer that is not an owner<T> . (Moderate) Warn on failure to either reset or explicitly delete an owner<T> pointer on every code path. (Simple) Warn if the return value of new is assigned to a raw pointer. (Simple) Warn if a function returns an object that was allocated within the function but has a move constructor. Suggest considering returning it by value instead. R.4: A raw reference (a T& ) is non-owning # Reason # There is nothing (in the C++ standard or in most code) to say otherwise and most raw references are non-owning. We want owners identified so that we can reliably and efficiently delete the objects pointed to by owning pointers. Example # void f() { int& r = *new int{7}; // bad: raw owning reference // ... delete &r; // bad: violated the rule against deleting raw pointers } See also : The raw pointer rule Enforcement # See the raw pointer rule R.5: Prefer scoped objects, don\u2019t heap-allocate unnecessarily # Reason # A scoped object is a local object, a global object, or a member. This implies that there is no separate allocation and deallocation cost in excess of that already used for the containing scope or object. The members of a scoped object are themselves scoped and the scoped object\u2019s constructor and destructor manage the members\u2019 lifetimes. Example # The following example is inefficient (because it has unnecessary allocation and deallocation), vulnerable to exception throws and returns in the ... part (leading to leaks), and verbose: void f(int n) { auto p = new Gadget{n}; // ... delete p; } Instead, use a local variable: void f(int n) { Gadget g{n}; // ... } Enforcement # (Moderate) Warn if an object is allocated and then deallocated on all paths within a function. Suggest it should be a local auto stack object instead. (Simple) Warn if a local Unique_pointer or Shared_pointer is not moved, copied, reassigned or reset before its lifetime ends. R.6: Avoid non- const global variables # Reason # Global variables can be accessed from everywhere so they can introduce surprising dependencies between apparently unrelated objects. They are a notable source of errors. Warning : The initialization of global objects is not totally ordered. If you use a global object initialize it with a constant. Note that it is possible to get undefined initialization order even for const objects. Exception # A global object is often better than a singleton. Exception # An immutable ( const ) global does not introduce the problems we try to avoid by banning global objects. Enforcement # (??? NM: Obviously we can warn about non- const statics \u2026 do we want to?) R.alloc: Allocation and deallocation # R.10: Avoid malloc() and free() # Reason # malloc() and free() do not support construction and destruction, and do not mix well with new and delete . Example # class Record { int id; string name; // ... }; void use() { // p1 may be nullptr // *p1 is not initialized; in particular, // that string isn't a string, but a string-sized bag of bits Record* p1 = static_cast<Record*>(malloc(sizeof(Record))); auto p2 = new Record; // unless an exception is thrown, *p2 is default initialized auto p3 = new(nothrow) Record; // p3 may be nullptr; if not, *p3 is default initialized // ... delete p1; // error: cannot delete object allocated by malloc() free(p2); // error: cannot free() object allocated by new } In some implementations that delete and that free() might work, or maybe they will cause run-time errors. Exception # There are applications and sections of code where exceptions are not acceptable. Some of the best such examples are in life-critical hard-real-time code. Beware that many bans on exception use are based on superstition (bad) or by concerns for older code bases with unsystematic resource management (unfortunately, but sometimes necessary). In such cases, consider the nothrow versions of new . Enforcement # Flag explicit use of malloc and free . R.11: Avoid calling new and delete explicitly # Reason # The pointer returned by new should belong to a resource handle (that can call delete ). If the pointer returned by new is assigned to a plain/naked pointer, the object can be leaked. Note # In a large program, a naked delete (that is a delete in application code, rather than part of code devoted to resource management) is a likely bug: if you have N delete s, how can you be certain that you don\u2019t need N+1 or N-1? The bug may be latent: it may emerge only during maintenance. If you have a naked new , you probably need a naked delete somewhere, so you probably have a bug. Enforcement # (Simple) Warn on any explicit use of new and delete . Suggest using make_unique instead. R.12: Immediately give the result of an explicit resource allocation to a manager object # Reason # If you don\u2019t, an exception or a return may lead to a leak. Example, bad # void f(const string& name) { FILE* f = fopen(name, \"r\"); // open the file vector<char> buf(1024); auto _ = finally([f] { fclose(f); }); // remember to close the file // ... } The allocation of buf may fail and leak the file handle. Example # void f(const string& name) { ifstream f{name}; // open the file vector<char> buf(1024); // ... } The use of the file handle (in ifstream ) is simple, efficient, and safe. Enforcement # Flag explicit allocations used to initialize pointers (problem: how many direct resource allocations can we recognize?) R.13: Perform at most one explicit resource allocation in a single expression statement # Reason # If you perform two explicit resource allocations in one statement, you could leak resources because the order of evaluation of many subexpressions, including function arguments, is unspecified. Example # void fun(shared_ptr<Widget> sp1, shared_ptr<Widget> sp2); This fun can be called like this: // BAD: potential leak fun(shared_ptr<Widget>(new Widget(a, b)), shared_ptr<Widget>(new Widget(c, d))); This is exception-unsafe because the compiler may reorder the two expressions building the function\u2019s two arguments. In particular, the compiler can interleave execution of the two expressions: Memory allocation (by calling operator new ) could be done first for both objects, followed by attempts to call the two Widget constructors. If one of the constructor calls throws an exception, then the other object\u2019s memory will never be released! This subtle problem has a simple solution: Never perform more than one explicit resource allocation in a single expression statement. For example: shared_ptr<Widget> sp1(new Widget(a, b)); // Better, but messy fun(sp1, new Widget(c, d)); The best solution is to avoid explicit allocation entirely use factory functions that return owning objects: fun(make_shared<Widget>(a, b), make_shared<Widget>(c, d)); // Best Write your own factory wrapper if there is not one already. Enforcement # Flag expressions with multiple explicit resource allocations (problem: how many direct resource allocations can we recognize?) R.14: Avoid [] parameters, prefer span # Reason # An array decays to a pointer, thereby losing its size, opening the opportunity for range errors. Use span to preserve size information. Example # void f(int[]); // not recommended void f(int*); // not recommended for multiple objects // (a pointer should point to a single object, do not subscript) void f(gsl::span<int>); // good, recommended Enforcement # Flag [] parameters. Use span instead. R.15: Always overload matched allocation/deallocation pairs # Reason # Otherwise you get mismatched operations and chaos. Example # class X { // ... void* operator new(size_t s); void operator delete(void*); // ... }; Note # If you want memory that cannot be deallocated, =delete the deallocation operation. Don\u2019t leave it undeclared. Enforcement # Flag incomplete pairs. R.smart: Smart pointers # R.20: Use unique_ptr or shared_ptr to represent ownership # Reason # They can prevent resource leaks. Example # Consider: void f() { X x; X* p1 { new X }; // see also ??? unique_ptr<T> p2 { new X }; // unique ownership; see also ??? shared_ptr<T> p3 { new X }; // shared ownership; see also ??? auto p4 = make_unique<X>(); // unique_ownership, preferable to the explicit use \"new\" auto p5 = make_shared<X>(); // shared ownership, preferable to the explicit use \"new\" } This will leak the object used to initialize p1 (only). Enforcement # (Simple) Warn if the return value of new or a function call with return value of pointer type is assigned to a raw pointer. R.21: Prefer unique_ptr over shared_ptr unless you need to share ownership # Reason # A unique_ptr is conceptually simpler and more predictable (you know when destruction happens) and faster (you don\u2019t implicitly maintain a use count). Example, bad # This needlessly adds and maintains a reference count. void f() { shared_ptr<Base> base = make_shared<Derived>(); // use base locally, without copying it -- refcount never exceeds 1 } // destroy base Example # This is more efficient: void f() { unique_ptr<Base> base = make_unique<Derived>(); // use base locally } // destroy base Enforcement # (Simple) Warn if a function uses a Shared_pointer with an object allocated within the function, but never returns the Shared_pointer or passes it to a function requiring a Shared_pointer& . Suggest using unique_ptr instead. R.22: Use make_shared() to make shared_ptr s # Reason # If you first make an object and then give it to a shared_ptr constructor, you (most likely) do one more allocation (and later deallocation) than if you use make_shared() because the reference counts must be allocated separately from the object. Example # Consider: shared_ptr<X> p1 { new X{2} }; // bad auto p = make_shared<X>(2); // good The make_shared() version mentions X only once, so it is usually shorter (as well as faster) than the version with the explicit new . Enforcement # (Simple) Warn if a shared_ptr is constructed from the result of new rather than make_shared . R.23: Use make_unique() to make unique_ptr s # Reason # For convenience and consistency with shared_ptr . Note # make_unique() is C++14, but widely available (as well as simple to write). Enforcement # (Simple) Warn if a unique_ptr is constructed from the result of new rather than make_unique . R.24: Use std::weak_ptr to break cycles of shared_ptr s # Reason # shared_ptr \u2018s rely on use counting and the use count for a cyclic structure never goes to zero, so we need a mechanism to be able to destroy a cyclic structure. Example # #include <memory> class bar; class foo { public: explicit foo(const std::shared_ptr<bar>& forward_reference) : forward_reference_(forward_reference) { } private: std::shared_ptr<bar> forward_reference_; }; class bar { public: explicit bar(const std::weak_ptr<foo>& back_reference) : back_reference_(back_reference) { } void do_something() { if (auto shared_back_reference = back_reference_.lock()) { // Use *shared_back_reference } } private: std::weak_ptr<foo> back_reference_; }; Note # ??? (HS: A lot of people say \u201cto break cycles\u201d, while I think \u201ctemporary shared ownership\u201d is more to the point.) ???(BS: breaking cycles is what you must do; temporarily sharing ownership is how you do it. You could \u201ctemporarily share ownership\u201d simply by using another shared_ptr .) Enforcement # ??? probably impossible. If we could statically detect cycles, we wouldn\u2019t need weak_ptr R.30: Take smart pointers as parameters only to explicitly express lifetime semantics # Reason # Accepting a smart pointer to a widget is wrong if the function just needs the widget itself. It should be able to accept any widget object, not just ones whose lifetimes are managed by a particular kind of smart pointer. A function that does not manipulate lifetime should take raw pointers or references instead. Example, bad # // callee void f(shared_ptr<widget>& w) { // ... use(*w); // only use of w -- the lifetime is not used at all // ... }; // caller shared_ptr<widget> my_widget = /* ... */; f(my_widget); widget stack_widget; f(stack_widget); // error Example, good # // callee void f(widget& w) { // ... use(w); // ... }; // caller shared_ptr<widget> my_widget = /* ... */; f(*my_widget); widget stack_widget; f(stack_widget); // ok -- now this works Enforcement # (Simple) Warn if a function takes a parameter of a smart pointer type (that overloads operator-> or operator* ) that is copyable but the function only calls any of: operator* , operator-> or get() . Suggest using a T* or T& instead. Flag a parameter of a smart pointer type (a type that overloads operator-> or operator* ) that is copyable/movable but never copied/moved from in the function body, and that is never modified, and that is not passed along to another function that could do so. That means the ownership semantics are not used. Suggest using a T* or T& instead. R.31: If you have non- std smart pointers, follow the basic pattern from std # Reason # The rules in the following section also work for other kinds of third-party and custom smart pointers and are very useful for diagnosing common smart pointer errors that cause performance and correctness problems. You want the rules to work on all the smart pointers you use. Any type (including primary template or specialization) that overloads unary * and -> is considered a smart pointer: If it is copyable, it is recognized as a reference-counted shared_ptr . If it is not copyable, it is recognized as a unique unique_ptr . Example # // use Boost's intrusive_ptr #include <boost/intrusive_ptr.hpp> void f(boost::intrusive_ptr<widget> p) // error under rule 'sharedptrparam' { p->foo(); } // use Microsoft's CComPtr #include <atlbase.h> void f(CComPtr<widget> p) // error under rule 'sharedptrparam' { p->foo(); } Both cases are an error under the sharedptrparam guideline : p is a Shared_pointer , but nothing about its sharedness is used here and passing it by value is a silent pessimization; these functions should accept a smart pointer only if they need to participate in the widget\u2019s lifetime management. Otherwise they should accept a widget* , if it can be nullptr . Otherwise, and ideally, the function should accept a widget& . These smart pointers match the Shared_pointer concept, so these guideline enforcement rules work on them out of the box and expose this common pessimization. R.32: Take a unique_ptr<widget> parameter to express that a function assumes ownership of a widget # Reason # Using unique_ptr in this way both documents and enforces the function call\u2019s ownership transfer. Example # void sink(unique_ptr<widget>); // takes ownership of the widget void uses(widget*); // just uses the widget Example, bad # void thinko(const unique_ptr<widget>&); // usually not what you want Enforcement # (Simple) Warn if a function takes a Unique_pointer<T> parameter by lvalue reference and does not either assign to it or call reset() on it on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Unique_pointer<T> parameter by reference to const . Suggest taking a const T* or const T& instead. R.33: Take a unique_ptr<widget>& parameter to express that a function reseats the widget # Reason # Using unique_ptr in this way both documents and enforces the function call\u2019s reseating semantics. Note # \u201creseat\u201d means \u201cmaking a pointer or a smart pointer refer to a different object.\u201d Example # void reseat(unique_ptr<widget>&); // \"will\" or \"might\" reseat pointer Example, bad # void thinko(const unique_ptr<widget>&); // usually not what you want Enforcement # (Simple) Warn if a function takes a Unique_pointer<T> parameter by lvalue reference and does not either assign to it or call reset() on it on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Unique_pointer<T> parameter by reference to const . Suggest taking a const T* or const T& instead. R.34: Take a shared_ptr<widget> parameter to express that a function is part owner # Reason # This makes the function\u2019s ownership sharing explicit. Example, good # void share(shared_ptr<widget>); // share -- \"will\" retain refcount void may_share(const shared_ptr<widget>&); // \"might\" retain refcount void reseat(shared_ptr<widget>&); // \"might\" reseat ptr Enforcement # (Simple) Warn if a function takes a Shared_pointer<T> parameter by lvalue reference and does not either assign to it or call reset() on it on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Shared_pointer<T> by value or by reference to const and does not copy or move it to another Shared_pointer on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Shared_pointer<T> by rvalue reference. Suggesting taking it by value instead. R.35: Take a shared_ptr<widget>& parameter to express that a function might reseat the shared pointer # Reason # This makes the function\u2019s reseating explicit. Note # \u201creseat\u201d means \u201cmaking a reference or a smart pointer refer to a different object.\u201d Example, good # void share(shared_ptr<widget>); // share -- \"will\" retain refcount void reseat(shared_ptr<widget>&); // \"might\" reseat ptr void may_share(const shared_ptr<widget>&); // \"might\" retain refcount Enforcement # (Simple) Warn if a function takes a Shared_pointer<T> parameter by lvalue reference and does not either assign to it or call reset() on it on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Shared_pointer<T> by value or by reference to const and does not copy or move it to another Shared_pointer on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Shared_pointer<T> by rvalue reference. Suggesting taking it by value instead. R.36: Take a const shared_ptr<widget>& parameter to express that it might retain a reference count to the object ??? # Reason # This makes the function\u2019s ??? explicit. Example, good # void share(shared_ptr<widget>); // share -- \"will\" retain refcount void reseat(shared_ptr<widget>&); // \"might\" reseat ptr void may_share(const shared_ptr<widget>&); // \"might\" retain refcount Enforcement # (Simple) Warn if a function takes a Shared_pointer<T> parameter by lvalue reference and does not either assign to it or call reset() on it on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Shared_pointer<T> by value or by reference to const and does not copy or move it to another Shared_pointer on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Shared_pointer<T> by rvalue reference. Suggesting taking it by value instead. R.37: Do not pass a pointer or reference obtained from an aliased smart pointer # Reason # Violating this rule is the number one cause of losing reference counts and finding yourself with a dangling pointer. Functions should prefer to pass raw pointers and references down call chains. At the top of the call tree where you obtain the raw pointer or reference from a smart pointer that keeps the object alive. You need to be sure that the smart pointer cannot inadvertently be reset or reassigned from within the call tree below. Note # To do this, sometimes you need to take a local copy of a smart pointer, which firmly keeps the object alive for the duration of the function and the call tree. Example # Consider this code: // global (static or heap), or aliased local ... shared_ptr<widget> g_p = ...; void f(widget& w) { g(); use(w); // A } void g() { g_p = ...; // oops, if this was the last shared_ptr to that widget, destroys the widget } The following should not pass code review: void my_code() { // BAD: passing pointer or reference obtained from a nonlocal smart pointer // that could be inadvertently reset somewhere inside f or it callees f(*g_p); // BAD: same reason, just passing it as a \"this\" pointer g_p->func(); } The fix is simple \u2013 take a local copy of the pointer to \u201ckeep a ref count\u201d for your call tree: void my_code() { // cheap: 1 increment covers this entire function and all the call trees below us auto pin = g_p; // GOOD: passing pointer or reference obtained from a local unaliased smart pointer f(*pin); // GOOD: same reason pin->func(); } Enforcement # (Simple) Warn if a pointer or reference obtained from a smart pointer variable ( Unique_pointer or Shared_pointer ) that is nonlocal, or that is local but potentially aliased, is used in a function call. If the smart pointer is a Shared_pointer then suggest taking a local copy of the smart pointer and obtain a pointer or reference from that instead. ES: Expressions and statements # Expressions and statements are the lowest and most direct way of expressing actions and computation. Declarations in local scopes are statements. For naming, commenting, and indentation rules, see NL: Naming and layout . General rules: ES.1: Prefer the standard library to other libraries and to \u201chandcrafted code\u201d ES.2: Prefer suitable abstractions to direct use of language features Declaration rules: ES.5: Keep scopes small ES.6: Declare names in for-statement initializers and conditions to limit scope ES.7: Keep common and local names short, and keep uncommon and nonlocal names longer ES.8: Avoid similar-looking names ES.9: Avoid ALL_CAPS names ES.10: Declare one name (only) per declaration ES.11: Use auto to avoid redundant repetition of type names ES.12: Do not reuse names in nested scopes ES.20: Always initialize an object ES.21: Don\u2019t introduce a variable (or constant) before you need to use it ES.22: Don\u2019t declare a variable until you have a value to initialize it with ES.23: Prefer the {} -initializer syntax ES.24: Use a unique_ptr<T> to hold pointers ES.25: Declare an object const or constexpr unless you want to modify its value later on ES.26: Don\u2019t use a variable for two unrelated purposes ES.27: Use std::array or stack_array for arrays on the stack ES.28: Use lambdas for complex initialization, especially of const variables ES.30: Don\u2019t use macros for program text manipulation ES.31: Don\u2019t use macros for constants or \u201cfunctions\u201d ES.32: Use ALL_CAPS for all macro names ES.33: If you must use macros, give them unique names ES.34: Don\u2019t define a (C-style) variadic function Expression rules: ES.40: Avoid complicated expressions ES.41: If in doubt about operator precedence, parenthesize ES.42: Keep use of pointers simple and straightforward ES.43: Avoid expressions with undefined order of evaluation ES.44: Don\u2019t depend on order of evaluation of function arguments ES.45: Avoid \u201cmagic constants\u201d; use symbolic constants ES.46: Avoid narrowing conversions ES.47: Use nullptr rather than 0 or NULL ES.48: Avoid casts ES.49: If you must use a cast, use a named cast ES.50: Don\u2019t cast away const ES.55: Avoid the need for range checking ES.56: Write std::move() only when you need to explicitly move an object to another scope ES.60: Avoid new and delete outside resource management functions ES.61: Delete arrays using delete[] and non-arrays using delete ES.62: Don\u2019t compare pointers into different arrays ES.63: Don\u2019t slice ES.64: Use the T{e} notation for construction ES.65: Don\u2019t dereference an invalid pointer Statement rules: ES.70: Prefer a switch -statement to an if -statement when there is a choice ES.71: Prefer a range- for -statement to a for -statement when there is a choice ES.72: Prefer a for -statement to a while -statement when there is an obvious loop variable ES.73: Prefer a while -statement to a for -statement when there is no obvious loop variable ES.74: Prefer to declare a loop variable in the initializer part of a for -statement ES.75: Avoid do -statements ES.76: Avoid goto ES.77: Minimize the use of break and continue in loops ES.78: Always end a non-empty case with a break ES.79: Use default to handle common cases (only) ES.84: Don\u2019t try to declare a local variable with no name ES.85: Make empty statements visible ES.86: Avoid modifying loop control variables inside the body of raw for-loops ES.87: Don\u2019t add redundant == or != to conditions Arithmetic rules: ES.100: Don\u2019t mix signed and unsigned arithmetic ES.101: Use unsigned types for bit manipulation ES.102: Use signed types for arithmetic ES.103: Don\u2019t overflow ES.104: Don\u2019t underflow ES.105: Don\u2019t divide by zero ES.106: Don\u2019t try to avoid negative values by using unsigned ES.107: Don\u2019t use unsigned for subscripts, prefer gsl::index ES.1: Prefer the standard library to other libraries and to \u201chandcrafted code\u201d # Reason # Code using a library can be much easier to write than code working directly with language features, much shorter, tend to be of a higher level of abstraction, and the library code is presumably already tested. The ISO C++ Standard Library is among the most widely known and best tested libraries. It is available as part of all C++ implementations. Example # auto sum = accumulate(begin(a), end(a), 0.0); // good a range version of accumulate would be even better: auto sum = accumulate(v, 0.0); // better but don\u2019t hand-code a well-known algorithm: int max = v.size(); // bad: verbose, purpose unstated double sum = 0.0; for (int i = 0; i < max; ++i) sum = sum + v[i]; Exception # Large parts of the standard library rely on dynamic allocation (free store). These parts, notably the containers but not the algorithms, are unsuitable for some hard-real-time and embedded applications. In such cases, consider providing/using similar facilities, e.g., a standard-library-style container implemented using a pool allocator. Enforcement # Not easy. ??? Look for messy loops, nested loops, long functions, absence of function calls, lack of use of non-built-in types. Cyclomatic complexity? ES.2: Prefer suitable abstractions to direct use of language features # Reason # A \u201csuitable abstraction\u201d (e.g., library or class) is closer to the application concepts than the bare language, leads to shorter and clearer code, and is likely to be better tested. Example # vector<string> read1(istream& is) // good { vector<string> res; for (string s; is >> s;) res.push_back(s); return res; } The more traditional and lower-level near-equivalent is longer, messier, harder to get right, and most likely slower: char** read2(istream& is, int maxelem, int maxstring, int* nread) // bad: verbose and incomplete { auto res = new char*[maxelem]; int elemcount = 0; while (is && elemcount < maxelem) { auto s = new char[maxstring]; is.read(s, maxstring); res[elemcount++] = s; } nread = &elemcount; return res; } Once the checking for overflow and error handling has been added that code gets quite messy, and there is the problem remembering to delete the returned pointer and the C-style strings that array contains. Enforcement # Not easy. ??? Look for messy loops, nested loops, long functions, absence of function calls, lack of use of non-built-in types. Cyclomatic complexity? ES.dcl: Declarations # A declaration is a statement. A declaration introduces a name into a scope and may cause the construction of a named object. ES.5: Keep scopes small # Reason # Readability. Minimize resource retention. Avoid accidental misuse of value. Alternative formulation : Don\u2019t declare a name in an unnecessarily large scope. Example # void use() { int i; // bad: i is needlessly accessible after loop for (i = 0; i < 20; ++i) { /* ... */ } // no intended use of i here for (int i = 0; i < 20; ++i) { /* ... */ } // good: i is local to for-loop if (auto pc = dynamic_cast<Circle*>(ps)) { // good: pc is local to if-statement // ... deal with Circle ... } else { // ... handle error ... } } Example, bad # void use(const string& name) { string fn = name + \".txt\"; ifstream is {fn}; Record r; is >> r; // ... 200 lines of code without intended use of fn or is ... } This function is by most measure too long anyway, but the point is that the resources used by fn and the file handle held by is are retained for much longer than needed and that unanticipated use of is and fn could happen later in the function. In this case, it might be a good idea to factor out the read: Record load_record(const string& name) { string fn = name + \".txt\"; ifstream is {fn}; Record r; is >> r; return r; } void use(const string& name) { Record r = load_record(name); // ... 200 lines of code ... } Enforcement # Flag loop variable declared outside a loop and not used after the loop Flag when expensive resources, such as file handles and locks are not used for N-lines (for some suitable N) ES.6: Declare names in for-statement initializers and conditions to limit scope # Reason # Readability. Minimize resource retention. Example # void use() { for (string s; cin >> s;) v.push_back(s); for (int i = 0; i < 20; ++i) { // good: i is local to for-loop // ... } if (auto pc = dynamic_cast<Circle*>(ps)) { // good: pc is local to if-statement // ... deal with Circle ... } else { // ... handle error ... } } Enforcement # Flag loop variables declared before the loop and not used after the loop (hard) Flag loop variables declared before the loop and used after the loop for an unrelated purpose. C++17 and C++20 example # Note: C++17 and C++20 also add if , switch , and range- for initializer statements. These require C++17 and C++20 support. map<int, string> mymap; if (auto result = mymap.insert(value); result.second) { // insert succeeded, and result is valid for this block use(result.first); // ok // ... } // result is destroyed here C++17 and C++20 enforcement (if using a C++17 or C++20 compiler) # Flag selection/loop variables declared before the body and not used after the body (hard) Flag selection/loop variables declared before the body and used after the body for an unrelated purpose. ES.7: Keep common and local names short, and keep uncommon and nonlocal names longer # Reason # Readability. Lowering the chance of clashes between unrelated non-local names. Example # Conventional short, local names increase readability: template<typename T> // good void print(ostream& os, const vector<T>& v) { for (gsl::index i = 0; i < v.size(); ++i) os << v[i] << '\\n'; } An index is conventionally called i and there is no hint about the meaning of the vector in this generic function, so v is as good name as any. Compare template<typename Element_type> // bad: verbose, hard to read void print(ostream& target_stream, const vector<Element_type>& current_vector) { for (gsl::index current_element_index = 0; current_element_index < current_vector.size(); ++current_element_index ) target_stream << current_vector[current_element_index] << '\\n'; } Yes, it is a caricature, but we have seen worse. Example # Unconventional and short non-local names obscure code: void use1(const string& s) { // ... tt(s); // bad: what is tt()? // ... } Better, give non-local entities readable names: void use1(const string& s) { // ... trim_tail(s); // better // ... } Here, there is a chance that the reader knows what trim_tail means and that the reader can remember it after looking it up. Example, bad # Argument names of large functions are de facto non-local and should be meaningful: void complicated_algorithm(vector<Record>& vr, const vector<int>& vi, map<string, int>& out) // read from events in vr (marking used Records) for the indices in // vi placing (name, index) pairs into out { // ... 500 lines of code using vr, vi, and out ... } We recommend keeping functions short, but that rule isn\u2019t universally adhered to and naming should reflect that. Enforcement # Check length of local and non-local names. Also take function length into account. ES.8: Avoid similar-looking names # Reason # Code clarity and readability. Too-similar names slow down comprehension and increase the likelihood of error. Example, bad # if (readable(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) surprise(); Example, bad # Do not declare a non-type with the same name as a type in the same scope. This removes the need to disambiguate with a keyword such as struct or enum . It also removes a source of errors, as struct X can implicitly declare X if lookup fails. struct foo { int n; }; struct foo foo(); // BAD, foo is a type already in scope struct foo x = foo(); // requires disambiguation Exception # Antique header files might declare non-types and types with the same name in the same scope. Enforcement # Check names against a list of known confusing letter and digit combinations. Flag a declaration of a variable, function, or enumerator that hides a class or enumeration declared in the same scope. ES.9: Avoid ALL_CAPS names # Reason # Such names are commonly used for macros. Thus, ALL_CAPS name are vulnerable to unintended macro substitution. Example # // somewhere in some header: #define NE != // somewhere else in some other header: enum Coord { N, NE, NW, S, SE, SW, E, W }; // somewhere third in some poor programmer's .cpp: switch (direction) { case N: // ... case NE: // ... // ... } Note # Do not use ALL_CAPS for constants just because constants used to be macros. Enforcement # Flag all uses of ALL CAPS. For older code, accept ALL CAPS for macro names and flag all non-ALL-CAPS macro names. ES.10: Declare one name (only) per declaration # Reason # One declaration per line increases readability and avoids mistakes related to the C/C++ grammar. It also leaves room for a more descriptive end-of-line comment. Example, bad # char *p, c, a[7], *pp[7], **aa[10]; // yuck! Exception # A function declaration can contain several function argument declarations. Exception # A structured binding (C++17) is specifically designed to introduce several variables: auto [iter, inserted] = m.insert_or_assign(k, val); if (inserted) { /* new entry was inserted */ } Example # template <class InputIterator, class Predicate> bool any_of(InputIterator first, InputIterator last, Predicate pred); or better using concepts: bool any_of(InputIterator first, InputIterator last, Predicate pred); Example # double scalbn(double x, int n); // OK: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2 or: double scalbn( // better: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2 double x, // base value int n // exponent ); or: // better: base * pow(FLT_RADIX, exponent); FLT_RADIX is usually 2 double scalbn(double base, int exponent); Example # int a = 7, b = 9, c, d = 10, e = 3; In a long list of declarators it is easy to overlook an uninitialized variable. Enforcement # Flag variable and constant declarations with multiple declarators (e.g., int* p, q; ) ES.11: Use auto to avoid redundant repetition of type names # Reason # Simple repetition is tedious and error-prone. When you use auto , the name of the declared entity is in a fixed position in the declaration, increasing readability. In a template function declaration the return type can be a member type. Example # Consider: auto p = v.begin(); // vector<int>::iterator auto h = t.future(); auto q = make_unique<int[]>(s); auto f = [](int x){ return x + 10; }; In each case, we save writing a longish, hard-to-remember type that the compiler already knows but a programmer could get wrong. Example # template<class T> auto Container<T>::first() -> Iterator; // Container<T>::Iterator Exception # Avoid auto for initializer lists and in cases where you know exactly which type you want and where an initializer might require conversion. Example # auto lst = { 1, 2, 3 }; // lst is an initializer list auto x{1}; // x is an int (in C++17; initializer_list in C++11) Note # When concepts become available, we can (and should) be more specific about the type we are deducing: // ... ForwardIterator p = algo(x, y, z); Example (C++17) # auto [ quotient, remainder ] = div(123456, 73); // break out the members of the div_t result Enforcement # Flag redundant repetition of type names in a declaration. ES.12: Do not reuse names in nested scopes # Reason # It is easy to get confused about which variable is used. Can cause maintenance problems. Example, bad # int d = 0; // ... if (cond) { // ... d = 9; // ... } else { // ... int d = 7; // ... d = value_to_be_returned; // ... } return d; If this is a large if -statement, it is easy to overlook that a new d has been introduced in the inner scope. This is a known source of bugs. Sometimes such reuse of a name in an inner scope is called \u201cshadowing\u201d. Note # Shadowing is primarily a problem when functions are too large and too complex. Example # Shadowing of function arguments in the outermost block is disallowed by the language: void f(int x) { int x = 4; // error: reuse of function argument name if (x) { int x = 7; // allowed, but bad // ... } } Example, bad # Reuse of a member name as a local variable can also be a problem: struct S { int m; void f(int x); }; void S::f(int x) { m = 7; // assign to member if (x) { int m = 9; // ... m = 99; // assign to local variable // ... } } Exception # We often reuse function names from a base class in a derived class: struct B { void f(int); }; struct D : B { void f(double); using B::f; }; This is error-prone. For example, had we forgotten the using declaration, a call d.f(1) would not have found the int version of f . ??? Do we need a specific rule about shadowing/hiding in class hierarchies? Enforcement # Flag reuse of a name in nested local scopes Flag reuse of a member name as a local variable in a member function Flag reuse of a global name as a local variable or a member name Flag reuse of a base class member name in a derived class (except for function names) ES.20: Always initialize an object # Reason # Avoid used-before-set errors and their associated undefined behavior. Avoid problems with comprehension of complex initialization. Simplify refactoring. Example # void use(int arg) { int i; // bad: uninitialized variable // ... i = 7; // initialize i } No, i = 7 does not initialize i ; it assigns to it. Also, i can be read in the ... part. Better: void use(int arg) // OK { int i = 7; // OK: initialized string s; // OK: default initialized // ... } Note # The always initialize rule is deliberately stronger than the an object must be set before used language rule. The latter, more relaxed rule, catches the technical bugs, but: It leads to less readable code It encourages people to declare names in greater than necessary scopes It leads to harder to read code It leads to logic bugs by encouraging complex code It hampers refactoring The always initialize rule is a style rule aimed to improve maintainability as well as a rule protecting against used-before-set errors. Example # Here is an example that is often considered to demonstrate the need for a more relaxed rule for initialization widget i; // \"widget\" a type that's expensive to initialize, possibly a large POD widget j; if (cond) { // bad: i and j are initialized \"late\" i = f1(); j = f2(); } else { i = f3(); j = f4(); } This cannot trivially be rewritten to initialize i and j with initializers. Note that for types with a default constructor, attempting to postpone initialization simply leads to a default initialization followed by an assignment. A popular reason for such examples is \u201cefficiency\u201d, but a compiler that can detect whether we made a used-before-set error can also eliminate any redundant double initialization. Assuming that there is a logical connection between i and j , that connection should probably be expressed in code: pair<widget, widget> make_related_widgets(bool x) { return (x) ? {f1(), f2()} : {f3(), f4() }; } auto [i, j] = make_related_widgets(cond); // C++17 Note # Complex initialization has been popular with clever programmers for decades. It has also been a major source of errors and complexity. Many such errors are introduced during maintenance years after the initial implementation. Example # This rule covers member variables. class X { public: X(int i, int ci) : m2{i}, cm2{ci} {} // ... private: int m1 = 7; int m2; int m3; const int cm1 = 7; const int cm2; const int cm3; }; The compiler will flag the uninitialized cm3 because it is a const , but it will not catch the lack of initialization of m3 . Usually, a rare spurious member initialization is worth the absence of errors from lack of initialization and often an optimizer can eliminate a redundant initialization (e.g., an initialization that occurs immediately before an assignment). Exception # If you are declaring an object that is just about to be initialized from input, initializing it would cause a double initialization. However, beware that this may leave uninitialized data beyond the input \u2013 and that has been a fertile source of errors and security breaches: constexpr int max = 8 * 1024; int buf[max]; // OK, but suspicious: uninitialized f.read(buf, max); The cost of initializing that array could be significant in some situations. However, such examples do tend to leave uninitialized variables accessible, so they should be treated with suspicion. constexpr int max = 8 * 1024; int buf[max] = {}; // zero all elements; better in some situations f.read(buf, max); When feasible use a library function that is known not to overflow. For example: string s; // s is default initialized to \"\" cin >> s; // s expands to hold the string Don\u2019t consider simple variables that are targets for input operations exceptions to this rule: int i; // bad // ... cin >> i; In the not uncommon case where the input target and the input operation get separated (as they should not) the possibility of used-before-set opens up. int i2 = 0; // better, assuming that zero is an acceptable value for i2 // ... cin >> i2; A good optimizer should know about input operations and eliminate the redundant operation. Example # Using a value representing \u201cuninitialized\u201d is a symptom of a problem and not a solution: widget i = uninit; // bad widget j = uninit; // ... use(i); // possibly used before set // ... if (cond) { // bad: i and j are initialized \"late\" i = f1(); j = f2(); } else { i = f3(); j = f4(); } Now the compiler cannot even simply detect a used-before-set. Further, we\u2019ve introduced complexity in the state space for widget: which operations are valid on an uninit widget and which are not? Note # Sometimes, a lambda can be used as an initializer to avoid an uninitialized variable: error_code ec; Value v = [&] { auto p = get_value(); // get_value() returns a pair<error_code, Value> ec = p.first; return p.second; }(); or maybe: Value v = [] { auto p = get_value(); // get_value() returns a pair<error_code, Value> if (p.first) throw Bad_value{p.first}; return p.second; }(); See also : ES.28 Enforcement # Flag every uninitialized variable. Don\u2019t flag variables of user-defined types with default constructors. Check that an uninitialized buffer is written into immediately after declaration. Passing an uninitialized variable as a reference to non- const argument can be assumed to be a write into the variable. ES.21: Don\u2019t introduce a variable (or constant) before you need to use it # Reason # Readability. To limit the scope in which the variable can be used. Example # int x = 7; // ... no use of x here ... ++x; Enforcement # Flag declarations that are distant from their first use. ES.22: Don\u2019t declare a variable until you have a value to initialize it with # Reason # Readability. Limit the scope in which a variable can be used. Don\u2019t risk used-before-set. Initialization is often more efficient than assignment. Example, bad # string s; // ... no use of s here ... s = \"what a waste\"; Example, bad # SomeLargeType var; // ugly CaMeLcAsEvArIaBlE if (cond) // some non-trivial condition Set(&var); else if (cond2 || !cond3) { var = Set2(3.14); } else { var = 0; for (auto& e : something) var += e; } // use var; that this isn't done too early can be enforced statically with only control flow This would be fine if there was a default initialization for SomeLargeType that wasn\u2019t too expensive. Otherwise, a programmer might very well wonder if every possible path through the maze of conditions has been covered. If not, we have a \u201cuse before set\u201d bug. This is a maintenance trap. For initializers of moderate complexity, including for const variables, consider using a lambda to express the initializer; see ES.28 . Enforcement # Flag declarations with default initialization that are assigned to before they are first read. Flag any complicated computation after an uninitialized variable and before its use. ES.23: Prefer the {} -initializer syntax # Reason # Prefer {} . The rules for {} initialization are simpler, more general, less ambiguous, and safer than for other forms of initialization. Use = only when you are sure that there can be no narrowing conversions. For built-in arithmetic types, use = only with auto . Avoid () initialization, which allows parsing ambiguities. Example # int x {f(99)}; int y = x; vector<int> v = {1, 2, 3, 4, 5, 6}; Exception # For containers, there is a tradition for using {...} for a list of elements and (...) for sizes: vector<int> v1(10); // vector of 10 elements with the default value 0 vector<int> v2{10}; // vector of 1 element with the value 10 vector<int> v3(1, 2); // vector of 1 element with the value 2 vector<int> v4{1, 2}; // vector of 2 element with the values 1 and 2 Note # {} -initializers do not allow narrowing conversions (and that is usually a good thing) and allow explicit constructors (which is fine, we\u2019re intentionally initializing a new variable). Example # int x {7.9}; // error: narrowing int y = 7.9; // OK: y becomes 7. Hope for a compiler warning int z = gsl::narrow_cast<int>(7.9); // OK: you asked for it Note # {} initialization can be used for nearly all initialization; other forms of initialization can\u2019t: auto p = new vector<int> {1, 2, 3, 4, 5}; // initialized vector D::D(int a, int b) :m{a, b} { // member initializer (e.g., m might be a pair) // ... }; X var {}; // initialize var to be empty struct S { int m {7}; // default initializer for a member // ... }; For that reason, {} -initialization is often called \u201cuniform initialization\u201d (though there unfortunately are a few irregularities left). Note # Initialization of a variable declared using auto with a single value, e.g., {v} , had surprising results until C++17. The C++17 rules are somewhat less surprising: auto x1 {7}; // x1 is an int with the value 7 auto x2 = {7}; // x2 is an initializer_list<int> with an element 7 auto x11 {7, 8}; // error: two initializers auto x22 = {7, 8}; // x22 is an initializer_list<int> with elements 7 and 8 Use ={...} if you really want an initializer_list<T> auto fib10 = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55}; // fib10 is a list Note # ={} gives copy initialization whereas {} gives direct initialization. Like the distinction between copy-initialization and direct-initialization itself, this can lead to surprises. {} accepts explicit constructors; ={} does not. For example: struct Z { explicit Z() {} }; Z z1{}; // OK: direct initialization, so we use explicit constructor Z z2 = {}; // error: copy initialization, so we cannot use the explicit constructor Use plain {} -initialization unless you specifically want to disable explicit constructors. Example # template<typename T> void f() { T x1(1); // T initialized with 1 T x0(); // bad: function declaration (often a mistake) T y1 {1}; // T initialized with 1 T y0 {}; // default initialized T // ... } See also : Discussion Enforcement # Flag uses of = to initialize arithmetic types where narrowing occurs. Flag uses of () initialization syntax that are actually declarations. (Many compilers should warn on this already.) ES.24: Use a unique_ptr<T> to hold pointers # Reason # Using std::unique_ptr is the simplest way to avoid leaks. It is reliable, it makes the type system do much of the work to validate ownership safety, it increases readability, and it has zero or near zero run-time cost. Example # void use(bool leak) { auto p1 = make_unique<int>(7); // OK int* p2 = new int{7}; // bad: might leak // ... no assignment to p2 ... if (leak) return; // ... no assignment to p2 ... vector<int> v(7); v.at(7) = 0; // exception thrown // ... } If leak == true the object pointed to by p2 is leaked and the object pointed to by p1 is not. The same is the case when at() throws. Enforcement # Look for raw pointers that are targets of new , malloc() , or functions that may return such pointers. ES.25: Declare an object const or constexpr unless you want to modify its value later on # Reason # That way you can\u2019t change the value by mistake. That way may offer the compiler optimization opportunities. Example # void f(int n) { const int bufmax = 2 * n + 2; // good: we can't change bufmax by accident int xmax = n; // suspicious: is xmax intended to change? // ... } Enforcement # Look to see if a variable is actually mutated, and flag it if not. Unfortunately, it may be impossible to detect when a non- const was not intended to vary (vs when it merely did not vary). ES.26: Don\u2019t use a variable for two unrelated purposes # Reason # Readability and safety. Example, bad # void use() { int i; for (i = 0; i < 20; ++i) { /* ... */ } for (i = 0; i < 200; ++i) { /* ... */ } // bad: i recycled } Note # As an optimization, you may want to reuse a buffer as a scratch pad, but even then prefer to limit the variable\u2019s scope as much as possible and be careful not to cause bugs from data left in a recycled buffer as this is a common source of security bugs. void write_to_file() { std::string buffer; // to avoid reallocations on every loop iteration for (auto& o : objects) { // First part of the work. generate_first_string(buffer, o); write_to_file(buffer); // Second part of the work. generate_second_string(buffer, o); write_to_file(buffer); // etc... } } Enforcement # Flag recycled variables. ES.27: Use std::array or stack_array for arrays on the stack # Reason # They are readable and don\u2019t implicitly convert to pointers. They are not confused with non-standard extensions of built-in arrays. Example, bad # const int n = 7; int m = 9; void f() { int a1[n]; int a2[m]; // error: not ISO C++ // ... } Note # The definition of a1 is legal C++ and has always been. There is a lot of such code. It is error-prone, though, especially when the bound is non-local. Also, it is a \u201cpopular\u201d source of errors (buffer overflow, pointers from array decay, etc.). The definition of a2 is C but not C++ and is considered a security risk Example # const int n = 7; int m = 9; void f() { array<int, n> a1; stack_array<int> a2(m); // ... } Enforcement # Flag arrays with non-constant bounds (C-style VLAs) Flag arrays with non-local constant bounds ES.28: Use lambdas for complex initialization, especially of const variables # Reason # It nicely encapsulates local initialization, including cleaning up scratch variables needed only for the initialization, without needing to create a needless nonlocal yet nonreusable function. It also works for variables that should be const but only after some initialization work. Example, bad # widget x; // should be const, but: for (auto i = 2; i <= N; ++i) { // this could be some x += some_obj.do_something_with(i); // arbitrarily long code } // needed to initialize x // from here, x should be const, but we can't say so in code in this style Example, good # const widget x = [&]{ widget val; // assume that widget has a default constructor for (auto i = 2; i <= N; ++i) { // this could be some val += some_obj.do_something_with(i); // arbitrarily long code } // needed to initialize x return val; }(); Example # string var = [&]{ if (!in) return \"\"; // default string s; for (char c : in >> c) s += toupper(c); return s; }(); // note () If at all possible, reduce the conditions to a simple set of alternatives (e.g., an enum ) and don\u2019t mix up selection and initialization. Enforcement # Hard. At best a heuristic. Look for an uninitialized variable followed by a loop assigning to it. ES.30: Don\u2019t use macros for program text manipulation # Reason # Macros are a major source of bugs. Macros don\u2019t obey the usual scope and type rules. Macros ensure that the human reader sees something different from what the compiler sees. Macros complicate tool building. Example, bad # #define Case break; case /* BAD */ This innocuous-looking macro makes a single lower case c instead of a C into a bad flow-control bug. Note # This rule does not ban the use of macros for \u201cconfiguration control\u201d use in #ifdef s, etc. In the future, modules are likely to eliminate the need for macros in configuration control. Note # This rule is meant to also discourage use of # for stringification and ## for concatenation. As usual for macros, there are uses that are \u201cmostly harmless\u201d, but even these can create problems for tools, such as auto completers, static analyzers, and debuggers. Often the desire to use fancy macros is a sign of an overly complex design. Also, # and ## encourages the definition and use of macros: #define CAT(a, b) a ## b #define STRINGIFY(a) #a void f(int x, int y) { string CAT(x, y) = \"asdf\"; // BAD: hard for tools to handle (and ugly) string sx2 = STRINGIFY(x); // ... } There are workarounds for low-level string manipulation using macros. For example: string s = \"asdf\" \"lkjh\"; // ordinary string literal concatenation enum E { a, b }; template<int x> constexpr const char* stringify() { switch (x) { case a: return \"a\"; case b: return \"b\"; } } void f(int x, int y) { string sx = stringify<x>(); // ... } This is not as convenient as a macro to define, but as easy to use, has zero overhead, and is typed and scoped. In the future, static reflection is likely to eliminate the last needs for the preprocessor for program text manipulation. Enforcement # Scream when you see a macro that isn\u2019t just used for source control (e.g., #ifdef ) ES.31: Don\u2019t use macros for constants or \u201cfunctions\u201d # Reason # Macros are a major source of bugs. Macros don\u2019t obey the usual scope and type rules. Macros don\u2019t obey the usual rules for argument passing. Macros ensure that the human reader sees something different from what the compiler sees. Macros complicate tool building. Example, bad # #define PI 3.14 #define SQUARE(a, b) (a * b) Even if we hadn\u2019t left a well-known bug in SQUARE there are much better behaved alternatives; for example: constexpr double pi = 3.14; template<typename T> T square(T a, T b) { return a * b; } Enforcement # Scream when you see a macro that isn\u2019t just used for source control (e.g., #ifdef ) ES.32: Use ALL_CAPS for all macro names # Reason # Convention. Readability. Distinguishing macros. Example # #define forever for (;;) /* very BAD */ #define FOREVER for (;;) /* Still evil, but at least visible to humans */ Enforcement # Scream when you see a lower case macro. ES.33: If you must use macros, give them unique names # Reason # Macros do not obey scope rules. Example # #define MYCHAR /* BAD, will eventually clash with someone else's MYCHAR*/ #define ZCORP_CHAR /* Still evil, but less likely to clash */ Note # Avoid macros if you can: ES.30 , ES.31 , and ES.32 . However, there are billions of lines of code littered with macros and a long tradition for using and overusing macros. If you are forced to use macros, use long names and supposedly unique prefixes (e.g., your organization\u2019s name) to lower the likelihood of a clash. Enforcement # Warn against short macro names. ES.34: Don\u2019t define a (C-style) variadic function # Reason # Not type safe. Requires messy cast-and-macro-laden code to get working right. Example # #include <cstdarg> // \"severity\" followed by a zero-terminated list of char*s; write the C-style strings to cerr void error(int severity ...) { va_list ap; // a magic type for holding arguments va_start(ap, severity); // arg startup: \"severity\" is the first argument of error() for (;;) { // treat the next var as a char*; no checking: a cast in disguise char* p = va_arg(ap, char*); if (!p) break; cerr << p << ' '; } va_end(ap); // arg cleanup (don't forget this) cerr << '\\n'; if (severity) exit(severity); } void use() { error(7, \"this\", \"is\", \"an\", \"error\", nullptr); error(7); // crash error(7, \"this\", \"is\", \"an\", \"error\"); // crash const char* is = \"is\"; string an = \"an\"; error(7, \"this\", \"is\", an, \"error\"); // crash } Alternative : Overloading. Templates. Variadic templates. #include <iostream> void error(int severity) { std::cerr << '\\n'; std::exit(severity); } template <typename T, typename... Ts> constexpr void error(int severity, T head, Ts... tail) { std::cerr << head; error(severity, tail...); } void use() { error(7); // No crash! error(5, \"this\", \"is\", \"not\", \"an\", \"error\"); // No crash! std::string an = \"an\"; error(7, \"this\", \"is\", \"not\", an, \"error\"); // No crash! error(5, \"oh\", \"no\", nullptr); // Compile error! No need for nullptr. } Note # This is basically the way printf is implemented. Enforcement # Flag definitions of C-style variadic functions. Flag #include <cstdarg> and #include <stdarg.h> ES.expr: Expressions # Expressions manipulate values. ES.40: Avoid complicated expressions # Reason # Complicated expressions are error-prone. Example # // bad: assignment hidden in subexpression while ((c = getc()) != -1) // bad: two non-local variables assigned in sub-expressions while ((cin >> c1, cin >> c2), c1 == c2) // better, but possibly still too complicated for (char c1, c2; cin >> c1 >> c2 && c1 == c2;) // OK: if i and j are not aliased int x = ++i + ++j; // OK: if i != j and i != k v[i] = v[j] + v[k]; // bad: multiple assignments \"hidden\" in subexpressions x = a + (b = f()) + (c = g()) * 7; // bad: relies on commonly misunderstood precedence rules x = a & b + c * d && e ^ f == 7; // bad: undefined behavior x = x++ + x++ + ++x; Some of these expressions are unconditionally bad (e.g., they rely on undefined behavior). Others are simply so complicated and/or unusual that even good programmers could misunderstand them or overlook a problem when in a hurry. Note # C++17 tightens up the rules for the order of evaluation (left-to-right except right-to-left in assignments, and the order of evaluation of function arguments is unspecified; see ES.43 ), but that doesn\u2019t change the fact that complicated expressions are potentially confusing. Note # A programmer should know and use the basic rules for expressions. Example # x = k * y + z; // OK auto t1 = k * y; // bad: unnecessarily verbose x = t1 + z; if (0 <= x && x < max) // OK auto t1 = 0 <= x; // bad: unnecessarily verbose auto t2 = x < max; if (t1 && t2) // ... Enforcement # Tricky. How complicated must an expression be to be considered complicated? Writing computations as statements with one operation each is also confusing. Things to consider: side effects: side effects on multiple non-local variables (for some definition of non-local) can be suspect, especially if the side effects are in separate subexpressions writes to aliased variables more than N operators (and what should N be?) reliance of subtle precedence rules uses undefined behavior (can we catch all undefined behavior?) implementation defined behavior? ??? ES.41: If in doubt about operator precedence, parenthesize # Reason # Avoid errors. Readability. Not everyone has the operator table memorized. Example # const unsigned int flag = 2; unsigned int a = flag; if (a & flag != 0) // bad: means a&(flag != 0) Note: We recommend that programmers know their precedence table for the arithmetic operations, the logical operations, but consider mixing bitwise logical operations with other operators in need of parentheses. if ((a & flag) != 0) // OK: works as intended Note # You should know enough not to need parentheses for: if (a < 0 || a <= max) { // ... } Enforcement # Flag combinations of bitwise-logical operators and other operators. Flag assignment operators not as the leftmost operator. ??? ES.42: Keep use of pointers simple and straightforward # Reason # Complicated pointer manipulation is a major source of errors. Note # Use gsl::span instead. Pointers should only refer to single objects . Pointer arithmetic is fragile and easy to get wrong, the source of many, many bad bugs and security violations. span is a bounds-checked, safe type for accessing arrays of data. Access into an array with known bounds using a constant as a subscript can be validated by the compiler. Example, bad # void f(int* p, int count) { if (count < 2) return; int* q = p + 1; // BAD ptrdiff_t d; int n; d = (p - &n); // OK d = (q - p); // OK int n = *p++; // BAD if (count < 6) return; p[4] = 1; // BAD p[count - 1] = 2; // BAD use(&p[0], 3); // BAD } Example, good # void f(span<int> a) // BETTER: use span in the function declaration { if (a.size() < 2) return; int n = a[0]; // OK span<int> q = a.subspan(1); // OK if (a.size() < 6) return; a[4] = 1; // OK a[a.size() - 1] = 2; // OK use(a.data(), 3); // OK } Note # Subscripting with a variable is difficult for both tools and humans to validate as safe. span is a run-time bounds-checked, safe type for accessing arrays of data. at() is another alternative that ensures single accesses are bounds-checked. If iterators are needed to access an array, use the iterators from a span constructed over the array. Example, bad # void f(array<int, 10> a, int pos) { a[pos / 2] = 1; // BAD a[pos - 1] = 2; // BAD a[-1] = 3; // BAD (but easily caught by tools) -- no replacement, just don't do this a[10] = 4; // BAD (but easily caught by tools) -- no replacement, just don't do this } Example, good # Use a span : void f1(span<int, 10> a, int pos) // A1: Change parameter type to use span { a[pos / 2] = 1; // OK a[pos - 1] = 2; // OK } void f2(array<int, 10> arr, int pos) // A2: Add local span and use that { span<int> a = {arr.data(), pos}; a[pos / 2] = 1; // OK a[pos - 1] = 2; // OK } Use at() : void f3(array<int, 10> a, int pos) // ALTERNATIVE B: Use at() for access { at(a, pos / 2) = 1; // OK at(a, pos - 1) = 2; // OK } Example, bad # void f() { int arr[COUNT]; for (int i = 0; i < COUNT; ++i) arr[i] = i; // BAD, cannot use non-constant indexer } Example, good # Use a span : void f1() { int arr[COUNT]; span<int> av = arr; for (int i = 0; i < COUNT; ++i) av[i] = i; } Use a span and range- for : void f1a() { int arr[COUNT]; span<int, COUNT> av = arr; int i = 0; for (auto& e : av) e = i++; } Use at() for access: void f2() { int arr[COUNT]; for (int i = 0; i < COUNT; ++i) at(arr, i) = i; } Use a range- for : void f3() { int arr[COUNT]; int i = 0; for (auto& e : arr) e = i++; } Note # Tooling can offer rewrites of array accesses that involve dynamic index expressions to use at() instead: static int a[10]; void f(int i, int j) { a[i + j] = 12; // BAD, could be rewritten as ... at(a, i + j) = 12; // OK -- bounds-checked } Example # Turning an array into a pointer (as the language does essentially always) removes opportunities for checking, so avoid it void g(int* p); void f() { int a[5]; g(a); // BAD: are we trying to pass an array? g(&a[0]); // OK: passing one object } If you want to pass an array, say so: void g(int* p, size_t length); // old (dangerous) code void g1(span<int> av); // BETTER: get g() changed. void f2() { int a[5]; span<int> av = a; g(av.data(), av.size()); // OK, if you have no choice g1(a); // OK -- no decay here, instead use implicit span ctor } Enforcement # Flag any arithmetic operation on an expression of pointer type that results in a value of pointer type. Flag any indexing expression on an expression or variable of array type (either static array or std::array ) where the indexer is not a compile-time constant expression with a value between 0 and the upper bound of the array. Flag any expression that would rely on implicit conversion of an array type to a pointer type. This rule is part of the bounds-safety profile . ES.43: Avoid expressions with undefined order of evaluation # Reason # You have no idea what such code does. Portability. Even if it does something sensible for you, it may do something different on another compiler (e.g., the next release of your compiler) or with a different optimizer setting. Note # C++17 tightens up the rules for the order of evaluation: left-to-right except right-to-left in assignments, and the order of evaluation of function arguments is unspecified. However, remember that your code may be compiled with a pre-C++17 compiler (e.g., through cut-and-paste) so don\u2019t be too clever. Example # v[i] = ++i; // the result is undefined A good rule of thumb is that you should not read a value twice in an expression where you write to it. Enforcement # Can be detected by a good analyzer. ES.44: Don\u2019t depend on order of evaluation of function arguments # Reason # Because that order is unspecified. Note # C++17 tightens up the rules for the order of evaluation, but the order of evaluation of function arguments is still unspecified. Example # int i = 0; f(++i, ++i); The call will most likely be f(0, 1) or f(1, 0) , but you don\u2019t know which. Technically, the behavior is undefined. In C++17, this code does not have undefined behavior, but it is still not specified which argument is evaluated first. Example # Overloaded operators can lead to order of evaluation problems: f1()->m(f2()); // m(f1(), f2()) cout << f1() << f2(); // operator<<(operator<<(cout, f1()), f2()) In C++17, these examples work as expected (left to right) and assignments are evaluated right to left (just as =\u2019s binding is right-to-left) f1() = f2(); // undefined behavior in C++14; in C++17, f2() is evaluated before f1() Enforcement # Can be detected by a good analyzer. ES.45: Avoid \u201cmagic constants\u201d; use symbolic constants # Reason # Unnamed constants embedded in expressions are easily overlooked and often hard to understand: Example # for (int m = 1; m <= 12; ++m) // don't: magic constant 12 cout << month[m] << '\\n'; No, we don\u2019t all know that there are 12 months, numbered 1..12, in a year. Better: // months are indexed 1..12 constexpr int first_month = 1; constexpr int last_month = 12; for (int m = first_month; m <= last_month; ++m) // better cout << month[m] << '\\n'; Better still, don\u2019t expose constants: for (auto m : month) cout << m << '\\n'; Enforcement # Flag literals in code. Give a pass to 0 , 1 , nullptr , \\n , \"\" , and others on a positive list. ES.46: Avoid lossy (narrowing, truncating) arithmetic conversions # Reason # A narrowing conversion destroys information, often unexpectedly so. Example, bad # A key example is basic narrowing: double d = 7.9; int i = d; // bad: narrowing: i becomes 7 i = (int) d; // bad: we're going to claim this is still not explicit enough void f(int x, long y, double d) { char c1 = x; // bad: narrowing char c2 = y; // bad: narrowing char c3 = d; // bad: narrowing } Note # The guidelines support library offers a narrow_cast operation for specifying that narrowing is acceptable and a narrow (\u201cnarrow if\u201d) that throws an exception if a narrowing would throw away information: i = narrow_cast<int>(d); // OK (you asked for it): narrowing: i becomes 7 i = narrow<int>(d); // OK: throws narrowing_error We also include lossy arithmetic casts, such as from a negative floating point type to an unsigned integral type: double d = -7.9; unsigned u = 0; u = d; // BAD u = narrow_cast<unsigned>(d); // OK (you asked for it): u becomes 4294967289 u = narrow<unsigned>(d); // OK: throws narrowing_error Enforcement # A good analyzer can detect all narrowing conversions. However, flagging all narrowing conversions will lead to a lot of false positives. Suggestions: Flag all floating-point to integer conversions (maybe only float -> char and double -> int . Here be dragons! we need data). Flag all long -> char (I suspect int -> char is very common. Here be dragons! we need data). Consider narrowing conversions for function arguments especially suspect. ES.47: Use nullptr rather than 0 or NULL # Reason # Readability. Minimize surprises: nullptr cannot be confused with an int . nullptr also has a well-specified (very restrictive) type, and thus works in more scenarios where type deduction might do the wrong thing on NULL or 0 . Example # Consider: void f(int); void f(char*); f(0); // call f(int) f(nullptr); // call f(char*) Enforcement # Flag uses of 0 and NULL for pointers. The transformation may be helped by simple program transformation. ES.48: Avoid casts # Reason # Casts are a well-known source of errors. Make some optimizations unreliable. Example, bad # double d = 2; auto p = (long*)&d; auto q = (long long*)&d; cout << d << ' ' << *p << ' ' << *q << '\\n'; What would you think this fragment prints? The result is at best implementation defined. I got 2 0 4611686018427387904 Adding *q = 666; cout << d << ' ' << *p << ' ' << *q << '\\n'; I got 3.29048e-321 666 666 Surprised? I\u2019m just glad I didn\u2019t crash the program. Note # Programmers who write casts typically assume that they know what they are doing, or that writing a cast makes the program \u201ceasier to read\u201d. In fact, they often disable the general rules for using values. Overload resolution and template instantiation usually pick the right function if there is a right function to pick. If there is not, maybe there ought to be, rather than applying a local fix (cast). Note # Casts are necessary in a systems programming language. For example, how else would we get the address of a device register into a pointer? However, casts are seriously overused as well as a major source of errors. Note # If you feel the need for a lot of casts, there may be a fundamental design problem. Exception # Casting to (void) is the Standard-sanctioned way to turn off [[nodiscard]] warnings. If you are calling a function with a [[nodiscard]] return and you deliberately want to discard the result, first think hard about whether that is really a good idea (there is usually a good reason the author of the function or of the return type used [[nodiscard]] in the first place), but if you still think it\u2019s appropriate and your code reviewer agrees, write (void) to turn off the warning. Alternatives # Casts are widely (mis) used. Modern C++ has rules and constructs that eliminate the need for casts in many contexts, such as Use templates Use std::variant Rely on the well-defined, safe, implicit conversions between pointer types Enforcement # Force the elimination of C-style casts, except on a function with a [[nodiscard]] return. Warn if there are many functional style casts (there is an obvious problem in quantifying \u2018many\u2019). The type profile bans reinterpret_cast . Warn against identity casts between pointer types, where the source and target types are the same (#Pro-type-identitycast). Warn if a pointer cast could be implicit . ES.49: If you must use a cast, use a named cast # Reason # Readability. Error avoidance. Named casts are more specific than a C-style or functional cast, allowing the compiler to catch some errors. The named casts are: static_cast const_cast reinterpret_cast dynamic_cast std::move // move(x) is an rvalue reference to x std::forward // forward<T>(x) is an rvalue or an lvalue reference to x depending on T gsl::narrow_cast // narrow_cast<T>(x) is static_cast<T>(x) gsl::narrow // narrow<T>(x) is static_cast<T>(x) if static_cast<T>(x) == x or it throws narrowing_error Example # class B { /* ... */ }; class D { /* ... */ }; template<typename D> D* upcast(B* pb) { D* pd0 = pb; // error: no implicit conversion from B* to D* D* pd1 = (D*)pb; // legal, but what is done? D* pd2 = static_cast<D*>(pb); // error: D is not derived from B D* pd3 = reinterpret_cast<D*>(pb); // OK: on your head be it! D* pd4 = dynamic_cast<D*>(pb); // OK: return nullptr // ... } The example was synthesized from real-world bugs where D used to be derived from B , but someone refactored the hierarchy. The C-style cast is dangerous because it can do any kind of conversion, depriving us of any protection from mistakes (now or in the future). Note # When converting between types with no information loss (e.g. from float to double or int64 from int32 ), brace initialization may be used instead. double d {some_float}; int64_t i {some_int32}; This makes it clear that the type conversion was intended and also prevents conversions between types that might result in loss of precision. (It is a compilation error to try to initialize a float from a double in this fashion, for example.) Note # reinterpret_cast can be essential, but the essential uses (e.g., turning a machine address into pointer) are not type safe: auto p = reinterpret_cast<Device_register>(0x800); // inherently dangerous Enforcement # Flag C-style and functional casts. The type profile bans reinterpret_cast . The type profile warns when using static_cast between arithmetic types. ES.50: Don\u2019t cast away const # Reason # It makes a lie out of const . If the variable is actually declared const , the result of \u201ccasting away const \u201d is undefined behavior. Example, bad # void f(const int& x) { const_cast<int&>(x) = 42; // BAD } static int i = 0; static const int j = 0; f(i); // silent side effect f(j); // undefined behavior Example # Sometimes, you may be tempted to resort to const_cast to avoid code duplication, such as when two accessor functions that differ only in const -ness have similar implementations. For example: class Bar; class Foo { public: // BAD, duplicates logic Bar& get_bar() { /* complex logic around getting a non-const reference to my_bar */ } const Bar& get_bar() const { /* same complex logic around getting a const reference to my_bar */ } private: Bar my_bar; }; Instead, prefer to share implementations. Normally, you can just have the non- const function call the const function. However, when there is complex logic this can lead to the following pattern that still resorts to a const_cast : class Foo { public: // not great, non-const calls const version but resorts to const_cast Bar& get_bar() { return const_cast<Bar&>(static_cast<const Foo&>(*this).get_bar()); } const Bar& get_bar() const { /* the complex logic around getting a const reference to my_bar */ } private: Bar my_bar; }; Although this pattern is safe when applied correctly, because the caller must have had a non- const object to begin with, it\u2019s not ideal because the safety is hard to enforce automatically as a checker rule. Instead, prefer to put the common code in a common helper function \u2013 and make it a template so that it deduces const . This doesn\u2019t use any const_cast at all: class Foo { public: // good Bar& get_bar() { return get_bar_impl(*this); } const Bar& get_bar() const { return get_bar_impl(*this); } private: Bar my_bar; template<class T> // good, deduces whether T is const or non-const static auto get_bar_impl(T& t) -> decltype(t.get_bar()) { /* the complex logic around getting a possibly-const reference to my_bar */ } }; Exception # You may need to cast away const when calling const -incorrect functions. Prefer to wrap such functions in inline const -correct wrappers to encapsulate the cast in one place. Example # Sometimes, \u201ccast away const \u201d is to allow the updating of some transient information of an otherwise immutable object. Examples are caching, memoization, and precomputation. Such examples are often handled as well or better using mutable or an indirection than with a const_cast . Consider keeping previously computed results around for a costly operation: int compute(int x); // compute a value for x; assume this to be costly class Cache { // some type implementing a cache for an int->int operation public: pair<bool, int> find(int x) const; // is there a value for x? void set(int x, int v); // make y the value for x // ... private: // ... }; class X { public: int get_val(int x) { auto p = cache.find(x); if (p.first) return p.second; int val = compute(x); cache.set(x, val); // insert value for x return val; } // ... private: Cache cache; }; Here, get_val() is logically constant, so we would like to make it a const member. To do this we still need to mutate cache , so people sometimes resort to a const_cast : class X { // Suspicious solution based on casting public: int get_val(int x) const { auto p = cache.find(x); if (p.first) return p.second; int val = compute(x); const_cast<Cache&>(cache).set(x, val); // ugly return val; } // ... private: Cache cache; }; Fortunately, there is a better solution: State that cache is mutable even for a const object: class X { // better solution public: int get_val(int x) const { auto p = cache.find(x); if (p.first) return p.second; int val = compute(x); cache.set(x, val); return val; } // ... private: mutable Cache cache; }; An alternative solution would be to store a pointer to the cache : class X { // OK, but slightly messier solution public: int get_val(int x) const { auto p = cache->find(x); if (p.first) return p.second; int val = compute(x); cache->set(x, val); return val; } // ... private: unique_ptr<Cache> cache; }; That solution is the most flexible, but requires explicit construction and destruction of *cache (most likely in the constructor and destructor of X ). In any variant, we must guard against data races on the cache in multi-threaded code, possibly using a std::mutex . Enforcement # Flag const_cast s. This rule is part of the type-safety profile for the related Profile. ES.55: Avoid the need for range checking # Reason # Constructs that cannot overflow do not overflow (and usually run faster): Example # for (auto& x : v) // print all elements of v cout << x << '\\n'; auto p = find(v, x); // find x in v Enforcement # Look for explicit range checks and heuristically suggest alternatives. ES.56: Write std::move() only when you need to explicitly move an object to another scope # Reason # We move, rather than copy, to avoid duplication and for improved performance. A move typically leaves behind an empty object ( C.64 ), which can be surprising or even dangerous, so we try to avoid moving from lvalues (they might be accessed later). Notes # Moving is done implicitly when the source is an rvalue (e.g., value in a return treatment or a function result), so don\u2019t pointlessly complicate code in those cases by writing move explicitly. Instead, write short functions that return values, and both the function\u2019s return and the caller\u2019s accepting of the return will be optimized naturally. In general, following the guidelines in this document (including not making variables\u2019 scopes needlessly large, writing short functions that return values, returning local variables) help eliminate most need for explicit std::move . Explicit move is needed to explicitly move an object to another scope, notably to pass it to a \u201csink\u201d function and in the implementations of the move operations themselves (move constructor, move assignment operator) and swap operations. Example, bad # void sink(X&& x); // sink takes ownership of x void user() { X x; // error: cannot bind an lvalue to a rvalue reference sink(x); // OK: sink takes the contents of x, x must now be assumed to be empty sink(std::move(x)); // ... // probably a mistake use(x); } Usually, a std::move() is used as an argument to a && parameter. And after you do that, assume the object has been moved from (see C.64 ) and don\u2019t read its state again until you first set it to a new value. void f() { string s1 = \"supercalifragilisticexpialidocious\"; string s2 = s1; // ok, takes a copy assert(s1 == \"supercalifragilisticexpialidocious\"); // ok // bad, if you want to keep using s1's value string s3 = move(s1); // bad, assert will likely fail, s1 likely changed assert(s1 == \"supercalifragilisticexpialidocious\"); } Example # void sink(unique_ptr<widget> p); // pass ownership of p to sink() void f() { auto w = make_unique<widget>(); // ... sink(std::move(w)); // ok, give to sink() // ... sink(w); // Error: unique_ptr is carefully designed so that you cannot copy it } Notes # std::move() is a cast to && in disguise; it doesn\u2019t itself move anything, but marks a named object as a candidate that can be moved from. The language already knows the common cases where objects can be moved from, especially when returning values from functions, so don\u2019t complicate code with redundant std::move() \u2018s. Never write std::move() just because you\u2019ve heard \u201cit\u2019s more efficient.\u201d In general, don\u2019t believe claims of \u201cefficiency\u201d without data (???). In general, don\u2019t complicate your code without reason (??) Example, bad # vector<int> make_vector() { vector<int> result; // ... load result with data return std::move(result); // bad; just write \"return result;\" } Never write return move(local_variable); , because the language already knows the variable is a move candidate. Writing move in this code won\u2019t help, and can actually be detrimental because on some compilers it interferes with RVO (the return value optimization) by creating an additional reference alias to the local variable. Example, bad # vector<int> v = std::move(make_vector()); // bad; the std::move is entirely redundant Never write move on a returned value such as x = move(f()); where f returns by value. The language already knows that a returned value is a temporary object that can be moved from. Example # void mover(X&& x) { call_something(std::move(x)); // ok call_something(std::forward<X>(x)); // bad, don't std::forward an rvalue reference call_something(x); // suspicious, why not std::move? } template<class T> void forwarder(T&& t) { call_something(std::move(t)); // bad, don't std::move a forwarding reference call_something(std::forward<T>(t)); // ok call_something(t); // suspicious, why not std::forward? } Enforcement # Flag use of std::move(x) where x is an rvalue or the language will already treat it as an rvalue, including return std::move(local_variable); and std::move(f()) on a function that returns by value. Flag functions taking an S&& parameter if there is no const S& overload to take care of lvalues. Flag a std::move s argument passed to a parameter, except when the parameter type is one of the following: an X&& rvalue reference; a T&& forwarding reference where T is a template parameter type; or by value and the type is move-only. Flag when std::move is applied to a forwarding reference ( T&& where T is a template parameter type). Use std::forward instead. Flag when std::move is applied to other than an rvalue reference. (More general case of the previous rule to cover the non-forwarding cases.) Flag when std::forward is applied to an rvalue reference ( X&& where X is a concrete type). Use std::move instead. Flag when std::forward is applied to other than a forwarding reference. (More general case of the previous rule to cover the non-moving cases.) Flag when an object is potentially moved from and the next operation is a const operation; there should first be an intervening non- const operation, ideally assignment, to first reset the object\u2019s value. ES.60: Avoid new and delete outside resource management functions # Reason # Direct resource management in application code is error-prone and tedious. Note # This is also known as the rule of \u201cNo naked new !\u201d Example, bad # void f(int n) { auto p = new X[n]; // n default constructed Xs // ... delete[] p; } There can be code in the ... part that causes the delete never to happen. See also : R: Resource management Enforcement # Flag naked new s and naked delete s. ES.61: Delete arrays using delete[] and non-arrays using delete # Reason # That\u2019s what the language requires and mistakes can lead to resource release errors and/or memory corruption. Example, bad # void f(int n) { auto p = new X[n]; // n default constructed Xs // ... delete p; // error: just delete the object p, rather than delete the array p[] } Note # This example not only violates the no naked new rule as in the previous example, it has many more problems. Enforcement # If the new and the delete are in the same scope, mistakes can be flagged. If the new and the delete are in a constructor/destructor pair, mistakes can be flagged. ES.62: Don\u2019t compare pointers into different arrays # Reason # The result of doing so is undefined. Example, bad # void f() { int a1[7]; int a2[9]; if (&a1[5] < &a2[7]) {} // bad: undefined if (0 < &a1[5] - &a2[7]) {} // bad: undefined } Note # This example has many more problems. Enforcement # ??? ES.63: Don\u2019t slice # Reason # Slicing \u2013 that is, copying only part of an object using assignment or initialization \u2013 most often leads to errors because the object was meant to be considered as a whole. In the rare cases where the slicing was deliberate the code can be surprising. Example # class Shape { /* ... */ }; class Circle : public Shape { /* ... */ Point c; int r; }; Circle c {{0, 0}, 42}; Shape s {c}; // copy construct only the Shape part of Circle s = c; // or copy assign only the Shape part of Circle void assign(const Shape& src, Shape& dest) { dest = src; } Circle c2 {{1, 1}, 43}; assign(c, c2); // oops, not the whole state is transferred assert(c == c2); // if we supply copying, we should also provide comparison, // but this will likely return false The result will be meaningless because the center and radius will not be copied from c into s . The first defense against this is to define the base class Shape not to allow this . Alternative # If you mean to slice, define an explicit operation to do so. This saves readers from confusion. For example: class Smiley : public Circle { public: Circle copy_circle(); // ... }; Smiley sm { /* ... */ }; Circle c1 {sm}; // ideally prevented by the definition of Circle Circle c2 {sm.copy_circle()}; Enforcement # Warn against slicing. ES.64: Use the T{e} notation for construction # Reason # The T{e} construction syntax makes it explicit that construction is desired. The T{e} construction syntax doesn\u2019t allow narrowing. T{e} is the only safe and general expression for constructing a value of type T from an expression e . The casts notations T(e) and (T)e are neither safe nor general. Example # For built-in types, the construction notation protects against narrowing and reinterpretation void use(char ch, int i, double d, char* p, long long lng) { int x1 = int{ch}; // OK, but redundant int x2 = int{d}; // error: double->int narrowing; use a cast if you need to int x3 = int{p}; // error: pointer to->int; use a reinterpret_cast if you really need to int x4 = int{lng}; // error: long long->int narrowing; use a cast if you need to int y1 = int(ch); // OK, but redundant int y2 = int(d); // bad: double->int narrowing; use a cast if you need to int y3 = int(p); // bad: pointer to->int; use a reinterpret_cast if you really need to int y4 = int(lng); // bad: long long->int narrowing; use a cast if you need to int z1 = (int)ch; // OK, but redundant int z2 = (int)d; // bad: double->int narrowing; use a cast if you need to int z3 = (int)p; // bad: pointer to->int; use a reinterpret_cast if you really need to int z4 = (int)lng; // bad: long long->int narrowing; use a cast if you need to } The integer to/from pointer conversions are implementation defined when using the T(e) or (T)e notations, and non-portable between platforms with different integer and pointer sizes. Note # Avoid casts (explicit type conversion) and if you must prefer named casts . Note # When unambiguous, the T can be left out of T{e} . complex<double> f(complex<double>); auto z = f({2*pi, 1}); Note # The construction notation is the most general initializer notation . Exception # std::vector and other containers were defined before we had {} as a notation for construction. Consider: vector<string> vs {10}; // ten empty strings vector<int> vi1 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // ten elements 1..10 vector<int> vi2 {10}; // one element with the value 10 How do we get a vector of 10 default initialized int s? vector<int> v3(10); // ten elements with value 0 The use of () rather than {} for number of elements is conventional (going back to the early 1980s), hard to change, but still a design error: for a container where the element type can be confused with the number of elements, we have an ambiguity that must be resolved. The conventional resolution is to interpret {10} as a list of one element and use (10) to distinguish a size. This mistake need not be repeated in new code. We can define a type to represent the number of elements: struct Count { int n; }; template<typename T> class Vector { public: Vector(Count n); // n default-initialized elements Vector(initializer_list<T> init); // init.size() elements // ... }; Vector<int> v1{10}; Vector<int> v2{Count{10}}; Vector<Count> v3{Count{10}}; // yes, there is still a very minor problem The main problem left is to find a suitable name for Count . Enforcement # Flag the C-style (T)e and functional-style T(e) casts. ES.65: Don\u2019t dereference an invalid pointer # Reason # Dereferencing an invalid pointer, such as nullptr , is undefined behavior, typically leading to immediate crashes, wrong results, or memory corruption. Note # This rule is an obvious and well-known language rule, but can be hard to follow. It takes good coding style, library support, and static analysis to eliminate violations without major overhead. This is a major part of the discussion of C++\u2019s resource- and type-safety model . See also : Use RAII to avoid lifetime problems. Use unique_ptr to avoid lifetime problems. Use shared_ptr to avoid lifetime problems. Use references when nullptr isn\u2019t a possibility. Use not_null to catch unexpected nullptr early. Use the bounds profile to avoid range errors. Example # void f() { int x = 0; int* p = &x; if (condition()) { int y = 0; p = &y; } // invalidates p *p = 42; // BAD, p might be invalid if the branch was taken } To resolve the problem, either extend the lifetime of the object the pointer is intended to refer to, or shorten the lifetime of the pointer (move the dereference to before the pointed-to object\u2019s lifetime ends). void f1() { int x = 0; int* p = &x; int y = 0; if (condition()) { p = &y; } *p = 42; // OK, p points to x or y and both are still in scope } Unfortunately, most invalid pointer problems are harder to spot and harder to fix. Example # void f(int* p) { int x = *p; // BAD: how do we know that p is valid? } There is a huge amount of such code. Most works \u2013 after lots of testing \u2013 but in isolation it is impossible to tell whether p could be the nullptr . Consequently, this is also a major source of errors. There are many approaches to dealing with this potential problem: void f1(int* p) // deal with nullptr { if (!p) { // deal with nullptr (allocate, return, throw, make p point to something, whatever } int x = *p; } There are two potential problems with testing for nullptr : it is not always obvious what to do what to do if we find nullptr the test can be redundant and/or relatively expensive it is not obvious if the test is to protect against a violation or part of the required logic. void f2(int* p) // state that p is not supposed to be nullptr { assert(p); int x = *p; } This would carry a cost only when the assertion checking was enabled and would give a compiler/analyzer useful information. This would work even better if/when C++ gets direct support for contracts: void f3(int* p) // state that p is not supposed to be nullptr [[expects: p]] { int x = *p; } Alternatively, we could use gsl::not_null to ensure that p is not the nullptr . void f(not_null<int*> p) { int x = *p; } These remedies take care of nullptr only. Remember that there are other ways of getting an invalid pointer. Example # void f(int* p) // old code, doesn't use owner { delete p; } void g() // old code: uses naked new { auto q = new int{7}; f(q); int x = *q; // BAD: dereferences invalid pointer } Example # void f() { vector<int> v(10); int* p = &v[5]; v.push_back(99); // could reallocate v's elements int x = *p; // BAD: dereferences potentially invalid pointer } Enforcement # This rule is part of the lifetime safety profile Flag a dereference of a pointer that points to an object that has gone out of scope Flag a dereference of a pointer that may have been invalidated by assigning a nullptr Flag a dereference of a pointer that may have been invalidated by a delete Flag a dereference to a pointer to a container element that may have been invalidated by dereference ES.stmt: Statements # Statements control the flow of control (except for function calls and exception throws, which are expressions). ES.70: Prefer a switch -statement to an if -statement when there is a choice # Reason # Readability. Efficiency: A switch compares against constants and is usually better optimized than a series of tests in an if - then - else chain. A switch enables some heuristic consistency checking. For example, have all values of an enum been covered? If not, is there a default ? Example # void use(int n) { switch (n) { // good case 0: // ... break; case 7: // ... break; default: // ... break; } } rather than: void use2(int n) { if (n == 0) // bad: if-then-else chain comparing against a set of constants // ... else if (n == 7) // ... } Enforcement # Flag if - then - else chains that check against constants (only). ES.71: Prefer a range- for -statement to a for -statement when there is a choice # Reason # Readability. Error prevention. Efficiency. Example # for (gsl::index i = 0; i < v.size(); ++i) // bad cout << v[i] << '\\n'; for (auto p = v.begin(); p != v.end(); ++p) // bad cout << *p << '\\n'; for (auto& x : v) // OK cout << x << '\\n'; for (gsl::index i = 1; i < v.size(); ++i) // touches two elements: can't be a range-for cout << v[i] + v[i - 1] << '\\n'; for (gsl::index i = 0; i < v.size(); ++i) // possible side effect: can't be a range-for cout << f(v, &v[i]) << '\\n'; for (gsl::index i = 0; i < v.size(); ++i) { // body messes with loop variable: can't be a range-for if (i % 2 == 0) continue; // skip even elements else cout << v[i] << '\\n'; } A human or a good static analyzer may determine that there really isn\u2019t a side effect on v in f(v, &v[i]) so that the loop can be rewritten. \u201cMessing with the loop variable\u201d in the body of a loop is typically best avoided. Note # Don\u2019t use expensive copies of the loop variable of a range- for loop: for (string s : vs) // ... This will copy each elements of vs into s . Better: for (string& s : vs) // ... Better still, if the loop variable isn\u2019t modified or copied: for (const string& s : vs) // ... Enforcement # Look at loops, if a traditional loop just looks at each element of a sequence, and there are no side effects on what it does with the elements, rewrite the loop to a ranged- for loop. ES.72: Prefer a for -statement to a while -statement when there is an obvious loop variable # Reason # Readability: the complete logic of the loop is visible \u201cup front\u201d. The scope of the loop variable can be limited. Example # for (gsl::index i = 0; i < vec.size(); i++) { // do work } Example, bad # int i = 0; while (i < vec.size()) { // do work i++; } Enforcement # ??? ES.73: Prefer a while -statement to a for -statement when there is no obvious loop variable # Reason # Readability. Example # int events = 0; for (; wait_for_event(); ++events) { // bad, confusing // ... } The \u201cevent loop\u201d is misleading because the events counter has nothing to do with the loop condition ( wait_for_event() ). Better int events = 0; while (wait_for_event()) { // better ++events; // ... } Enforcement # Flag actions in for -initializers and for -increments that do not relate to the for -condition. ES.74: Prefer to declare a loop variable in the initializer part of a for -statement # Reason # Limit the loop variable visibility to the scope of the loop. Avoid using the loop variable for other purposes after the loop. Example # for (int i = 0; i < 100; ++i) { // GOOD: i var is visible only inside the loop // ... } Example, don\u2019t # int j; // BAD: j is visible outside the loop for (j = 0; j < 100; ++j) { // ... } // j is still visible here and isn't needed See also : Don\u2019t use a variable for two unrelated purposes Example # for (string s; cin >> s; ) { cout << s << '\\n'; } Enforcement # Warn when a variable modified inside the for -statement is declared outside the loop and not being used outside the loop. Discussion : Scoping the loop variable to the loop body also helps code optimizers greatly. Recognizing that the induction variable is only accessible in the loop body unblocks optimizations such as hoisting, strength reduction, loop-invariant code motion, etc. ES.75: Avoid do -statements # Reason # Readability, avoidance of errors. The termination condition is at the end (where it can be overlooked) and the condition is not checked the first time through. Example # int x; do { cin >> x; // ... } while (x < 0); Note # Yes, there are genuine examples where a do -statement is a clear statement of a solution, but also many bugs. Enforcement # Flag do -statements. ES.76: Avoid goto # Reason # Readability, avoidance of errors. There are better control structures for humans; goto is for machine generated code. Exception # Breaking out of a nested loop. In that case, always jump forwards. for (int i = 0; i < imax; ++i) for (int j = 0; j < jmax; ++j) { if (a[i][j] > elem_max) goto finished; // ... } finished: // ... Example, bad # There is a fair amount of use of the C goto-exit idiom: void f() { // ... goto exit; // ... goto exit; // ... exit: // ... common cleanup code ... } This is an ad-hoc simulation of destructors. Declare your resources with handles with destructors that clean up. If for some reason you cannot handle all cleanup with destructors for the variables used, consider gsl::finally() as a cleaner and more reliable alternative to goto exit Enforcement # Flag goto . Better still flag all goto s that do not jump from a nested loop to the statement immediately after a nest of loops. ES.77: Minimize the use of break and continue in loops # Reason # In a non-trivial loop body, it is easy to overlook a break or a continue . A break in a loop has a dramatically different meaning than a break in a switch -statement (and you can have switch -statement in a loop and a loop in a switch -case). Example # ??? Alternative # Often, a loop that requires a break is a good candidate for a function (algorithm), in which case the break becomes a return . ??? Often, a loop that uses continue can equivalently and as clearly be expressed by an if -statement. ??? Note # If you really need to break out a loop, a break is typically better than alternatives such as modifying the loop variable or a goto : Enforcement # ??? ES.78: Always end a non-empty case with a break # Reason # Accidentally leaving out a break is a fairly common bug. A deliberate fallthrough can be a maintenance hazard and should be rare and explicit. Example # switch (eventType) { case Information: update_status_bar(); break; case Warning: write_event_log(); // Bad - implicit fallthrough case Error: display_error_window(); break; } Multiple case labels of a single statement is OK: switch (x) { case 'a': case 'b': case 'f': do_something(x); break; } Exceptions # In rare cases if fallthrough is deemed appropriate, be explicit and use the [[fallthrough]] annotation: switch (eventType) { case Information: update_status_bar(); break; case Warning: write_event_log(); [[fallthrough]]; case Error: display_error_window(); break; } Note # Enforcement # Flag all implicit fallthroughs from non-empty case s. ES.79: Use default to handle common cases (only) # Reason # Code clarity. Improved opportunities for error detection. Example # enum E { a, b, c , d }; void f1(E x) { switch (x) { case a: do_something(); break; case b: do_something_else(); break; default: take_the_default_action(); break; } } Here it is clear that there is a default action and that cases a and b are special. Example # But what if there is no default action and you mean to handle only specific cases? In that case, have an empty default or else it is impossible to know if you meant to handle all cases: void f2(E x) { switch (x) { case a: do_something(); break; case b: do_something_else(); break; default: // do nothing for the rest of the cases break; } } If you leave out the default , a maintainer and/or a compiler may reasonably assume that you intended to handle all cases: void f2(E x) { switch (x) { case a: do_something(); break; case b: case c: do_something_else(); break; } } Did you forget case d or deliberately leave it out? Forgetting a case typically happens when a case is added to an enumeration and the person doing so fails to add it to every switch over the enumerators. Enforcement # Flag switch -statements over an enumeration that don\u2019t handle all enumerators and do not have a default . This may yield too many false positives in some code bases; if so, flag only switch es that handle most but not all cases (that was the strategy of the very first C++ compiler). ES.84: Don\u2019t try to declare a local variable with no name # Reason # There is no such thing. What looks to a human like a variable without a name is to the compiler a statement consisting of a temporary that immediately goes out of scope. Example, bad # void f() { lock<mutex>{mx}; // Bad // ... } This declares an unnamed lock object that immediately goes out of scope at the point of the semicolon. This is not an uncommon mistake. In particular, this particular example can lead to hard-to find race conditions. Note # Unnamed function arguments are fine. Enforcement # Flag statements that are just a temporary. ES.85: Make empty statements visible # Reason # Readability. Example # for (i = 0; i < max; ++i); // BAD: the empty statement is easily overlooked v[i] = f(v[i]); for (auto x : v) { // better // nothing } v[i] = f(v[i]); Enforcement # Flag empty statements that are not blocks and don\u2019t contain comments. ES.86: Avoid modifying loop control variables inside the body of raw for-loops # Reason # The loop control up front should enable correct reasoning about what is happening inside the loop. Modifying loop counters in both the iteration-expression and inside the body of the loop is a perennial source of surprises and bugs. Example # for (int i = 0; i < 10; ++i) { // no updates to i -- ok } for (int i = 0; i < 10; ++i) { // if (/* something */) ++i; // BAD // } bool skip = false; for (int i = 0; i < 10; ++i) { if (skip) { skip = false; continue; } // if (/* something */) skip = true; // Better: using two variables for two concepts. // } Enforcement # Flag variables that are potentially updated (have a non- const use) in both the loop control iteration-expression and the loop body. ES.87: Don\u2019t add redundant == or != to conditions # Reason # Doing so avoids verbosity and eliminates some opportunities for mistakes. Helps make style consistent and conventional. Example # By definition, a condition in an if -statement, while -statement, or a for -statement selects between true and false . A numeric value is compared to 0 and a pointer value to nullptr . // These all mean \"if `p` is not `nullptr`\" if (p) { ... } // good if (p != 0) { ... } // redundant `!=0`; bad: don't use 0 for pointers if (p != nullptr) { ... } // redundant `!=nullptr`, not recommended Often, if (p) is read as \u201cif p is valid\u201d which is a direct expression of the programmers intent, whereas if (p != nullptr) would be a long-winded workaround. Example # This rule is especially useful when a declaration is used as a condition if (auto pc = dynamic_cast<Circle>(ps)) { ... } // execute if ps points to a kind of Circle, good if (auto pc = dynamic_cast<Circle>(ps); pc != nullptr) { ... } // not recommended Example # Note that implicit conversions to bool are applied in conditions. For example: for (string s; cin >> s; ) v.push_back(s); This invokes istream \u2018s operator bool() . Note # Explicit comparison of an integer to 0 is in general not redundant. The reason is that (as opposed to pointers and Booleans) an integer often has more than two reasonable values. Furthermore 0 (zero) is often used to indicate success. Consequently, it is best to be specific about the comparison. void f(int i) { if (i) // suspect // ... if (i == success) // possibly better // ... } Always remember that an integer can have more than two values. Example, bad # It has been noted that if(strcmp(p1, p2)) { ... } // are the two C-style strings equal? (mistake!) is a common beginners error. If you use C-style strings, you must know the <cstring> functions well. Being verbose and writing if(strcmp(p1, p2) != 0) { ... } // are the two C-style strings equal? (mistake!) would not in itself save you. Note # The opposite condition is most easily expressed using a negation: // These all mean \"if `p` is `nullptr`\" if (!p) { ... } // good if (p == 0) { ... } // redundant `== 0`; bad: don't use `0` for pointers if (p == nullptr) { ... } // redundant `== nullptr`, not recommended Enforcement # Easy, just check for redundant use of != and == in conditions. Arithmetic # ES.100: Don\u2019t mix signed and unsigned arithmetic # Reason # Avoid wrong results. Example # int x = -3; unsigned int y = 7; cout << x - y << '\\n'; // unsigned result, possibly 4294967286 cout << x + y << '\\n'; // unsigned result: 4 cout << x * y << '\\n'; // unsigned result, possibly 4294967275 It is harder to spot the problem in more realistic examples. Note # Unfortunately, C++ uses signed integers for array subscripts and the standard library uses unsigned integers for container subscripts. This precludes consistency. Use gsl::index for subscripts; see ES.107 . Enforcement # Compilers already know and sometimes warn. (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is sizeof or a call to container .size() and the other is ptrdiff_t . ES.101: Use unsigned types for bit manipulation # Reason # Unsigned types support bit manipulation without surprises from sign bits. Example # unsigned char x = 0b1010'1010; unsigned char y = ~x; // y == 0b0101'0101; Note # Unsigned types can also be useful for modulo arithmetic. However, if you want modulo arithmetic add comments as necessary noting the reliance on wraparound behavior, as such code can be surprising for many programmers. Enforcement # Just about impossible in general because of the use of unsigned subscripts in the standard library ??? ES.102: Use signed types for arithmetic # Reason # Because most arithmetic is assumed to be signed; x - y yields a negative number when y > x except in the rare cases where you really want modulo arithmetic. Example # Unsigned arithmetic can yield surprising results if you are not expecting it. This is even more true for mixed signed and unsigned arithmetic. template<typename T, typename T2> T subtract(T x, T2 y) { return x - y; } void test() { int s = 5; unsigned int us = 5; cout << subtract(s, 7) << '\\n'; // -2 cout << subtract(us, 7u) << '\\n'; // 4294967294 cout << subtract(s, 7u) << '\\n'; // -2 cout << subtract(us, 7) << '\\n'; // 4294967294 cout << subtract(s, us + 2) << '\\n'; // -2 cout << subtract(us, s + 2) << '\\n'; // 4294967294 } Here we have been very explicit about what\u2019s happening, but if you had seen us - (s + 2) or s += 2; ...; us - s , would you reliably have suspected that the result would print as 4294967294 ? Exception # Use unsigned types if you really want modulo arithmetic - add comments as necessary noting the reliance on overflow behavior, as such code is going to be surprising for many programmers. Example # The standard library uses unsigned types for subscripts. The built-in array uses signed types for subscripts. This makes surprises (and bugs) inevitable. int a[10]; for (int i = 0; i < 10; ++i) a[i] = i; vector<int> v(10); // compares signed to unsigned; some compilers warn, but we should not for (gsl::index i = 0; i < v.size(); ++i) v[i] = i; int a2[-2]; // error: negative size // OK, but the number of ints (4294967294) is so large that we should get an exception vector<int> v2(-2); Use gsl::index for subscripts; see ES.107 . Enforcement # Flag mixed signed and unsigned arithmetic Flag results of unsigned arithmetic assigned to or printed as signed. Flag negative literals (e.g. -2 ) used as container subscripts. (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is sizeof or a call to container .size() and the other is ptrdiff_t . ES.103: Don\u2019t overflow # Reason # Overflow usually makes your numeric algorithm meaningless. Incrementing a value beyond a maximum value can lead to memory corruption and undefined behavior. Example, bad # int a[10]; a[10] = 7; // bad int n = 0; while (n++ < 10) a[n - 1] = 9; // bad (twice) Example, bad # int n = numeric_limits<int>::max(); int m = n + 1; // bad Example, bad # int area(int h, int w) { return h * w; } auto a = area(10'000'000, 100'000'000); // bad Exception # Use unsigned types if you really want modulo arithmetic. Alternative : For critical applications that can afford some overhead, use a range-checked integer and/or floating-point type. Enforcement # ??? ES.104: Don\u2019t underflow # Reason # Decrementing a value beyond a minimum value can lead to memory corruption and undefined behavior. Example, bad # int a[10]; a[-2] = 7; // bad int n = 101; while (n--) a[n - 1] = 9; // bad (twice) Exception # Use unsigned types if you really want modulo arithmetic. Enforcement # ??? ES.105: Don\u2019t divide by zero # Reason # The result is undefined and probably a crash. Note # This also applies to % . Example, bad # double divide(int a, int b) { // BAD, should be checked (e.g., in a precondition) return a / b; } Example, good # double divide(int a, int b) { // good, address via precondition (and replace with contracts once C++ gets them) Expects(b != 0); return a / b; } double divide(int a, int b) { // good, address via check return b ? a / b : quiet_NaN<double>(); } Alternative : For critical applications that can afford some overhead, use a range-checked integer and/or floating-point type. Enforcement # Flag division by an integral value that could be zero ES.106: Don\u2019t try to avoid negative values by using unsigned # Reason # Choosing unsigned implies many changes to the usual behavior of integers, including modulo arithmetic, can suppress warnings related to overflow, and opens the door for errors related to signed/unsigned mixes. Using unsigned doesn\u2019t actually eliminate the possibility of negative values. Example # unsigned int u1 = -2; // Valid: the value of u1 is 4294967294 int i1 = -2; unsigned int u2 = i1; // Valid: the value of u2 is 4294967294 int i2 = u2; // Valid: the value of i2 is -2 These problems with such (perfectly legal) constructs are hard to spot in real code and are the source of many real-world errors. Consider: unsigned area(unsigned height, unsigned width) { return height*width; } // [see also](#Ri-expects) // ... int height; cin >> height; auto a = area(height, 2); // if the input is -2 a becomes 4294967292 Remember that -1 when assigned to an unsigned int becomes the largest unsigned int . Also, since unsigned arithmetic is modulo arithmetic the multiplication didn\u2019t overflow, it wrapped around. Example # unsigned max = 100000; // \"accidental typo\", I mean to say 10'000 unsigned short x = 100; while (x < max) x += 100; // infinite loop Had x been a signed short , we could have warned about the undefined behavior upon overflow. Alternatives # use signed integers and check for x >= 0 use a positive integer type use an integer subrange type Assert(-1 < x) For example struct Positive { int val; Positive(int x) :val{x} { Assert(0 < x); } operator int() { return val; } }; int f(Positive arg) { return arg; } int r1 = f(2); int r2 = f(-2); // throws Note # ??? Enforcement # See ES.100 Enforcements. ES.107: Don\u2019t use unsigned for subscripts, prefer gsl::index # Reason # To avoid signed/unsigned confusion. To enable better optimization. To enable better error detection. To avoid the pitfalls with auto and int . Example, bad # vector<int> vec = /*...*/; for (int i = 0; i < vec.size(); i += 2) // may not be big enough cout << vec[i] << '\\n'; for (unsigned i = 0; i < vec.size(); i += 2) // risk wraparound cout << vec[i] << '\\n'; for (auto i = 0; i < vec.size(); i += 2) // may not be big enough cout << vec[i] << '\\n'; for (vector<int>::size_type i = 0; i < vec.size(); i += 2) // verbose cout << vec[i] << '\\n'; for (auto i = vec.size()-1; i >= 0; i -= 2) // bug cout << vec[i] << '\\n'; for (int i = vec.size()-1; i >= 0; i -= 2) // may not be big enough cout << vec[i] << '\\n'; Example, good # vector<int> vec = /*...*/; for (gsl::index i = 0; i < vec.size(); i += 2) // ok cout << vec[i] << '\\n'; for (gsl::index i = vec.size()-1; i >= 0; i -= 2) // ok cout << vec[i] << '\\n'; Note # The built-in array uses signed subscripts. The standard-library containers use unsigned subscripts. Thus, no perfect and fully compatible solution is possible (unless and until the standard-library containers change to use signed subscripts someday in the future). Given the known problems with unsigned and signed/unsigned mixtures, better stick to (signed) integers of a sufficient size, which is guaranteed by gsl::index . Example # template<typename T> struct My_container { public: // ... T& operator[](gsl::index i); // not unsigned // ... }; Example # ??? demonstrate improved code generation and potential for error detection ??? Alternatives # Alternatives for users use algorithms use range-for use iterators/pointers Enforcement # Very tricky as long as the standard-library containers get it wrong. (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is sizeof or a call to container .size() and the other is ptrdiff_t . Per: Performance # ??? should this section be in the main guide??? This section contains rules for people who need high performance or low-latency. That is, these are rules that relate to how to use as little time and as few resources as possible to achieve a task in a predictably short time. The rules in this section are more restrictive and intrusive than what is needed for many (most) applications. Do not blindly try to follow them in general code: achieving the goals of low latency requires extra work. Performance rule summary: Per.1: Don\u2019t optimize without reason Per.2: Don\u2019t optimize prematurely Per.3: Don\u2019t optimize something that\u2019s not performance critical Per.4: Don\u2019t assume that complicated code is necessarily faster than simple code Per.5: Don\u2019t assume that low-level code is necessarily faster than high-level code Per.6: Don\u2019t make claims about performance without measurements Per.7: Design to enable optimization Per.10: Rely on the static type system Per.11: Move computation from run time to compile time Per.12: Eliminate redundant aliases Per.13: Eliminate redundant indirections Per.14: Minimize the number of allocations and deallocations Per.15: Do not allocate on a critical branch Per.16: Use compact data structures Per.17: Declare the most used member of a time-critical struct first Per.18: Space is time Per.19: Access memory predictably Per.30: Avoid context switches on the critical path Per.1: Don\u2019t optimize without reason # Reason # If there is no need for optimization, the main result of the effort will be more errors and higher maintenance costs. Note # Some people optimize out of habit or because it\u2019s fun. ??? Per.2: Don\u2019t optimize prematurely # Reason # Elaborately optimized code is usually larger and harder to change than unoptimized code. ??? Per.3: Don\u2019t optimize something that\u2019s not performance critical # Reason # Optimizing a non-performance-critical part of a program has no effect on system performance. Note # If your program spends most of its time waiting for the web or for a human, optimization of in-memory computation is probably useless. Put another way: If your program spends 4% of its processing time doing computation A and 40% of its time doing computation B, a 50% improvement on A is only as impactful as a 5% improvement on B. (If you don\u2019t even know how much time is spent on A or B, see Per.1 and Per.2 .) Per.4: Don\u2019t assume that complicated code is necessarily faster than simple code # Reason # Simple code can be very fast. Optimizers sometimes do marvels with simple code Example, good # // clear expression of intent, fast execution vector<uint8_t> v(100000); for (auto& c : v) c = ~c; Example, bad # // intended to be faster, but is actually slower vector<uint8_t> v(100000); for (size_t i = 0; i < v.size(); i += sizeof(uint64_t)) { uint64_t& quad_word = *reinterpret_cast<uint64_t*>(&v[i]); quad_word = ~quad_word; } Note # ??? ??? Per.5: Don\u2019t assume that low-level code is necessarily faster than high-level code # Reason # Low-level code sometimes inhibits optimizations. Optimizers sometimes do marvels with high-level code. Note # ??? ??? Per.6: Don\u2019t make claims about performance without measurements # Reason # The field of performance is littered with myth and bogus folklore. Modern hardware and optimizers defy naive assumptions; even experts are regularly surprised. Note # Getting good performance measurements can be hard and require specialized tools. Note # A few simple microbenchmarks using Unix time or the standard-library <chrono> can help dispel the most obvious myths. If you can\u2019t measure your complete system accurately, at least try to measure a few of your key operations and algorithms. A profiler can help tell you which parts of your system are performance critical. Often, you will be surprised. ??? Per.7: Design to enable optimization # Reason # Because we often need to optimize the initial design. Because a design that ignores the possibility of later improvement is hard to change. Example # From the C (and C++) standard: void qsort (void* base, size_t num, size_t size, int (*compar)(const void*, const void*)); When did you even want to sort memory? Really, we sort sequences of elements, typically stored in containers. A call to qsort throws away much useful information (e.g., the element type), forces the user to repeat information already known (e.g., the element size), and forces the user to write extra code (e.g., a function to compare double s). This implies added work for the programmer, is error-prone, and deprives the compiler of information needed for optimization. double data[100]; // ... fill a ... // 100 chunks of memory of sizeof(double) starting at // address data using the order defined by compare_doubles qsort(data, 100, sizeof(double), compare_doubles); From the point of view of interface design is that qsort throws away useful information. We can do better (in C++98) template<typename Iter> void sort(Iter b, Iter e); // sort [b:e) sort(data, data + 100); Here, we use the compiler\u2019s knowledge about the size of the array, the type of elements, and how to compare double s. With C++11 plus concepts , we can do better still // Sortable specifies that c must be a // random-access sequence of elements comparable with < void sort(Sortable& c); sort(c); The key is to pass sufficient information for a good implementation to be chosen. In this, the sort interfaces shown here still have a weakness: They implicitly rely on the element type having less-than ( < ) defined. To complete the interface, we need a second version that accepts a comparison criteria: // compare elements of c using p void sort(Sortable& c, Predicate<Value_type<Sortable>> p); The standard-library specification of sort offers those two versions, but the semantics is expressed in English rather than code using concepts. Note # Premature optimization is said to be the root of all evil , but that\u2019s not a reason to despise performance. It is never premature to consider what makes a design amenable to improvement, and improved performance is a commonly desired improvement. Aim to build a set of habits that by default results in efficient, maintainable, and optimizable code. In particular, when you write a function that is not a one-off implementation detail, consider Information passing: Prefer clean interfaces carrying sufficient information for later improvement of implementation. Note that information flows into and out of an implementation through the interfaces we provide. Compact data: By default, use compact data , such as std::vector and access it in a systematic fashion . If you think you need a linked structure, try to craft the interface so that this structure isn\u2019t seen by users. Function argument passing and return: Distinguish between mutable and non-mutable data. Don\u2019t impose a resource management burden on your users. Don\u2019t impose spurious run-time indirections on your users. Use conventional ways of passing information through an interface; unconventional and/or \u201coptimized\u201d ways of passing data can seriously complicate later reimplementation. Abstraction: Don\u2019t overgeneralize; a design that tries to cater for every possible use (and misuse) and defers every design decision for later (using compile-time or run-time indirections) is usually a complicated, bloated, hard-to-understand mess. Generalize from concrete examples, preserving performance as we generalize. Do not generalize based on mere speculation about future needs. The ideal is zero-overhead generalization. Libraries: Use libraries with good interfaces. If no library is available build one yourself and imitate the interface style from a good library. The standard library is a good first place to look for inspiration. Isolation: Isolate your code from messy and/or old-style code by providing an interface of your choosing to it. This is sometimes called \u201cproviding a wrapper\u201d for the useful/necessary but messy code. Don\u2019t let bad designs \u201cbleed into\u201d your code. Example # Consider: template <class ForwardIterator, class T> bool binary_search(ForwardIterator first, ForwardIterator last, const T& val); binary_search(begin(c), end(c), 7) will tell you whether 7 is in c or not. However, it will not tell you where that 7 is or whether there are more than one 7 . Sometimes, just passing the minimal amount of information back (here, true or false ) is sufficient, but a good interface passes needed information back to the caller. Therefore, the standard library also offers template <class ForwardIterator, class T> ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T& val); lower_bound returns an iterator to the first match if any, otherwise to the first element greater than val , or last if no such element is found. However, lower_bound still doesn\u2019t return enough information for all uses, so the standard library also offers template <class ForwardIterator, class T> pair<ForwardIterator, ForwardIterator> equal_range(ForwardIterator first, ForwardIterator last, const T& val); equal_range returns a pair of iterators specifying the first and one beyond last match. auto r = equal_range(begin(c), end(c), 7); for (auto p = r.first; p != r.second; ++p) cout << *p << '\\n'; Obviously, these three interfaces are implemented by the same basic code. They are simply three ways of presenting the basic binary search algorithm to users, ranging from the simplest (\u201cmake simple things simple!\u201d) to returning complete, but not always needed, information (\u201cdon\u2019t hide useful information\u201d). Naturally, crafting such a set of interfaces requires experience and domain knowledge. Note # Do not simply craft the interface to match the first implementation and the first use case you think of. Once your first initial implementation is complete, review it; once you deploy it, mistakes will be hard to remedy. Note # A need for efficiency does not imply a need for low-level code . High-level code does not imply slow or bloated. Note # Things have costs. Don\u2019t be paranoid about costs (modern computers really are very fast), but have a rough idea of the order of magnitude of cost of what you use. For example, have a rough idea of the cost of a memory access, a function call, a string comparison, a system call, a disk access, and a message through a network. Note # If you can only think of one implementation, you probably don\u2019t have something for which you can devise a stable interface. Maybe, it is just an implementation detail - not every piece of code needs a stable interface - but pause and consider. One question that can be useful is \u201cwhat interface would be needed if this operation should be implemented using multiple threads? be vectorized?\u201d Note # This rule does not contradict the Don\u2019t optimize prematurely rule. It complements it encouraging developers enable later - appropriate and non-premature - optimization, if and where needed. Enforcement # Tricky. Maybe looking for void* function arguments will find examples of interfaces that hinder later optimization. Per.10: Rely on the static type system # Reason # Type violations, weak types (e.g. void* s), and low-level code (e.g., manipulation of sequences as individual bytes) make the job of the optimizer much harder. Simple code often optimizes better than hand-crafted complex code. ??? Per.11: Move computation from run time to compile time # Reason # To decrease code size and run time. To avoid data races by using constants. To catch errors at compile time (and thus eliminate the need for error-handling code). Example # double square(double d) { return d*d; } static double s2 = square(2); // old-style: dynamic initialization constexpr double ntimes(double d, int n) // assume 0 <= n { double m = 1; while (n--) m *= d; return m; } constexpr double s3 {ntimes(2, 3)}; // modern-style: compile-time initialization Code like the initialization of s2 isn\u2019t uncommon, especially for initialization that\u2019s a bit more complicated than square() . However, compared to the initialization of s3 there are two problems: we suffer the overhead of a function call at run time s2 just might be accessed by another thread before the initialization happens. Note: you can\u2019t have a data race on a constant. Example # Consider a popular technique for providing a handle for storing small objects in the handle itself and larger ones on the heap. constexpr int on_stack_max = 20; template<typename T> struct Scoped { // store a T in Scoped // ... T obj; }; template<typename T> struct On_heap { // store a T on the free store // ... T* objp; }; template<typename T> using Handle = typename std::conditional<(sizeof(T) <= on_stack_max), Scoped<T>, // first alternative On_heap<T> // second alternative >::type; void f() { Handle<double> v1; // the double goes on the stack Handle<std::array<double, 200>> v2; // the array goes on the free store // ... } Assume that Scoped and On_heap provide compatible user interfaces. Here we compute the optimal type to use at compile time. There are similar techniques for selecting the optimal function to call. Note # The ideal is {not} to try execute everything at compile time. Obviously, most computations depend on inputs so they can\u2019t be moved to compile time, but beyond that logical constraint is the fact that complex compile-time computation can seriously increase compile times and complicate debugging. It is even possible to slow down code by compile-time computation. This is admittedly rare, but by factoring out a general computation into separate optimal sub-calculations it is possible to render the instruction cache less effective. Enforcement # Look for simple functions that might be constexpr (but are not). Look for functions called with all constant-expression arguments. Look for macros that could be constexpr. Per.12: Eliminate redundant aliases # ??? Per.13: Eliminate redundant indirections # ??? Per.14: Minimize the number of allocations and deallocations # ??? Per.15: Do not allocate on a critical branch # ??? Per.16: Use compact data structures # Reason # Performance is typically dominated by memory access times. ??? Per.17: Declare the most used member of a time-critical struct first # ??? Per.18: Space is time # Reason # Performance is typically dominated by memory access times. ??? Per.19: Access memory predictably # Reason # Performance is very sensitive to cache performance and cache algorithms favor simple (usually linear) access to adjacent data. Example # int matrix[rows][cols]; // bad for (int c = 0; c < cols; ++c) for (int r = 0; r < rows; ++r) sum += matrix[r][c]; // good for (int r = 0; r < rows; ++r) for (int c = 0; c < cols; ++c) sum += matrix[r][c]; Per.30: Avoid context switches on the critical path # ??? CP: Concurrency and parallelism # We often want our computers to do many tasks at the same time (or at least appear to do them at the same time). The reasons for doing so vary (e.g., waiting for many events using only a single processor, processing many data streams simultaneously, or utilizing many hardware facilities) and so do the basic facilities for expressing concurrency and parallelism. Here, we articulate principles and rules for using the ISO standard C++ facilities for expressing basic concurrency and parallelism. Threads are the machine-level foundation for concurrent and parallel programming. Threads allow running multiple sections of a program independently, while sharing the same memory. Concurrent programming is tricky, because protecting shared data between threads is easier said than done. Making existing single-threaded code execute concurrently can be as trivial as adding std::async or std::thread strategically, or it can necessitate a full rewrite, depending on whether the original code was written in a thread-friendly way. The concurrency/parallelism rules in this document are designed with three goals in mind: To help in writing code that is amenable to being used in a threaded environment To show clean, safe ways to use the threading primitives offered by the standard library To offer guidance on what to do when concurrency and parallelism aren\u2019t giving the performance gains needed It is also important to note that concurrency in C++ is an unfinished story. C++11 introduced many core concurrency primitives, C++14 and C++17 improved on them, and there is much interest in making the writing of concurrent programs in C++ even easier. We expect some of the library-related guidance here to change significantly over time. This section needs a lot of work (obviously). Please note that we start with rules for relative non-experts. Real experts must wait a bit; contributions are welcome, but please think about the majority of programmers who are struggling to get their concurrent programs correct and performant. Concurrency and parallelism rule summary: CP.1: Assume that your code will run as part of a multi-threaded program CP.2: Avoid data races CP.3: Minimize explicit sharing of writable data CP.4: Think in terms of tasks, rather than threads CP.8: Don\u2019t try to use volatile for synchronization CP.9: Whenever feasible use tools to validate your concurrent code See also : CP.con: Concurrency CP.par: Parallelism CP.mess: Message passing CP.vec: Vectorization CP.free: Lock-free programming CP.etc: Etc. concurrency rules CP.1: Assume that your code will run as part of a multi-threaded program # Reason # It\u2019s hard to be certain that concurrency isn\u2019t used now or won\u2019t be used sometime in the future. Code gets reused. Libraries not using threads may be used from some other part of a program that does use threads. Note that this rule applies most urgently to library code and least urgently to stand-alone applications. However, over time, code fragments can turn up in unexpected places. Example, bad # double cached_computation(double x) { // bad: these two statics cause data races in multi-threaded usage static double cached_x = 0.0; static double cached_result = COMPUTATION_OF_ZERO; double result; if (cached_x == x) return cached_result; result = computation(x); cached_x = x; cached_result = result; return result; } Although cached_computation works perfectly in a single-threaded environment, in a multi-threaded environment the two static variables result in data races and thus undefined behavior. There are several ways that this example could be made safe for a multi-threaded environment: Delegate concurrency concerns upwards to the caller. Mark the static variables as thread_local (which might make caching less effective). Implement concurrency control, for example, protecting the two static variables with a static lock (which might reduce performance). Have the caller provide the memory to be used for the cache, thereby delegating both memory allocation and concurrency concerns upwards to the caller. Refuse to build and/or run in a multi-threaded environment. Provide two implementations, one which is used in single-threaded environments and another which is used in multi-threaded environments. Exception # Code that is never run in a multi-threaded environment. Be careful: there are many examples where code that was \u201cknown\u201d to never run in a multi-threaded program was run as part of a multi-threaded program, often years later. Typically, such programs lead to a painful effort to remove data races. Therefore, code that is never intended to run in a multi-threaded environment should be clearly labeled as such and ideally come with compile or run-time enforcement mechanisms to catch those usage bugs early. CP.2: Avoid data races # Reason # Unless you do, nothing is guaranteed to work and subtle errors will persist. Note # In a nutshell, if two threads can access the same object concurrently (without synchronization), and at least one is a writer (performing a non- const operation), you have a data race. For further information of how to use synchronization well to eliminate data races, please consult a good book about concurrency. Example, bad # There are many examples of data races that exist, some of which are running in production software at this very moment. One very simple example: int get_id() { static int id = 1; return id++; } The increment here is an example of a data race. This can go wrong in many ways, including: Thread A loads the value of id , the OS context switches A out for some period, during which other threads create hundreds of IDs. Thread A is then allowed to run again, and id is written back to that location as A\u2019s read of id plus one. Thread A and B load id and increment it simultaneously. They both get the same ID. Local static variables are a common source of data races. Example, bad: # void f(fstream& fs, regex pattern) { array<double, max> buf; int sz = read_vec(fs, buf, max); // read from fs into buf gsl::span<double> s {buf}; // ... auto h1 = async([&]{ sort(std::execution::par, s); }); // spawn a task to sort // ... auto h2 = async([&]{ return find_all(buf, sz, pattern); }); // spawn a task to find matches // ... } Here, we have a (nasty) data race on the elements of buf ( sort will both read and write). All data races are nasty. Here, we managed to get a data race on data on the stack. Not all data races are as easy to spot as this one. Example, bad: # // code not controlled by a lock unsigned val; if (val < 5) { // ... other thread can change val here ... switch (val) { case 0: // ... case 1: // ... case 2: // ... case 3: // ... case 4: // ... } } Now, a compiler that does not know that val can change will most likely implement that switch using a jump table with five entries. Then, a val outside the [0..4] range will cause a jump to an address that could be anywhere in the program, and execution would proceed there. Really, \u201call bets are off\u201d if you get a data race. Actually, it can be worse still: by looking at the generated code you may be able to determine where the stray jump will go for a given value; this can be a security risk. Enforcement # Some is possible, do at least something. There are commercial and open-source tools that try to address this problem, but be aware that solutions have costs and blind spots. Static tools often have many false positives and run-time tools often have a significant cost. We hope for better tools. Using multiple tools can catch more problems than a single one. There are other ways you can mitigate the chance of data races: Avoid global data Avoid static variables More use of value types on the stack (and don\u2019t pass pointers around too much) More use of immutable data (literals, constexpr , and const ) CP.3: Minimize explicit sharing of writable data # Reason # If you don\u2019t share writable data, you can\u2019t have a data race. The less sharing you do, the less chance you have to forget to synchronize access (and get data races). The less sharing you do, the less chance you have to wait on a lock (so performance can improve). Example # bool validate(const vector<Reading>&); Graph<Temp_node> temperature_gradiants(const vector<Reading>&); Image altitude_map(const vector<Reading>&); // ... void process_readings(const vector<Reading>& surface_readings) { auto h1 = async([&] { if (!validate(surface_readings)) throw Invalid_data{}; }); auto h2 = async([&] { return temperature_gradiants(surface_readings); }); auto h3 = async([&] { return altitude_map(surface_readings); }); // ... h1.get(); auto v2 = h2.get(); auto v3 = h3.get(); // ... } Without those const s, we would have to review every asynchronously invoked function for potential data races on surface_readings . Making surface_readings be const (with respect to this function) allow reasoning using only the function body. Note # Immutable data can be safely and efficiently shared. No locking is needed: You can\u2019t have a data race on a constant. See also CP.mess: Message Passing and CP.31: prefer pass by value . Enforcement # ??? CP.4: Think in terms of tasks, rather than threads # Reason # A thread is an implementation concept, a way of thinking about the machine. A task is an application notion, something you\u2019d like to do, preferably concurrently with other tasks. Application concepts are easier to reason about. Example # void some_fun() { std::string msg, msg2; std::thread publisher([&] { msg = \"Hello\"; }); // bad: less expressive // and more error-prone auto pubtask = std::async([&] { msg2 = \"Hello\"; }); // OK // ... publisher.join(); } Note # With the exception of async() , the standard-library facilities are low-level, machine-oriented, threads-and-lock level. This is a necessary foundation, but we have to try to raise the level of abstraction: for productivity, for reliability, and for performance. This is a potent argument for using higher level, more applications-oriented libraries (if possibly, built on top of standard-library facilities). Enforcement # ??? CP.8: Don\u2019t try to use volatile for synchronization # Reason # In C++, unlike some other languages, volatile does not provide atomicity, does not synchronize between threads, and does not prevent instruction reordering (neither compiler nor hardware). It simply has nothing to do with concurrency. Example, bad: # int free_slots = max_slots; // current source of memory for objects Pool* use() { if (int n = free_slots--) return &pool[n]; } Here we have a problem: This is perfectly good code in a single-threaded program, but have two threads execute this and there is a race condition on free_slots so that two threads might get the same value and free_slots . That\u2019s (obviously) a bad data race, so people trained in other languages may try to fix it like this: volatile int free_slots = max_slots; // current source of memory for objects Pool* use() { if (int n = free_slots--) return &pool[n]; } This has no effect on synchronization: The data race is still there! The C++ mechanism for this is atomic types: atomic<int> free_slots = max_slots; // current source of memory for objects Pool* use() { if (int n = free_slots--) return &pool[n]; } Now the -- operation is atomic, rather than a read-increment-write sequence where another thread might get in-between the individual operations. Alternative # Use atomic types where you might have used volatile in some other language. Use a mutex for more complicated examples. See also # (rare) proper uses of volatile CP.9: Whenever feasible use tools to validate your concurrent code # Experience shows that concurrent code is exceptionally hard to get right and that compile-time checking, run-time checks, and testing are less effective at finding concurrency errors than they are at finding errors in sequential code. Subtle concurrency errors can have dramatically bad effects, including memory corruption and deadlocks. Example # ??? Note # Thread safety is challenging, often getting the better of experienced programmers: tooling is an important strategy to mitigate those risks. There are many tools \u201cout there\u201d, both commercial and open-source tools, both research and production tools. Unfortunately people\u2019s needs and constraints differ so dramatically that we cannot make specific recommendations, but we can mention: Static enforcement tools: both clang and some older versions of GCC have some support for static annotation of thread safety properties. Consistent use of this technique turns many classes of thread-safety errors into compile-time errors. The annotations are generally local (marking a particular member variable as guarded by a particular mutex), and are usually easy to learn. However, as with many static tools, it can often present false negatives; cases that should have been caught but were allowed. dynamic enforcement tools: Clang\u2019s Thread Sanitizer (aka TSAN) is a powerful example of dynamic tools: it changes the build and execution of your program to add bookkeeping on memory access, absolutely identifying data races in a given execution of your binary. The cost for this is both memory (5-10x in most cases) and CPU slowdown (2-20x). Dynamic tools like this are best when applied to integration tests, canary pushes, or unittests that operate on multiple threads. Workload matters: When TSAN identifies a problem, it is effectively always an actual data race, but it can only identify races seen in a given execution. Enforcement # It is up to an application builder to choose which support tools are valuable for a particular applications. CP.con: Concurrency # This section focuses on relatively ad-hoc uses of multiple threads communicating through shared data. For parallel algorithms, see parallelism For inter-task communication without explicit sharing, see messaging For vector parallel code, see vectorization For lock-free programming, see lock free Concurrency rule summary: CP.20: Use RAII, never plain lock() / unlock() CP.21: Use std::lock() or std::scoped_lock to acquire multiple mutex es CP.22: Never call unknown code while holding a lock (e.g., a callback) CP.23: Think of a joining thread as a scoped container CP.24: Think of a thread as a global container CP.25: Prefer gsl::joining_thread over std::thread CP.26: Don\u2019t detach() a thread CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer CP.32: To share ownership between unrelated thread s use shared_ptr CP.40: Minimize context switching CP.41: Minimize thread creation and destruction CP.42: Don\u2019t wait without a condition CP.43: Minimize time spent in a critical section CP.44: Remember to name your lock_guard s and unique_lock s CP.50: Define a mutex together with the data it guards. Use synchronized_value<T> where possible When ??? when to use try_lock() ??? when to prefer lock_guard over unique_lock Time ??? when/how to use new thread CP.20: Use RAII, never plain lock() / unlock() # Reason # Avoids nasty errors from unreleased locks. Example, bad # mutex mtx; void do_stuff() { mtx.lock(); // ... do stuff ... mtx.unlock(); } Sooner or later, someone will forget the mtx.unlock() , place a return in the ... do stuff ... , throw an exception, or something. mutex mtx; void do_stuff() { unique_lock<mutex> lck {mtx}; // ... do stuff ... } Enforcement # Flag calls of member lock() and unlock() . ??? CP.21: Use std::lock() or std::scoped_lock to acquire multiple mutex es # Reason # To avoid deadlocks on multiple mutex es. Example # This is asking for deadlock: // thread 1 lock_guard<mutex> lck1(m1); lock_guard<mutex> lck2(m2); // thread 2 lock_guard<mutex> lck2(m2); lock_guard<mutex> lck1(m1); Instead, use lock() : // thread 1 lock(m1, m2); lock_guard<mutex> lck1(m1, adopt_lock); lock_guard<mutex> lck2(m2, adopt_lock); // thread 2 lock(m2, m1); lock_guard<mutex> lck2(m2, adopt_lock); lock_guard<mutex> lck1(m1, adopt_lock); or (better, but C++17 only): // thread 1 scoped_lock<mutex, mutex> lck1(m1, m2); // thread 2 scoped_lock<mutex, mutex> lck2(m2, m1); Here, the writers of thread1 and thread2 are still not agreeing on the order of the mutex es, but order no longer matters. Note # In real code, mutex es are rarely named to conveniently remind the programmer of an intended relation and intended order of acquisition. In real code, mutex es are not always conveniently acquired on consecutive lines. In C++17 it\u2019s possible to write plain lock_guard lck1(m1, adopt_lock); and have the mutex type deduced. Enforcement # Detect the acquisition of multiple mutex es. This is undecidable in general, but catching common simple examples (like the one above) is easy. CP.22: Never call unknown code while holding a lock (e.g., a callback) # Reason # If you don\u2019t know what a piece of code does, you are risking deadlock. Example # void do_this(Foo* p) { lock_guard<mutex> lck {my_mutex}; // ... do something ... p->act(my_data); // ... } If you don\u2019t know what Foo::act does (maybe it is a virtual function invoking a derived class member of a class not yet written), it may call do_this (recursively) and cause a deadlock on my_mutex . Maybe it will lock on a different mutex and not return in a reasonable time, causing delays to any code calling do_this . Example # A common example of the \u201ccalling unknown code\u201d problem is a call to a function that tries to gain locked access to the same object. Such problem can often be solved by using a recursive_mutex . For example: recursive_mutex my_mutex; template<typename Action> void do_something(Action f) { unique_lock<recursive_mutex> lck {my_mutex}; // ... do something ... f(this); // f will do something to *this // ... } If, as it is likely, f() invokes operations on *this , we must make sure that the object\u2019s invariant holds before the call. Enforcement # Flag calling a virtual function with a non-recursive mutex held Flag calling a callback with a non-recursive mutex held CP.23: Think of a joining thread as a scoped container # Reason # To maintain pointer safety and avoid leaks, we need to consider what pointers are used by a thread . If a thread joins, we can safely pass pointers to objects in the scope of the thread and its enclosing scopes. Example # void f(int* p) { // ... *p = 99; // ... } int glob = 33; void some_fct(int* p) { int x = 77; joining_thread t0(f, &x); // OK joining_thread t1(f, p); // OK joining_thread t2(f, &glob); // OK auto q = make_unique<int>(99); joining_thread t3(f, q.get()); // OK // ... } A gsl::joining_thread is a std::thread with a destructor that joins and that cannot be detached() . By \u201cOK\u201d we mean that the object will be in scope (\u201clive\u201d) for as long as a thread can use the pointer to it. The fact that thread s run concurrently doesn\u2019t affect the lifetime or ownership issues here; these thread s can be seen as just a function object called from some_fct . Enforcement # Ensure that joining_thread s don\u2019t detach() . After that, the usual lifetime and ownership (for local objects) enforcement applies. CP.24: Think of a thread as a global container # Reason # To maintain pointer safety and avoid leaks, we need to consider what pointers are used by a thread . If a thread is detached, we can safely pass pointers to static and free store objects (only). Example # void f(int* p) { // ... *p = 99; // ... } int glob = 33; void some_fct(int* p) { int x = 77; std::thread t0(f, &x); // bad std::thread t1(f, p); // bad std::thread t2(f, &glob); // OK auto q = make_unique<int>(99); std::thread t3(f, q.get()); // bad // ... t0.detach(); t1.detach(); t2.detach(); t3.detach(); // ... } By \u201cOK\u201d we mean that the object will be in scope (\u201clive\u201d) for as long as a thread can use the pointers to it. By \u201cbad\u201d we mean that a thread may use a pointer after the pointed-to object is destroyed. The fact that thread s run concurrently doesn\u2019t affect the lifetime or ownership issues here; these thread s can be seen as just a function object called from some_fct . Note # Even objects with static storage duration can be problematic if used from detached threads: if the thread continues until the end of the program, it might be running concurrently with the destruction of objects with static storage duration, and thus accesses to such objects might race. Note # This rule is redundant if you don\u2019t detach() and use gsl::joining_thread . However, converting code to follow those guidelines could be difficult and even impossible for third-party libraries. In such cases, the rule becomes essential for lifetime safety and type safety. In general, it is undecidable whether a detach() is executed for a thread , but simple common cases are easily detected. If we cannot prove that a thread does not detach() , we must assume that it does and that it outlives the scope in which it was constructed; After that, the usual lifetime and ownership (for global objects) enforcement applies. Enforcement # Flag attempts to pass local variables to a thread that might detach() . CP.25: Prefer gsl::joining_thread over std::thread # Reason # A joining_thread is a thread that joins at the end of its scope. Detached threads are hard to monitor. It is harder to ensure absence of errors in detached threads (and potentially detached threads) Example, bad # void f() { std::cout << \"Hello \"; } struct F { void operator()() { std::cout << \"parallel world \"; } }; int main() { std::thread t1{f}; // f() executes in separate thread std::thread t2{F()}; // F()() executes in separate thread } // spot the bugs Example # void f() { std::cout << \"Hello \"; } struct F { void operator()() { std::cout << \"parallel world \"; } }; int main() { std::thread t1{f}; // f() executes in separate thread std::thread t2{F()}; // F()() executes in separate thread t1.join(); t2.join(); } // one bad bug left Example, bad # The code determining whether to join() or detach() may be complicated and even decided in the thread of functions called from it or functions called by the function that creates a thread: void tricky(thread* t, int n) { // ... if (is_odd(n)) t->detach(); // ... } void use(int n) { thread t { tricky, this, n }; // ... // ... should I join here? ... } This seriously complicates lifetime analysis, and in not too unlikely cases makes lifetime analysis impossible. This implies that we cannot safely refer to local objects in use() from the thread or refer to local objects in the thread from use() . Note # Make \u201cimmortal threads\u201d globals, put them in an enclosing scope, or put them on the free store rather than detach() . don\u2019t detach . Note # Because of old code and third party libraries using std::thread this rule can be hard to introduce. Enforcement # Flag uses of std::thread : Suggest use of gsl::joining_thread . Suggest \u201cexporting ownership\u201d to an enclosing scope if it detaches. Seriously warn if it is not obvious whether if joins of detaches. CP.26: Don\u2019t detach() a thread # Reason # Often, the need to outlive the scope of its creation is inherent in the thread s task, but implementing that idea by detach makes it harder to monitor and communicate with the detached thread. In particular, it is harder (though not impossible) to ensure that the thread completed as expected or lives for as long as expected. Example # void heartbeat(); void use() { std::thread t(heartbeat); // don't join; heartbeat is meant to run forever t.detach(); // ... } This is a reasonable use of a thread, for which detach() is commonly used. There are problems, though. How do we monitor the detached thread to see if it is alive? Something might go wrong with the heartbeat, and losing a heartbeat can be very serious in a system for which it is needed. So, we need to communicate with the heartbeat thread (e.g., through a stream of messages or notification events using a condition_variable ). An alternative, and usually superior solution is to control its lifetime by placing it in a scope outside its point of creation (or activation). For example: void heartbeat(); gsl::joining_thread t(heartbeat); // heartbeat is meant to run \"forever\" This heartbeat will (barring error, hardware problems, etc.) run for as long as the program does. Sometimes, we need to separate the point of creation from the point of ownership: void heartbeat(); unique_ptr<gsl::joining_thread> tick_tock {nullptr}; void use() { // heartbeat is meant to run as long as tick_tock lives tick_tock = make_unique<gsl::joining_thread>(heartbeat); // ... } Enforcement # Flag detach() . CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer # Reason # Copying a small amount of data is cheaper to copy and access than to share it using some locking mechanism. Copying naturally gives unique ownership (simplifies code) and eliminates the possibility of data races. Note # Defining \u201csmall amount\u201d precisely is impossible. Example # string modify1(string); void modify2(string&); void fct(string& s) { auto res = async(modify1, s); async(modify2, s); } The call of modify1 involves copying two string values; the call of modify2 does not. On the other hand, the implementation of modify1 is exactly as we would have written it for single-threaded code, whereas the implementation of modify2 will need some form of locking to avoid data races. If the string is short (say 10 characters), the call of modify1 can be surprisingly fast; essentially all the cost is in the thread switch. If the string is long (say 1,000,000 characters), copying it twice is probably not a good idea. Note that this argument has nothing to do with async as such. It applies equally to considerations about whether to use message passing or shared memory. Enforcement # ??? CP.32: To share ownership between unrelated thread s use shared_ptr # Reason # If threads are unrelated (that is, not known to be in the same scope or one within the lifetime of the other) and they need to share free store memory that needs to be deleted, a shared_ptr (or equivalent) is the only safe way to ensure proper deletion. Example # ??? Note # A static object (e.g. a global) can be shared because it is not owned in the sense that some thread is responsible for its deletion. An object on free store that is never to be deleted can be shared. An object owned by one thread can be safely shared with another as long as that second thread doesn\u2019t outlive the owner. Enforcement # ??? CP.40: Minimize context switching # Reason # Context switches are expensive. Example # ??? Enforcement # ??? CP.41: Minimize thread creation and destruction # Reason # Thread creation is expensive. Example # void worker(Message m) { // process } void master(istream& is) { for (Message m; is >> m; ) run_list.push_back(new thread(worker, m)); } This spawns a thread per message, and the run_list is presumably managed to destroy those tasks once they are finished. Instead, we could have a set of pre-created worker threads processing the messages Sync_queue<Message> work; void master(istream& is) { for (Message m; is >> m; ) work.put(m); } void worker() { for (Message m; m = work.get(); ) { // process } } void workers() // set up worker threads (specifically 4 worker threads) { joining_thread w1 {worker}; joining_thread w2 {worker}; joining_thread w3 {worker}; joining_thread w4 {worker}; } Note # If your system has a good thread pool, use it. If your system has a good message queue, use it. Enforcement # ??? CP.42: Don\u2019t wait without a condition # Reason # A wait without a condition can miss a wakeup or wake up simply to find that there is no work to do. Example, bad # std::condition_variable cv; std::mutex mx; void thread1() { while (true) { // do some work ... std::unique_lock<std::mutex> lock(mx); cv.notify_one(); // wake other thread } } void thread2() { while (true) { std::unique_lock<std::mutex> lock(mx); cv.wait(lock); // might block forever // do work ... } } Here, if some other thread consumes thread1 \u2018s notification, thread2 can wait forever. Example # template<typename T> class Sync_queue { public: void put(const T& val); void put(T&& val); void get(T& val); private: mutex mtx; condition_variable cond; // this controls access list<T> q; }; template<typename T> void Sync_queue<T>::put(const T& val) { lock_guard<mutex> lck(mtx); q.push_back(val); cond.notify_one(); } template<typename T> void Sync_queue<T>::get(T& val) { unique_lock<mutex> lck(mtx); cond.wait(lck, [this]{ return !q.empty(); }); // prevent spurious wakeup val = q.front(); q.pop_front(); } Now if the queue is empty when a thread executing get() wakes up (e.g., because another thread has gotten to get() before it), it will immediately go back to sleep, waiting. Enforcement # Flag all wait s without conditions. CP.43: Minimize time spent in a critical section # Reason # The less time is spent with a mutex taken, the less chance that another thread has to wait, and thread suspension and resumption are expensive. Example # void do_something() // bad { unique_lock<mutex> lck(my_lock); do0(); // preparation: does not need lock do1(); // transaction: needs locking do2(); // cleanup: does not need locking } Here, we are holding the lock for longer than necessary: We should not have taken the lock before we needed it and should have released it again before starting the cleanup. We could rewrite this to void do_something() // bad { do0(); // preparation: does not need lock my_lock.lock(); do1(); // transaction: needs locking my_lock.unlock(); do2(); // cleanup: does not need locking } But that compromises safety and violates the use RAII rule. Instead, add a block for the critical section: void do_something() // OK { do0(); // preparation: does not need lock { unique_lock<mutex> lck(my_lock); do1(); // transaction: needs locking } do2(); // cleanup: does not need locking } Enforcement # Impossible in general. Flag \u201cnaked\u201d lock() and unlock() . CP.44: Remember to name your lock_guard s and unique_lock s # Reason # An unnamed local objects is a temporary that immediately goes out of scope. Example # unique_lock<mutex>(m1); lock_guard<mutex> {m2}; lock(m1, m2); This looks innocent enough, but it isn\u2019t. Enforcement # Flag all unnamed lock_guard s and unique_lock s. CP.50: Define a mutex together with the data it guards. Use synchronized_value<T> where possible # Reason # It should be obvious to a reader that the data is to be guarded and how. This decreases the chance of the wrong mutex being locked, or the mutex not being locked. Using a synchronized_value<T> ensures that the data has a mutex, and the right mutex is locked when the data is accessed. See the WG21 proposal to add synchronized_value to a future TS or revision of the C++ standard. Example # struct Record { std::mutex m; // take this mutex before accessing other members // ... }; class MyClass { struct DataRecord { // ... }; synchronized_value<DataRecord> data; // Protect the data with a mutex }; Enforcement # ??? Possible? CP.par: Parallelism # By \u201cparallelism\u201d we refer to performing a task (more or less) simultaneously (\u201cin parallel with\u201d) on many data items. Parallelism rule summary: ??? ??? Where appropriate, prefer the standard-library parallel algorithms Use algorithms that are designed for parallelism, not algorithms with unnecessary dependency on linear evaluation CP.mess: Message passing # The standard-library facilities are quite low-level, focused on the needs of close-to the hardware critical programming using thread s, mutex es, atomic types, etc. Most people shouldn\u2019t work at this level: it\u2019s error-prone and development is slow. If possible, use a higher level facility: messaging libraries, parallel algorithms, and vectorization. This section looks at passing messages so that a programmer doesn\u2019t have to do explicit synchronization. Message passing rules summary: CP.60: Use a future to return a value from a concurrent task CP.61: Use an async() to spawn a concurrent task message queues messaging libraries ???? should there be a \u201cuse X rather than std::async \u201d where X is something that would use a better specified thread pool? ??? Is std::async worth using in light of future (and even existing, as libraries) parallelism facilities? What should the guidelines recommend if someone wants to parallelize, e.g., std::accumulate (with the additional precondition of commutativity), or merge sort? CP.60: Use a future to return a value from a concurrent task # Reason # A future preserves the usual function call return semantics for asynchronous tasks. There is no explicit locking and both correct (value) return and error (exception) return are handled simply. Example # ??? Note # ??? Enforcement # ??? CP.61: Use an async() to spawn a concurrent task # Reason # A future preserves the usual function call return semantics for asynchronous tasks. There is no explicit locking and both correct (value) return and error (exception) return are handled simply. Example # ??? Note # Unfortunately, async() is not perfect. For example, there is no guarantee that a thread pool is used to minimize thread construction. In fact, most current async() implementations don\u2019t. However, async() is simple and logically correct so until something better comes along and unless you really need to optimize for many asynchronous tasks, stick with async() . Enforcement # ??? CP.vec: Vectorization # Vectorization is a technique for executing a number of tasks concurrently without introducing explicit synchronization. An operation is simply applied to elements of a data structure (a vector, an array, etc.) in parallel. Vectorization has the interesting property of often requiring no non-local changes to a program. However, vectorization works best with simple data structures and with algorithms specifically crafted to enable it. Vectorization rule summary: ??? ??? CP.free: Lock-free programming # Synchronization using mutex es and condition_variable s can be relatively expensive. Furthermore, it can lead to deadlock. For performance and to eliminate the possibility of deadlock, we sometimes have to use the tricky low-level \u201clock-free\u201d facilities that rely on briefly gaining exclusive (\u201catomic\u201d) access to memory. Lock-free programming is also used to implement higher-level concurrency mechanisms, such as thread s and mutex es. Lock-free programming rule summary: CP.100: Don\u2019t use lock-free programming unless you absolutely have to CP.101: Distrust your hardware/compiler combination CP.102: Carefully study the literature how/when to use atomics avoid starvation use a lock-free data structure rather than hand-crafting specific lock-free access CP.110: Do not write your own double-checked locking for initialization CP.111: Use a conventional pattern if you really need double-checked locking how/when to compare and swap CP.100: Don\u2019t use lock-free programming unless you absolutely have to # Reason # It\u2019s error-prone and requires expert level knowledge of language features, machine architecture, and data structures. Example, bad # extern atomic<Link*> head; // the shared head of a linked list Link* nh = new Link(data, nullptr); // make a link ready for insertion Link* h = head.load(); // read the shared head of the list do { if (h->data <= data) break; // if so, insert elsewhere nh->next = h; // next element is the previous head } while (!head.compare_exchange_weak(h, nh)); // write nh to head or to h Spot the bug. It would be really hard to find through testing. Read up on the ABA problem. Exception # Atomic variables can be used simply and safely, as long as you are using the sequentially consistent memory model (memory_order_seq_cst), which is the default. Note # Higher-level concurrency mechanisms, such as thread s and mutex es are implemented using lock-free programming. Alternative : Use lock-free data structures implemented by others as part of some library. CP.101: Distrust your hardware/compiler combination # Reason # The low-level hardware interfaces used by lock-free programming are among the hardest to implement well and among the areas where the most subtle portability problems occur. If you are doing lock-free programming for performance, you need to check for regressions. Note # Instruction reordering (static and dynamic) makes it hard for us to think effectively at this level (especially if you use relaxed memory models). Experience, (semi)formal models and model checking can be useful. Testing - often to an extreme extent - is essential. \u201cDon\u2019t fly too close to the sun.\u201d Enforcement # Have strong rules for re-testing in place that covers any change in hardware, operating system, compiler, and libraries. CP.102: Carefully study the literature # Reason # With the exception of atomics and a few use standard patterns, lock-free programming is really an expert-only topic. Become an expert before shipping lock-free code for others to use. References # Anthony Williams: C++ concurrency in action. Manning Publications. Boehm, Adve, You Don\u2019t Know Jack About Shared Variables or Memory Models , Communications of the ACM, Feb 2012. Boehm, \u201cThreads Basics\u201d, HPL TR 2009-259. Adve, Boehm, \u201cMemory Models: A Case for Rethinking Parallel Languages and Hardware\u201d, Communications of the ACM, August 2010. Boehm, Adve, \u201cFoundations of the C++ Concurrency Memory Model\u201d, PLDI 08. Mark Batty, Scott Owens, Susmit Sarkar, Peter Sewell, and Tjark Weber, \u201cMathematizing C++ Concurrency\u201d, POPL 2011. Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup: Understanding and Effectively Preventing the ABA Problem in Descriptor-based Lock-free Designs. 13 th IEEE Computer Society ISORC 2010 Symposium. May 2010. Damian Dechev and Bjarne Stroustrup: Scalable Non-blocking Concurrent Objects for Mission Critical Code. ACM OOPSLA\u201809. October 2009 Damian Dechev, Peter Pirkelbauer, Nicolas Rouquette, and Bjarne Stroustrup: Semantically Enhanced Containers for Concurrent Real-Time Systems. Proc. 16 th Annual IEEE International Conference and Workshop on the Engineering of Computer Based Systems (IEEE ECBS). April 2009. CP.110: Do not write your own double-checked locking for initialization # Reason # Since C++11, static local variables are now initialized in a thread-safe way. When combined with the RAII pattern, static local variables can replace the need for writing your own double-checked locking for initialization. std::call_once can also achieve the same purpose. Use either static local variables of C++11 or std::call_once instead of writing your own double-checked locking for initialization. Example # Example with std::call_once. void f() { static std::once_flag my_once_flag; std::call_once(my_once_flag, []() { // do this only once }); // ... } Example with thread-safe static local variables of C++11. void f() { // Assuming the compiler is compliant with C++11 static My_class my_object; // Constructor called only once // ... } class My_class { public: My_class() { // do this only once } }; Enforcement # ??? Is it possible to detect the idiom? CP.111: Use a conventional pattern if you really need double-checked locking # Reason # Double-checked locking is easy to mess up. If you really need to write your own double-checked locking, in spite of the rules CP.110: Do not write your own double-checked locking for initialization and CP.100: Don\u2019t use lock-free programming unless you absolutely have to , then do it in a conventional pattern. The uses of the double-checked locking pattern that are not in violation of CP.110: Do not write your own double-checked locking for initialization arise when a non-thread-safe action is both hard and rare, and there exists a fast thread-safe test that can be used to guarantee that the action is not needed, but cannot be used to guarantee the converse. Example, bad # The use of volatile does not make the first check thread-safe, see also CP.200: Use volatile only to talk to non-C++ memory mutex action_mutex; volatile bool action_needed; if (action_needed) { std::lock_guard<std::mutex> lock(action_mutex); if (action_needed) { take_action(); action_needed = false; } } Example, good # mutex action_mutex; atomic<bool> action_needed; if (action_needed) { std::lock_guard<std::mutex> lock(action_mutex); if (action_needed) { take_action(); action_needed = false; } } Fine-tuned memory order may be beneficial where acquire load is more efficient than sequentially-consistent load mutex action_mutex; atomic<bool> action_needed; if (action_needed.load(memory_order_acquire)) { lock_guard<std::mutex> lock(action_mutex); if (action_needed.load(memory_order_relaxed)) { take_action(); action_needed.store(false, memory_order_release); } } Enforcement # ??? Is it possible to detect the idiom? CP.etc: Etc. concurrency rules # These rules defy simple categorization: CP.200: Use volatile only to talk to non-C++ memory CP.201: ??? Signals CP.200: Use volatile only to talk to non-C++ memory # Reason # volatile is used to refer to objects that are shared with \u201cnon-C++\u201d code or hardware that does not follow the C++ memory model. Example # const volatile long clock; This describes a register constantly updated by a clock circuit. clock is volatile because its value will change without any action from the C++ program that uses it. For example, reading clock twice will often yield two different values, so the optimizer had better not optimize away the second read in this code: long t1 = clock; // ... no use of clock here ... long t2 = clock; clock is const because the program should not try to write to clock . Note # Unless you are writing the lowest level code manipulating hardware directly, consider volatile an esoteric feature that is best avoided. Example # Usually C++ code receives volatile memory that is owned elsewhere (hardware or another language): int volatile* vi = get_hardware_memory_location(); // note: we get a pointer to someone else's memory here // volatile says \"treat this with extra respect\" Sometimes C++ code allocates the volatile memory and shares it with \u201celsewhere\u201d (hardware or another language) by deliberately escaping a pointer: static volatile long vl; please_use_this(&vl); // escape a reference to this to \"elsewhere\" (not C++) Example, bad # volatile local variables are nearly always wrong \u2013 how can they be shared with other languages or hardware if they\u2019re ephemeral? The same applies almost as strongly to member variables, for the same reason. void f() { volatile int i = 0; // bad, volatile local variable // etc. } class My_type { volatile int i = 0; // suspicious, volatile member variable // etc. }; Note # In C++, unlike in some other languages, volatile has nothing to do with synchronization . Enforcement # Flag volatile T local and member variables; almost certainly you intended to use atomic<T> instead. ??? CP.201: ??? Signals # ???UNIX signal handling???. May be worth reminding how little is async-signal-safe, and how to communicate with a signal handler (best is probably \u201cnot at all\u201d) E: Error handling # Error handling involves: Detecting an error Transmitting information about an error to some handler code Preserving a valid state of the program Avoiding resource leaks It is not possible to recover from all errors. If recovery from an error is not possible, it is important to quickly \u201cget out\u201d in a well-defined way. A strategy for error handling must be simple, or it becomes a source of even worse errors. Untested and rarely executed error-handling code is itself the source of many bugs. The rules are designed to help avoid several kinds of errors: Type violations (e.g., misuse of union s and casts) Resource leaks (including memory leaks) Bounds errors Lifetime errors (e.g., accessing an object after is has been delete d) Complexity errors (logical errors made likely by overly complex expression of ideas) Interface errors (e.g., an unexpected value is passed through an interface) Error-handling rule summary: E.1: Develop an error-handling strategy early in a design E.2: Throw an exception to signal that a function can\u2019t perform its assigned task E.3: Use exceptions for error handling only E.4: Design your error-handling strategy around invariants E.5: Let a constructor establish an invariant, and throw if it cannot E.6: Use RAII to prevent leaks E.7: State your preconditions E.8: State your postconditions E.12: Use noexcept when exiting a function because of a throw is impossible or unacceptable E.13: Never throw while being the direct owner of an object E.14: Use purpose-designed user-defined types as exceptions (not built-in types) E.15: Catch exceptions from a hierarchy by reference E.16: Destructors, deallocation, and swap must never fail E.17: Don\u2019t try to catch every exception in every function E.18: Minimize the use of explicit try / catch E.19: Use a final_action object to express cleanup if no suitable resource handle is available E.25: If you can\u2019t throw exceptions, simulate RAII for resource management E.26: If you can\u2019t throw exceptions, consider failing fast E.27: If you can\u2019t throw exceptions, use error codes systematically E.28: Avoid error handling based on global state (e.g. errno ) E.30: Don\u2019t use exception specifications E.31: Properly order your catch -clauses E.1: Develop an error-handling strategy early in a design # Reason # A consistent and complete strategy for handling errors and resource leaks is hard to retrofit into a system. E.2: Throw an exception to signal that a function can\u2019t perform its assigned task # Reason # To make error handling systematic, robust, and non-repetitive. Example # struct Foo { vector<Thing> v; File_handle f; string s; }; void use() { Foo bar {{Thing{1}, Thing{2}, Thing{monkey}}, {\"my_file\", \"r\"}, \"Here we go!\"}; // ... } Here, vector and string s constructors may not be able to allocate sufficient memory for their elements, vector s constructor may not be able copy the Thing s in its initializer list, and File_handle may not be able to open the required file. In each case, they throw an exception for use() \u2018s caller to handle. If use() could handle the failure to construct bar it can take control using try / catch . In either case, Foo \u2018s constructor correctly destroys constructed members before passing control to whatever tried to create a Foo . Note that there is no return value that could contain an error code. The File_handle constructor might be defined like this: File_handle::File_handle(const string& name, const string& mode) :f{fopen(name.c_str(), mode.c_str())} { if (!f) throw runtime_error{\"File_handle: could not open \" + name + \" as \" + mode}; } Note # It is often said that exceptions are meant to signal exceptional events and failures. However, that\u2019s a bit circular because \u201cwhat is exceptional?\u201d Examples: A precondition that cannot be met A constructor that cannot construct an object (failure to establish its class\u2019s invariant ) An out-of-range error (e.g., v[v.size()] = 7 ) Inability to acquire a resource (e.g., the network is down) In contrast, termination of an ordinary loop is not exceptional. Unless the loop was meant to be infinite, termination is normal and expected. Note # Don\u2019t use a throw as simply an alternative way of returning a value from a function. Exception # Some systems, such as hard-real-time systems require a guarantee that an action is taken in a (typically short) constant maximum time known before execution starts. Such systems can use exceptions only if there is tool support for accurately predicting the maximum time to recover from a throw . See also : RAII See also : discussion Note # Before deciding that you cannot afford or don\u2019t like exception-based error handling, have a look at the alternatives ; they have their own complexities and problems. Also, as far as possible, measure before making claims about efficiency. E.3: Use exceptions for error handling only # Reason # To keep error handling separated from \u201cordinary code.\u201d C++ implementations tend to be optimized based on the assumption that exceptions are rare. Example, don\u2019t # // don't: exception not used for error handling int find_index(vector<string>& vec, const string& x) { try { for (gsl::index i = 0; i < vec.size(); ++i) if (vec[i] == x) throw i; // found x } catch (int i) { return i; } return -1; // not found } This is more complicated and most likely runs much slower than the obvious alternative. There is nothing exceptional about finding a value in a vector . Enforcement # Would need to be heuristic. Look for exception values \u201cleaked\u201d out of catch clauses. E.4: Design your error-handling strategy around invariants # Reason # To use an object it must be in a valid state (defined formally or informally by an invariant) and to recover from an error every object not destroyed must be in a valid state. Note # An invariant is a logical condition for the members of an object that a constructor must establish for the public member functions to assume. Enforcement # ??? E.5: Let a constructor establish an invariant, and throw if it cannot # Reason # Leaving an object without its invariant established is asking for trouble. Not all member functions can be called. Example # class Vector { // very simplified vector of doubles // if elem != nullptr then elem points to sz doubles public: Vector() : elem{nullptr}, sz{0}{} Vector(int s) : elem{new double[s]}, sz{s} { /* initialize elements */ } ~Vector() { delete [] elem; } double& operator[](int s) { return elem[s]; } // ... private: owner<double*> elem; int sz; }; The class invariant - here stated as a comment - is established by the constructors. new throws if it cannot allocate the required memory. The operators, notably the subscript operator, relies on the invariant. See also : If a constructor cannot construct a valid object, throw an exception Enforcement # Flag classes with private state without a constructor (public, protected, or private). E.6: Use RAII to prevent leaks # Reason # Leaks are typically unacceptable. Manual resource release is error-prone. RAII (\u201cResource Acquisition Is Initialization\u201d) is the simplest, most systematic way of preventing leaks. Example # void f1(int i) // Bad: possible leak { int* p = new int[12]; // ... if (i < 17) throw Bad{\"in f()\", i}; // ... } We could carefully release the resource before the throw: void f2(int i) // Clumsy and error-prone: explicit release { int* p = new int[12]; // ... if (i < 17) { delete[] p; throw Bad{\"in f()\", i}; } // ... } This is verbose. In larger code with multiple possible throw s explicit releases become repetitive and error-prone. void f3(int i) // OK: resource management done by a handle (but see below) { auto p = make_unique<int[]>(12); // ... if (i < 17) throw Bad{\"in f()\", i}; // ... } Note that this works even when the throw is implicit because it happened in a called function: void f4(int i) // OK: resource management done by a handle (but see below) { auto p = make_unique<int[]>(12); // ... helper(i); // may throw // ... } Unless you really need pointer semantics, use a local resource object: void f5(int i) // OK: resource management done by local object { vector<int> v(12); // ... helper(i); // may throw // ... } That\u2019s even simpler and safer, and often more efficient. Note # If there is no obvious resource handle and for some reason defining a proper RAII object/handle is infeasible, as a last resort, cleanup actions can be represented by a final_action object. Note # But what do we do if we are writing a program where exceptions cannot be used? First challenge that assumption; there are many anti-exceptions myths around. We know of only a few good reasons: We are on a system so small that the exception support would eat up most of our 2K memory. We are in a hard-real-time system and we don\u2019t have tools that guarantee us that an exception is handled within the required time. We are in a system with tons of legacy code using lots of pointers in difficult-to-understand ways (in particular without a recognizable ownership strategy) so that exceptions could cause leaks. Our implementation of the C++ exception mechanisms is unreasonably poor (slow, memory consuming, failing to work correctly for dynamically linked libraries, etc.). Complain to your implementation purveyor; if no user complains, no improvement will happen. We get fired if we challenge our manager\u2019s ancient wisdom. Only the first of these reasons is fundamental, so whenever possible, use exceptions to implement RAII, or design your RAII objects to never fail. When exceptions cannot be used, simulate RAII. That is, systematically check that objects are valid after construction and still release all resources in the destructor. One strategy is to add a valid() operation to every resource handle: void f() { vector<string> vs(100); // not std::vector: valid() added if (!vs.valid()) { // handle error or exit } ifstream fs(\"foo\"); // not std::ifstream: valid() added if (!fs.valid()) { // handle error or exit } // ... } // destructors clean up as usual Obviously, this increases the size of the code, doesn\u2019t allow for implicit propagation of \u201cexceptions\u201d ( valid() checks), and valid() checks can be forgotten. Prefer to use exceptions. See also : Use of noexcept Enforcement # ??? E.7: State your preconditions # Reason # To avoid interface errors. See also : precondition rule E.8: State your postconditions # Reason # To avoid interface errors. See also : postcondition rule E.12: Use noexcept when exiting a function because of a throw is impossible or unacceptable # Reason # To make error handling systematic, robust, and efficient. Example # double compute(double d) noexcept { return log(sqrt(d <= 0 ? 1 : d)); } Here, we know that compute will not throw because it is composed out of operations that don\u2019t throw. By declaring compute to be noexcept , we give the compiler and human readers information that can make it easier for them to understand and manipulate compute . Note # Many standard-library functions are noexcept including all the standard-library functions \u201cinherited\u201d from the C Standard Library. Example # vector<double> munge(const vector<double>& v) noexcept { vector<double> v2(v.size()); // ... do something ... } The noexcept here states that I am not willing or able to handle the situation where I cannot construct the local vector . That is, I consider memory exhaustion a serious design error (on par with hardware failures) so that I\u2019m willing to crash the program if it happens. Note # Do not use traditional exception-specifications . See also # discussion . E.13: Never throw while being the direct owner of an object # Reason # That would be a leak. Example # void leak(int x) // don't: may leak { auto p = new int{7}; if (x < 0) throw Get_me_out_of_here{}; // may leak *p // ... delete p; // we may never get here } One way of avoiding such problems is to use resource handles consistently: void no_leak(int x) { auto p = make_unique<int>(7); if (x < 0) throw Get_me_out_of_here{}; // will delete *p if necessary // ... // no need for delete p } Another solution (often better) would be to use a local variable to eliminate explicit use of pointers: void no_leak_simplified(int x) { vector<int> v(7); // ... } Note # If you have local \u201cthings\u201d that requires cleanup, but is not represented by an object with a destructor, such cleanup must also be done before a throw . Sometimes, finally() can make such unsystematic cleanup a bit more manageable. E.14: Use purpose-designed user-defined types as exceptions (not built-in types) # Reason # A user-defined type is unlikely to clash with other people\u2019s exceptions. Example # void my_code() { // ... throw Moonphase_error{}; // ... } void your_code() { try { // ... my_code(); // ... } catch(const Bufferpool_exhausted&) { // ... } } Example, don\u2019t # void my_code() // Don't { // ... throw 7; // 7 means \"moon in the 4th quarter\" // ... } void your_code() // Don't { try { // ... my_code(); // ... } catch(int i) { // i == 7 means \"input buffer too small\" // ... } } Note # The standard-library classes derived from exception should be used only as base classes or for exceptions that require only \u201cgeneric\u201d handling. Like built-in types, their use could clash with other people\u2019s use of them. Example, don\u2019t # void my_code() // Don't { // ... throw runtime_error{\"moon in the 4th quarter\"}; // ... } void your_code() // Don't { try { // ... my_code(); // ... } catch(const runtime_error&) { // runtime_error means \"input buffer too small\" // ... } } See also : Discussion Enforcement # Catch throw and catch of a built-in type. Maybe warn about throw and catch using a standard-library exception type. Obviously, exceptions derived from the std::exception hierarchy are fine. E.15: Catch exceptions from a hierarchy by reference # Reason # To prevent slicing. Example # void f() { try { // ... } catch (exception e) { // don't: may slice // ... } } Instead, use a reference: catch (exception& e) { /* ... */ } or - typically better still - a const reference: catch (const exception& e) { /* ... */ } Most handlers do not modify their exception and in general we recommend use of const . Note # To rethrow a caught exception use throw; not throw e; . Using throw e; would throw a new copy of e (sliced to the static type std::exception ) instead of rethrowing the original exception of type std::runtime_error . (But keep Don\u2019t try to catch every exception in every function and Minimize the use of explicit try / catch in mind.) Enforcement # Flag by-value exceptions if their types are part of a hierarchy (could require whole-program analysis to be perfect). E.16: Destructors, deallocation, and swap must never fail # Reason # We don\u2019t know how to write reliable programs if a destructor, a swap, or a memory deallocation fails; that is, if it exits by an exception or simply doesn\u2019t perform its required action. Example, don\u2019t # class Connection { // ... public: ~Connection() // Don't: very bad destructor { if (cannot_disconnect()) throw I_give_up{information}; // ... } }; Note # Many have tried to write reliable code violating this rule for examples, such as a network connection that \u201crefuses to close\u201d. To the best of our knowledge nobody has found a general way of doing this. Occasionally, for very specific examples, you can get away with setting some state for future cleanup. For example, we might put a socket that does not want to close on a \u201cbad socket\u201d list, to be examined by a regular sweep of the system state. Every example we have seen of this is error-prone, specialized, and often buggy. Note # The standard library assumes that destructors, deallocation functions (e.g., operator delete ), and swap do not throw. If they do, basic standard-library invariants are broken. Note # Deallocation functions, including operator delete , must be noexcept . swap functions must be noexcept . Most destructors are implicitly noexcept by default. Also, make move operations noexcept . Enforcement # Catch destructors, deallocation operations, and swap s that throw . Catch such operations that are not noexcept . See also : discussion E.17: Don\u2019t try to catch every exception in every function # Reason # Catching an exception in a function that cannot take a meaningful recovery action leads to complexity and waste. Let an exception propagate until it reaches a function that can handle it. Let cleanup actions on the unwinding path be handled by RAII . Example, don\u2019t # void f() // bad { try { // ... } catch (...) { // no action throw; // propagate exception } } Enforcement # Flag nested try-blocks. Flag source code files with a too high ratio of try-blocks to functions. (??? Problem: define \u201ctoo high\u201d) E.18: Minimize the use of explicit try / catch # Reason # try / catch is verbose and non-trivial uses are error-prone. try / catch can be a sign of unsystematic and/or low-level resource management or error handling. Example, Bad # void f(zstring s) { Gadget* p; try { p = new Gadget(s); // ... delete p; } catch (Gadget_construction_failure) { delete p; throw; } } This code is messy. There could be a leak from the naked pointer in the try block. Not all exceptions are handled. deleting an object that failed to construct is almost certainly a mistake. Better: void f2(zstring s) { Gadget g {s}; } Alternatives # proper resource handles and RAII finally Enforcement # ??? hard, needs a heuristic E.19: Use a final_action object to express cleanup if no suitable resource handle is available # Reason # finally is less verbose and harder to get wrong than try / catch . Example # void f(int n) { void* p = malloc(n); auto _ = finally([p] { free(p); }); // ... } Note # finally is not as messy as try / catch , but it is still ad-hoc. Prefer proper resource management objects . Consider finally a last resort. Note # Use of finally is a systematic and reasonably clean alternative to the old goto exit; technique for dealing with cleanup where resource management is not systematic. Enforcement # Heuristic: Detect goto exit; E.25: If you can\u2019t throw exceptions, simulate RAII for resource management # Reason # Even without exceptions, RAII is usually the best and most systematic way of dealing with resources. Note # Error handling using exceptions is the only complete and systematic way of handling non-local errors in C++. In particular, non-intrusively signaling failure to construct an object requires an exception. Signaling errors in a way that cannot be ignored requires exceptions. If you can\u2019t use exceptions, simulate their use as best you can. A lot of fear of exceptions is misguided. When used for exceptional circumstances in code that is not littered with pointers and complicated control structures, exception handling is almost always affordable (in time and space) and almost always leads to better code. This, of course, assumes a good implementation of the exception handling mechanisms, which is not available on all systems. There are also cases where the problems above do not apply, but exceptions cannot be used for other reasons. Some hard-real-time systems are an example: An operation has to be completed within a fixed time with an error or a correct answer. In the absence of appropriate time estimation tools, this is hard to guarantee for exceptions. Such systems (e.g. flight control software) typically also ban the use of dynamic (heap) memory. So, the primary guideline for error handling is \u201cuse exceptions and RAII .\u201d This section deals with the cases where you either do not have an efficient implementation of exceptions, or have such a rat\u2019s nest of old-style code (e.g., lots of pointers, ill-defined ownership, and lots of unsystematic error handling based on tests of error codes) that it is infeasible to introduce simple and systematic exception handling. Before condemning exceptions or complaining too much about their cost, consider examples of the use of error codes . Consider the cost and complexity of the use of error codes. If performance is your worry, measure. Example # Assume you wanted to write void func(zstring arg) { Gadget g {arg}; // ... } If the gadget isn\u2019t correctly constructed, func exits with an exception. If we cannot throw an exception, we can simulate this RAII style of resource handling by adding a valid() member function to Gadget : error_indicator func(zstring arg) { Gadget g {arg}; if (!g.valid()) return gadget_construction_error; // ... return 0; // zero indicates \"good\" } The problem is of course that the caller now has to remember to test the return value. See also : Discussion Enforcement # Possible (only) for specific versions of this idea: e.g., test for systematic test of valid() after resource handle construction E.26: If you can\u2019t throw exceptions, consider failing fast # Reason # If you can\u2019t do a good job at recovering, at least you can get out before too much consequential damage is done. See also : Simulating RAII Note # If you cannot be systematic about error handling, consider \u201ccrashing\u201d as a response to any error that cannot be handled locally. That is, if you cannot recover from an error in the context of the function that detected it, call abort() , quick_exit() , or a similar function that will trigger some sort of system restart. In systems where you have lots of processes and/or lots of computers, you need to expect and handle fatal crashes anyway, say from hardware failures. In such cases, \u201ccrashing\u201d is simply leaving error handling to the next level of the system. Example # void f(int n) { // ... p = static_cast<X*>(malloc(n * sizeof(X))); if (!p) abort(); // abort if memory is exhausted // ... } Most programs cannot handle memory exhaustion gracefully anyway. This is roughly equivalent to void f(int n) { // ... p = new X[n]; // throw if memory is exhausted (by default, terminate) // ... } Typically, it is a good idea to log the reason for the \u201ccrash\u201d before exiting. Enforcement # Awkward E.27: If you can\u2019t throw exceptions, use error codes systematically # Reason # Systematic use of any error-handling strategy minimizes the chance of forgetting to handle an error. See also : Simulating RAII Note # There are several issues to be addressed: How do you transmit an error indicator from out of a function? How do you release all resources from a function before doing an error exit? What do you use as an error indicator? In general, returning an error indicator implies returning two values: The result and an error indicator. The error indicator can be part of the object, e.g. an object can have a valid() indicator or a pair of values can be returned. Example # Gadget make_gadget(int n) { // ... } void user() { Gadget g = make_gadget(17); if (!g.valid()) { // error handling } // ... } This approach fits with simulated RAII resource management . The valid() function could return an error_indicator (e.g. a member of an error_indicator enumeration). Example # What if we cannot or do not want to modify the Gadget type? In that case, we must return a pair of values. For example: std::pair<Gadget, error_indicator> make_gadget(int n) { // ... } void user() { auto r = make_gadget(17); if (!r.second) { // error handling } Gadget& g = r.first; // ... } As shown, std::pair is a possible return type. Some people prefer a specific type. For example: Gval make_gadget(int n) { // ... } void user() { auto r = make_gadget(17); if (!r.err) { // error handling } Gadget& g = r.val; // ... } One reason to prefer a specific return type is to have names for its members, rather than the somewhat cryptic first and second and to avoid confusion with other uses of std::pair . Example # In general, you must clean up before an error exit. This can be messy: std::pair<int, error_indicator> user() { Gadget g1 = make_gadget(17); if (!g1.valid()) { return {0, g1_error}; } Gadget g2 = make_gadget(17); if (!g2.valid()) { cleanup(g1); return {0, g2_error}; } // ... if (all_foobar(g1, g2)) { cleanup(g1); cleanup(g2); return {0, foobar_error}; // ... cleanup(g1); cleanup(g2); return {res, 0}; } Simulating RAII can be non-trivial, especially in functions with multiple resources and multiple possible errors. A not uncommon technique is to gather cleanup at the end of the function to avoid repetition (note the extra scope around g2 is undesirable but necessary to make the goto version compile): std::pair<int, error_indicator> user() { error_indicator err = 0; Gadget g1 = make_gadget(17); if (!g1.valid()) { err = g1_error; goto exit; } { Gadget g2 = make_gadget(17); if (!g2.valid()) { err = g2_error; goto exit; } if (all_foobar(g1, g2)) { err = foobar_error; goto exit; } // ... } exit: if (g1.valid()) cleanup(g1); if (g2.valid()) cleanup(g2); return {res, err}; } The larger the function, the more tempting this technique becomes. finally can ease the pain a bit . Also, the larger the program becomes the harder it is to apply an error-indicator-based error-handling strategy systematically. We prefer exception-based error handling and recommend keeping functions short . See also : Discussion See also : Returning multiple values Enforcement # Awkward. E.28: Avoid error handling based on global state (e.g. errno ) # Reason # Global state is hard to manage and it is easy to forget to check it. When did you last test the return value of printf() ? See also : Simulating RAII Example, bad # int last_err; void f(int n) { // ... p = static_cast<X*>(malloc(n * sizeof(X))); if (!p) last_err = -1; // error if memory is exhausted // ... } Note # C-style error handling is based on the global variable errno , so it is essentially impossible to avoid this style completely. Enforcement # Awkward. E.30: Don\u2019t use exception specifications # Reason # Exception specifications make error handling brittle, impose a run-time cost, and have been removed from the C++ standard. Example # int use(int arg) throw(X, Y) { // ... auto x = f(arg); // ... } If f() throws an exception different from X and Y the unexpected handler is invoked, which by default terminates. That\u2019s OK, but say that we have checked that this cannot happen and f is changed to throw a new exception Z , we now have a crash on our hands unless we change use() (and re-test everything). The snag is that f() may be in a library we do not control and the new exception is not anything that use() can do anything about or is in any way interested in. We can change use() to pass Z through, but now use() \u2018s callers probably needs to be modified. This quickly becomes unmanageable. Alternatively, we can add a try - catch to use() to map Z into an acceptable exception. This too, quickly becomes unmanageable. Note that changes to the set of exceptions often happens at the lowest level of a system (e.g., because of changes to a network library or some middleware), so changes \u201cbubble up\u201d through long call chains. In a large code base, this could mean that nobody could update to a new version of a library until the last user was modified. If use() is part of a library, it may not be possible to update it because a change could affect unknown clients. The policy of letting exceptions propagate until they reach a function that potentially can handle it has proven itself over the years. Note # No. This would not be any better had exception specifications been statically enforced. For example, see Stroustrup94 . Note # If no exception may be thrown, use noexcept or its equivalent throw() . Enforcement # Flag every exception specification. E.31: Properly order your catch -clauses # Reason # catch -clauses are evaluated in the order they appear and one clause can hide another. Example # void f() { // ... try { // ... } catch (Base& b) { /* ... */ } catch (Derived& d) { /* ... */ } catch (...) { /* ... */ } catch (std::exception& e){ /* ... */ } } If Derived is derived from Base the Derived -handler will never be invoked. The \u201ccatch everything\u201d handler ensured that the std::exception -handler will never be invoked. Enforcement # Flag all \u201chiding handlers\u201d. Con: Constants and immutability # You can\u2019t have a race condition on a constant. It is easier to reason about a program when many of the objects cannot change their values. Interfaces that promises \u201cno change\u201d of objects passed as arguments greatly increase readability. Constant rule summary: Con.1: By default, make objects immutable Con.2: By default, make member functions const Con.3: By default, pass pointers and references to const s Con.4: Use const to define objects with values that do not change after construction Con.5: Use constexpr for values that can be computed at compile time Con.1: By default, make objects immutable # Reason # Immutable objects are easier to reason about, so make objects non- const only when there is a need to change their value. Prevents accidental or hard-to-notice change of value. Example # for (const int i : c) cout << i << '\\n'; // just reading: const for (int i : c) cout << i << '\\n'; // BAD: just reading Exception # Function arguments are rarely mutated, but also rarely declared const. To avoid confusion and lots of false positives, don\u2019t enforce this rule for function arguments. void f(const char* const p); // pedantic void g(const int i); // pedantic Note that function parameter is a local variable so changes to it are local. Enforcement # Flag non- const variables that are not modified (except for parameters to avoid many false positives) Con.2: By default, make member functions const # Reason # A member function should be marked const unless it changes the object\u2019s observable state. This gives a more precise statement of design intent, better readability, more errors caught by the compiler, and sometimes more optimization opportunities. Example, bad # class Point { int x, y; public: int getx() { return x; } // BAD, should be const as it doesn't modify the object's state // ... }; void f(const Point& pt) { int x = pt.getx(); // ERROR, doesn't compile because getx was not marked const } Note # It is not inherently bad to pass a pointer or reference to non- const , but that should be done only when the called function is supposed to modify the object. A reader of code must assume that a function that takes a \u201cplain\u201d T* or T& will modify the object referred to. If it doesn\u2019t now, it might do so later without forcing recompilation. Note # There are code/libraries that offer functions that declare a T* even though those function do not modify that T . This is a problem for people modernizing code. You can update the library to be const -correct; preferred long-term solution \u201ccast away const \u201d; best avoided provide a wrapper function Example: void f(int* p); // old code: f() does not modify `*p` void f(const int* p) { f(const_cast<int*>(p)); } // wrapper Note that this wrapper solution is a patch that should be used only when the declaration of f() cannot be modified, e.g. because it is in a library that you cannot modify. Note # A const member function can modify the value of an object that is mutable or accessed through a pointer member. A common use is to maintain a cache rather than repeatedly do a complicated computation. For example, here is a Date that caches (memoizes) its string representation to simplify repeated uses: class Date { public: // ... const string& string_ref() const { if (string_val == \"\") compute_string_rep(); return string_val; } // ... private: void compute_string_rep() const; // compute string representation and place it in string_val mutable string string_val; // ... }; Another way of saying this is that const ness is not transitive. It is possible for a const member function to change the value of mutable members and the value of objects accessed through non- const pointers. It is the job of the class to ensure such mutation is done only when it makes sense according to the semantics (invariants) it offers to its users. See also : Pimpl Enforcement # Flag a member function that is not marked const , but that does not perform a non- const operation on any member variable. Con.3: By default, pass pointers and references to const s # Reason # To avoid a called function unexpectedly changing the value. It\u2019s far easier to reason about programs when called functions don\u2019t modify state. Example # void f(char* p); // does f modify *p? (assume it does) void g(const char* p); // g does not modify *p Note # It is not inherently bad to pass a pointer or reference to non- const , but that should be done only when the called function is supposed to modify the object. Note # Do not cast away const . Enforcement # Flag function that does not modify an object passed by pointer or reference to non- const Flag a function that (using a cast) modifies an object passed by pointer or reference to const Con.4: Use const to define objects with values that do not change after construction # Reason # Prevent surprises from unexpectedly changed object values. Example # void f() { int x = 7; const int y = 9; for (;;) { // ... } // ... } As x is not const , we must assume that it is modified somewhere in the loop. Enforcement # Flag unmodified non- const variables. Con.5: Use constexpr for values that can be computed at compile time # Reason # Better performance, better compile-time checking, guaranteed compile-time evaluation, no possibility of race conditions. Example # double x = f(2); // possible run-time evaluation const double y = f(2); // possible run-time evaluation constexpr double z = f(2); // error unless f(2) can be evaluated at compile time Note # See F.4. Enforcement # Flag const definitions with constant expression initializers. T: Templates and generic programming # Generic programming is programming using types and algorithms parameterized by types, values, and algorithms. In C++, generic programming is supported by the template language mechanisms. Arguments to generic functions are characterized by sets of requirements on the argument types and values involved. In C++, these requirements are expressed by compile-time predicates called concepts. Templates can also be used for meta-programming; that is, programs that compose code at compile time. A central notion in generic programming is \u201cconcepts\u201d; that is, requirements on template arguments presented as compile-time predicates. \u201cConcepts\u201d are defined in an ISO Technical Specification: concepts . A draft of a set of standard-library concepts can be found in another ISO TS: ranges Concepts are supported in GCC 6.1 and later. Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only. If you use GCC 6.1 or later, you can uncomment them. Template use rule summary: T.1: Use templates to raise the level of abstraction of code T.2: Use templates to express algorithms that apply to many argument types T.3: Use templates to express containers and ranges T.4: Use templates to express syntax tree manipulation T.5: Combine generic and OO techniques to amplify their strengths, not their costs Concept use rule summary: T.10: Specify concepts for all template arguments T.11: Whenever possible use standard concepts T.12: Prefer concept names over auto for local variables T.13: Prefer the shorthand notation for simple, single-type argument concepts ??? Concept definition rule summary: T.20: Avoid \u201cconcepts\u201d without meaningful semantics T.21: Require a complete set of operations for a concept T.22: Specify axioms for concepts T.23: Differentiate a refined concept from its more general case by adding new use patterns T.24: Use tag classes or traits to differentiate concepts that differ only in semantics T.25: Avoid complementary constraints T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax T.30: Use concept negation ( !C<T> ) sparingly to express a minor difference T.31: Use concept disjunction ( C1<T> || C2<T> ) sparingly to express alternatives ??? Template interface rule summary: T.40: Use function objects to pass operations to algorithms T.41: Require only essential properties in a template\u2019s concepts T.42: Use template aliases to simplify notation and hide implementation details T.43: Prefer using over typedef for defining aliases T.44: Use function templates to deduce class template argument types (where feasible) T.46: Require template arguments to be at least Regular or SemiRegular T.47: Avoid highly visible unconstrained templates with common names T.48: If your compiler does not support concepts, fake them with enable_if T.49: Where possible, avoid type-erasure Template definition rule summary: T.60: Minimize a template\u2019s context dependencies T.61: Do not over-parameterize members (SCARY) T.62: Place non-dependent class template members in a non-templated base class T.64: Use specialization to provide alternative implementations of class templates T.65: Use tag dispatch to provide alternative implementations of functions T.67: Use specialization to provide alternative implementations for irregular types T.68: Use {} rather than () within templates to avoid ambiguities T.69: Inside a template, don\u2019t make an unqualified nonmember function call unless you intend it to be a customization point Template and hierarchy rule summary: T.80: Do not naively templatize a class hierarchy T.81: Do not mix hierarchies and arrays // ??? somewhere in \u201chierarchies\u201d T.82: Linearize a hierarchy when virtual functions are undesirable T.83: Do not declare a member function template virtual T.84: Use a non-template core implementation to provide an ABI-stable interface T.??: ???? Variadic template rule summary: T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types T.101: ??? How to pass arguments to a variadic template ??? T.102: ??? How to process arguments to a variadic template ??? T.103: Don\u2019t use variadic templates for homogeneous argument lists T.??: ???? Metaprogramming rule summary: T.120: Use template metaprogramming only when you really need to T.121: Use template metaprogramming primarily to emulate concepts T.122: Use templates (usually template aliases) to compute types at compile time T.123: Use constexpr functions to compute values at compile time T.124: Prefer to use standard-library TMP facilities T.125: If you need to go beyond the standard-library TMP facilities, use an existing library T.??: ???? Other template rules summary: T.140: Name all operations with potential for reuse T.141: Use an unnamed lambda if you need a simple function object in one place only T.142: Use template variables to simplify notation T.143: Don\u2019t write unintentionally nongeneric code T.144: Don\u2019t specialize function templates T.150: Check that a class matches a concept using static_assert T.??: ???? T.gp: Generic programming # Generic programming is programming using types and algorithms parameterized by types, values, and algorithms. T.1: Use templates to raise the level of abstraction of code # Reason # Generality. Reuse. Efficiency. Encourages consistent definition of user types. Example, bad # Conceptually, the following requirements are wrong because what we want of T is more than just the very low-level concepts of \u201ccan be incremented\u201d or \u201ccan be added\u201d: template<typename T> // requires Incrementable<T> T sum1(vector<T>& v, T s) { for (auto x : v) s += x; return s; } template<typename T> // requires Simple_number<T> T sum2(vector<T>& v, T s) { for (auto x : v) s = s + x; return s; } Assuming that Incrementable does not support + and Simple_number does not support += , we have overconstrained implementers of sum1 and sum2 . And, in this case, missed an opportunity for a generalization. Example # template<typename T> // requires Arithmetic<T> T sum(vector<T>& v, T s) { for (auto x : v) s += x; return s; } Assuming that Arithmetic requires both + and += , we have constrained the user of sum to provide a complete arithmetic type. That is not a minimal requirement, but it gives the implementer of algorithms much needed freedom and ensures that any Arithmetic type can be used for a wide variety of algorithms. For additional generality and reusability, we could also use a more general Container or Range concept instead of committing to only one container, vector . Note # If we define a template to require exactly the operations required for a single implementation of a single algorithm (e.g., requiring just += rather than also = and + ) and only those, we have overconstrained maintainers. We aim to minimize requirements on template arguments, but the absolutely minimal requirements of an implementation is rarely a meaningful concept. Note # Templates can be used to express essentially everything (they are Turing complete), but the aim of generic programming (as expressed using templates) is to efficiently generalize operations/algorithms over a set of types with similar semantic properties. Note # The requires in the comments are uses of concepts . \u201cConcepts\u201d are defined in an ISO Technical Specification: concepts . Concepts are supported in GCC 6.1 and later. Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only. If you use GCC 6.1 or later, you can uncomment them. Enforcement # Flag algorithms with \u201coverly simple\u201d requirements, such as direct use of specific operators without a concept. Do not flag the definition of the \u201coverly simple\u201d concepts themselves; they may simply be building blocks for more useful concepts. T.2: Use templates to express algorithms that apply to many argument types # Reason # Generality. Minimizing the amount of source code. Interoperability. Reuse. Example # That\u2019s the foundation of the STL. A single find algorithm easily works with any kind of input range: template<typename Iter, typename Val> // requires Input_iterator<Iter> // && Equality_comparable<Value_type<Iter>, Val> Iter find(Iter b, Iter e, Val v) { // ... } Note # Don\u2019t use a template unless you have a realistic need for more than one template argument type. Don\u2019t overabstract. Enforcement # ??? tough, probably needs a human T.3: Use templates to express containers and ranges # Reason # Containers need an element type, and expressing that as a template argument is general, reusable, and type safe. It also avoids brittle or inefficient workarounds. Convention: That\u2019s the way the STL does it. Example # template<typename T> // requires Regular<T> class Vector { // ... T* elem; // points to sz Ts int sz; }; Vector<double> v(10); v[7] = 9.9; Example, bad # class Container { // ... void* elem; // points to size elements of some type int sz; }; Container c(10, sizeof(double)); ((double*) c.elem)[7] = 9.9; This doesn\u2019t directly express the intent of the programmer and hides the structure of the program from the type system and optimizer. Hiding the void* behind macros simply obscures the problems and introduces new opportunities for confusion. Exceptions : If you need an ABI-stable interface, you might have to provide a base implementation and express the (type-safe) template in terms of that. See Stable base . Enforcement # Flag uses of void* s and casts outside low-level implementation code T.4: Use templates to express syntax tree manipulation # Reason # ??? Example # ??? Exceptions : ??? T.5: Combine generic and OO techniques to amplify their strengths, not their costs # Reason # Generic and OO techniques are complementary. Example # Static helps dynamic: Use static polymorphism to implement dynamically polymorphic interfaces. class Command { // pure virtual functions }; // implementations template<!--*...*/--> class ConcreteCommand : public Command { // implement virtuals }; Example # Dynamic helps static: Offer a generic, comfortable, statically bound interface, but internally dispatch dynamically, so you offer a uniform object layout. Examples include type erasure as with std::shared_ptr \u2018s deleter (but don\u2019t overuse type erasure ). Note # In a class template, nonvirtual functions are only instantiated if they\u2019re used \u2013 but virtual functions are instantiated every time. This can bloat code size, and may overconstrain a generic type by instantiating functionality that is never needed. Avoid this, even though the standard-library facets made this mistake. See also # ref ??? ref ??? ref ??? Enforcement # See the reference to more specific rules. T.concepts: Concept rules # Concepts is a facility for specifying requirements for template arguments. It is an ISO Technical Specification , but currently supported only by GCC. Concepts are, however, crucial in the thinking about generic programming and the basis of much work on future C++ libraries (standard and other). This section assumes concept support Concept use rule summary: T.10: Specify concepts for all template arguments T.11: Whenever possible use standard concepts T.12: Prefer concept names over auto T.13: Prefer the shorthand notation for simple, single-type argument concepts ??? Concept definition rule summary: T.20: Avoid \u201cconcepts\u201d without meaningful semantics T.21: Require a complete set of operations for a concept T.22: Specify axioms for concepts T.23: Differentiate a refined concept from its more general case by adding new use patterns T.24: Use tag classes or traits to differentiate concepts that differ only in semantics T.25: Avoid complimentary constraints T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax ??? T.con-use: Concept use # T.10: Specify concepts for all template arguments # Reason # Correctness and readability. The assumed meaning (syntax and semantics) of a template argument is fundamental to the interface of a template. A concept dramatically improves documentation and error handling for the template. Specifying concepts for template arguments is a powerful design tool. Example # template<typename Iter, typename Val> // requires Input_iterator<Iter> // && Equality_comparable<Value_type<Iter>, Val> Iter find(Iter b, Iter e, Val v) { // ... } or equivalently and more succinctly: template<Input_iterator Iter, typename Val> // requires Equality_comparable<Value_type<Iter>, Val> Iter find(Iter b, Iter e, Val v) { // ... } Note # \u201cConcepts\u201d are defined in an ISO Technical Specification: concepts . A draft of a set of standard-library concepts can be found in another ISO TS: ranges Concepts are supported in GCC 6.1 and later. Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only. If you use GCC 6.1 or later, you can uncomment them: template<typename Iter, typename Val> requires Input_iterator<Iter> && Equality_comparable<Value_type<Iter>, Val> Iter find(Iter b, Iter e, Val v) { // ... } Note # Plain typename (or auto ) is the least constraining concept. It should be used only rarely when nothing more than \u201cit\u2019s a type\u201d can be assumed. This is typically only needed when (as part of template metaprogramming code) we manipulate pure expression trees, postponing type checking. References : TC++PL4, Palo Alto TR, Sutton Enforcement # Flag template type arguments without concepts T.11: Whenever possible use standard concepts # Reason # \u201cStandard\u201d concepts (as provided by the GSL and the Ranges TS , and hopefully soon the ISO standard itself) save us the work of thinking up our own concepts, are better thought out than we can manage to do in a hurry, and improve interoperability. Note # Unless you are creating a new generic library, most of the concepts you need will already be defined by the standard library. Example (using TS concepts) # template<typename T> // don't define this: Sortable is in the GSL concept Ordered_container = Sequence<T> && Random_access<Iterator<T>> && Ordered<Value_type<T>>; void sort(Ordered_container& s); This Ordered_container is quite plausible, but it is very similar to the Sortable concept in the GSL (and the Range TS). Is it better? Is it right? Does it accurately reflect the standard\u2019s requirements for sort ? It is better and simpler just to use Sortable : void sort(Sortable& s); // better Note # The set of \u201cstandard\u201d concepts is evolving as we approach an ISO standard including concepts. Note # Designing a useful concept is challenging. Enforcement # Hard. Look for unconstrained arguments, templates that use \u201cunusual\u201d/non-standard concepts, templates that use \u201chomebrew\u201d concepts without axioms. Develop a concept-discovery tool (e.g., see an early experiment ). T.12: Prefer concept names over auto for local variables # Reason # auto is the weakest concept. Concept names convey more meaning than just auto . Example (using TS concepts) # vector<string> v{ \"abc\", \"xyz\" }; auto& x = v.front(); // bad String& s = v.front(); // good (String is a GSL concept) Enforcement # ??? T.13: Prefer the shorthand notation for simple, single-type argument concepts # Reason # Readability. Direct expression of an idea. Example (using TS concepts) # To say \u201c T is Sortable \u201d: template<typename T> // Correct but verbose: \"The parameter is // requires Sortable<T> // of type T which is the name of a type void sort(T&); // that is Sortable\" template<Sortable T> // Better (assuming support for concepts): \"The parameter is of type T void sort(T&); // which is Sortable\" void sort(Sortable&); // Best (assuming support for concepts): \"The parameter is Sortable\" The shorter versions better match the way we speak. Note that many templates don\u2019t need to use the template keyword. Note # \u201cConcepts\u201d are defined in an ISO Technical Specification: concepts . A draft of a set of standard-library concepts can be found in another ISO TS: ranges Concepts are supported in GCC 6.1 and later. Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only. If you use a compiler that supports concepts (e.g., GCC 6.1 or later), you can remove the // . Enforcement # Not feasible in the short term when people convert from the <typename T> and <class T > notation. Later, flag declarations that first introduce a typename and then constrain it with a simple, single-type-argument concept. T.concepts.def: Concept definition rules # Defining good concepts is non-trivial. Concepts are meant to represent fundamental concepts in an application domain (hence the name \u201cconcepts\u201d). Similarly throwing together a set of syntactic constraints to be used for the arguments for a single class or algorithm is not what concepts were designed for and will not give the full benefits of the mechanism. Obviously, defining concepts will be most useful for code that can use an implementation (e.g., GCC 6.1 or later), but defining concepts is in itself a useful design technique and help catch conceptual errors and clean up the concepts (sic!) of an implementation. T.20: Avoid \u201cconcepts\u201d without meaningful semantics # Reason # Concepts are meant to express semantic notions, such as \u201ca number\u201d, \u201ca range\u201d of elements, and \u201ctotally ordered.\u201d Simple constraints, such as \u201chas a + operator\u201d and \u201chas a > operator\u201d cannot be meaningfully specified in isolation and should be used only as building blocks for meaningful concepts, rather than in user code. Example, bad (using TS concepts) # template<typename T> concept Addable = has_plus<T>; // bad; insufficient template<Addable N> auto algo(const N& a, const N& b) // use two numbers { // ... return a + b; } int x = 7; int y = 9; auto z = algo(x, y); // z = 16 string xx = \"7\"; string yy = \"9\"; auto zz = algo(xx, yy); // zz = \"79\" Maybe the concatenation was expected. More likely, it was an accident. Defining minus equivalently would give dramatically different sets of accepted types. This Addable violates the mathematical rule that addition is supposed to be commutative: a+b == b+a . Note # The ability to specify a meaningful semantics is a defining characteristic of a true concept, as opposed to a syntactic constraint. Example (using TS concepts) # template<typename T> // The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules concept Number = has_plus<T> && has_minus<T> && has_multiply<T> && has_divide<T>; template<Number N> auto algo(const N& a, const N& b) { // ... return a + b; } int x = 7; int y = 9; auto z = algo(x, y); // z = 16 string xx = \"7\"; string yy = \"9\"; auto zz = algo(xx, yy); // error: string is not a Number Note # Concepts with multiple operations have far lower chance of accidentally matching a type than a single-operation concept. Enforcement # Flag single-operation concepts when used outside the definition of other concepts . Flag uses of enable_if that appears to simulate single-operation concepts . T.21: Require a complete set of operations for a concept # Reason # Ease of comprehension. Improved interoperability. Helps implementers and maintainers. Note # This is a specific variant of the general rule that a concept must make semantic sense . Example, bad (using TS concepts) # template<typename T> concept Subtractable = requires(T a, T, b) { a-b; }; This makes no semantic sense. You need at least + to make - meaningful and useful. Examples of complete sets are Arithmetic : + , - , * , / , += , -= , *= , /= Comparable : < , > , <= , >= , == , != Note # This rule applies whether we use direct language support for concepts or not. It is a general design rule that even applies to non-templates: class Minimal { // ... }; bool operator==(const Minimal&, const Minimal&); bool operator<(const Minimal&, const Minimal&); Minimal operator+(const Minimal&, const Minimal&); // no other operators void f(const Minimal& x, const Minimal& y) { if (!(x == y)) { /* ... */ } // OK if (x != y) { /* ... */ } // surprise! error while (!(x < y)) { /* ... */ } // OK while (x >= y) { /* ... */ } // surprise! error x = x + y; // OK x += y; // surprise! error } This is minimal, but surprising and constraining for users. It could even be less efficient. The rule supports the view that a concept should reflect a (mathematically) coherent set of operations. Example # class Convenient { // ... }; bool operator==(const Convenient&, const Convenient&); bool operator<(const Convenient&, const Convenient&); // ... and the other comparison operators ... Minimal operator+(const Convenient&, const Convenient&); // .. and the other arithmetic operators ... void f(const Convenient& x, const Convenient& y) { if (!(x == y)) { /* ... */ } // OK if (x != y) { /* ... */ } // OK while (!(x < y)) { /* ... */ } // OK while (x >= y) { /* ... */ } // OK x = x + y; // OK x += y; // OK } It can be a nuisance to define all operators, but not hard. Ideally, that rule should be language supported by giving you comparison operators by default. Enforcement # Flag classes that support \u201codd\u201d subsets of a set of operators, e.g., == but not != or + but not - . Yes, std::string is \u201codd\u201d, but it\u2019s too late to change that. T.22: Specify axioms for concepts # Reason # A meaningful/useful concept has a semantic meaning. Expressing these semantics in an informal, semi-formal, or formal way makes the concept comprehensible to readers and the effort to express it can catch conceptual errors. Specifying semantics is a powerful design tool. Example (using TS concepts) # template<typename T> // The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules // axiom(T a, T b) { a + b == b + a; a - a == 0; a * (b + c) == a * b + a * c; /*...*/ } concept Number = requires(T a, T b) { {a + b} -> T; // the result of a + b is convertible to T {a - b} -> T; {a * b} -> T; {a / b} -> T; } Note # This is an axiom in the mathematical sense: something that may be assumed without proof. In general, axioms are not provable, and when they are the proof is often beyond the capability of a compiler. An axiom may not be general, but the template writer may assume that it holds for all inputs actually used (similar to a precondition). Note # In this context axioms are Boolean expressions. See the Palo Alto TR for examples. Currently, C++ does not support axioms (even the ISO Concepts TS), so we have to make do with comments for a longish while. Once language support is available, the // in front of the axiom can be removed Note # The GSL concepts have well-defined semantics; see the Palo Alto TR and the Ranges TS. Exception (using TS concepts) # Early versions of a new \u201cconcept\u201d still under development will often just define simple sets of constraints without a well-specified semantics. Finding good semantics can take effort and time. An incomplete set of constraints can still be very useful: // balancer for a generic binary tree template<typename Node> concept bool Balancer = requires(Node* p) { add_fixup(p); touch(p); detach(p); } So a Balancer must supply at least thee operations on a tree Node , but we are not yet ready to specify detailed semantics because a new kind of balanced tree might require more operations and the precise general semantics for all nodes is hard to pin down in the early stages of design. A \u201cconcept\u201d that is incomplete or without a well-specified semantics can still be useful. For example, it allows for some checking during initial experimentation. However, it should not be assumed to be stable. Each new use case may require such an incomplete concept to be improved. Enforcement # Look for the word \u201caxiom\u201d in concept definition comments T.23: Differentiate a refined concept from its more general case by adding new use patterns. # Reason # Otherwise they cannot be distinguished automatically by the compiler. Example (using TS concepts) # template<typename I> concept bool Input_iter = requires(I iter) { ++iter; }; template<typename I> concept bool Fwd_iter = Input_iter<I> && requires(I iter) { iter++; } The compiler can determine refinement based on the sets of required operations (here, suffix ++ ). This decreases the burden on implementers of these types since they do not need any special declarations to \u201chook into the concept\u201d. If two concepts have exactly the same requirements, they are logically equivalent (there is no refinement). Enforcement # Flag a concept that has exactly the same requirements as another already-seen concept (neither is more refined). To disambiguate them, see T.24 . T.24: Use tag classes or traits to differentiate concepts that differ only in semantics. # Reason # Two concepts requiring the same syntax but having different semantics leads to ambiguity unless the programmer differentiates them. Example (using TS concepts) # template<typename I> // iterator providing random access concept bool RA_iter = ...; template<typename I> // iterator providing random access to contiguous data concept bool Contiguous_iter = RA_iter<I> && is_contiguous<I>::value; // using is_contiguous trait The programmer (in a library) must define is_contiguous (a trait) appropriately. Wrapping a tag class into a concept leads to a simpler expression of this idea: template<typename I> concept Contiguous = is_contiguous<I>::value; template<typename I> concept bool Contiguous_iter = RA_iter<I> && Contiguous<I>; The programmer (in a library) must define is_contiguous (a trait) appropriately. Note # Traits can be trait classes or type traits. These can be user-defined or standard-library ones. Prefer the standard-library ones. Enforcement # The compiler flags ambiguous use of identical concepts. Flag the definition of identical concepts. T.25: Avoid complementary constraints # Reason # Clarity. Maintainability. Functions with complementary requirements expressed using negation are brittle. Example (using TS concepts) # Initially, people will try to define functions with complementary requirements: template<typename T> requires !C<T> // bad void f(); template<typename T> requires C<T> void f(); This is better: template<typename T> // general template void f(); template<typename T> // specialization by concept requires C<T> void f(); The compiler will choose the unconstrained template only when C<T> is unsatisfied. If you do not want to (or cannot) define an unconstrained version of f() , then delete it. template<typename T> void f() = delete; The compiler will select the overload and emit an appropriate error. Note # Complementary constraints are unfortunately common in enable_if code: template<typename T> enable_if<!--C<T-->, void> // bad f(); template<typename T> enable_if<C<T>, void> f(); Note # Complementary requirements on one requirements is sometimes (wrongly) considered manageable. However, for two or more requirements the number of definitions needs can go up exponentially (2,4,9,16,\u2026): C1<T> && C2<T> !C1<T> && C2<T> C1<T> && !C2<T> !C1<T> && !C2<T> Now the opportunities for errors multiply. Enforcement # Flag pairs of functions with C<T> and !C<T> constraints T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax # Reason # The definition is more readable and corresponds directly to what a user has to write. Conversions are taken into account. You don\u2019t have to remember the names of all the type traits. Example (using TS concepts) # You might be tempted to define a concept Equality like this: template<typename T> concept Equality = has_equal<T> && has_not_equal<T>; Obviously, it would be better and easier just to use the standard EqualityComparable , but - just as an example - if you had to define such a concept, prefer: template<typename T> concept Equality = requires(T a, T b) { bool == { a == b } bool == { a != b } // axiom { !(a == b) == (a != b) } // axiom { a = b; => a == b } // => means \"implies\" } as opposed to defining two meaningless concepts has_equal and has_not_equal just as helpers in the definition of Equality . By \u201cmeaningless\u201d we mean that we cannot specify the semantics of has_equal in isolation. Enforcement # ??? Template interfaces # Over the years, programming with templates have suffered from a weak distinction between the interface of a template and its implementation. Before concepts, that distinction had no direct language support. However, the interface to a template is a critical concept - a contract between a user and an implementer - and should be carefully designed. T.40: Use function objects to pass operations to algorithms # Reason # Function objects can carry more information through an interface than a \u201cplain\u201d pointer to function. In general, passing function objects gives better performance than passing pointers to functions. Example (using TS concepts) # bool greater(double x, double y) { return x > y; } sort(v, greater); // pointer to function: potentially slow sort(v, [](double x, double y) { return x > y; }); // function object sort(v, std::greater<>); // function object bool greater_than_7(double x) { return x > 7; } auto x = find_if(v, greater_than_7); // pointer to function: inflexible auto y = find_if(v, [](double x) { return x > 7; }); // function object: carries the needed data auto z = find_if(v, Greater_than<double>(7)); // function object: carries the needed data You can, of course, generalize those functions using auto or (when and where available) concepts. For example: auto y1 = find_if(v, [](Ordered x) { return x > 7; }); // require an ordered type auto z1 = find_if(v, [](auto x) { return x > 7; }); // hope that the type has a > Note # Lambdas generate function objects. Note # The performance argument depends on compiler and optimizer technology. Enforcement # Flag pointer to function template arguments. Flag pointers to functions passed as arguments to a template (risk of false positives). T.41: Require only essential properties in a template\u2019s concepts # Reason # Keep interfaces simple and stable. Example (using TS concepts) # Consider, a sort instrumented with (oversimplified) simple debug support: void sort(Sortable& s) // sort sequence s { if (debug) cerr << \"enter sort( \" << s << \")\\n\"; // ... if (debug) cerr << \"exit sort( \" << s << \")\\n\"; } Should this be rewritten to: template<Sortable S> requires Streamable<S> void sort(S& s) // sort sequence s { if (debug) cerr << \"enter sort( \" << s << \")\\n\"; // ... if (debug) cerr << \"exit sort( \" << s << \")\\n\"; } After all, there is nothing in Sortable that requires iostream support. On the other hand, there is nothing in the fundamental idea of sorting that says anything about debugging. Note # If we require every operation used to be listed among the requirements, the interface becomes unstable: Every time we change the debug facilities, the usage data gathering, testing support, error reporting, etc., the definition of the template would need change and every use of the template would have to be recompiled. This is cumbersome, and in some environments infeasible. Conversely, if we use an operation in the implementation that is not guaranteed by concept checking, we may get a late compile-time error. By not using concept checking for properties of a template argument that is not considered essential, we delay checking until instantiation time. We consider this a worthwhile tradeoff. Note that using non-local, non-dependent names (such as debug and cerr ) also introduces context dependencies that may lead to \u201cmysterious\u201d errors. Note # It can be hard to decide which properties of a type are essential and which are not. Enforcement # ??? T.42: Use template aliases to simplify notation and hide implementation details # Reason # Improved readability. Implementation hiding. Note that template aliases replace many uses of traits to compute a type. They can also be used to wrap a trait. Example # template<typename T, size_t N> class Matrix { // ... using Iterator = typename std::vector<T>::iterator; // ... }; This saves the user of Matrix from having to know that its elements are stored in a vector and also saves the user from repeatedly typing typename std::vector<T>:: . Example # template<typename T> void user(T& c) { // ... typename container_traits<T>::value_type x; // bad, verbose // ... } template<typename T> using Value_type = typename container_traits<T>::value_type; This saves the user of Value_type from having to know the technique used to implement value_type s. template<typename T> void user2(T& c) { // ... Value_type<T> x; // ... } Note # A simple, common use could be expressed: \u201cWrap traits!\u201d Enforcement # Flag use of typename as a disambiguator outside using declarations. ??? T.43: Prefer using over typedef for defining aliases # Reason # Improved readability: With using , the new name comes first rather than being embedded somewhere in a declaration. Generality: using can be used for template aliases, whereas typedef s can\u2019t easily be templates. Uniformity: using is syntactically similar to auto . Example # typedef int (*PFI)(int); // OK, but convoluted using PFI2 = int (*)(int); // OK, preferred template<typename T> typedef int (*PFT)(T); // error template<typename T> using PFT2 = int (*)(T); // OK Enforcement # Flag uses of typedef . This will give a lot of \u201chits\u201d :-( T.44: Use function templates to deduce class template argument types (where feasible) # Reason # Writing the template argument types explicitly can be tedious and unnecessarily verbose. Example # tuple<int, string, double> t1 = {1, \"Hamlet\", 3.14}; // explicit type auto t2 = make_tuple(1, \"Ophelia\"s, 3.14); // better; deduced type Note the use of the s suffix to ensure that the string is a std::string , rather than a C-style string. Note # Since you can trivially write a make_T function, so could the compiler. Thus, make_T functions may become redundant in the future. Exception # Sometimes there isn\u2019t a good way of getting the template arguments deduced and sometimes, you want to specify the arguments explicitly: vector<double> v = { 1, 2, 3, 7.9, 15.99 }; list<Record*> lst; Note # Note that C++17 will make this rule redundant by allowing the template arguments to be deduced directly from constructor arguments: Template parameter deduction for constructors (Rev. 3) . For example: tuple t1 = {1, \"Hamlet\"s, 3.14}; // deduced: tuple<int, string, double> Enforcement # Flag uses where an explicitly specialized type exactly matches the types of the arguments used. T.46: Require template arguments to be at least Regular or SemiRegular # Reason # Readability. Preventing surprises and errors. Most uses support that anyway. Example # class X { // ... public: explicit X(int); X(const X&); // copy X operator=(const X&); X(X&&) noexcept; // move X& operator=(X&&) noexcept; ~X(); // ... no more constructors ... }; X x {1}; // fine X y = x; // fine std::vector<X> v(10); // error: no default constructor Note # Semiregular requires default constructible. Enforcement # Flag types that are not at least SemiRegular . T.47: Avoid highly visible unconstrained templates with common names # Reason # An unconstrained template argument is a perfect match for anything so such a template can be preferred over more specific types that require minor conversions. This is particularly annoying/dangerous when ADL is used. Common names make this problem more likely. Example # namespace Bad { struct S { int m; }; template<typename T1, typename T2> bool operator==(T1, T2) { cout << \"Bad\\n\"; return true; } } namespace T0 { bool operator==(int, Bad::S) { cout << \"T0\\n\"; return true; } // compare to int void test() { Bad::S bad{ 1 }; vector<int> v(10); bool b = 1 == bad; bool b2 = v.size() == bad; } } This prints T0 and Bad . Now the == in Bad was designed to cause trouble, but would you have spotted the problem in real code? The problem is that v.size() returns an unsigned integer so that a conversion is needed to call the local == ; the == in Bad requires no conversions. Realistic types, such as the standard-library iterators can be made to exhibit similar anti-social tendencies. Note # If an unconstrained template is defined in the same namespace as a type, that unconstrained template can be found by ADL (as happened in the example). That is, it is highly visible. Note # This rule should not be necessary, but the committee cannot agree to exclude unconstrained templated from ADL. Unfortunately this will get many false positives; the standard library violates this widely, by putting many unconstrained templates and types into the single namespace std . Enforcement # Flag templates defined in a namespace where concrete types are also defined (maybe not feasible until we have concepts). T.48: If your compiler does not support concepts, fake them with enable_if # Reason # Because that\u2019s the best we can do without direct concept support. enable_if can be used to conditionally define functions and to select among a set of functions. Example # template <typename T> enable_if_t<is_integral_v<T>> f(T v) { // ... } // Equivalent to: template <Integral T> void f(T v) { // ... } Note # Beware of complementary constraints . Faking concept overloading using enable_if sometimes forces us to use that error-prone design technique. Enforcement # ??? T.49: Where possible, avoid type-erasure # Reason # Type erasure incurs an extra level of indirection by hiding type information behind a separate compilation boundary. Example # ??? Exceptions : Type erasure is sometimes appropriate, such as for std::function . Enforcement # ??? Note # T.def: Template definitions # A template definition (class or function) can contain arbitrary code, so only a comprehensive review of C++ programming techniques would cover this topic. However, this section focuses on what is specific to template implementation. In particular, it focuses on a template definition\u2019s dependence on its context. T.60: Minimize a template\u2019s context dependencies # Reason # Eases understanding. Minimizes errors from unexpected dependencies. Eases tool creation. Example # template<typename C> void sort(C& c) { std::sort(begin(c), end(c)); // necessary and useful dependency } template<typename Iter> Iter algo(Iter first, Iter last) { for (; first != last; ++first) { auto x = sqrt(*first); // potentially surprising dependency: which sqrt()? helper(first, x); // potentially surprising dependency: // helper is chosen based on first and x TT var = 7; // potentially surprising dependency: which TT? } } Note # Templates typically appear in header files so their context dependencies are more vulnerable to #include order dependencies than functions in .cpp files. Note # Having a template operate only on its arguments would be one way of reducing the number of dependencies to a minimum, but that would generally be unmanageable. For example, an algorithm usually uses other algorithms and invoke operations that does not exclusively operate on arguments. And don\u2019t get us started on macros! See also : T.69 Enforcement # Tricky T.61: Do not over-parameterize members (SCARY) # Reason # A member that does not depend on a template parameter cannot be used except for a specific template argument. This limits use and typically increases code size. Example, bad # template<typename T, typename A = std::allocator{}> // requires Regular<T> && Allocator<A> class List { public: struct Link { // does not depend on A T elem; T* pre; T* suc; }; using iterator = Link*; iterator first() const { return head; } // ... private: Link* head; }; List<int> lst1; List<int, My_allocator> lst2; This looks innocent enough, but now Link formally depends on the allocator (even though it doesn\u2019t use the allocator). This forces redundant instantiations that can be surprisingly costly in some real-world scenarios. Typically, the solution is to make what would have been a nested class non-local, with its own minimal set of template parameters. template<typename T> struct Link { T elem; T* pre; T* suc; }; template<typename T, typename A = std::allocator{}> // requires Regular<T> && Allocator<A> class List2 { public: using iterator = Link<T>*; iterator first() const { return head; } // ... private: Link* head; }; List<int> lst1; List<int, My_allocator> lst2; Some people found the idea that the Link no longer was hidden inside the list scary, so we named the technique SCARY . From that academic paper: \u201cThe acronym SCARY describes assignments and initializations that are Seemingly erroneous (appearing Constrained by conflicting generic parameters), but Actually work with the Right implementation (unconstrained bY the conflict due to minimized dependencies).\u201d Enforcement # Flag member types that do not depend on every template argument Flag member functions that do not depend on every template argument T.62: Place non-dependent class template members in a non-templated base class # Reason # Allow the base class members to be used without specifying template arguments and without template instantiation. Example # template<typename T> class Foo { public: enum { v1, v2 }; // ... }; ??? struct Foo_base { enum { v1, v2 }; // ... }; template<typename T> class Foo : public Foo_base { public: // ... }; Note # A more general version of this rule would be \u201cIf a template class member depends on only N template parameters out of M, place it in a base class with only N parameters.\u201d For N == 1, we have a choice of a base class of a class in the surrounding scope as in T.61 . ??? What about constants? class statics? Enforcement # Flag ??? T.64: Use specialization to provide alternative implementations of class templates # Reason # A template defines a general interface. Specialization offers a powerful mechanism for providing alternative implementations of that interface. Example # ??? string specialization (==) ??? representation specialization ? Note # ??? Enforcement # ??? T.65: Use tag dispatch to provide alternative implementations of a function # Reason # A template defines a general interface. Tag dispatch allows us to select implementations based on specific properties of an argument type. Performance. Example # This is a simplified version of std::copy (ignoring the possibility of non-contiguous sequences) struct pod_tag {}; struct non_pod_tag {}; template<class T> struct copy_trait { using tag = non_pod_tag; }; // T is not \"plain old data\" template<> struct copy_trait<int> { using tag = pod_tag; }; // int is \"plain old data\" template<class Iter> Out copy_helper(Iter first, Iter last, Iter out, pod_tag) { // use memmove } template<class Iter> Out copy_helper(Iter first, Iter last, Iter out, non_pod_tag) { // use loop calling copy constructors } template<class Itert> Out copy(Iter first, Iter last, Iter out) { return copy_helper(first, last, out, typename copy_trait<Iter>::tag{}) } void use(vector<int>& vi, vector<int>& vi2, vector<string>& vs, vector<string>& vs2) { copy(vi.begin(), vi.end(), vi2.begin()); // uses memmove copy(vs.begin(), vs.end(), vs2.begin()); // uses a loop calling copy constructors } This is a general and powerful technique for compile-time algorithm selection. Note # When concept s become widely available such alternatives can be distinguished directly: template<class Iter> requires Pod<Value_type<iter>> Out copy_helper(In, first, In last, Out out) { // use memmove } template<class Iter> Out copy_helper(In, first, In last, Out out) { // use loop calling copy constructors } Enforcement # ??? T.67: Use specialization to provide alternative implementations for irregular types # Reason # ??? Example # ??? Enforcement # ??? T.68: Use {} rather than () within templates to avoid ambiguities # Reason # () is vulnerable to grammar ambiguities. Example # template<typename T, typename U> void f(T t, U u) { T v1(x); // is v1 a function or a variable? T v2 {x}; // variable auto x = T(u); // construction or cast? } f(1, \"asdf\"); // bad: cast from const char* to int Enforcement # flag () initializers flag function-style casts T.69: Inside a template, don\u2019t make an unqualified nonmember function call unless you intend it to be a customization point # Reason # Provide only intended flexibility. Avoid vulnerability to accidental environmental changes. Example # There are three major ways to let calling code customize a template. template<class T> // Call a member function void test1(T t) { t.f(); // require T to provide f() } template<class T> void test2(T t) // Call a nonmember function without qualification { f(t); // require f(/*T*/) be available in caller's scope or in T's namespace } template<class T> void test3(T t) // Invoke a \"trait\" { test_traits<T>::f(t); // require customizing test_traits<> // to get non-default functions/types } A trait is usually a type alias to compute a type, a constexpr function to compute a value, or a traditional traits template to be specialized on the user\u2019s type. Note # If you intend to call your own helper function helper(t) with a value t that depends on a template type parameter, put it in a ::detail namespace and qualify the call as detail::helper(t); . An unqualified call becomes a customization point where any function helper in the namespace of t \u2018s type can be invoked; this can cause problems like unintentionally invoking unconstrained function templates . Enforcement # In a template, flag an unqualified call to a nonmember function that passes a variable of dependent type when there is a nonmember function of the same name in the template\u2019s namespace. T.temp-hier: Template and hierarchy rules: # Templates are the backbone of C++\u2019s support for generic programming and class hierarchies the backbone of its support for object-oriented programming. The two language mechanisms can be used effectively in combination, but a few design pitfalls must be avoided. T.80: Do not naively templatize a class hierarchy # Reason # Templating a class hierarchy that has many functions, especially many virtual functions, can lead to code bloat. Example, bad # template<typename T> struct Container { // an interface virtual T* get(int i); virtual T* first(); virtual T* next(); virtual void sort(); }; template<typename T> class Vector : public Container<T> { public: // ... }; Vector<int> vi; Vector<string> vs; It is probably a dumb idea to define a sort as a member function of a container, but it is not unheard of and it makes a good example of what not to do. Given this, the compiler cannot know if vector<int>::sort() is called, so it must generate code for it. Similar for vector<string>::sort() . Unless those two functions are called that\u2019s code bloat. Imagine what this would do to a class hierarchy with dozens of member functions and dozens of derived classes with many instantiations. Note # In many cases you can provide a stable interface by not parameterizing a base; see \u201cstable base\u201d and OO and GP Enforcement # Flag virtual functions that depend on a template argument. ??? False positives T.81: Do not mix hierarchies and arrays # Reason # An array of derived classes can implicitly \u201cdecay\u201d to a pointer to a base class with potential disastrous results. Example # Assume that Apple and Pear are two kinds of Fruit s. void maul(Fruit* p) { *p = Pear{}; // put a Pear into *p p[1] = Pear{}; // put a Pear into p[1] } Apple aa [] = { an_apple, another_apple }; // aa contains Apples (obviously!) maul(aa); Apple& a0 = &aa[0]; // a Pear? Apple& a1 = &aa[1]; // a Pear? Probably, aa[0] will be a Pear (without the use of a cast!). If sizeof(Apple) != sizeof(Pear) the access to aa[1] will not be aligned to the proper start of an object in the array. We have a type violation and possibly (probably) a memory corruption. Never write such code. Note that maul() violates the a T* points to an individual object rule . Alternative : Use a proper (templatized) container: void maul2(Fruit* p) { *p = Pear{}; // put a Pear into *p } vector<Apple> va = { an_apple, another_apple }; // va contains Apples (obviously!) maul2(va); // error: cannot convert a vector<Apple> to a Fruit* maul2(&va[0]); // you asked for it Apple& a0 = &va[0]; // a Pear? Note that the assignment in maul2() violated the no-slicing rule . Enforcement # Detect this horror! T.82: Linearize a hierarchy when virtual functions are undesirable # Reason # ??? Example # ??? Enforcement # ??? T.83: Do not declare a member function template virtual # Reason # C++ does not support that. If it did, vtbls could not be generated until link time. And in general, implementations must deal with dynamic linking. Example, don\u2019t # class Shape { // ... template<class T> virtual bool intersect(T* p); // error: template cannot be virtual }; Note # We need a rule because people keep asking about this Alternative # Double dispatch, visitors, calculate which function to call Enforcement # The compiler handles that. T.84: Use a non-template core implementation to provide an ABI-stable interface # Reason # Improve stability of code. Avoid code bloat. Example # It could be a base class: struct Link_base { // stable Link_base* suc; Link_base* pre; }; template<typename T> // templated wrapper to add type safety struct Link : Link_base { T val; }; struct List_base { Link_base* first; // first element (if any) int sz; // number of elements void add_front(Link_base* p); // ... }; template<typename T> class List : List_base { public: void put_front(const T& e) { add_front(new Link<T>{e}); } // implicit cast to Link_base T& front() { static_cast<Link<T>*>(first).val; } // explicit cast back to Link<T> // ... }; List<int> li; List<string> ls; Now there is only one copy of the operations linking and unlinking elements of a List . The Link and List classes do nothing but type manipulation. Instead of using a separate \u201cbase\u201d type, another common technique is to specialize for void or void* and have the general template for T be just the safely-encapsulated casts to and from the core void implementation. Alternative : Use a Pimpl implementation. Enforcement # ??? T.var: Variadic template rules # ??? T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types # Reason # Variadic templates is the most general mechanism for that, and is both efficient and type-safe. Don\u2019t use C varargs. Example # ??? printf Enforcement # Flag uses of va_arg in user code. T.101: ??? How to pass arguments to a variadic template ??? # Reason # ??? Example # ??? beware of move-only and reference arguments Enforcement # ??? T.102: How to process arguments to a variadic template # Reason # ??? Example # ??? forwarding, type checking, references Enforcement # ??? T.103: Don\u2019t use variadic templates for homogeneous argument lists # Reason # There are more precise ways of specifying a homogeneous sequence, such as an initializer_list . Example # ??? Enforcement # ??? T.meta: Template metaprogramming (TMP) # Templates provide a general mechanism for compile-time programming. Metaprogramming is programming where at least one input or one result is a type. Templates offer Turing-complete (modulo memory capacity) duck typing at compile time. The syntax and techniques needed are pretty horrendous. T.120: Use template metaprogramming only when you really need to # Reason # Template metaprogramming is hard to get right, slows down compilation, and is often very hard to maintain. However, there are real-world examples where template metaprogramming provides better performance than any alternative short of expert-level assembly code. Also, there are real-world examples where template metaprogramming expresses the fundamental ideas better than run-time code. For example, if you really need AST manipulation at compile time (e.g., for optional matrix operation folding) there may be no other way in C++. Example, bad # ??? Example, bad # enable_if Instead, use concepts. But see How to emulate concepts if you don\u2019t have language support . Example # ??? good Alternative : If the result is a value, rather than a type, use a constexpr function . Note # If you feel the need to hide your template metaprogramming in macros, you have probably gone too far. T.121: Use template metaprogramming primarily to emulate concepts # Reason # Until concepts become generally available, we need to emulate them using TMP. Use cases that require concepts (e.g. overloading based on concepts) are among the most common (and simple) uses of TMP. Example # template<typename Iter> /*requires*/ enable_if<random_access_iterator<Iter>, void> advance(Iter p, int n) { p += n; } template<typename Iter> /*requires*/ enable_if<forward_iterator<Iter>, void> advance(Iter p, int n) { assert(n >= 0); while (n--) ++p;} Note # Such code is much simpler using concepts: void advance(RandomAccessIterator p, int n) { p += n; } void advance(ForwardIterator p, int n) { assert(n >= 0); while (n--) ++p;} Enforcement # ??? T.122: Use templates (usually template aliases) to compute types at compile time # Reason # Template metaprogramming is the only directly supported and half-way principled way of generating types at compile time. Note # \u201cTraits\u201d techniques are mostly replaced by template aliases to compute types and constexpr functions to compute values. Example # ??? big object / small object optimization Enforcement # ??? T.123: Use constexpr functions to compute values at compile time # Reason # A function is the most obvious and conventional way of expressing the computation of a value. Often a constexpr function implies less compile-time overhead than alternatives. Note # \u201cTraits\u201d techniques are mostly replaced by template aliases to compute types and constexpr functions to compute values. Example # template<typename T> // requires Number<T> constexpr T pow(T v, int n) // power/exponential { T res = 1; while (n--) res *= v; return res; } constexpr auto f7 = pow(pi, 7); Enforcement # Flag template metaprograms yielding a value. These should be replaced with constexpr functions. T.124: Prefer to use standard-library TMP facilities # Reason # Facilities defined in the standard, such as conditional , enable_if , and tuple , are portable and can be assumed to be known. Example # ??? Enforcement # ??? T.125: If you need to go beyond the standard-library TMP facilities, use an existing library # Reason # Getting advanced TMP facilities is not easy and using a library makes you part of a (hopefully supportive) community. Write your own \u201cadvanced TMP support\u201d only if you really have to. Example # ??? Enforcement # ??? Other template rules # T.140: Name all operations with potential for reuse # Reason # Documentation, readability, opportunity for reuse. Example # struct Rec { string name; string addr; int id; // unique identifier }; bool same(const Rec& a, const Rec& b) { return a.id == b.id; } vector<Rec*> find_id(const string& name); // find all records for \"name\" auto x = find_if(vr.begin(), vr.end(), [&](Rec& r) { if (r.name.size() != n.size()) return false; // name to compare to is in n for (int i = 0; i < r.name.size(); ++i) if (tolower(r.name[i]) != tolower(n[i])) return false; return true; } ); There is a useful function lurking here (case insensitive string comparison), as there often is when lambda arguments get large. bool compare_insensitive(const string& a, const string& b) { if (a.size() != b.size()) return false; for (int i = 0; i < a.size(); ++i) if (tolower(a[i]) != tolower(b[i])) return false; return true; } auto x = find_if(vr.begin(), vr.end(), [&](Rec& r) { compare_insensitive(r.name, n); } ); Or maybe (if you prefer to avoid the implicit name binding to n): auto cmp_to_n = [&n](const string& a) { return compare_insensitive(a, n); }; auto x = find_if(vr.begin(), vr.end(), [](const Rec& r) { return cmp_to_n(r.name); } ); Note # whether functions, lambdas, or operators. Exception # Lambdas logically used only locally, such as an argument to for_each and similar control flow algorithms. Lambdas as initializers Enforcement # (hard) flag similar lambdas ??? T.141: Use an unnamed lambda if you need a simple function object in one place only # Reason # That makes the code concise and gives better locality than alternatives. Example # auto earlyUsersEnd = std::remove_if(users.begin(), users.end(), [](const User &a) { return a.id > 100; }); Exception # Naming a lambda can be useful for clarity even if it is used only once. Enforcement # Look for identical and near identical lambdas (to be replaced with named functions or named lambdas). T.142?: Use template variables to simplify notation # Reason # Improved readability. Example # ??? Enforcement # ??? T.143: Don\u2019t write unintentionally nongeneric code # Reason # Generality. Reusability. Don\u2019t gratuitously commit to details; use the most general facilities available. Example # Use != instead of < to compare iterators; != works for more objects because it doesn\u2019t rely on ordering. for (auto i = first; i < last; ++i) { // less generic // ... } for (auto i = first; i != last; ++i) { // good; more generic // ... } Of course, range- for is better still where it does what you want. Example # Use the least-derived class that has the functionality you need. class Base { public: Bar f(); Bar g(); }; class Derived1 : public Base { public: Bar h(); }; class Derived2 : public Base { public: Bar j(); }; // bad, unless there is a specific reason for limiting to Derived1 objects only void my_func(Derived1& param) { use(param.f()); use(param.g()); } // good, uses only Base interface so only commit to that void my_func(Base& param) { use(param.f()); use(param.g()); } Enforcement # Flag comparison of iterators using < instead of != . Flag x.size() == 0 when x.empty() or x.is_empty() is available. Emptiness works for more containers than size(), because some containers don\u2019t know their size or are conceptually of unbounded size. Flag functions that take a pointer or reference to a more-derived type but only use functions declared in a base type. T.144: Don\u2019t specialize function templates # Reason # You can\u2019t partially specialize a function template per language rules. You can fully specialize a function template but you almost certainly want to overload instead \u2013 because function template specializations don\u2019t participate in overloading, they don\u2019t act as you probably wanted. Rarely, you should actually specialize by delegating to a class template that you can specialize properly. Example # ??? Exceptions : If you do have a valid reason to specialize a function template, just write a single function template that delegates to a class template, then specialize the class template (including the ability to write partial specializations). Enforcement # Flag all specializations of a function template. Overload instead. T.150: Check that a class matches a concept using static_assert # Reason # If you intend for a class to match a concept, verifying that early saves users pain. Example # class X { public: X() = delete; X(const X&) = default; X(X&&) = default; X& operator=(const X&) = default; // ... }; Somewhere, possibly in an implementation file, let the compiler check the desired properties of X : static_assert(Default_constructible<X>); // error: X has no default constructor static_assert(Copyable<X>); // error: we forgot to define X's move constructor Enforcement # Not feasible. CPL: C-style programming # C and C++ are closely related languages. They both originate in \u201cClassic C\u201d from 1978 and have evolved in ISO committees since then. Many attempts have been made to keep them compatible, but neither is a subset of the other. C rule summary: CPL.1: Prefer C++ to C CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++ CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces CPL.1: Prefer C++ to C # Reason # C++ provides better type checking and more notational support. It provides better support for high-level programming and often generates faster code. Example # char ch = 7; void* pv = &ch; int* pi = pv; // not C++ *pi = 999; // overwrite sizeof(int) bytes near &ch The rules for implicit casting to and from void* in C are subtle and unenforced. In particular, this example violates a rule against converting to a type with stricter alignment. Enforcement # Use a C++ compiler. CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++ # Reason # That subset can be compiled with both C and C++ compilers, and when compiled as C++ is better type checked than \u201cpure C.\u201d Example # int* p1 = malloc(10 * sizeof(int)); // not C++ int* p2 = static_cast<int*>(malloc(10 * sizeof(int))); // not C, C-style C++ int* p3 = new int[10]; // not C int* p4 = (int*) malloc(10 * sizeof(int)); // both C and C++ Enforcement # Flag if using a build mode that compiles code as C. The C++ compiler will enforce that the code is valid C++ unless you use C extension options. CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces # Reason # C++ is more expressive than C and offers better support for many types of programming. Example # For example, to use a 3 rd party C library or C systems interface, define the low-level interface in the common subset of C and C++ for better type checking. Whenever possible encapsulate the low-level interface in an interface that follows the C++ guidelines (for better abstraction, memory safety, and resource safety) and use that C++ interface in C++ code. Example # You can call C from C++: // in C: double sqrt(double); // in C++: extern \"C\" double sqrt(double); sqrt(2); Example # You can call C++ from C: // in C: X call_f(struct Y*, int); // in C++: extern \"C\" X call_f(Y* p, int i) { return p->f(i); // possibly a virtual function call } Enforcement # None needed SF: Source files # Distinguish between declarations (used as interfaces) and definitions (used as implementations). Use header files to represent interfaces and to emphasize logical structure. Source file rule summary: SF.1: Use a .cpp suffix for code files and .h for interface files if your project doesn\u2019t already follow another convention SF.2: A .h file may not contain object definitions or non-inline function definitions SF.3: Use .h files for all declarations used in multiple source files SF.4: Include .h files before other declarations in a file SF.5: A .cpp file must include the .h file(s) that defines its interface SF.6: Use using namespace directives for transition, for foundation libraries (such as std ), or within a local scope (only) SF.7: Don\u2019t write using namespace at global scope in a header file SF.8: Use #include guards for all .h files SF.9: Avoid cyclic dependencies among source files SF.10: Avoid dependencies on implicitly #include d names SF.11: Header files should be self-contained SF.20: Use namespace s to express logical structure SF.21: Don\u2019t use an unnamed (anonymous) namespace in a header SF.22: Use an unnamed (anonymous) namespace for all internal/nonexported entities SF.1: Use a .cpp suffix for code files and .h for interface files if your project doesn\u2019t already follow another convention # Reason # It\u2019s a longstanding convention. But consistency is more important, so if your project uses something else, follow that. Note # This convention reflects a common use pattern: Headers are more often shared with C to compile as both C++ and C, which typically uses .h , and it\u2019s easier to name all headers .h instead of having different extensions for just those headers that are intended to be shared with C. On the other hand, implementation files are rarely shared with C and so should typically be distinguished from .c files, so it\u2019s normally best to name all C++ implementation files something else (such as .cpp ). The specific names .h and .cpp are not required (just recommended as a default) and other names are in widespread use. Examples are .hh , .C , and .cxx . Use such names equivalently. In this document, we refer to .h and .cpp as a shorthand for header and implementation files, even though the actual extension may be different. Your IDE (if you use one) may have strong opinions about suffixes. Example # // foo.h: extern int a; // a declaration extern void foo(); // foo.cpp: int a; // a definition void foo() { ++a; } foo.h provides the interface to foo.cpp . Global variables are best avoided. Example, bad # // foo.h: int a; // a definition void foo() { ++a; } #include <foo.h> twice in a program and you get a linker error for two one-definition-rule violations. Enforcement # Flag non-conventional file names. Check that .h and .cpp (and equivalents) follow the rules below. SF.2: A .h file may not contain object definitions or non-inline function definitions # Reason # Including entities subject to the one-definition rule leads to linkage errors. Example # // file.h: namespace Foo { int x = 7; int xx() { return x+x; } } // file1.cpp: #include <file.h> // ... more ... // file2.cpp: #include <file.h> // ... more ... Linking file1.cpp and file2.cpp will give two linker errors. Alternative formulation : A .h file must contain only: #include s of other .h files (possibly with include guards) templates class definitions function declarations extern declarations inline function definitions constexpr definitions const definitions using alias definitions ??? Enforcement # Check the positive list above. SF.3: Use .h files for all declarations used in multiple source files # Reason # Maintainability. Readability. Example, bad # // bar.cpp: void bar() { cout << \"bar\\n\"; } // foo.cpp: extern void bar(); void foo() { bar(); } A maintainer of bar cannot find all declarations of bar if its type needs changing. The user of bar cannot know if the interface used is complete and correct. At best, error messages come (late) from the linker. Enforcement # Flag declarations of entities in other source files not placed in a .h . SF.4: Include .h files before other declarations in a file # Reason # Minimize context dependencies and increase readability. Example # #include <vector> #include <algorithm> #include <string> // ... my code here ... Example, bad # #include <vector> // ... my code here ... #include <algorithm> #include <string> Note # This applies to both .h and .cpp files. Note # There is an argument for insulating code from declarations and macros in header files by #including headers after the code we want to protect (as in the example labeled \u201cbad\u201d). However that only works for one file (at one level): Use that technique in a header included with other headers and the vulnerability reappears. a namespace (an \u201cimplementation namespace\u201d) can protect against many context dependencies. full protection and flexibility require modules. See also : Working Draft, Extensions to C++ for Modules Modules, Componentization, and Transition Enforcement # Easy. SF.5: A .cpp file must include the .h file(s) that defines its interface # Reason # This enables the compiler to do an early consistency check. Example, bad # // foo.h: void foo(int); int bar(long); int foobar(int); // foo.cpp: void foo(int) { /* ... */ } int bar(double) { /* ... */ } double foobar(int); The errors will not be caught until link time for a program calling bar or foobar . Example # // foo.h: void foo(int); int bar(long); int foobar(int); // foo.cpp: #include <foo.h> void foo(int) { /* ... */ } int bar(double) { /* ... */ } double foobar(int); // error: wrong return type The return-type error for foobar is now caught immediately when foo.cpp is compiled. The argument-type error for bar cannot be caught until link time because of the possibility of overloading, but systematic use of .h files increases the likelihood that it is caught earlier by the programmer. Enforcement # ??? SF.6: Use using namespace directives for transition, for foundation libraries (such as std ), or within a local scope (only) # Reason # using namespace can lead to name clashes, so it should be used sparingly. However, it is not always possible to qualify every name from a namespace in user code (e.g., during transition) and sometimes a namespace is so fundamental and prevalent in a code base, that consistent qualification would be verbose and distracting. Example # #include <string> #include <vector> #include <iostream> #include <memory> #include <algorithm> using namespace std; // ... Here (obviously), the standard library is used pervasively and apparently no other library is used, so requiring std:: everywhere could be distracting. Example # The use of using namespace std; leaves the programmer open to a name clash with a name from the standard library #include <cmath> using namespace std; int g(int x) { int sqrt = 7; // ... return sqrt(x); // error } However, this is not particularly likely to lead to a resolution that is not an error and people who use using namespace std are supposed to know about std and about this risk. Note # A .cpp file is a form of local scope. There is little difference in the opportunities for name clashes in an N-line .cpp containing a using namespace X , an N-line function containing a using namespace X , and M functions each containing a using namespace X with N lines of code in total. Note # Don\u2019t write using namespace in a header file . Enforcement # Flag multiple using namespace directives for different namespaces in a single source file. SF.7: Don\u2019t write using namespace at global scope in a header file # Reason # Doing so takes away an #include r\u2019s ability to effectively disambiguate and to use alternatives. It also makes #include d headers order-dependent as they may have different meaning when included in different orders. Example # // bad.h #include <iostream> using namespace std; // bad // user.cpp #include \"bad.h\" bool copy(/*... some parameters ...*/); // some function that happens to be named copy int main() { copy(/*...*/); // now overloads local ::copy and std::copy, could be ambiguous } Note # An exception is using namespace std::literals; . This is necessary to use string literals in header files and given the rules - users are required to name their own UDLs operator\"\"_x - they will not collide with the standard library. Enforcement # Flag using namespace at global scope in a header file. SF.8: Use #include guards for all .h files # Reason # To avoid files being #include d several times. In order to avoid include guard collisions, do not just name the guard after the filename. Be sure to also include a key and good differentiator, such as the name of library or component the header file is part of. Example # // file foobar.h: #ifndef LIBRARY_FOOBAR_H #define LIBRARY_FOOBAR_H // ... declarations ... #endif // LIBRARY_FOOBAR_H Enforcement # Flag .h files without #include guards. Note # Some implementations offer vendor extensions like #pragma once as alternative to include guards. It is not standard and it is not portable. It injects the hosting machine\u2019s filesystem semantics into your program, in addition to locking you down to a vendor. Our recommendation is to write in ISO C++: See rule P.2 . SF.9: Avoid cyclic dependencies among source files # Reason # Cycles complicates comprehension and slows down compilation. Complicates conversion to use language-supported modules (when they become available). Note # Eliminate cycles; don\u2019t just break them with #include guards. Example, bad # // file1.h: #include \"file2.h\" // file2.h: #include \"file3.h\" // file3.h: #include \"file1.h\" Enforcement # Flag all cycles. SF.10: Avoid dependencies on implicitly #include d names # Reason # Avoid surprises. Avoid having to change #include s if an #include d header changes. Avoid accidentally becoming dependent on implementation details and logically separate entities included in a header. Example # #include <iostream> using namespace std; void use() // bad { string s; cin >> s; // fine getline(cin, s); // error: getline() not defined if (s == \"surprise\") { // error == not defined // ... } } <iostream> exposes the definition of std::string (\u201cwhy?\u201d makes for a fun trivia question), but it is not required to do so by transitively including the entire <string> header, resulting in the popular beginner question \u201cwhy doesn\u2019t getline(cin,s); work?\u201d or even an occasional \u201c string s cannot be compared with == ). The solution is to explicitly #include <string> : #include <iostream> #include <string> using namespace std; void use() { string s; cin >> s; // fine getline(cin, s); // fine if (s == \"surprise\") { // fine // ... } } Note # Some headers exist exactly to collect a set of consistent declarations from a variety of headers. For example: // basic_std_lib.h: #include <string> #include <map> #include <iostream> #include <random> #include <vector> a user can now get that set of declarations with a single #include \u201c #include \"basic_std_lib.h\" This rule against implicit inclusion is not meant to prevent such deliberate aggregation. Enforcement # Enforcement would require some knowledge about what in a header is meant to be \u201cexported\u201d to users and what is there to enable implementation. No really good solution is possible until we have modules. SF.11: Header files should be self-contained # Reason # Usability, headers should be simple to use and work when included on their own. Headers should encapsulate the functionality they provide. Avoid clients of a header having to manage that header\u2019s dependencies. Example # #include \"helpers.h\" // helpers.h depends on std::string and includes <string> Note # Failing to follow this results in difficult to diagnose errors for clients of a header. Note # A header should include all its dependencies. Be careful about using relative paths because C++ implementations diverge on their meaning. Enforcement # A test should verify that the header file itself compiles or that a cpp file which only includes the header file compiles. SF.20: Use namespace s to express logical structure # Reason # ??? Example # ??? Enforcement # ??? SF.21: Don\u2019t use an unnamed (anonymous) namespace in a header # Reason # It is almost always a bug to mention an unnamed namespace in a header file. Example # ??? Enforcement # Flag any use of an anonymous namespace in a header file. SF.22: Use an unnamed (anonymous) namespace for all internal/nonexported entities # Reason # Nothing external can depend on an entity in a nested unnamed namespace. Consider putting every definition in an implementation source file in an unnamed namespace unless that is defining an \u201cexternal/exported\u201d entity. Example # An API class and its members can\u2019t live in an unnamed namespace; but any \u201chelper\u201d class or function that is defined in an implementation source file should be at an unnamed namespace scope. ??? Enforcement # ??? SL: The Standard Library # Using only the bare language, every task is tedious (in any language). Using a suitable library any task can be reasonably simple. The standard library has steadily grown over the years. Its description in the standard is now larger than that of the language features. So, it is likely that this library section of the guidelines will eventually grow in size to equal or exceed all the rest. << ??? We need another level of rule numbering ??? >> C++ Standard Library component summary: SL.con: Containers SL.str: String SL.io: Iostream SL.regex: Regex SL.chrono: Time SL.C: The C Standard Library Standard-library rule summary: SL.1: Use libraries wherever possible SL.2: Prefer the standard library to other libraries SL.3: Do not add non-standard entities to namespace std SL.4: Use the standard library in a type-safe manner ??? SL.1: Use libraries wherever possible # Reason # Save time. Don\u2019t re-invent the wheel. Don\u2019t replicate the work of others. Benefit from other people\u2019s work when they make improvements. Help other people when you make improvements. SL.2: Prefer the standard library to other libraries # Reason # More people know the standard library. It is more likely to be stable, well-maintained, and widely available than your own code or most other libraries. SL.3: Do not add non-standard entities to namespace std # Reason # Adding to std may change the meaning of otherwise standards conforming code. Additions to std may clash with future versions of the standard. Example # ??? Enforcement # Possible, but messy and likely to cause problems with platforms. SL.4: Use the standard library in a type-safe manner # Reason # Because, obviously, breaking this rule can lead to undefined behavior, memory corruption, and all kinds of other bad errors. Note # This is a semi-philosophical meta-rule, which needs many supporting concrete rules. We need it as an umbrella for the more specific rules. Summary of more specific rules: SL.4: Use the standard library in a type-safe manner SL.con: Containers # ??? Container rule summary: SL.con.1: Prefer using STL array or vector instead of a C array SL.con.2: Prefer using STL vector by default unless you have a reason to use a different container SL.con.3: Avoid bounds errors ??? SL.con.1: Prefer using STL array or vector instead of a C array # Reason # C arrays are less safe, and have no advantages over array and vector . For a fixed-length array, use std::array , which does not degenerate to a pointer when passed to a function and does know its size. Also, like a built-in array, a stack-allocated std::array keeps its elements on the stack. For a variable-length array, use std::vector , which additionally can change its size and handles memory allocation. Example # int v[SIZE]; // BAD std::array<int, SIZE> w; // ok Example # int* v = new int[initial_size]; // BAD, owning raw pointer delete[] v; // BAD, manual delete std::vector<int> w(initial_size); // ok Note # Use gsl::span for non-owning references into a container. Note # Comparing the performance of a fixed-sized array allocated on the stack against a vector with its elements on the free store is bogus. You could just as well compare a std::array on the stack against the result of a malloc() accessed through a pointer. For most code, even the difference between stack allocation and free-store allocation doesn\u2019t matter, but the convenience and safety of vector does. People working with code for which that difference matters are quite capable of choosing between array and vector . Enforcement # Flag declaration of a C array inside a function or class that also declares an STL container (to avoid excessive noisy warnings on legacy non-STL code). To fix: At least change the C array to a std::array . SL.con.2: Prefer using STL vector by default unless you have a reason to use a different container # Reason # vector and array are the only standard containers that offer the following advantages: the fastest general-purpose access (random access, including being vectorization-friendly); the fastest default access pattern (begin-to-end or end-to-begin is prefetcher-friendly); the lowest space overhead (contiguous layout has zero per-element overhead, which is cache-friendly). Usually you need to add and remove elements from the container, so use vector by default; if you don\u2019t need to modify the container\u2019s size, use array . Even when other containers seem more suited, such as map for O(log N) lookup performance or a list for efficient insertion in the middle, a vector will usually still perform better for containers up to a few KB in size. Note # string should not be used as a container of individual characters. A string is a textual string; if you want a container of characters, use vector<!--*char_type*/--> or array<!--*char_type*/--> instead. Exceptions # If you have a good reason to use another container, use that instead. For example: If vector suits your needs but you don\u2019t need the container to be variable size, use array instead. If you want a dictionary-style lookup container that guarantees O(K) or O(log N) lookups, the container will be larger (more than a few KB) and you perform frequent inserts so that the overhead of maintaining a sorted vector is infeasible, go ahead and use an unordered_map or map instead. Note # To initialize a vector with a number of elements, use () -initialization. To initialize a vector with a list of elements, use {} -initialization. vector<int> v1(20); // v1 has 20 elements with the value 0 (vector<int>{}) vector<int> v2 {20}; // v2 has 1 element with the value 20 Prefer the {}-initializer syntax . Enforcement # Flag a vector whose size never changes after construction (such as because it\u2019s const or because no non- const functions are called on it). To fix: Use an array instead. SL.con.3: Avoid bounds errors # Reason # Read or write beyond an allocated range of elements typically leads to bad errors, wrong results, crashes, and security violations. Note # The standard-library functions that apply to ranges of elements all have (or could have) bounds-safe overloads that take span . Standard types such as vector can be modified to perform bounds-checks under the bounds profile (in a compatible way, such as by adding contracts), or used with at() . Ideally, the in-bounds guarantee should be statically enforced. For example: a range- for cannot loop beyond the range of the container to which it is applied a v.begin(),v.end() is easily determined to be bounds safe Such loops are as fast as any unchecked/unsafe equivalent. Often a simple pre-check can eliminate the need for checking of individual indices. For example for v.begin(),v.begin()+i the i can easily be checked against v.size() Such loops can be much faster than individually checked element accesses. Example, bad # void f() { array<int, 10> a, b; memset(a.data(), 0, 10); // BAD, and contains a length error (length = 10 * sizeof(int)) memcmp(a.data(), b.data(), 10); // BAD, and contains a length error (length = 10 * sizeof(int)) } Also, std::array<>::fill() or std::fill() or even an empty initializer are better candidate than memset() . Example, good # void f() { array<int, 10> a, b, c{}; // c is initialized to zero a.fill(0); fill(b.begin(), b.end(), 0); // std::fill() fill(b, 0); // std::fill() + Ranges TS if ( a == b ) { // ... } } Example # If code is using an unmodified standard library, then there are still workarounds that enable use of std::array and std::vector in a bounds-safe manner. Code can call the .at() member function on each class, which will result in an std::out_of_range exception being thrown. Alternatively, code can call the at() free function, which will result in fail-fast (or a customized action) on a bounds violation. void f(std::vector<int>& v, std::array<int, 12> a, int i) { v[0] = a[0]; // BAD v.at(0) = a[0]; // OK (alternative 1) at(v, 0) = a[0]; // OK (alternative 2) v.at(0) = a[i]; // BAD v.at(0) = a.at(i); // OK (alternative 1) v.at(0) = at(a, i); // OK (alternative 2) } Enforcement # Insert This rule is part of the bounds profile . TODO Notes : Impact on the standard library will require close coordination with WG21, if only to ensure compatibility even if never standardized. We are considering specifying bounds-safe overloads for stdlib (especially C stdlib) functions like memcmp and shipping them in the GSL. For existing stdlib functions and types like vector that are not fully bounds-checked, the goal is for these features to be bounds-checked when called from code with the bounds profile on, and unchecked when called from legacy code, possibly using contracts (concurrently being proposed by several WG21 members). SL.str: String # Text manipulation is a huge topic. std::string doesn\u2019t cover all of it. This section primarily tries to clarify std::string \u2018s relation to char* , zstring , string_view , and gsl::string_span . The important issue of non-ASCII character sets and encodings (e.g., wchar_t , Unicode, and UTF-8) will be covered elsewhere. See also : regular expressions Here, we use \u201csequence of characters\u201d or \u201cstring\u201d to refer to a sequence of characters meant to be read as text (somehow, eventually). We don\u2019t consider ??? String summary: SL.str.1: Use std::string to own character sequences SL.str.2: Use std::string_view or gsl::string_span to refer to character sequences SL.str.3: Use zstring or czstring to refer to a C-style, zero-terminated, sequence of characters SL.str.4: Use char* to refer to a single character SL.str.5: Use std::byte to refer to byte values that do not necessarily represent characters SL.str.10: Use std::string when you need to perform locale-sensitive string operations SL.str.11: Use gsl::string_span rather than std::string_view when you need to mutate a string SL.str.12: Use the s suffix for string literals meant to be standard-library string s See also : F.24 span F.25 zstring SL.str.1: Use std::string to own character sequences # Reason # string correctly handles allocation, ownership, copying, gradual expansion, and offers a variety of useful operations. Example # vector<string> read_until(const string& terminator) { vector<string> res; for (string s; cin >> s && s != terminator; ) // read a word res.push_back(s); return res; } Note how >> and != are provided for string (as examples of useful operations) and there are no explicit allocations, deallocations, or range checks ( string takes care of those). In C++17, we might use string_view as the argument, rather than const string* to allow more flexibility to callers: vector<string> read_until(string_view terminator) // C++17 { vector<string> res; for (string s; cin >> s && s != terminator; ) // read a word res.push_back(s); return res; } The gsl::string_span is a current alternative offering most of the benefits of std::string_view for simple examples: vector<string> read_until(string_span terminator) { vector<string> res; for (string s; cin >> s && s != terminator; ) // read a word res.push_back(s); return res; } Example, bad # Don\u2019t use C-style strings for operations that require non-trivial memory management char* cat(const char* s1, const char* s2) // beware! // return s1 + '.' + s2 { int l1 = strlen(s1); int l2 = strlen(s2); char* p = (char*) malloc(l1 + l2 + 2); strcpy(p, s1, l1); p[l1] = '.'; strcpy(p + l1 + 1, s2, l2); p[l1 + l2 + 1] = 0; return p; } Did we get that right? Will the caller remember to free() the returned pointer? Will this code pass a security review? Note # Do not assume that string is slower than lower-level techniques without measurement and remember that not all code is performance critical. Don\u2019t optimize prematurely Enforcement # ??? SL.str.2: Use std::string_view or gsl::string_span to refer to character sequences # Reason # std::string_view or gsl::string_span provides simple and (potentially) safe access to character sequences independently of how those sequences are allocated and stored. Example # vector<string> read_until(string_span terminator); void user(zstring p, const string& s, string_span ss) { auto v1 = read_until(p); auto v2 = read_until(s); auto v3 = read_until(ss); // ... } Note # std::string_view (C++17) is read-only. Enforcement # ??? SL.str.3: Use zstring or czstring to refer to a C-style, zero-terminated, sequence of characters # Reason # Readability. Statement of intent. A plain char* can be a pointer to a single character, a pointer to an array of characters, a pointer to a C-style (zero-terminated) string, or even to a small integer. Distinguishing these alternatives prevents misunderstandings and bugs. Example # void f1(const char* s); // s is probably a string All we know is that it is supposed to be the nullptr or point to at least one character void f1(zstring s); // s is a C-style string or the nullptr void f1(czstring s); // s is a C-style string constant or the nullptr void f1(std::byte* s); // s is a pointer to a byte (C++17) Note # Don\u2019t convert a C-style string to string unless there is a reason to. Note # Like any other \u201cplain pointer\u201d, a zstring should not represent ownership. Note # There are billions of lines of C++ \u201cout there\u201d, most use char* and const char* without documenting intent. They are used in a wide variety of ways, including to represent ownership and as generic pointers to memory (instead of void* ). It is hard to separate these uses, so this guideline is hard to follow. This is one of the major sources of bugs in C and C++ programs, so it is worthwhile to follow this guideline wherever feasible.. Enforcement # Flag uses of [] on a char* Flag uses of delete on a char* Flag uses of free() on a char* SL.str.4: Use char* to refer to a single character # Reason # The variety of uses of char* in current code is a major source of errors. Example, bad # char arr[] = {'a', 'b', 'c'}; void print(const char* p) { cout << p << '\\n'; } void use() { print(arr); // run-time error; potentially very bad } The array arr is not a C-style string because it is not zero-terminated. Alternative # See zstring , string , and string_span . Enforcement # Flag uses of [] on a char* SL.str.5: Use std::byte to refer to byte values that do not necessarily represent characters # Reason # Use of char* to represent a pointer to something that is not necessarily a character causes confusion and disables valuable optimizations. Example # ??? Note # C++17 Enforcement # ??? SL.str.10: Use std::string when you need to perform locale-sensitive string operations # Reason # std::string supports standard-library locale facilities Example # ??? Note # ??? Enforcement # ??? SL.str.11: Use gsl::string_span rather than std::string_view when you need to mutate a string # Reason # std::string_view is read-only. Example # ??? Note # ??? Enforcement # The compiler will flag attempts to write to a string_view . SL.str.12: Use the s suffix for string literals meant to be standard-library string s # Reason # Direct expression of an idea minimizes mistakes. Example # auto pp1 = make_pair(\"Tokyo\", 9.00); // {C-style string,double} intended? pair<string, double> pp2 = {\"Tokyo\", 9.00}; // a bit verbose auto pp3 = make_pair(\"Tokyo\"s, 9.00); // {std::string,double} // C++14 pair pp4 = {\"Tokyo\"s, 9.00}; // {std::string,double} // C++17 Enforcement # ??? SL.io: Iostream # iostream s is a type safe, extensible, formatted and unformatted I/O library for streaming I/O. It supports multiple (and user extensible) buffering strategies and multiple locales. It can be used for conventional I/O, reading and writing to memory (string streams), and user-defines extensions, such as streaming across networks (asio: not yet standardized). Iostream rule summary: SL.io.1: Use character-level input only when you have to SL.io.2: When reading, always consider ill-formed input SL.io.3: Prefer iostreams for I/O SL.io.10: Unless you use printf -family functions call ios_base::sync_with_stdio(false) SL.io.50: Avoid endl ??? SL.io.1: Use character-level input only when you have to # Reason # Unless you genuinely just deal with individual characters, using character-level input leads to the user code performing potentially error-prone and potentially inefficient composition of tokens out of characters. Example # char c; char buf[128]; int i = 0; while (cin.get(c) && !isspace(c) && i < 128) buf[i++] = c; if (i == 128) { // ... handle too long string .... } Better (much simpler and probably faster): string s; s.reserve(128); cin >> s; and the reserve(128) is probably not worthwhile. Enforcement # ??? SL.io.2: When reading, always consider ill-formed input # Reason # Errors are typically best handled as soon as possible. If input isn\u2019t validated, every function must be written to cope with bad data (and that is not practical). Example # ??? Enforcement # ??? SL.io.3: Prefer iostream s for I/O # Reason # iostream s are safe, flexible, and extensible. Example # // write a complex number: complex<double> z{ 3, 4 }; cout << z << '\\n'; complex is a user-defined type and its I/O is defined without modifying the iostream library. Example # // read a file of complex numbers: for (complex<double> z; cin >> z; ) v.push_back(z); Exception # ??? performance ??? Discussion: iostream s vs. the printf() family # It is often (and often correctly) pointed out that the printf() family has two advantages compared to iostream s: flexibility of formatting and performance. This has to be weighed against iostream s advantages of extensibility to handle user-defined types, resilient against security violations, implicit memory management, and locale handling. If you need I/O performance, you can almost always do better than printf() . gets() , scanf() using %s , and printf() using %s are security hazards (vulnerable to buffer overflow and generally error-prone). In C11, they are replaced by gets_s() , scanf_s() , and printf_s() as safer alternatives, but they are still not type safe. Enforcement # Optionally flag <cstdio> and <stdio.h> . SL.io.10: Unless you use printf -family functions call ios_base::sync_with_stdio(false) # Reason # Synchronizing iostreams with printf-style I/O can be costly. cin and cout are by default synchronized with printf . Example # int main() { ios_base::sync_with_stdio(false); // ... use iostreams ... } Enforcement # ??? SL.io.50: Avoid endl # Reason # The endl manipulator is mostly equivalent to '\\n' and \"\\n\" ; as most commonly used it simply slows down output by doing redundant flush() s. This slowdown can be significant compared to printf -style output. Example # cout << \"Hello, World!\" << endl; // two output operations and a flush cout << \"Hello, World!\\n\"; // one output operation and no flush Note # For cin / cout (and equivalent) interaction, there is no reason to flush; that\u2019s done automatically. For writing to a file, there is rarely a need to flush . Note # Apart from the (occasionally important) issue of performance, the choice between '\\n' and endl is almost completely aesthetic. SL.regex: Regex # <regex> is the standard C++ regular expression library. It supports a variety of regular expression pattern conventions. SL.chrono: Time # <chrono> (defined in namespace std::chrono ) provides the notions of time_point and duration together with functions for outputting time in various units. It provides clocks for registering time_points . SL.C: The C Standard Library # ??? C Standard Library rule summary: S.C.1: Don\u2019t use setjmp/longjmp ??? ??? SL.C.1: Don\u2019t use setjmp/longjmp # Reason # a longjmp ignores destructors, thus invalidating all resource-management strategies relying on RAII Enforcement # Flag all occurrences of longjmp and setjmp A: Architectural ideas # This section contains ideas about higher-level architectural ideas and libraries. Architectural rule summary: A.1: Separate stable code from less stable code A.2: Express potentially reusable parts as a library A.4: There should be no cycles among libraries ??? ??? ??? ??? ??? ??? A.1: Separate stable code from less stable code # Isolating less stable code facilitates its unit testing, interface improvement, refactoring, and eventual deprecation. A.2: Express potentially reusable parts as a library # Reason # Note # A library is a collection of declarations and definitions maintained, documented, and shipped together. A library could be a set of headers (a \u201cheader-only library\u201d) or a set of headers plus a set of object files. You can statically or dynamically link a library into a program, or you can #include a header-only library. A.4: There should be no cycles among libraries # Reason # A cycle complicates the build process. Cycles are hard to understand and may introduce indeterminism (unspecified behavior). Note # A library can contain cyclic references in the definition of its components. For example: ??? However, a library should not depend on another that depends on it. NR: Non-Rules and myths # This section contains rules and guidelines that are popular somewhere, but that we deliberately don\u2019t recommend. We know full well that there have been times and places where these rules made sense, and we have used them ourselves at times. However, in the context of the styles of programming we recommend and support with the guidelines, these \u201cnon-rules\u201d would do harm. Even today, there can be contexts where the rules make sense. For example, lack of suitable tool support can make exceptions unsuitable in hard-real-time systems, but please don\u2019t blindly trust \u201ccommon wisdom\u201d (e.g., unsupported statements about \u201cefficiency\u201d); such \u201cwisdom\u201d may be based on decades-old information or experienced from languages with very different properties than C++ (e.g., C or Java). The positive arguments for alternatives to these non-rules are listed in the rules offered as \u201cAlternatives\u201d. Non-rule summary: NR.1: Don\u2019t: All declarations should be at the top of a function NR.2: Don\u2019t: Have only a single return -statement in a function NR.3: Don\u2019t: Don\u2019t use exceptions NR.4: Don\u2019t: Place each class declaration in its own source file NR.5: Don\u2019t: Don\u2019t do substantive work in a constructor; instead use two-phase initialization NR.6: Don\u2019t: Place all cleanup actions at the end of a function and goto exit NR.7: Don\u2019t: Make all data members protected ??? NR.1: Don\u2019t: All declarations should be at the top of a function # Reason (not to follow this rule) # This rule is a legacy of old programming languages that didn\u2019t allow initialization of variables and constants after a statement. This leads to longer programs and more errors caused by uninitialized and wrongly initialized variables. Example, bad # int use(int x) { int i; char c; double d; // ... some stuff ... if (x < i) { // ... i = f(x, d); } if (i < x) { // ... i = g(x, c); } return i; } The larger the distance between the uninitialized variable and its use, the larger the chance of a bug. Fortunately, compilers catch many \u201cused before set\u201d errors. Unfortunately, compilers cannot catch all such errors and unfortunately, the bugs aren\u2019t always as simple to spot as in this small example. Alternative # Always initialize an object ES.21: Don\u2019t introduce a variable (or constant) before you need to use it NR.2: Don\u2019t: Have only a single return -statement in a function # Reason (not to follow this rule) # The single-return rule can lead to unnecessarily convoluted code and the introduction of extra state variables. In particular, the single-return rule makes it harder to concentrate error checking at the top of a function. Example # template<class T> // requires Number<T> string sign(T x) { if (x < 0) return \"negative\"; else if (x > 0) return \"positive\"; return \"zero\"; } to use a single return only we would have to do something like template<class T> // requires Number<T> string sign(T x) // bad { string res; if (x < 0) res = \"negative\"; else if (x > 0) res = \"positive\"; else res = \"zero\"; return res; } This is both longer and likely to be less efficient. The larger and more complicated the function is, the more painful the workarounds get. Of course many simple functions will naturally have just one return because of their simpler inherent logic. Example # int index(const char* p) { if (!p) return -1; // error indicator: alternatively \"throw nullptr_error{}\" // ... do a lookup to find the index for p return i; } If we applied the rule, we\u2019d get something like int index2(const char* p) { int i; if (!p) i = -1; // error indicator else { // ... do a lookup to find the index for p } return i; } Note that we (deliberately) violated the rule against uninitialized variables because this style commonly leads to that. Also, this style is a temptation to use the goto exit non-rule. Alternative # Keep functions short and simple Feel free to use multiple return statements (and to throw exceptions). NR.3: Don\u2019t: Don\u2019t use exceptions # Reason (not to follow this rule) # There seem to be three main reasons given for this non-rule: exceptions are inefficient exceptions lead to leaks and errors exception performance is not predictable There is no way we can settle this issue to the satisfaction of everybody. After all, the discussions about exceptions have been going on for 40+ years. Some languages cannot be used without exceptions, but others do not support them. This leads to strong traditions for the use and non-use of exceptions, and to heated debates. However, we can briefly outline why we consider exceptions the best alternative for general-purpose programming and in the context of these guidelines. Simple arguments for and against are often inconclusive. There are specialized applications where exceptions indeed can be inappropriate (e.g., hard-real-time systems without support for reliable estimates of the cost of handling an exception). Consider the major objections to exceptions in turn Exceptions are inefficient: Compared to what? When comparing make sure that the same set of errors are handled and that they are handled equivalently. In particular, do not compare a program that immediately terminate on seeing an error with a program that carefully cleans up resources before logging an error. Yes, some systems have poor exception handling implementations; sometimes, such implementations force us to use other error-handling approaches, but that\u2019s not a fundamental problem with exceptions. When using an efficiency argument - in any context - be careful that you have good data that actually provides insight into the problem under discussion. Exceptions lead to leaks and errors. They do not. If your program is a rat\u2019s nest of pointers without an overall strategy for resource management, you have a problem whatever you do. If your system consists of a million lines of such code, you probably will not be able to use exceptions, but that\u2019s a problem with excessive and undisciplined pointer use, rather than with exceptions. In our opinion, you need RAII to make exception-based error handling simple and safe \u2013 simpler and safer than alternatives. Exception performance is not predictable. If you are in a hard-real-time system where you must guarantee completion of a task in a given time, you need tools to back up such guarantees. As far as we know such tools are not available (at least not to most programmers). Many, possibly most, problems with exceptions stem from historical needs to interact with messy old code. The fundamental arguments for the use of exceptions are They clearly differentiate between erroneous return and ordinary return They cannot be forgotten or ignored They can be used systematically Remember Exceptions are for reporting errors (in C++; other languages can have different uses for exceptions). Exceptions are not for errors that can be handled locally. Don\u2019t try to catch every exception in every function (that\u2019s tedious, clumsy, and leads to slow code). Exceptions are not for errors that require instant termination of a module/system after a non-recoverable error. Example # ??? Alternative # RAII Contracts/assertions: Use GSL\u2019s Expects and Ensures (until we get language support for contracts) NR.4: Don\u2019t: Place each class declaration in its own source file # Reason (not to follow this rule) # The resulting number of files are hard to manage and can slow down compilation. Individual classes are rarely a good logical unit of maintenance and distribution. Example # ??? Alternative # Use namespaces containing logically cohesive sets of classes and functions. NR.5: Don\u2019t: Don\u2019t do substantive work in a constructor; instead use two-phase initialization # Reason (not to follow this rule) # Following this rule leads to weaker invariants, more complicated code (having to deal with semi-constructed objects), and errors (when we didn\u2019t deal correctly with semi-constructed objects consistently). Example, bad # class Picture { int mx; int my; char * data; public: Picture(int x, int y) { mx = x, my = y; data = nullptr; } ~Picture() { Cleanup(); } bool Init() { // invariant checks if (mx <= 0 || my <= 0) { return false; } if (data) { return false; } data = (char*) malloc(x*y*sizeof(int)); return data != nullptr; } void Cleanup() { if (data) free(data); data = nullptr; } }; Picture picture(100, 0); // not ready-to-use picture here // this will fail.. if (!picture.Init()) { puts(\"Error, invalid picture\"); } // now have a invalid picture object instance. Example, good # class Picture { size_t mx; size_t my; vector<char> data; static size_t check_size(size_t s) { // invariant check Expects(s > 0); return s; } public: // even more better would be a class for a 2D Size as one single parameter Picture(size_t x, size_t y) : mx(check_size(x)) , my(check_size(y)) // now we know x and y have a valid size , data(mx * my * sizeof(int)) // will throw std::bad_alloc on error { // picture is ready-to-use } // compiler generated dtor does the job. (also see C.21) }; Picture picture1(100, 100); // picture is ready-to-use here... // not a valid size for y, // default contract violation behavior will call std::terminate then Picture picture2(100, 0); // not reach here... Alternative # Always establish a class invariant in a constructor. Don\u2019t define an object before it is needed. NR.6: Don\u2019t: Place all cleanup actions at the end of a function and goto exit # Reason (not to follow this rule) # goto is error-prone. This technique is a pre-exception technique for RAII-like resource and error handling. Example, bad # void do_something(int n) { if (n < 100) goto exit; // ... int* p = (int*) malloc(n); // ... if (some_error) goto_exit; // ... exit: free(p); } and spot the bug. Alternative # Use exceptions and RAII for non-RAII resources, use finally . NR.7: Don\u2019t: Make all data members protected # Reason (not to follow this rule) # protected data is a source of errors. protected data can be manipulated from an unbounded amount of code in various places. protected data is the class hierarchy equivalent to global data. Example # ??? Alternative # Make member data public or (preferably) private RF: References # Many coding standards, rules, and guidelines have been written for C++, and especially for specialized uses of C++. Many focus on lower-level issues, such as the spelling of identifiers are written by C++ novices see \u201cstopping programmers from doing unusual things\u201d as their primary aim aim at portability across many compilers (some 10 years old) are written to preserve decades old code bases aim at a single application domain are downright counterproductive are ignored (must be ignored by programmers to get their work done well) A bad coding standard is worse than no coding standard. However an appropriate set of guidelines are much better than no standards: \u201cForm is liberating.\u201d Why can\u2019t we just have a language that allows all we want and disallows all we don\u2019t want (\u201ca perfect language\u201d)? Fundamentally, because affordable languages (and their tool chains) also serve people with needs that differ from yours and serve more needs than you have today. Also, your needs change over time and a general-purpose language is needed to allow you to adapt. A language that is ideal for today would be overly restrictive tomorrow. Coding guidelines adapt the use of a language to specific needs. Thus, there cannot be a single coding style for everybody. We expect different organizations to provide additions, typically with more restrictions and firmer style rules. Reference sections: RF.rules: Coding rules RF.books: Books with coding guidelines RF.C++: C++ Programming (C++11/C++14/C++17) RF.web: Websites RS.video: Videos about \u201cmodern C++\u201d RF.man: Manuals RF.core: Core Guidelines materials RF.rules: Coding rules # Boost Library Requirements and Guidelines . ???. Bloomberg: BDE C++ Coding . Has a strong emphasis on code organization and layout. Facebook: ??? GCC Coding Conventions . C++03 and (reasonably) a bit backwards looking. Google C++ Style Guide . Geared toward C++03 and (also) older code bases. Google experts are now actively collaborating here on helping to improve these Guidelines, and hopefully to merge efforts so these can be a modern common set they could also recommend. JSF++: JOINT STRIKE FIGHTER AIR VEHICLE C++ CODING STANDARDS . Document Number 2RDU00001 Rev C. December 2005. For flight control software. For hard-real-time. This means that it is necessarily very restrictive (\u201cif the program fails somebody dies\u201d). For example, no free store allocation or deallocation may occur after the plane takes off (no memory overflow and no fragmentation allowed). No exception may be used (because there was no available tool for guaranteeing that an exception would be handled within a fixed short time). Libraries used have to have been approved for mission critical applications. Any similarities to this set of guidelines are unsurprising because Bjarne Stroustrup was an author of JSF++. Recommended, but note its very specific focus. Mozilla Portability Guide . As the name indicates, this aims for portability across many (old) compilers. As such, it is restrictive. Geosoft.no: C++ Programming Style Guidelines . ???. Possibility.com: C++ Coding Standard . ???. SEI CERT: Secure C++ Coding Standard . A very nicely done set of rules (with examples and rationales) done for security-sensitive code. Many of their rules apply generally. High Integrity C++ Coding Standard . llvm . Somewhat brief, pre-C++11, and (not unreasonably) adjusted to its domain. ??? RF.books: Books with coding guidelines # Meyers96 Scott Meyers: More Effective C++ . Addison-Wesley 1996. Meyers97 Scott Meyers: Effective C++, Second Edition . Addison-Wesley 1997. Meyers01 Scott Meyers: Effective STL . Addison-Wesley 2001. Meyers05 Scott Meyers: Effective C++, Third Edition . Addison-Wesley 2005. Meyers15 Scott Meyers: Effective Modern C++ . O\u2019Reilly 2015. SuttAlex05 Sutter and Alexandrescu: C++ Coding Standards . Addison-Wesley 2005. More a set of meta-rules than a set of rules. Pre-C++11. Stroustrup05 Bjarne Stroustrup: A rationale for semantically enhanced library languages . LCSD05. October 2005. Stroustrup14 Stroustrup: A Tour of C++ . Addison Wesley 2014. Each chapter ends with an advice section consisting of a set of recommendations. Stroustrup13 Stroustrup: The C++ Programming Language (4 th Edition) . Addison Wesley 2013. Each chapter ends with an advice section consisting of a set of recommendations. Stroustrup: Style Guide for Programming: Principles and Practice using C++ . Mostly low-level naming and layout rules. Primarily a teaching tool. RF.C++: C++ Programming (C++11/C++14) # TC++PL4 : A thorough description of the C++ language and standard libraries for experienced programmers. Tour++ : An overview of the C++ language and standard libraries for experienced programmers. Programming: Principles and Practice using C++ : A textbook for beginners and relative novices. RF.web: Websites # isocpp.org Bjarne Stroustrup\u2019s home pages WG21 Boost Adobe open source Poco libraries Sutter\u2019s Mill? ??? RS.video: Videos about \u201cmodern C++\u201d # Bjarne Stroustrup: C++11 Style . 2012. Bjarne Stroustrup: The Essence of C++: With Examples in C++84, C++98, C++11, and C++14 . 2013 All the talks from CppCon \u201814 Bjarne Stroustrup: The essence of C++ at the University of Edinburgh. 2014. Bjarne Stroustrup: The Evolution of C++ Past, Present and Future . CppCon 2016 keynote. Bjarne Stroustrup: Make Simple Tasks Simple! . CppCon 2014 keynote. Bjarne Stroustrup: Writing Good C++14 . CppCon 2015 keynote about the Core Guidelines. Herb Sutter: Writing Good C++14\u2026 By Default . CppCon 2015 keynote about the Core Guidelines. CppCon 15 ??? C++ Next ??? Meting C++ ??? more ??? RF.man: Manuals # ISO C++ Standard C++11. ISO C++ Standard C++14. ISO C++ Standard C++17 . Committee Draft. Palo Alto \u201cConcepts\u201d TR . ISO C++ Concepts TS . WG21 Ranges report . Draft. RF.core: Core Guidelines materials # This section contains materials that has been useful for presenting the core guidelines and the ideas behind them: Our documents directory Stroustrup, Sutter, and Dos Reis: A brief introduction to C++\u2019s model for type- and resource-safety . A paper with lots of examples. Sergey Zubkov: a Core Guidelines talk and here are the slides . In Russian. 2017. Neil MacIntosh: The Guideline Support Library: One Year Later . CppCon 2016. Bjarne Stroustrup: Writing Good C++14 . CppCon 2015 keynote. Herb Sutter: Writing Good C++14\u2026 By Default . CppCon 2015 keynote. Peter Sommerlad: C++ Core Guidelines - Modernize your C++ Code Base . ACCU 2017. Bjarne Stroustrup: No Littering! . Bay Area ACCU 2016. It gives some idea of the ambition level for the Core Guidelines. Note that slides for CppCon presentations are available (links with the posted videos). Contributions to this list would be most welcome. Acknowledgements # Thanks to the many people who contributed rules, suggestions, supporting information, references, etc.: Peter Juhl Neil MacIntosh Axel Naumann Andrew Pardoe Gabriel Dos Reis Zhuang, Jiangang (Jeff) Sergey Zubkov and see the contributor list on the github. Pro: Profiles # Ideally, we would follow all of the guidelines. That would give the cleanest, most regular, least error-prone, and often the fastest code. Unfortunately, that is usually impossible because we have to fit our code into large code bases and use existing libraries. Often, such code has been written over decades and does not follow these guidelines. We must aim for gradual adoption . Whatever strategy for gradual adoption we adopt, we need to be able to apply sets of related guidelines to address some set of problems first and leave the rest until later. A similar idea of \u201crelated guidelines\u201d becomes important when some, but not all, guidelines are considered relevant to a code base or if a set of specialized guidelines is to be applied for a specialized application area. We call such a set of related guidelines a \u201cprofile\u201d. We aim for such a set of guidelines to be coherent so that they together help us reach a specific goal, such as \u201cabsence of range errors\u201d or \u201cstatic type safety.\u201d Each profile is designed to eliminate a class of errors. Enforcement of \u201crandom\u201d rules in isolation is more likely to be disruptive to a code base than delivering a definite improvement. A \u201cprofile\u201d is a set of deterministic and portably enforceable subset rules (i.e., restrictions) that are designed to achieve a specific guarantee. \u201cDeterministic\u201d means they require only local analysis and could be implemented in a compiler (though they don\u2019t need to be). \u201cPortably enforceable\u201d means they are like language rules, so programmers can count on different enforcement tools giving the same answer for the same code. Code written to be warning-free using such a language profile is considered to conform to the profile. Conforming code is considered to be safe by construction with regard to the safety properties targeted by that profile. Conforming code will not be the root cause of errors for that property, although such errors may be introduced into a program by other code, libraries or the external environment. A profile may also introduce additional library types to ease conformance and encourage correct code. Profiles summary: Pro.type: Type safety Pro.bounds: Bounds safety Pro.lifetime: Lifetime safety In the future, we expect to define many more profiles and add more checks to existing profiles. Candidates include: narrowing arithmetic promotions/conversions (likely part of a separate safe-arithmetic profile) arithmetic cast from negative floating point to unsigned integral type (ditto) selected undefined behavior: Start with Gabriel Dos Reis\u2019s UB list developed for the WG21 study group selected unspecified behavior: Addressing portability concerns. const violations: Mostly done by compilers already, but we can catch inappropriate casting and underuse of const . Enabling a profile is implementation defined; typically, it is set in the analysis tool used. To suppress enforcement of a profile check, place a suppress annotation on a language contract. For example: [[suppress(bounds)]] char* raw_find(char* p, int n, char x) // find x in p[0]..p[n - 1] { // ... } Now raw_find() can scramble memory to its heart\u2019s content. Obviously, suppression should be very rare. Pro.safety: Type-safety profile # This profile makes it easier to construct code that uses types correctly and avoids inadvertent type punning. It does so by focusing on removing the primary sources of type violations, including unsafe uses of casts and unions. For the purposes of this section, type-safety is defined to be the property that a variable is not used in a way that doesn\u2019t obey the rules for the type of its definition. Memory accessed as a type T should not be valid memory that actually contains an object of an unrelated type U . Note that the safety is intended to be complete when combined also with Bounds safety and Lifetime safety . An implementation of this profile shall recognize the following patterns in source code as non-conforming and issue a diagnostic. Type safety profile summary: Type.1: Avoid casts : a. Don\u2019t use reinterpret_cast ; A strict version of Avoid casts and prefer named casts . b. Don\u2019t use static_cast for arithmetic types; A strict version of Avoid casts and prefer named casts . c. Don\u2019t cast between pointer types where the source type and the target type are the same; A strict version of Avoid casts . d. Don\u2019t cast between pointer types when the conversion could be implicit; A strict version of Avoid casts . Type.2: Don\u2019t use static_cast to downcast: Use dynamic_cast instead . Type.3: Don\u2019t use const_cast to cast away const (i.e., at all): Don\u2019t cast away const . Type.4: Don\u2019t use C-style (T)expression or functional T(expression) casts: Prefer construction or named casts . Type.5: Don\u2019t use a variable before it has been initialized: always initialize . Type.6: Always initialize a member variable: always initialize , possibly using default constructors or default member initializers . Type.7: Avoid naked union: Use variant instead . Type.8: Avoid varargs: Don\u2019t use va_arg arguments . Impact # With the type-safety profile you can trust that every operation is applied to a valid object. Exception may be thrown to indicate errors that cannot be detected statically (at compile time). Note that this type-safety can be complete only if we also have Bounds safety and Lifetime safety . Without those guarantees, a region of memory could be accessed independent of which object, objects, or parts of objects are stored in it. Pro.bounds: Bounds safety profile # This profile makes it easier to construct code that operates within the bounds of allocated blocks of memory. It does so by focusing on removing the primary sources of bounds violations: pointer arithmetic and array indexing. One of the core features of this profile is to restrict pointers to only refer to single objects, not arrays. We define bounds-safety to be the property that a program does not use an object to access memory outside of the range that was allocated for it. Bounds safety is intended to be complete only when combined with Type safety and Lifetime safety , which cover other unsafe operations that allow bounds violations. Bounds safety profile summary: Bounds.1: Don\u2019t use pointer arithmetic. Use span instead: Pass pointers to single objects (only) and Keep pointer arithmetic simple . Bounds.2: Only index into arrays using constant expressions: Pass pointers to single objects (only) and Keep pointer arithmetic simple . Bounds.3: No array-to-pointer decay: Pass pointers to single objects (only) and Keep pointer arithmetic simple . Bounds.4: Don\u2019t use standard-library functions and types that are not bounds-checked: Use the standard library in a type-safe manner . Impact # Bounds safety implies that access to an object - notably arrays - does not access beyond the object\u2019s memory allocation. This eliminates a large class of insidious and hard-to-find errors, including the (in)famous \u201cbuffer overflow\u201d errors. This closes security loopholes as well as a prominent source of memory corruption (when writing out of bounds). Even if an out-of-bounds access is \u201cjust a read\u201d, it can lead to invariant violations (when the accessed isn\u2019t of the assumed type) and \u201cmysterious values.\u201d Pro.lifetime: Lifetime safety profile # Accessing through a pointer that doesn\u2019t point to anything is a major source of errors, and very hard to avoid in many traditional C or C++ styles of programming. For example, a pointer may be uninitialized, the nullptr , point beyond the range of an array, or to a deleted object. See the current design specification here. Lifetime safety profile summary: Lifetime.1: Don\u2019t dereference a possibly invalid pointer: detect or avoid . Impact # Once completely enforced through a combination of style rules, static analysis, and library support, this profile eliminates one of the major sources of nasty errors in C++ eliminates a major source of potential security violations improves performance by eliminating redundant \u201cparanoia\u201d checks increases confidence in correctness of code avoids undefined behavior by enforcing a key C++ language rule GSL: Guidelines support library # The GSL is a small library of facilities designed to support this set of guidelines. Without these facilities, the guidelines would have to be far more restrictive on language details. The Core Guidelines support library is defined in namespace gsl and the names may be aliases for standard library or other well-known library names. Using the (compile-time) indirection through the gsl namespace allows for experimentation and for local variants of the support facilities. The GSL is header only, and can be found at GSL: Guidelines support library . The support library facilities are designed to be extremely lightweight (zero-overhead) so that they impose no overhead compared to using conventional alternatives. Where desirable, they can be \u201cinstrumented\u201d with additional functionality (e.g., checks) for tasks such as debugging. These Guidelines assume a variant type, but this is not currently in GSL. Eventually, use the one voted into C++17 . Summary of GSL components: GSL.view: Views GSL.owner GSL.assert: Assertions GSL.util: Utilities GSL.concept: Concepts We plan for a \u201cISO C++ standard style\u201d semi-formal specification of the GSL. We rely on the ISO C++ Standard Library and hope for parts of the GSL to be absorbed into the standard library. GSL.view: Views # These types allow the user to distinguish between owning and non-owning pointers and between pointers to a single object and pointers to the first element of a sequence. These \u201cviews\u201d are never owners. References are never owners (see R.4 . Note: References have many opportunities to outlive the objects they refer to (returning a local variable by reference, holding a reference to an element of a vector and doing push_back , binding to std::max(x, y + 1) , etc. The Lifetime safety profile aims to address those things, but even so owner<T&> does not make sense and is discouraged. The names are mostly ISO standard-library style (lower case and underscore): T* // The T* is not an owner, may be null; assumed to be pointing to a single element. T& // The T& is not an owner and can never be a \u201cnull reference\u201d; references are always bound to objects. The \u201craw-pointer\u201d notation (e.g. int* ) is assumed to have its most common meaning; that is, a pointer points to an object, but does not own it. Owners should be converted to resource handles (e.g., unique_ptr or vector<T> ) or marked owner<T*> . owner<T*> // a T* that owns the object pointed/referred to; may be nullptr . owner is used to mark owning pointers in code that cannot be upgraded to use proper resource handles. Reasons for that include: Cost of conversion. The pointer is used with an ABI. The pointer is part of the implementation of a resource handle. An owner<T> differs from a resource handle for a T by still requiring an explicit delete . An owner<T> is assumed to refer to an object on the free store (heap). If something is not supposed to be nullptr , say so: not_null<T> // T is usually a pointer type (e.g., not_null<int*> and not_null<owner<Foo*>> ) that may not be nullptr . T can be any type for which ==nullptr is meaningful. span<T> // [p:p+n) , constructor from {p, q} and {p, n} ; T is the pointer type span_p<T> // {p, predicate} [p:q) where q is the first element for which predicate(*p) is true string_span // span<char> cstring_span // span<const char> A span<T> refers to zero or more mutable T s unless T is a const type. \u201cPointer arithmetic\u201d is best done within span s. A char* that points to more than one char but is not a C-style string (e.g., a pointer into an input buffer) should be represented by a span . zstring // a char* supposed to be a C-style string; that is, a zero-terminated sequence of char or nullptr czstring // a const char* supposed to be a C-style string; that is, a zero-terminated sequence of const char or nullptr Logically, those last two aliases are not needed, but we are not always logical, and they make the distinction between a pointer to one char and a pointer to a C-style string explicit. A sequence of characters that is not assumed to be zero-terminated should be a char* , rather than a zstring . French accent optional. Use not_null<zstring> for C-style strings that cannot be nullptr . ??? Do we need a name for not_null<zstring> ? or is its ugliness a feature? GSL.owner: Ownership pointers # unique_ptr<T> // unique ownership: std::unique_ptr<T> shared_ptr<T> // shared ownership: std::shared_ptr<T> (a counted pointer) stack_array<T> // A stack-allocated array. The number of elements are determined at construction and fixed thereafter. The elements are mutable unless T is a const type. dyn_array<T> // ??? needed ??? A heap-allocated array. The number of elements are determined at construction and fixed thereafter. The elements are mutable unless T is a const type. Basically a span that allocates and owns its elements. GSL.assert: Assertions # Expects // precondition assertion. Currently placed in function bodies. Later, should be moved to declarations. // Expects(p) terminates the program unless p == true // Expect in under control of some options (enforcement, error message, alternatives to terminate) Ensures // postcondition assertion. Currently placed in function bodies. Later, should be moved to declarations. These assertions are currently macros (yuck!) and must appear in function definitions (only) pending standard committee decisions on contracts and assertion syntax. See the contract proposal ; using the attribute syntax, for example, Expects(p) will become [[expects: p]] . GSL.util: Utilities # finally // finally(f) makes a final_action{f} with a destructor that invokes f narrow_cast // narrow_cast<T>(x) is static_cast<T>(x) narrow // narrow<T>(x) is static_cast<T>(x) if static_cast<T>(x) == x or it throws narrowing_error [[implicit]] // \u201cMarker\u201d to put on single-argument constructors to explicitly make them non-explicit. move_owner // p = move_owner(q) means p = q but ??? joining_thread // a RAII style version of std::thread that joins. index // a type to use for all container and array indexing (currently an alias for ptrdiff_t ) GSL.concept: Concepts # These concepts (type predicates) are borrowed from Andrew Sutton\u2019s Origin library, the Range proposal, and the ISO WG21 Palo Alto TR. They are likely to be very similar to what will become part of the ISO C++ standard. The notation is that of the ISO WG21 Concepts TS . Most of the concepts below are defined in the Ranges TS . Range String // ??? Number // ??? Sortable EqualityComparable // ???Must we suffer CaMelcAse??? Convertible Common Boolean Integral SignedIntegral SemiRegular // ??? Copyable? Regular TotallyOrdered Function RegularFunction Predicate Relation \u2026 GSL.ptr: Smart pointer concepts # Pointer // A type with * , -> , == , and default construction (default construction is assumed to set the singular \u201cnull\u201d value) Unique_pointer // A type that matches Pointer , is movable, and is not copyable Shared_pointer // A type that matches Pointer , and is copyable NL: Naming and layout rules # Consistent naming and layout are helpful. If for no other reason because it minimizes \u201cmy style is better than your style\u201d arguments. However, there are many, many, different styles around and people are passionate about them (pro and con). Also, most real-world projects includes code from many sources, so standardizing on a single style for all code is often impossible. After many requests for guidance from users, we present a set of rules that you might use if you have no better ideas, but the real aim is consistency, rather than any particular rule set. IDEs and tools can help (as well as hinder). Naming and layout rules: NL.1: Don\u2019t say in comments what can be clearly stated in code NL.2: State intent in comments NL.3: Keep comments crisp NL.4: Maintain a consistent indentation style NL.5: Avoid encoding type information in names NL.7: Make the length of a name roughly proportional to the length of its scope NL.8: Use a consistent naming style NL.9: Use ALL_CAPS for macro names only NL.10: Prefer underscore_style names NL.11: Make literals readable NL.15: Use spaces sparingly NL.16: Use a conventional class member declaration order NL.17: Use K&R-derived layout NL.18: Use C++-style declarator layout NL.19: Avoid names that are easily misread NL.20: Don\u2019t place two statements on the same line NL.21: Declare one name (only) per declaration NL.25: Don\u2019t use void as an argument type NL.26: Use conventional const notation Most of these rules are aesthetic and programmers hold strong opinions. IDEs also tend to have defaults and a range of alternatives. These rules are suggested defaults to follow unless you have reasons not to. We have had comments to the effect that naming and layout are so personal and/or arbitrary that we should not try to \u201clegislate\u201d them. We are not \u201clegislating\u201d (see the previous paragraph). However, we have had many requests for a set of naming and layout conventions to use when there are no external constraints. More specific and detailed rules are easier to enforce. These rules bear a strong resemblance to the recommendations in the PPP Style Guide written in support of Stroustrup\u2019s Programming: Principles and Practice using C++ . NL.1: Don\u2019t say in comments what can be clearly stated in code # Reason # Compilers do not read comments. Comments are less precise than code. Comments are not updated as consistently as code. Example, bad # auto x = m * v1 + vv; // multiply m with v1 and add the result to vv Enforcement # Build an AI program that interprets colloquial English text and see if what is said could be better expressed in C++. NL.2: State intent in comments # Reason # Code says what is done, not what is supposed to be done. Often intent can be stated more clearly and concisely than the implementation. Example # void stable_sort(Sortable& c) // sort c in the order determined by <, keep equal elements (as defined by ==) in // their original relative order { // ... quite a few lines of non-trivial code ... } Note # If the comment and the code disagree, both are likely to be wrong. NL.3: Keep comments crisp # Reason # Verbosity slows down understanding and makes the code harder to read by spreading it around in the source file. Note # Use intelligible English. I may be fluent in Danish, but most programmers are not; the maintainers of my code may not be. Avoid SMS lingo and watch your grammar, punctuation, and capitalization. Aim for professionalism, not \u201ccool.\u201d Enforcement # not possible. NL.4: Maintain a consistent indentation style # Reason # Readability. Avoidance of \u201csilly mistakes.\u201d Example, bad # int i; for (i = 0; i < max; ++i); // bug waiting to happen if (i == j) return i; Note # Always indenting the statement after if (...) , for (...) , and while (...) is usually a good idea: if (i < 0) error(\"negative argument\"); if (i < 0) error(\"negative argument\"); Enforcement # Use a tool. NL.5: Avoid encoding type information in names # Rationale # If names reflect types rather than functionality, it becomes hard to change the types used to provide that functionality. Also, if the type of a variable is changed, code using it will have to be modified. Minimize unintentional conversions. Example, bad # void print_int(int i); void print_string(const char*); print_int(1); // repetitive, manual type matching print_string(\"xyzzy\"); // repetitive, manual type matching Example, good # void print(int i); void print(string_view); // also works on any string-like sequence print(1); // clear, automatic type matching print(\"xyzzy\"); // clear, automatic type matching Note # Names with types encoded are either verbose or cryptic. printS // print a std::string prints // print a C-style string printi // print an int Requiring techniques like Hungarian notation to encode a type has been used in untyped languages, but is generally unnecessary and actively harmful in a strongly statically-typed language like C++, because the annotations get out of date (the warts are just like comments and rot just like them) and they interfere with good use of the language (use the same name and overload resolution instead). Note # Some styles use very general (not type-specific) prefixes to denote the general use of a variable. auto p = new User(); auto p = make_unique<User>(); // note: \"p\" is not being used to say \"raw pointer to type User,\" // just generally to say \"this is an indirection\" auto cntHits = calc_total_of_hits(/*...*/); // note: \"cnt\" is not being used to encode a type, // just generally to say \"this is a count of something\" This is not harmful and does not fall under this guideline because it does not encode type information. Note # Some styles distinguish members from local variable, and/or from global variable. struct S { int m_; S(int m) :m_{abs(m)} { } }; This is not harmful and does not fall under this guideline because it does not encode type information. Note # Like C++, some styles distinguish types from non-types. For example, by capitalizing type names, but not the names of functions and variables. typename<typename T> class HashTable { // maps string to T // ... }; HashTable<int> index; This is not harmful and does not fall under this guideline because it does not encode type information. NL.7: Make the length of a name roughly proportional to the length of its scope # Rationale : The larger the scope the greater the chance of confusion and of an unintended name clash. Example # double sqrt(double x); // return the square root of x; x must be non-negative int length(const char* p); // return the number of characters in a zero-terminated C-style string int length_of_string(const char zero_terminated_array_of_char[]) // bad: verbose int g; // bad: global variable with a cryptic name int open; // bad: global variable with a short, popular name The use of p for pointer and x for a floating-point variable is conventional and non-confusing in a restricted scope. Enforcement # ??? NL.8: Use a consistent naming style # Rationale : Consistence in naming and naming style increases readability. Note # There are many styles and when you use multiple libraries, you can\u2019t follow all their different conventions. Choose a \u201chouse style\u201d, but leave \u201cimported\u201d libraries with their original style. Example # ISO Standard, use lower case only and digits, separate words with underscores: int vector my_map Avoid double underscores __ . Example # Stroustrup : ISO Standard, but with upper case used for your own types and concepts: int vector My_map Example # CamelCase: capitalize each word in a multi-word identifier: int vector MyMap myMap Some conventions capitalize the first letter, some don\u2019t. Note # Try to be consistent in your use of acronyms and lengths of identifiers: int mtbf {12}; int mean_time_between_failures {12}; // make up your mind Enforcement # Would be possible except for the use of libraries with varying conventions. NL.9: Use ALL_CAPS for macro names only # Reason # To avoid confusing macros with names that obey scope and type rules. Example # void f() { const int SIZE{1000}; // Bad, use 'size' instead int v[SIZE]; } Note # This rule applies to non-macro symbolic constants: enum bad { BAD, WORSE, HORRIBLE }; // BAD Enforcement # Flag macros with lower-case letters Flag ALL_CAPS non-macro names NL.10: Prefer underscore_style names # Reason # The use of underscores to separate parts of a name is the original C and C++ style and used in the C++ Standard Library. Note # This rule is a default to use only if you have a choice. Often, you don\u2019t have a choice and must follow an established style for consistency . The need for consistency beats personal taste. This is a recommendation for when you have no constraints or better ideas . This rule was added after many requests for guidance. Example # Stroustrup : ISO Standard, but with upper case used for your own types and concepts: int vector My_map Enforcement # Impossible. NL.15: Use spaces sparingly # Reason # Too much space makes the text larger and distracts. Example, bad # #include < map > int main(int argc, char * argv [ ]) { // ... } Example # #include <map> int main(int argc, char* argv[]) { // ... } Note # Some IDEs have their own opinions and add distracting space. This is a recommendation for when you have no constraints or better ideas . This rule was added after many requests for guidance. Note # We value well-placed whitespace as a significant help for readability. Just don\u2019t overdo it. NL.11: Make literals readable # Reason # Readability. Example # Use digit separators to avoid long strings of digits auto c = 299'792'458; // m/s2 auto q2 = 0b0000'1111'0000'0000; auto ss_number = 123'456'7890; Example # Use literal suffixes where clarification is needed auto hello = \"Hello!\"s; // a std::string auto world = \"world\"; // a C-style string auto interval = 100ms; // using <chrono> Note # Literals should not be sprinkled all over the code as \u201cmagic constants\u201d , but it is still a good idea to make them readable where they are defined. It is easy to make a typo in a long string of integers. Enforcement # Flag long digit sequences. The trouble is to define \u201clong\u201d; maybe 7. NL.16: Use a conventional class member declaration order # Reason # A conventional order of members improves readability. When declaring a class use the following order types: classes, enums, and aliases ( using ) constructors, assignments, destructor functions data Use the public before protected before private order. This is a recommendation for when you have no constraints or better ideas . This rule was added after many requests for guidance. Example # class X { public: // interface protected: // unchecked function for use by derived class implementations private: // implementation details }; Example # Sometimes, the default order of members conflicts with a desire to separate the public interface from implementation details. In such cases, private types and functions can be placed with private data. class X { public: // interface protected: // unchecked function for use by derived class implementations private: // implementation details (types, functions, and data) }; Example, bad # Avoid multiple blocks of declarations of one access (e.g., public ) dispersed among blocks of declarations with different access (e.g. private ). class X { // bad public: void f(); public: int g(); // ... }; The use of macros to declare groups of members often leads to violation of any ordering rules. However, macros obscures what is being expressed anyway. Enforcement # Flag departures from the suggested order. There will be a lot of old code that doesn\u2019t follow this rule. NL.17: Use K&R-derived layout # Reason # This is the original C and C++ layout. It preserves vertical space well. It distinguishes different language constructs (such as functions and classes) well. Note # In the context of C++, this style is often called \u201cStroustrup\u201d. This is a recommendation for when you have no constraints or better ideas . This rule was added after many requests for guidance. Example # struct Cable { int x; // ... }; double foo(int x) { if (0 < x) { // ... } switch (x) { case 0: // ... break; case amazing: // ... break; default: // ... break; } if (0 < x) ++x; if (x < 0) something(); else something_else(); return some_value; } Note the space between if and ( Note # Use separate lines for each statement, the branches of an if , and the body of a for . Note # The { for a class and a struct is not on a separate line, but the { for a function is. Note # Capitalize the names of your user-defined types to distinguish them from standards-library types. Note # Do not capitalize function names. Enforcement # If you want enforcement, use an IDE to reformat. NL.18: Use C++-style declarator layout # Reason # The C-style layout emphasizes use in expressions and grammar, whereas the C++-style emphasizes types. The use in expressions argument doesn\u2019t hold for references. Example # T& operator[](size_t); // OK T &operator[](size_t); // just strange T & operator[](size_t); // undecided Note # This is a recommendation for when you have no constraints or better ideas . This rule was added after many requests for guidance. Enforcement # Impossible in the face of history. NL.19: Avoid names that are easily misread # Reason # Readability. Not everyone has screens and printers that make it easy to distinguish all characters. We easily confuse similarly spelled and slightly misspelled words. Example # int oO01lL = 6; // bad int splunk = 7; int splonk = 8; // bad: splunk and splonk are easily confused Enforcement # ??? NL.20: Don\u2019t place two statements on the same line # Reason # Readability. It is really easy to overlook a statement when there is more on a line. Example # int x = 7; char* p = 29; // don't int x = 7; f(x); ++x; // don't Enforcement # Easy. NL.21: Declare one name (only) per declaration # Reason # Readability. Minimizing confusion with the declarator syntax. Note # For details, see ES.10 . NL.25: Don\u2019t use void as an argument type # Reason # It\u2019s verbose and only needed where C compatibility matters. Example # void f(void); // bad void g(); // better Note # Even Dennis Ritchie deemed void f(void) an abomination. You can make an argument for that abomination in C when function prototypes were rare so that banning: int f(); f(1, 2, \"weird but valid C89\"); // hope that f() is defined int f(a, b, c) char* c; { /* ... */ } would have caused major problems, but not in the 21 st century and in C++. NL.26: Use conventional const notation # Reason # Conventional notation is more familiar to more programmers. Consistency in large code bases. Example # const int x = 7; // OK int const y = 9; // bad const int *const p = nullptr; // OK, constant pointer to constant int int const *const p = nullptr; // bad, constant pointer to constant int Note # We are well aware that you could claim the \u201cbad\u201d examples more logical than the ones marked \u201cOK\u201d, but they also confuse more people, especially novices relying on teaching material using the far more common, conventional OK style. As ever, remember that the aim of these naming and layout rules is consistency and that aesthetics vary immensely. This is a recommendation for when you have no constraints or better ideas . This rule was added after many requests for guidance. Enforcement # Flag const used as a suffix for a type. FAQ: Answers to frequently asked questions # This section covers answers to frequently asked questions about these guidelines. FAQ.1: What do these guidelines aim to achieve? # See the top of this page . This is an open-source project to maintain modern authoritative guidelines for writing C++ code using the current C++ Standard (as of this writing, C++14). The guidelines are designed to be modern, machine-enforceable wherever possible, and open to contributions and forking so that organizations can easily incorporate them into their own corporate coding guidelines. FAQ.2: When and where was this work first announced? # It was announced by Bjarne Stroustrup in his CppCon 2015 opening keynote, \u201cWriting Good C++14\u201d . See also the accompanying isocpp.org blog post , and for the rationale of the type and memory safety guidelines see Herb Sutter\u2019s follow-up CppCon 2015 talk, \u201cWriting Good C++14 \u2026 By Default\u201d . FAQ.3: Who are the authors and maintainers of these guidelines? # The initial primary authors and maintainers are Bjarne Stroustrup and Herb Sutter, and the guidelines so far were developed with contributions from experts at CERN, Microsoft, Morgan Stanley, and several other organizations. At the time of their release, the guidelines are in a \u201c0.6\u201d state, and contributions are welcome. As Stroustrup said in his announcement: \u201cWe need help!\u201d FAQ.4: How can I contribute? # See CONTRIBUTING.md . We appreciate volunteer help! FAQ.5: How can I become an editor/maintainer? # By contributing a lot first and having the consistent quality of your contributions recognized. See CONTRIBUTING.md . We appreciate volunteer help! FAQ.6: Have these guidelines been approved by the ISO C++ standards committee? Do they represent the consensus of the committee? # No. These guidelines are outside the standard. They are intended to serve the standard, and be maintained as current guidelines about how to use the current Standard C++ effectively. We aim to keep them in sync with the standard as that is evolved by the committee. FAQ.7: If these guidelines are not approved by the committee, why are they under github.com/isocpp ? # Because isocpp is the Standard C++ Foundation; the committee\u2019s repositories are under github.com/ cplusplus . Some neutral organization has to own the copyright and license to make it clear this is not being dominated by any one person or vendor. The natural entity is the Foundation, which exists to promote the use and up-to-date understanding of modern Standard C++ and the work of the committee. This follows the same pattern that isocpp.org did for the C++ FAQ , which was initially the work of Bjarne Stroustrup, Marshall Cline, and Herb Sutter and contributed to the open project in the same way. FAQ.8: Will there be a C++98 version of these Guidelines? a C++11 version? # No. These guidelines are about how to best use Standard C++14 (and, if you have an implementation available, the Concepts Technical Specification) and write code assuming you have a modern conforming compiler. FAQ.9: Do these guidelines propose new language features? # No. These guidelines are about how to best use Standard C++14 + the Concepts Technical Specification, and they limit themselves to recommending only those features. FAQ.10: What version of Markdown do these guidelines use? # These coding standards are written using CommonMark , and <a> HTML anchors. We are considering the following extensions from GitHub Flavored Markdown (GFM) : fenced code blocks (consistently using indented vs. fenced is under discussion) tables (none yet but we\u2019ll likely need them, and this is a GFM extension) Avoid other HTML tags and other extensions. Note: We are not yet consistent with this style. FAQ.50: What is the GSL (guidelines support library)? # The GSL is the small set of types and aliases specified in these guidelines. As of this writing, their specification herein is too sparse; we plan to add a WG21-style interface specification to ensure that different implementations agree, and to propose as a contribution for possible standardization, subject as usual to whatever the committee decides to accept/improve/alter/reject. FAQ.51: Is github.com/Microsoft/GSL the GSL? # No. That is just a first implementation contributed by Microsoft. Other implementations by other vendors are encouraged, as are forks of and contributions to that implementation. As of this writing one week into the public project, at least one GPLv3 open-source implementation already exists. We plan to produce a WG21-style interface specification to ensure that different implementations agree. FAQ.52: Why not supply an actual GSL implementation in/with these guidelines? # We are reluctant to bless one particular implementation because we do not want to make people think there is only one, and inadvertently stifle parallel implementations. And if these guidelines included an actual implementation, then whoever contributed it could be mistakenly seen as too influential. We prefer to follow the long-standing approach of the committee, namely to specify interfaces, not implementations. But at the same time we want at least one implementation available; we hope for many. FAQ.53: Why weren\u2019t the GSL types proposed through Boost? # Because we want to use them immediately, and because they are temporary in that we want to retire them as soon as types that fill the same needs exist in the standard library. FAQ.54: Has the GSL (guidelines support library) been approved by the ISO C++ standards committee? # No. The GSL exists only to supply a few types and aliases that are not currently in the standard library. If the committee decides on standardized versions (of these or other types that fill the same need) then they can be removed from the GSL. FAQ.55: If you\u2019re using the standard types where available, why is the GSL string_span different from the string_view in the Library Fundamentals 1 Technical Specification and C++17 Working Paper? Why not just use the committee-approved string_view ? # The consensus on the taxonomy of views for the C++ Standard Library was that \u201cview\u201d means \u201cread-only\u201d, and \u201cspan\u201d means \u201cread/write\u201d. The read-only string_view was the first such component to complete the standardization process, while span and string_span are currently being considered for standardization. FAQ.56: Is owner the same as the proposed observer_ptr ? # No. owner owns, is an alias, and can be applied to any indirection type. The main intent of observer_ptr is to signify a non -owning pointer. FAQ.57: Is stack_array the same as the standard array ? # No. stack_array is guaranteed to be allocated on the stack. Although a std::array contains its storage directly inside itself, the array object can be put anywhere, including the heap. FAQ.58: Is dyn_array the same as vector or the proposed dynarray ? # No. dyn_array is not resizable, and is a safe way to refer to a heap-allocated fixed-size array. Unlike vector , it is intended to replace array- new[] . Unlike the dynarray that has been proposed in the committee, this does not anticipate compiler/language magic to somehow allocate it on the stack when it is a member of an object that is allocated on the stack; it simply refers to a \u201cdynamic\u201d or heap-based array. FAQ.59: Is Expects the same as assert ? # No. It is a placeholder for language support for contract preconditions. FAQ.60: Is Ensures the same as assert ? # No. It is a placeholder for language support for contract postconditions. Appendix A: Libraries # This section lists recommended libraries, and explicitly recommends a few. ??? Suitable for the general guide? I think not ??? Appendix B: Modernizing code # Ideally, we follow all rules in all code. Realistically, we have to deal with a lot of old code: application code written before the guidelines were formulated or known libraries written to older/different standards code written under \u201cunusual\u201d constraints code that we just haven\u2019t gotten around to modernizing If we have a million lines of new code, the idea of \u201cjust changing it all at once\u201d is typically unrealistic. Thus, we need a way of gradually modernizing a code base. Upgrading older code to modern style can be a daunting task. Often, the old code is both a mess (hard to understand) and working correctly (for the current range of uses). Typically, the original programmer is not around and the test cases incomplete. The fact that the code is a mess dramatically increases the effort needed to make any change and the risk of introducing errors. Often, messy old code runs unnecessarily slowly because it requires outdated compilers and cannot take advantage of modern hardware. In many cases, automated \u201cmodernizer\u201d-style tool support would be required for major upgrade efforts. The purpose of modernizing code is to simplify adding new functionality, to ease maintenance, and to increase performance (throughput or latency), and to better utilize modern hardware. Making code \u201clook pretty\u201d or \u201cfollow modern style\u201d are not by themselves reasons for change. There are risks implied by every change and costs (including the cost of lost opportunities) implied by having an outdated code base. The cost reductions must outweigh the risks. But how? There is no one approach to modernizing code. How best to do it depends on the code, the pressure for updates, the backgrounds of the developers, and the available tool. Here are some (very general) ideas: The ideal is \u201cjust upgrade everything.\u201d That gives the most benefits for the shortest total time. In most circumstances, it is also impossible. We could convert a code base module for module, but any rules that affects interfaces (especially ABIs), such as use span , cannot be done on a per-module basis. We could convert code \u201cbottom up\u201d starting with the rules we estimate will give the greatest benefits and/or the least trouble in a given code base. We could start by focusing on the interfaces, e.g., make sure that no resources are lost and no pointer is misused. This would be a set of changes across the whole code base, but would most likely have huge benefits. Afterwards, code hidden behind those interfaces can be gradually modernized without affecting other code. Whichever way you choose, please note that the most advantages come with the highest conformance to the guidelines. The guidelines are not a random set of unrelated rules where you can randomly pick and choose with an expectation of success. We would dearly love to hear about experience and about tools used. Modernization can be much faster, simpler, and safer when supported with analysis tools and even code transformation tools. Appendix C: Discussion # This section contains follow-up material on rules and sets of rules. In particular, here we present further rationale, longer examples, and discussions of alternatives. Discussion: Define and initialize member variables in the order of member declaration # Member variables are always initialized in the order they are declared in the class definition, so write them in that order in the constructor initialization list. Writing them in a different order just makes the code confusing because it won\u2019t run in the order you see, and that can make it hard to see order-dependent bugs. class Employee { string email, first, last; public: Employee(const char* firstName, const char* lastName); // ... }; Employee::Employee(const char* firstName, const char* lastName) : first(firstName), last(lastName), // BAD: first and last not yet constructed email(first + \".\" + last + \"@acme.com\") {} In this example, email will be constructed before first and last because it is declared first. That means its constructor will attempt to use first and last too soon \u2013 not just before they are set to the desired values, but before they are constructed at all. If the class definition and the constructor body are in separate files, the long-distance influence that the order of member variable declarations has over the constructor\u2019s correctness will be even harder to spot. References : Cline99 \u00a722.03-11, Dewhurst03 \u00a752-53, Koenig97 \u00a74, Lakos96 \u00a710.3.5, Meyers97 \u00a713, Murray93 \u00a72.1.3, Sutter00 \u00a747 Discussion: Use of = , {} , and () as initializers # ??? Discussion: Use a factory function if you need \u201cvirtual behavior\u201d during initialization # If your design wants virtual dispatch into a derived class from a base class constructor or destructor for functions like f and g , you need other techniques, such as a post-constructor \u2013 a separate member function the caller must invoke to complete initialization, which can safely call f and g because in member functions virtual calls behave normally. Some techniques for this are shown in the References. Here\u2019s a non-exhaustive list of options: Pass the buck: Just document that user code must call the post-initialization function right after constructing an object. Post-initialize lazily: Do it during the first call of a member function. A Boolean flag in the base class tells whether or not post-construction has taken place yet. Use virtual base class semantics: Language rules dictate that the constructor most-derived class decides which base constructor will be invoked; you can use that to your advantage. (See Taligent94 .) Use a factory function: This way, you can easily force a mandatory invocation of a post-constructor function. Here is an example of the last option: class B { public: B() { /* ... */ f(); // BAD: C.82: Don't call virtual functions in constructors and destructors /* ... */ } virtual void f() = 0; }; class B { protected: class Token {}; public: // constructor needs to be public so that make_shared can access it. // protected access level is gained by requiring a Token. explicit B(Token) { /* ... */ } // create an imperfectly initialized object virtual void f() = 0; template<class T> static shared_ptr<T> create() // interface for creating shared objects { auto p = make_shared<T>(typename T::Token{}); p->post_initialize(); return p; } protected: virtual void post_initialize() // called right after construction { /* ... */ f(); /* ... */ } // GOOD: virtual dispatch is safe } }; class D : public B { // some derived class protected: class Token {}; public: // constructor needs to be public so that make_shared can access it. // protected access level is gained by requiring a Token. explicit D(Token) : B{ B::Token{} } {} void f() override { /* ... */ }; protected: template<class T> friend shared_ptr<T> B::create(); }; shared_ptr<D> p = D::create<D>(); // creating a D object This design requires the following discipline: Derived classes such as D must not expose a publicly callable constructor. Otherwise, D \u2018s users could create D objects that don\u2019t invoke post_initialize . Allocation is limited to operator new . B can, however, override new (see Items 45 and 46 in SuttAlex05 ). D must define a constructor with the same parameters that B selected. Defining several overloads of create can assuage this problem, however; and the overloads can even be templated on the argument types. If the requirements above are met, the design guarantees that post_initialize has been called for any fully constructed B -derived object. post_initialize doesn\u2019t need to be virtual; it can, however, invoke virtual functions freely. In summary, no post-construction technique is perfect. The worst techniques dodge the whole issue by simply asking the caller to invoke the post-constructor manually. Even the best require a different syntax for constructing objects (easy to check at compile time) and/or cooperation from derived class authors (impossible to check at compile time). References : Alexandrescu01 \u00a73, Boost , Dewhurst03 \u00a775, Meyers97 \u00a746, Stroustrup00 \u00a715.4.3, Taligent94 Discussion: Make base class destructors public and virtual, or protected and nonvirtual # Should destruction behave virtually? That is, should destruction through a pointer to a base class be allowed? If yes, then base \u2018s destructor must be public in order to be callable, and virtual otherwise calling it results in undefined behavior. Otherwise, it should be protected so that only derived classes can invoke it in their own destructors, and nonvirtual since it doesn\u2019t need to behave virtually. Example # The common case for a base class is that it\u2019s intended to have publicly derived classes, and so calling code is just about sure to use something like a shared_ptr<base> : class Base { public: ~Base(); // BAD, not virtual virtual ~Base(); // GOOD // ... }; class Derived : public Base { /* ... */ }; { unique_ptr<Base> pb = make_unique<Derived>(); // ... } // ~pb invokes correct destructor only when ~Base is virtual In rarer cases, such as policy classes, the class is used as a base class for convenience, not for polymorphic behavior. It is recommended to make those destructors protected and nonvirtual: class My_policy { public: virtual ~My_policy(); // BAD, public and virtual protected: ~My_policy(); // GOOD // ... }; template<class Policy> class customizable : Policy { /* ... */ }; // note: private inheritance Note # This simple guideline illustrates a subtle issue and reflects modern uses of inheritance and object-oriented design principles. For a base class Base , calling code might try to destroy derived objects through pointers to Base , such as when using a unique_ptr<Base> . If Base \u2018s destructor is public and nonvirtual (the default), it can be accidentally called on a pointer that actually points to a derived object, in which case the behavior of the attempted deletion is undefined. This state of affairs has led older coding standards to impose a blanket requirement that all base class destructors must be virtual. This is overkill (even if it is the common case); instead, the rule should be to make base class destructors virtual if and only if they are public. To write a base class is to define an abstraction (see Items 35 through 37). Recall that for each member function participating in that abstraction, you need to decide: Whether it should behave virtually or not. Whether it should be publicly available to all callers using a pointer to Base or else be a hidden internal implementation detail. As described in Item 39, for a normal member function, the choice is between allowing it to be called via a pointer to Base nonvirtually (but possibly with virtual behavior if it invokes virtual functions, such as in the NVI or Template Method patterns), virtually, or not at all. The NVI pattern is a technique to avoid public virtual functions. Destruction can be viewed as just another operation, albeit with special semantics that make nonvirtual calls dangerous or wrong. For a base class destructor, therefore, the choice is between allowing it to be called via a pointer to Base virtually or not at all; \u201cnonvirtually\u201d is not an option. Hence, a base class destructor is virtual if it can be called (i.e., is public), and nonvirtual otherwise. Note that the NVI pattern cannot be applied to the destructor because constructors and destructors cannot make deep virtual calls. (See Items 39 and 55.) Corollary: When writing a base class, always write a destructor explicitly, because the implicitly generated one is public and nonvirtual. You can always =default the implementation if the default body is fine and you\u2019re just writing the function to give it the proper visibility and virtuality. Exception # Some component architectures (e.g., COM and CORBA) don\u2019t use a standard deletion mechanism, and foster different protocols for object disposal. Follow the local patterns and idioms, and adapt this guideline as appropriate. Consider also this rare case: B is both a base class and a concrete class that can be instantiated by itself, and so the destructor must be public for B objects to be created and destroyed. Yet B also has no virtual functions and is not meant to be used polymorphically, and so although the destructor is public it does not need to be virtual. Then, even though the destructor has to be public, there can be great pressure to not make it virtual because as the first virtual function it would incur all the run-time type overhead when the added functionality should never be needed. In this rare case, you could make the destructor public and nonvirtual but clearly document that further-derived objects must not be used polymorphically as B \u2018s. This is what was done with std::unary_function . In general, however, avoid concrete base classes (see Item 35). For example, unary_function is a bundle-of-typedefs that was never intended to be instantiated standalone. It really makes no sense to give it a public destructor; a better design would be to follow this Item\u2019s advice and give it a protected nonvirtual destructor. References : C++CS Item 50, Cargill92 pp. 77-79, 207, Cline99 \u00a721.06, 21.12-13, Henricson97 pp. 110-114, Koenig97 Chapters 4, 11, Meyers97 \u00a714, Stroustrup00 \u00a712.4.2, Sutter02 \u00a727, Sutter04 \u00a718 Discussion: Usage of noexcept # ??? Discussion: Destructors, deallocation, and swap must never fail # Never allow an error to be reported from a destructor, a resource deallocation function (e.g., operator delete ), or a swap function using throw . It is nearly impossible to write useful code if these operations can fail, and even if something does go wrong it nearly never makes any sense to retry. Specifically, types whose destructors may throw an exception are flatly forbidden from use with the C++ Standard Library. Most destructors are now implicitly noexcept by default. Example # class Nefarious { public: Nefarious() { /* code that could throw */ } // ok ~Nefarious() { /* code that could throw */ } // BAD, should not throw // ... }; Nefarious objects are hard to use safely even as local variables: void test(string& s) { Nefarious n; // trouble brewing string copy = s; // copy the string } // destroy copy and then n Here, copying s could throw, and if that throws and if n \u2018s destructor then also throws, the program will exit via std::terminate because two exceptions can\u2019t be propagated simultaneously. Classes with Nefarious members or bases are also hard to use safely, because their destructors must invoke Nefarious \u2018 destructor, and are similarly poisoned by its poor behavior: class Innocent_bystander { Nefarious member; // oops, poisons the enclosing class's destructor // ... }; void test(string& s) { Innocent_bystander i; // more trouble brewing string copy2 = s; // copy the string } // destroy copy and then i Here, if constructing copy2 throws, we have the same problem because i \u2018s destructor now also can throw, and if so we\u2019ll invoke std::terminate . You can\u2019t reliably create global or static Nefarious objects either: static Nefarious n; // oops, any destructor exception can't be caught You can\u2019t reliably create arrays of Nefarious : void test() { std::array<Nefarious, 10> arr; // this line can std::terminate(!) } The behavior of arrays is undefined in the presence of destructors that throw because there is no reasonable rollback behavior that could ever be devised. Just think: What code can the compiler generate for constructing an arr where, if the fourth object\u2019s constructor throws, the code has to give up and in its cleanup mode tries to call the destructors of the already-constructed objects \u2026 and one or more of those destructors throws? There is no satisfactory answer. You can\u2019t use Nefarious objects in standard containers: std::vector<Nefarious> vec(10); // this line can std::terminate() The standard library forbids all destructors used with it from throwing. You can\u2019t store Nefarious objects in standard containers or use them with any other part of the standard library. Note # These are key functions that must not fail because they are necessary for the two key operations in transactional programming: to back out work if problems are encountered during processing, and to commit work if no problems occur. If there\u2019s no way to safely back out using no-fail operations, then no-fail rollback is impossible to implement. If there\u2019s no way to safely commit state changes using a no-fail operation (notably, but not limited to, swap ), then no-fail commit is impossible to implement. Consider the following advice and requirements found in the C++ Standard: If a destructor called during stack unwinding exits with an exception, terminate is called (15.5.1). So destructors should generally catch exceptions and not let them propagate out of the destructor. \u2013 C++03 \u00a715.2(3) No destructor operation defined in the C++ Standard Library (including the destructor of any type that is used to instantiate a standard-library template) will throw an exception. \u2013 C++03 \u00a717.4.4.8(3) Deallocation functions, including specifically overloaded operator delete and operator delete[] , fall into the same category, because they too are used during cleanup in general, and during exception handling in particular, to back out of partial work that needs to be undone. Besides destructors and deallocation functions, common error-safety techniques rely also on swap operations never failing \u2013 in this case, not because they are used to implement a guaranteed rollback, but because they are used to implement a guaranteed commit. For example, here is an idiomatic implementation of operator= for a type T that performs copy construction followed by a call to a no-fail swap : T& T::operator=(const T& other) { auto temp = other; swap(temp); return *this; } (See also Item 56. ???) Fortunately, when releasing a resource, the scope for failure is definitely smaller. If using exceptions as the error reporting mechanism, make sure such functions handle all exceptions and other errors that their internal processing might generate. (For exceptions, simply wrap everything sensitive that your destructor does in a try/catch(...) block.) This is particularly important because a destructor might be called in a crisis situation, such as failure to allocate a system resource (e.g., memory, files, locks, ports, windows, or other system objects). When using exceptions as your error handling mechanism, always document this behavior by declaring these functions noexcept . (See Item 75.) References : C++CS Item 51; C++03 \u00a715.2(3), \u00a717.4.4.8(3), Meyers96 \u00a711, Stroustrup00 \u00a714.4.7, \u00a7E.2-4, Sutter00 \u00a78, \u00a716, Sutter02 \u00a718-19 Define Copy, move, and destroy consistently # Reason # ??? Note # If you define a copy constructor, you must also define a copy assignment operator. Note # If you define a move constructor, you must also define a move assignment operator. Example # class X { // ... public: X(const X&) { /* stuff */ } // BAD: failed to also define a copy assignment operator X(x&&) noexcept { /* stuff */ } // BAD: failed to also define a move assignment operator }; X x1; X x2 = x1; // ok x2 = x1; // pitfall: either fails to compile, or does something suspicious If you define a destructor, you should not use the compiler-generated copy or move operation; you probably need to define or suppress copy and/or move. class X { HANDLE hnd; // ... public: ~X() { /* custom stuff, such as closing hnd */ } // suspicious: no mention of copying or moving -- what happens to hnd? }; X x1; X x2 = x1; // pitfall: either fails to compile, or does something suspicious x2 = x1; // pitfall: either fails to compile, or does something suspicious If you define copying, and any base or member has a type that defines a move operation, you should also define a move operation. class X { string s; // defines more efficient move operations // ... other data members ... public: X(const X&) { /* stuff */ } X& operator=(const X&) { /* stuff */ } // BAD: failed to also define a move construction and move assignment // (why wasn't the custom \"stuff\" repeated here?) }; X test() { X local; // ... return local; // pitfall: will be inefficient and/or do the wrong thing } If you define any of the copy constructor, copy assignment operator, or destructor, you probably should define the others. Note # If you need to define any of these five functions, it means you need it to do more than its default behavior \u2013 and the five are asymmetrically interrelated. Here\u2019s how: If you write/disable either of the copy constructor or the copy assignment operator, you probably need to do the same for the other: If one does \u201cspecial\u201d work, probably so should the other because the two functions should have similar effects. (See Item 53, which expands on this point in isolation.) If you explicitly write the copying functions, you probably need to write the destructor: If the \u201cspecial\u201d work in the copy constructor is to allocate or duplicate some resource (e.g., memory, file, socket), you need to deallocate it in the destructor. If you explicitly write the destructor, you probably need to explicitly write or disable copying: If you have to write a non-trivial destructor, it\u2019s often because you need to manually release a resource that the object held. If so, it is likely that those resources require careful duplication, and then you need to pay attention to the way objects are copied and assigned, or disable copying completely. In many cases, holding properly encapsulated resources using RAII \u201cowning\u201d objects can eliminate the need to write these operations yourself. (See Item 13.) Prefer compiler-generated (including =default ) special members; only these can be classified as \u201ctrivial\u201d, and at least one major standard library vendor heavily optimizes for classes having trivial special members. This is likely to become common practice. Exceptions : When any of the special functions are declared only to make them nonpublic or virtual, but without special semantics, it doesn\u2019t imply that the others are needed. In rare cases, classes that have members of strange types (such as reference members) are an exception because they have peculiar copy semantics. In a class holding a reference, you likely need to write the copy constructor and the assignment operator, but the default destructor already does the right thing. (Note that using a reference member is almost always wrong.) References : C++CS Item 52; Cline99 \u00a730.01-14, Koenig97 \u00a74, Stroustrup00 \u00a75.5, \u00a710.4, SuttHysl04b Resource management rule summary: Provide strong resource safety; that is, never leak anything that you think of as a resource Never throw while holding a resource not owned by a handle A \u201craw\u201d pointer or reference is never a resource handle Never let a pointer outlive the object it points to Use templates to express containers (and other resource handles) Return containers by value (relying on move or copy elision for efficiency) If a class is a resource handle, it needs a constructor, a destructor, and copy and/or move operations If a class is a container, give it an initializer-list constructor Discussion: Provide strong resource safety; that is, never leak anything that you think of as a resource # Reason # Prevent leaks. Leaks can lead to performance degradation, mysterious error, system crashes, and security violations. Alternative formulation : Have every resource represented as an object of some class managing its lifetime. Example # template<class T> class Vector { // ... private: T* elem; // sz elements on the free store, owned by the class object int sz; }; This class is a resource handle. It manages the lifetime of the T s. To do so, Vector must define or delete the set of special operations (constructors, a destructor, etc.). Example # ??? \"odd\" non-memory resource ??? Enforcement # The basic technique for preventing leaks is to have every resource owned by a resource handle with a suitable destructor. A checker can find \u201cnaked new s\u201d. Given a list of C-style allocation functions (e.g., fopen() ), a checker can also find uses that are not managed by a resource handle. In general, \u201cnaked pointers\u201d can be viewed with suspicion, flagged, and/or analyzed. A complete list of resources cannot be generated without human input (the definition of \u201ca resource\u201d is necessarily too general), but a tool can be \u201cparameterized\u201d with a resource list. Discussion: Never throw while holding a resource not owned by a handle # Reason # That would be a leak. Example # void f(int i) { FILE* f = fopen(\"a file\", \"r\"); ifstream is { \"another file\" }; // ... if (i == 0) return; // ... fclose(f); } If i == 0 the file handle for a file is leaked. On the other hand, the ifstream for another file will correctly close its file (upon destruction). If you must use an explicit pointer, rather than a resource handle with specific semantics, use a unique_ptr or a shared_ptr with a custom deleter: void f(int i) { unique_ptr<FILE, int(*)(FILE*)> f(fopen(\"a file\", \"r\"), fclose); // ... if (i == 0) return; // ... } Better: void f(int i) { ifstream input {\"a file\"}; // ... if (i == 0) return; // ... } Enforcement # A checker must consider all \u201cnaked pointers\u201d suspicious. A checker probably must rely on a human-provided list of resources. For starters, we know about the standard-library containers, string , and smart pointers. The use of span and string_span should help a lot (they are not resource handles). Discussion: A \u201craw\u201d pointer or reference is never a resource handle # Reason # To be able to distinguish owners from views. Note # This is independent of how you \u201cspell\u201d pointer: T* , T& , Ptr<T> and Range<T> are not owners. Discussion: Never let a pointer outlive the object it points to # Reason # To avoid extremely hard-to-find errors. Dereferencing such a pointer is undefined behavior and could lead to violations of the type system. Example # string* bad() // really bad { vector<string> v = { \"This\", \"will\", \"cause\", \"trouble\", \"!\" }; // leaking a pointer into a destroyed member of a destroyed object (v) return &v[0]; } void use() { string* p = bad(); vector<int> xx = {7, 8, 9}; // undefined behavior: x may not be the string \"This\" string x = *p; // undefined behavior: we don't know what (if anything) is allocated a location p *p = \"Evil!\"; } The string s of v are destroyed upon exit from bad() and so is v itself. The returned pointer points to unallocated memory on the free store. This memory (pointed into by p ) may have been reallocated by the time *p is executed. There may be no string to read and a write through p could easily corrupt objects of unrelated types. Enforcement # Most compilers already warn about simple cases and have the information to do more. Consider any pointer returned from a function suspect. Use containers, resource handles, and views (e.g., span known not to be resource handles) to lower the number of cases to be examined. For starters, consider every class with a destructor as resource handle. Discussion: Use templates to express containers (and other resource handles) # Reason # To provide statically type-safe manipulation of elements. Example # template<typename T> class Vector { // ... T* elem; // point to sz elements of type T int sz; }; Discussion: Return containers by value (relying on move or copy elision for efficiency) # Reason # To simplify code and eliminate a need for explicit memory management. To bring an object into a surrounding scope, thereby extending its lifetime. See also : F.20, the general item about \u201cout\u201d output values Example # vector<int> get_large_vector() { return ...; } auto v = get_large_vector(); // return by value is ok, most modern compilers will do copy elision Exception # See the Exceptions in F.20 . Enforcement # Check for pointers and references returned from functions and see if they are assigned to resource handles (e.g., to a unique_ptr ). Discussion: If a class is a resource handle, it needs a constructor, a destructor, and copy and/or move operations # Reason # To provide complete control of the lifetime of the resource. To provide a coherent set of operations on the resource. Example # ??? Messing with pointers Note # If all members are resource handles, rely on the default special operations where possible. template<typename T> struct Named { string name; T value; }; Now Named has a default constructor, a destructor, and efficient copy and move operations, provided T has. Enforcement # In general, a tool cannot know if a class is a resource handle. However, if a class has some of the default operations , it should have all, and if a class has a member that is a resource handle, it should be considered as resource handle. Discussion: If a class is a container, give it an initializer-list constructor # Reason # It is common to need an initial set of elements. Example # template<typename T> class Vector { public: Vector(std::initializer_list<T>); // ... }; Vector<string> vs { \"Nygaard\", \"Ritchie\" }; Enforcement # When is a class a container? ??? Appendix D: Supporting tools # This section contains a list of tools that directly support adoption of the C++ Core Guidelines. This list is not intended to be an exhaustive list of tools that are helpful in writing good C++ code. If a tool is designed specifically to support and links to the C++ Core Guidelines it is a candidate for inclusion. Tools: Clang-tidy # Clang-tidy has a set of rules that specifically enforce the C++ Core Guidelines. These rules are named in the pattern cppcoreguidelines-* . Tools: CppCoreCheck # The Microsoft compiler\u2019s C++ code analysis contains a set of rules specifically aimed at enforcement of the C++ Core Guidelines. Glossary # A relatively informal definition of terms used in the guidelines (based off the glossary in Programming: Principles and Practice using C++ ) More information on many topics about C++ can be found on the Standard C++ Foundation \u2018s site. ABI : Application Binary Interface, a specification for a specific hardware platform combined with the operating system. Contrast with API. abstract class : a class that cannot be directly used to create objects; often used to define an interface to derived classes. A class is made abstract by having a pure virtual function or only protected constructors. abstraction : a description of something that selectively and deliberately ignores (hides) details (e.g., implementation details); selective ignorance. address : a value that allows us to find an object in a computer\u2019s memory. algorithm : a procedure or formula for solving a problem; a finite series of computational steps to produce a result. alias : an alternative way of referring to an object; often a name, pointer, or reference. API : Application Programming Interface, a set of functions that form the communication between various software components. Contrast with ABI. application : a program or a collection of programs that is considered an entity by its users. approximation : something (e.g., a value or a design) that is close to the perfect or ideal (value or design). Often an approximation is a result of trade-offs among ideals. argument : a value passed to a function or a template, in which it is accessed through a parameter. array : a homogeneous sequence of elements, usually numbered, e.g., [0:max) . assertion : a statement inserted into a program to state (assert) that something must always be true at this point in the program. base class : a class used as the base of a class hierarchy. Typically a base class has one or more virtual functions. bit : the basic unit of information in a computer. A bit can have the value 0 or the value 1. bug : an error in a program. byte : the basic unit of addressing in most computers. Typically, a byte holds 8 bits. class : a user-defined type that may contain data members, function members, and member types. code : a program or a part of a program; ambiguously used for both source code and object code. compiler : a program that turns source code into object code. complexity : a hard-to-precisely-define notion or measure of the difficulty of constructing a solution to a problem or of the solution itself. Sometimes complexity is used to (simply) mean an estimate of the number of operations needed to execute an algorithm. computation : the execution of some code, usually taking some input and producing some output. concept : (1) a notion, and idea; (2) a set of requirements, usually for a template argument. concrete class : class for which objects can be created using usual construction syntax (e.g., on the stack) and the resulting object behaves much like an int as it comes to copying, comparison, and such (as opposed to a base class in a hierarchy). constant : a value that cannot be changed (in a given scope); not mutable. constructor : an operation that initializes (\u201cconstructs\u201d) an object. Typically a constructor establishes an invariant and often acquires resources needed for an object to be used (which are then typically released by a destructor). container : an object that holds elements (other objects). copy : an operation that makes two object have values that compare equal. See also move. correctness : a program or a piece of a program is correct if it meets its specification. Unfortunately, a specification can be incomplete or inconsistent, or can fail to meet users\u2019 reasonable expectations. Thus, to produce acceptable code, we sometimes have to do more than just follow the formal specification. cost : the expense (e.g., in programmer time, run time, or space) of producing a program or of executing it. Ideally, cost should be a function of complexity. customization point : ??? data : values used in a computation. debugging : the act of searching for and removing errors from a program; usually far less systematic than testing. declaration : the specification of a name with its type in a program. definition : a declaration of an entity that supplies all information necessary to complete a program using the entity. Simplified definition: a declaration that allocates memory. derived class : a class derived from one or more base classes. design : an overall description of how a piece of software should operate to meet its specification. destructor : an operation that is implicitly invoked (called) when an object is destroyed (e.g., at the end of a scope). Often, it releases resources. encapsulation : protecting something meant to be private (e.g., implementation details) from unauthorized access. error : a mismatch between reasonable expectations of program behavior (often expressed as a requirement or a users\u2019 guide) and what a program actually does. executable : a program ready to be run (executed) on a computer. feature creep : a tendency to add excess functionality to a program \u201cjust in case.\u201d file : a container of permanent information in a computer. floating-point number : a computer\u2019s approximation of a real number, such as 7.93 and 10.78e-3. function : a named unit of code that can be invoked (called) from different parts of a program; a logical unit of computation. generic programming : a style of programming focused on the design and efficient implementation of algorithms. A generic algorithm will work for all argument types that meet its requirements. In C++, generic programming typically uses templates. global variable : technically, a named object in namespace scope. handle : a class that allows access to another through a member pointer or reference. See also resource, copy, move. header : a file containing declarations used to share interfaces between parts of a program. hiding : the act of preventing a piece of information from being directly seen or accessed. For example, a name from a nested (inner) scope can prevent that same name from an outer (enclosing) scope from being directly used. ideal : the perfect version of something we are striving for. Usually we have to make trade-offs and settle for an approximation. implementation : (1) the act of writing and testing code; (2) the code that implements a program. infinite loop : a loop where the termination condition never becomes true. See iteration. infinite recursion : a recursion that doesn\u2019t end until the machine runs out of memory to hold the calls. In reality, such recursion is never infinite but is terminated by some hardware error. information hiding : the act of separating interface and implementation, thus hiding implementation details not meant for the user\u2019s attention and providing an abstraction. initialize : giving an object its first (initial) value. input : values used by a computation (e.g., function arguments and characters typed on a keyboard). integer : a whole number, such as 42 and -99. interface : a declaration or a set of declarations specifying how a piece of code (such as a function or a class) can be called. invariant : something that must be always true at a given point (or points) of a program; typically used to describe the state (set of values) of an object or the state of a loop before entry into the repeated statement. iteration : the act of repeatedly executing a piece of code; see recursion. iterator : an object that identifies an element of a sequence. ISO : International Organization for Standardization. The C++ language is an ISO standard, ISO/IEC 14882. More information at iso.org . library : a collection of types, functions, classes, etc. implementing a set of facilities (abstractions) meant to be potentially used as part of more that one program. lifetime : the time from the initialization of an object until it becomes unusable (goes out of scope, is deleted, or the program terminates). linker : a program that combines object code files and libraries into an executable program. literal : a notation that directly specifies a value, such as 12 specifying the integer value \u201ctwelve.\u201d loop : a piece of code executed repeatedly; in C++, typically a for-statement or a while -statement. move : an operation that transfers a value from one object to another leaving behind a value representing \u201cempty.\u201d See also copy. mutable : changeable; the opposite of immutable, constant, and invariable. object : (1) an initialized region of memory of a known type which holds a value of that type; (2) a region of memory. object code : output from a compiler intended as input for a linker (for the linker to produce executable code). object file : a file containing object code. object-oriented programming : (OOP) a style of programming focused on the design and use of classes and class hierarchies. operation : something that can perform some action, such as a function and an operator. output : values produced by a computation (e.g., a function result or lines of characters written on a screen). overflow : producing a value that cannot be stored in its intended target. overload : defining two functions or operators with the same name but different argument (operand) types. override : defining a function in a derived class with the same name and argument types as a virtual function in the base class, thus making the function callable through the interface defined by the base class. owner : an object responsible for releasing a resource. paradigm : a somewhat pretentious term for design or programming style; often used with the (erroneous) implication that there exists a paradigm that is superior to all others. parameter : a declaration of an explicit input to a function or a template. When called, a function can access the arguments passed through the names of its parameters. pointer : (1) a value used to identify a typed object in memory; (2) a variable holding such a value. post-condition : a condition that must hold upon exit from a piece of code, such as a function or a loop. pre-condition : a condition that must hold upon entry into a piece of code, such as a function or a loop. program : code (possibly with associated data) that is sufficiently complete to be executed by a computer. programming : the art of expressing solutions to problems as code. programming language : a language for expressing programs. pseudo code : a description of a computation written in an informal notation rather than a programming language. pure virtual function : a virtual function that must be overridden in a derived class. RAII : (\u201cResource Acquisition Is Initialization\u201d) a basic technique for resource management based on scopes. range : a sequence of values that can be described by a start point and an end point. For example, [0:5) means the values 0, 1, 2, 3, and 4. recursion : the act of a function calling itself; see also iteration. reference : (1) a value describing the location of a typed value in memory; (2) a variable holding such a value. regular expression : a notation for patterns in character strings. regular : a type that behaves similarly to built-in types like int and can be compared with == . In particular, an object of a regular type can be copied and the result of a copy is a separate object that compares equal to the original. See also semiregular type . requirement : (1) a description of the desired behavior of a program or part of a program; (2) a description of the assumptions a function or template makes of its arguments. resource : something that is acquired and must later be released, such as a file handle, a lock, or memory. See also handle, owner. rounding : conversion of a value to the mathematically nearest value of a less precise type. RTTI : Run-Time Type Information. ??? scope : the region of program text (source code) in which a name can be referred to. semiregular : a type that behaves roughly like an built-in type like int , but possibly without a == operator. See also regular type . sequence : elements that can be visited in a linear order. software : a collection of pieces of code and associated data; often used interchangeably with program. source code : code as produced by a programmer and (in principle) readable by other programmers. source file : a file containing source code. specification : a description of what a piece of code should do. standard : an officially agreed upon definition of something, such as a programming language. state : a set of values. STL : the containers, iterators, and algorithms part of the standard library. string : a sequence of characters. style : a set of techniques for programming leading to a consistent use of language features; sometimes used in a very restricted sense to refer just to low-level rules for naming and appearance of code. subtype : derived type; a type that has all the properties of a type and possibly more. supertype : base type; a type that has a subset of the properties of a type. system : (1) a program or a set of programs for performing a task on a computer; (2) a shorthand for \u201coperating system\u201d, that is, the fundamental execution environment and tools for a computer. TS : Technical Specification , A Technical Specification addresses work still under technical development, or where it is believed that there will be a future, but not immediate, possibility of agreement on an International Standard. A Technical Specification is published for immediate use, but it also provides a means to obtain feedback. The aim is that it will eventually be transformed and republished as an International Standard. template : a class or a function parameterized by one or more types or (compile-time) values; the basic C++ language construct supporting generic programming. testing : a systematic search for errors in a program. trade-off : the result of balancing several design and implementation criteria. truncation : loss of information in a conversion from a type into another that cannot exactly represent the value to be converted. type : something that defines a set of possible values and a set of operations for an object. uninitialized : the (undefined) state of an object before it is initialized. unit : (1) a standard measure that gives meaning to a value (e.g., km for a distance); (2) a distinguished (e.g., named) part of a larger whole. use case : a specific (typically simple) use of a program meant to test its functionality and demonstrate its purpose. value : a set of bits in memory interpreted according to a type. variable : a named object of a given type; contains a value unless uninitialized. virtual function : a member function that can be overridden in a derived class. word : a basic unit of memory in a computer, often the unit used to hold an integer. To-do: Unclassified proto-rules # This is our to-do list. Eventually, the entries will become rules or parts of rules. Alternatively, we will decide that no change is needed and delete the entry. No long-distance friendship Should physical design (what\u2019s in a file) and large-scale design (libraries, groups of libraries) be addressed? Namespaces Avoid using directives in the global scope (except for std, and other \u201cfundamental\u201d namespaces (e.g. experimental)) How granular should namespaces be? All classes/functions designed to work together and released together (as defined in Sutter/Alexandrescu) or something narrower or wider? Should there be inline namespaces (\u00e0 la std::literals::*_literals )? Avoid implicit conversions Const member functions should be thread safe \u2026 aka, but I don\u2019t really change the variable, just assign it a value the first time it\u2019s called \u2026 argh Always initialize variables, use initialization lists for member variables. Anyone writing a public interface which takes or returns void* should have their toes set on fire. That one has been a personal favorite of mine for a number of years. :) Use const -ness wherever possible: member functions, variables and (yippee) const_iterators Use auto (size) vs. {initializers} vs. {Extent{size}} Don\u2019t overabstract Never pass a pointer down the call stack falling through a function bottom Should there be guidelines to choose between polymorphisms? YES. classic (virtual functions, reference semantics) vs. Sean Parent style (value semantics, type-erased, kind of like std::function ) vs. CRTP/static? YES Perhaps even vs. tag dispatch? should virtual calls be banned from ctors/dtors in your guidelines? YES. A lot of people ban them, even though I think it\u2019s a big strength of C++ that they are ??? -preserving (D disappointed me so much when it went the Java way). WHAT WOULD BE A GOOD EXAMPLE? Speaking of lambdas, what would weigh in on the decision between lambdas and (local?) classes in algorithm calls and other callback scenarios? And speaking of std::bind , Stephen T. Lavavej criticizes it so much I\u2019m starting to wonder if it is indeed going to fade away in future. Should lambdas be recommended instead? What to do with leaks out of temporaries? : p = (s1 + s2).c_str(); pointer/iterator invalidation leading to dangling pointers: void bad() { int* p = new int[700]; int* q = &p[7]; delete p; vector<int> v(700); int* q2 = &v[7]; v.resize(900); // ... use q and q2 ... } LSP private inheritance vs/and membership avoid static class members variables (race conditions, almost-global variables) Use RAII lock guards ( lock_guard , unique_lock , shared_lock ), never call mutex.lock and mutex.unlock directly (RAII) Prefer non-recursive locks (often used to work around bad reasoning, overhead) Join your threads! (because of std::terminate in destructor if not joined or detached \u2026 is there a good reason to detach threads?) \u2013 ??? could support library provide a RAII wrapper for std::thread ? If two or more mutexes must be acquired at the same time, use std::lock (or another deadlock avoidance algorithm?) When using a condition_variable , always protect the condition by a mutex (atomic bool whose value is set outside of the mutex is wrong!), and use the same mutex for the condition variable itself. Never use atomic_compare_exchange_strong with std::atomic<user-defined-struct> (differences in padding matter, while compare_exchange_weak in a loop converges to stable padding) individual shared_future objects are not thread-safe: two threads cannot wait on the same shared_future object (they can wait on copies of a shared_future that refer to the same shared state) individual shared_ptr objects are not thread-safe: different threads can call non- const member functions on different shared_ptr s that refer to the same shared object, but one thread cannot call a non- const member function of a shared_ptr object while another thread accesses that same shared_ptr object (if you need that, consider atomic_shared_ptr instead) rules for arithmetic Bibliography # [Abrahams01]: D. Abrahams. Exception-Safety in Generic Components . [Alexandrescu01]: A. Alexandrescu. Modern C++ Design (Addison-Wesley, 2001). [C++03]: ISO/IEC 14882:2003(E), Programming Languages \u2014 C++ (updated ISO and ANSI C++ Standard including the contents of (C++98) plus errata corrections). [C++CS]: ??? [Cargill92]: T. Cargill. C++ Programming Style (Addison-Wesley, 1992). [Cline99]: M. Cline, G. Lomow, and M. Girou. C++ FAQs (2ndEdition) (Addison-Wesley, 1999). [Dewhurst03]: S. Dewhurst. C++ Gotchas (Addison-Wesley, 2003). [Henricson97]: M. Henricson and E. Nyquist. Industrial Strength C++ (Prentice Hall, 1997). [Koenig97]: A. Koenig and B. Moo. Ruminations on C++ (Addison-Wesley, 1997). [Lakos96]: J. Lakos. Large-Scale C++ Software Design (Addison-Wesley, 1996). [Meyers96]: S. Meyers. More Effective C++ (Addison-Wesley, 1996). [Meyers97]: S. Meyers. Effective C++ (2 nd Edition) (Addison-Wesley, 1997). [Meyers15]: S. Meyers. Effective Modern C++ (O\u2019Reilly, 2015). [Murray93]: R. Murray. C++ Strategies and Tactics (Addison-Wesley, 1993). [Stroustrup94]: B. Stroustrup. The Design and Evolution of C++ (Addison-Wesley, 1994). [Stroustrup00]: B. Stroustrup. The C++ Programming Language (Special 3rdEdition) (Addison-Wesley, 2000). [Stroustrup05]: B. Stroustrup. A rationale for semantically enhanced library languages . [Stroustrup13]: B. Stroustrup. The C++ Programming Language (4 th Edition) . Addison Wesley 2013. [Stroustrup14]: B. Stroustrup. A Tour of C++ . Addison Wesley 2014. [Stroustrup15]: B. Stroustrup, Herb Sutter, and G. Dos Reis: A brief introduction to C++\u2019s model for type- and resource-safety . [SuttHysl04b]: H. Sutter and J. Hyslop. \u201cCollecting Shared Objects\u201d (C/C++ Users Journal, 22(8), August 2004). [SuttAlex05]: H. Sutter and A. Alexandrescu. C++ Coding Standards. Addison-Wesley 2005. [Sutter00]: H. Sutter. Exceptional C++ (Addison-Wesley, 2000). [Sutter02]: H. Sutter. More Exceptional C++ (Addison-Wesley, 2002). [Sutter04]: H. Sutter. Exceptional C++ Style (Addison-Wesley, 2004). [Taligent94]: Taligent\u2019s Guide to Designing Programs (Addison-Wesley, 1994).","title":"\u539f\u6587"},{"location":"cppcg/CppCoreGuidelines/#c-core-guidelines","text":"June 16, 2019 Editors: Bjarne Stroustrup Herb Sutter This is a living document under continuous improvement. Had it been an open-source (code) project, this would have been release 0.8. Copying, use, modification, and creation of derivative works from this project is licensed under an MIT-style license. Contributing to this project requires agreeing to a Contributor License. See the accompanying LICENSE file for details. We make this project available to \u201cfriendly users\u201d to use, copy, modify, and derive from, hoping for constructive input. Comments and suggestions for improvements are most welcome. We plan to modify and extend this document as our understanding improves and the language and the set of available libraries improve. When commenting, please note the introduction that outlines our aims and general approach. The list of contributors is here . Problems: The sets of rules have not been completely checked for completeness, consistency, or enforceability. Triple question marks (???) mark known missing information Update reference sections; many pre-C++11 sources are too old. For a more-or-less up-to-date to-do list see: To-do: Unclassified proto-rules You can read an explanation of the scope and structure of this Guide or just jump straight in: In: Introduction P: Philosophy I: Interfaces F: Functions C: Classes and class hierarchies Enum: Enumerations R: Resource management ES: Expressions and statements Per: Performance CP: Concurrency and parallelism E: Error handling Con: Constants and immutability T: Templates and generic programming CPL: C-style programming SF: Source files SL: The Standard Library Supporting sections: A: Architectural ideas NR: Non-Rules and myths RF: References Pro: Profiles GSL: Guidelines support library NL: Naming and layout rules FAQ: Answers to frequently asked questions Appendix A: Libraries Appendix B: Modernizing code Appendix C: Discussion Appendix D: Supporting tools Glossary To-do: Unclassified proto-rules You can sample rules for specific language features: assignment: regular types \u2013 prefer initialization \u2013 copy \u2013 move \u2013 other operations \u2013 default class : data \u2013 invariant \u2013 members \u2013 helpers \u2013 concrete types \u2013 ctors, =, and dtors \u2013 hierarchy \u2013 operators concept : rules \u2013 in generic programming \u2013 template arguments \u2013 semantics constructor: invariant \u2013 establish invariant \u2013 throw \u2013 default \u2013 not needed \u2013 explicit \u2013 delegating \u2013 virtual derived class : when to use \u2013 as interface \u2013 destructors \u2013 copy \u2013 getters and setters \u2013 multiple inheritance \u2013 overloading \u2013 slicing \u2013 dynamic_cast destructor: and constructors \u2013 when needed? \u2013 may not fail exception: errors \u2013 throw \u2013 for errors only \u2013 noexcept \u2013 minimize try \u2013 what if no exceptions? for : range-for and for \u2013 for and while \u2013 for-initializer \u2013 empty body \u2013 loop variable \u2013 loop variable type ??? function: naming \u2013 single operation \u2013 no throw \u2013 arguments \u2013 argument passing \u2013 multiple return values \u2013 pointers \u2013 lambdas inline : small functions \u2013 in headers initialization: always \u2013 prefer {} \u2013 lambdas \u2013 in-class initializers \u2013 class members \u2013 factory functions lambda expression: when to use operator: conventional \u2013 avoid conversion operators \u2013 and lambdas public , private , and protected : information hiding \u2013 consistency \u2013 protected static_assert : compile-time checking \u2013 and concepts struct : for organizing data \u2013 use if no invariant \u2013 no private members template : abstraction \u2013 containers \u2013 concepts unsigned : and signed \u2013 bit manipulation virtual : interfaces \u2013 not virtual \u2013 destructor \u2013 never fail You can look at design concepts used to express the rules: assertion: ??? error: ??? exception: exception guarantee (???) failure: ??? invariant: ??? leak: ??? library: ??? precondition: ??? postcondition: ??? resource: ???","title":"C++ Core Guidelines"},{"location":"cppcg/CppCoreGuidelines/#abstract","text":"This document is a set of guidelines for using C++ well. The aim of this document is to help people to use modern C++ effectively. By \u201cmodern C++\u201d we mean effective use of the ISO C++ standard (currently C++17, but almost all of our recommendations also apply to C++14 and C++11). In other words, what would you like your code to look like in 5 years\u2019 time, given that you can start now? In 10 years\u2019 time? The guidelines are focused on relatively high-level issues, such as interfaces, resource management, memory management, and concurrency. Such rules affect application architecture and library design. Following the rules will lead to code that is statically type safe, has no resource leaks, and catches many more programming logic errors than is common in code today. And it will run fast \u2013 you can afford to do things right. We are less concerned with low-level issues, such as naming conventions and indentation style. However, no topic that can help a programmer is out of bounds. Our initial set of rules emphasizes safety (of various forms) and simplicity. They may very well be too strict. We expect to have to introduce more exceptions to better accommodate real-world needs. We also need more rules. You will find some of the rules contrary to your expectations or even contrary to your experience. If we haven\u2019t suggested you change your coding style in any way, we have failed! Please try to verify or disprove rules! In particular, we\u2019d really like to have some of our rules backed up with measurements or better examples. You will find some of the rules obvious or even trivial. Please remember that one purpose of a guideline is to help someone who is less experienced or coming from a different background or language to get up to speed. Many of the rules are designed to be supported by an analysis tool. Violations of rules will be flagged with references (or links) to the relevant rule. We do not expect you to memorize all the rules before trying to write code. One way of thinking about these guidelines is as a specification for tools that happens to be readable by humans. The rules are meant for gradual introduction into a code base. We plan to build tools for that and hope others will too. Comments and suggestions for improvements are most welcome. We plan to modify and extend this document as our understanding improves and the language and the set of available libraries improve.","title":"Abstract"},{"location":"cppcg/CppCoreGuidelines/#in-introduction","text":"This is a set of core guidelines for modern C++ (currently C++17) taking likely future enhancements and ISO Technical Specifications (TSs) into account. The aim is to help C++ programmers to write simpler, more efficient, more maintainable code. Introduction summary: In.target: Target readership In.aims: Aims In.not: Non-aims In.force: Enforcement In.struct: The structure of this document In.sec: Major sections","title":"In: Introduction"},{"location":"cppcg/CppCoreGuidelines/#intarget-target-readership","text":"All C++ programmers. This includes programmers who might consider C .","title":"In.target: Target readership"},{"location":"cppcg/CppCoreGuidelines/#inaims-aims","text":"The purpose of this document is to help developers to adopt modern C++ (currently C++17) and to achieve a more uniform style across code bases. We do not suffer the delusion that every one of these rules can be effectively applied to every code base. Upgrading old systems is hard. However, we do believe that a program that uses a rule is less error-prone and more maintainable than one that does not. Often, rules also lead to faster/easier initial development. As far as we can tell, these rules lead to code that performs as well or better than older, more conventional techniques; they are meant to follow the zero-overhead principle (\u201cwhat you don\u2019t use, you don\u2019t pay for\u201d or \u201cwhen you use an abstraction mechanism appropriately, you get at least as good performance as if you had handcoded using lower-level language constructs\u201d). Consider these rules ideals for new code, opportunities to exploit when working on older code, and try to approximate these ideals as closely as feasible. Remember:","title":"In.aims: Aims"},{"location":"cppcg/CppCoreGuidelines/#in0-dont-panic","text":"Take the time to understand the implications of a guideline rule on your program. These guidelines are designed according to the \u201csubset of superset\u201d principle ( Stroustrup05 ). They do not simply define a subset of C++ to be used (for reliability, safety, performance, or whatever). Instead, they strongly recommend the use of a few simple \u201cextensions\u201d ( library components ) that make the use of the most error-prone features of C++ redundant, so that they can be banned (in our set of rules). The rules emphasize static type safety and resource safety. For that reason, they emphasize possibilities for range checking, for avoiding dereferencing nullptr , for avoiding dangling pointers, and the systematic use of exceptions (via RAII). Partly to achieve that and partly to minimize obscure code as a source of errors, the rules also emphasize simplicity and the hiding of necessary complexity behind well-specified interfaces. Many of the rules are prescriptive. We are uncomfortable with rules that simply state \u201cdon\u2019t do that!\u201d without offering an alternative. One consequence of that is that some rules can be supported only by heuristics, rather than precise and mechanically verifiable checks. Other rules articulate general principles. For these more general rules, more detailed and specific rules provide partial checking. These guidelines address the core of C++ and its use. We expect that most large organizations, specific application areas, and even large projects will need further rules, possibly further restrictions, and further library support. For example, hard-real-time programmers typically can\u2019t use free store (dynamic memory) freely and will be restricted in their choice of libraries. We encourage the development of such more specific rules as addenda to these core guidelines. Build your ideal small foundation library and use that, rather than lowering your level of programming to glorified assembly code. The rules are designed to allow gradual adoption . Some rules aim to increase various forms of safety while others aim to reduce the likelihood of accidents, many do both. The guidelines aimed at preventing accidents often ban perfectly legal C++. However, when there are two ways of expressing an idea and one has shown itself a common source of errors and the other has not, we try to guide programmers towards the latter.","title":"In.0: Don't panic!"},{"location":"cppcg/CppCoreGuidelines/#innot-non-aims","text":"The rules are not intended to be minimal or orthogonal. In particular, general rules can be simple, but unenforceable. Also, it is often hard to understand the implications of a general rule. More specialized rules are often easier to understand and to enforce, but without general rules, they would just be a long list of special cases. We provide rules aimed at helping novices as well as rules supporting expert use. Some rules can be completely enforced, but others are based on heuristics. These rules are not meant to be read serially, like a book. You can browse through them using the links. However, their main intended use is to be targets for tools. That is, a tool looks for violations and the tool returns links to violated rules. The rules then provide reasons, examples of potential consequences of the violation, and suggested remedies. These guidelines are not intended to be a substitute for a tutorial treatment of C++. If you need a tutorial for some given level of experience, see the references . This is not a guide on how to convert old C++ code to more modern code. It is meant to articulate ideas for new code in a concrete fashion. However, see the modernization section for some possible approaches to modernizing/rejuvenating/upgrading. Importantly, the rules support gradual adoption: It is typically infeasible to completely convert a large code base all at once. These guidelines are not meant to be complete or exact in every language-technical detail. For the final word on language definition issues, including every exception to general rules and every feature, see the ISO C++ standard. The rules are not intended to force you to write in an impoverished subset of C++. They are emphatically not meant to define a, say, Java-like subset of C++. They are not meant to define a single \u201cone true C++\u201d language. We value expressiveness and uncompromised performance. The rules are not value-neutral. They are meant to make code simpler and more correct/safer than most existing C++ code, without loss of performance. They are meant to inhibit perfectly valid C++ code that correlates with errors, spurious complexity, and poor performance. The rules are not precise to the point where a person (or machine) can follow them blindly. The enforcement parts try to be that, but we would rather leave a rule or a definition a bit vague and open to interpretation than specify something precisely and wrong. Sometimes, precision comes only with time and experience. Design is not (yet) a form of Math. The rules are not perfect. A rule can do harm by prohibiting something that is useful in a given situation. A rule can do harm by failing to prohibit something that enables a serious error in a given situation. A rule can do a lot of harm by being vague, ambiguous, unenforceable, or by enabling every solution to a problem. It is impossible to completely meet the \u201cdo no harm\u201d criteria. Instead, our aim is the less ambitious: \u201cDo the most good for most programmers\u201d; if you cannot live with a rule, object to it, ignore it, but don\u2019t water it down until it becomes meaningless. Also, suggest an improvement.","title":"In.not: Non-aims"},{"location":"cppcg/CppCoreGuidelines/#inforce-enforcement","text":"Rules with no enforcement are unmanageable for large code bases. Enforcement of all rules is possible only for a small weak set of rules or for a specific user community. But we want lots of rules, and we want rules that everybody can use. But different people have different needs. But people don\u2019t like to read lots of rules. But people can\u2019t remember many rules. So, we need subsetting to meet a variety of needs. But arbitrary subsetting leads to chaos. We want guidelines that help a lot of people, make code more uniform, and strongly encourage people to modernize their code. We want to encourage best practices, rather than leave all to individual choices and management pressures. The ideal is to use all rules; that gives the greatest benefits. This adds up to quite a few dilemmas. We try to resolve those using tools. Each rule has an Enforcement section listing ideas for enforcement. Enforcement might be done by code review, by static analysis, by compiler, or by run-time checks. Wherever possible, we prefer \u201cmechanical\u201d checking (humans are slow, inaccurate, and bore easily) and static checking. Run-time checks are suggested only rarely where no alternative exists; we do not want to introduce \u201cdistributed fat\u201d. Where appropriate, we label a rule (in the Enforcement sections) with the name of groups of related rules (called \u201cprofiles\u201d). A rule can be part of several profiles, or none. For a start, we have a few profiles corresponding to common needs (desires, ideals): type : No type violations (reinterpreting a T as a U through casts, unions, or varargs) bounds : No bounds violations (accessing beyond the range of an array) lifetime : No leaks (failing to delete or multiple delete ) and no access to invalid objects (dereferencing nullptr , using a dangling reference). The profiles are intended to be used by tools, but also serve as an aid to the human reader. We do not limit our comment in the Enforcement sections to things we know how to enforce; some comments are mere wishes that might inspire some tool builder. Tools that implement these rules shall respect the following syntax to explicitly suppress a rule: [[gsl::suppress(tag)]] where \u201ctag\u201d is the anchor name of the item where the Enforcement rule appears (e.g., for C.134 it is \u201cRh-public\u201d), the name of a profile group-of-rules (\u201ctype\u201d, \u201cbounds\u201d, or \u201clifetime\u201d), or a specific rule in a profile ( type.4 , or bounds.2 ).","title":"In.force: Enforcement"},{"location":"cppcg/CppCoreGuidelines/#instruct-the-structure-of-this-document","text":"Each rule (guideline, suggestion) can have several parts: The rule itself \u2013 e.g., no naked new A rule reference number \u2013 e.g., C.7 (the 7 th rule related to classes). Since the major sections are not inherently ordered, we use letters as the first part of a rule reference \u201cnumber\u201d. We leave gaps in the numbering to minimize \u201cdisruption\u201d when we add or remove rules. **Reason**s (rationales) \u2013 because programmers find it hard to follow rules they don\u2019t understand **Example**s \u2013 because rules are hard to understand in the abstract; can be positive or negative **Alternative**s \u2013 for \u201cdon\u2019t do this\u201d rules **Exception**s \u2013 we prefer simple general rules. However, many rules apply widely, but not universally, so exceptions must be listed Enforcement \u2013 ideas about how the rule might be checked \u201cmechanically\u201d **See also**s \u2013 references to related rules and/or further discussion (in this document or elsewhere) **Note**s (comments) \u2013 something that needs saying that doesn\u2019t fit the other classifications Discussion \u2013 references to more extensive rationale and/or examples placed outside the main lists of rules Some rules are hard to check mechanically, but they all meet the minimal criteria that an expert programmer can spot many violations without too much trouble. We hope that \u201cmechanical\u201d tools will improve with time to approximate what such an expert programmer notices. Also, we assume that the rules will be refined over time to make them more precise and checkable. A rule is aimed at being simple, rather than carefully phrased to mention every alternative and special case. Such information is found in the Alternative paragraphs and the Discussion sections. If you don\u2019t understand a rule or disagree with it, please visit its Discussion . If you feel that a discussion is missing or incomplete, enter an Issue explaining your concerns and possibly a corresponding PR. This is not a language manual. It is meant to be helpful, rather than complete, fully accurate on technical details, or a guide to existing code. Recommended information sources can be found in the references .","title":"In.struct: The structure of this document"},{"location":"cppcg/CppCoreGuidelines/#insec-major-sections","text":"In: Introduction P: Philosophy I: Interfaces F: Functions C: Classes and class hierarchies Enum: Enumerations R: Resource management ES: Expressions and statements Per: Performance CP: Concurrency and parallelism E: Error handling Con: Constants and immutability T: Templates and generic programming CPL: C-style programming SF: Source files SL: The Standard Library Supporting sections: A: Architectural ideas NR: Non-Rules and myths RF: References Pro: Profiles GSL: Guidelines support library NL: Naming and layout rules FAQ: Answers to frequently asked questions Appendix A: Libraries Appendix B: Modernizing code Appendix C: Discussion Appendix D: Supporting tools Glossary To-do: Unclassified proto-rules These sections are not orthogonal. Each section (e.g., \u201cP\u201d for \u201cPhilosophy\u201d) and each subsection (e.g., \u201cC.hier\u201d for \u201cClass Hierarchies (OOP)\u201d) have an abbreviation for ease of searching and reference. The main section abbreviations are also used in rule numbers (e.g., \u201cC.11\u201d for \u201cMake concrete types regular\u201d).","title":"In.sec: Major sections"},{"location":"cppcg/CppCoreGuidelines/#p-philosophy","text":"The rules in this section are very general. Philosophy rules summary: P.1: Express ideas directly in code P.2: Write in ISO Standard C++ P.3: Express intent P.4: Ideally, a program should be statically type safe P.5: Prefer compile-time checking to run-time checking P.6: What cannot be checked at compile time should be checkable at run time P.7: Catch run-time errors early P.8: Don\u2019t leak any resources P.9: Don\u2019t waste time or space P.10: Prefer immutable data to mutable data P.11: Encapsulate messy constructs, rather than spreading through the code P.12: Use supporting tools as appropriate P.13: Use support libraries as appropriate Philosophical rules are generally not mechanically checkable. However, individual rules reflecting these philosophical themes are. Without a philosophical basis, the more concrete/specific/checkable rules lack rationale.","title":"P: Philosophy"},{"location":"cppcg/CppCoreGuidelines/#p1-express-ideas-directly-in-code","text":"","title":"P.1: Express ideas directly in code"},{"location":"cppcg/CppCoreGuidelines/#reason","text":"Compilers don\u2019t read comments (or design documents) and neither do many programmers (consistently). What is expressed in code has defined semantics and can (in principle) be checked by compilers and other tools.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example","text":"class Date { // ... public: Month month() const; // do int month(); // don't // ... }; The first declaration of month is explicit about returning a Month and about not modifying the state of the Date object. The second version leaves the reader guessing and opens more possibilities for uncaught bugs.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad","text":"This loop is a restricted form of std::find : void f(vector<string>& v) { string val; cin >> val; // ... int index = -1; // bad, plus should use gsl::index for (int i = 0; i < v.size(); ++i) { if (v[i] == val) { index = i; break; } } // ... }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good","text":"A much clearer expression of intent would be: void f(vector<string>& v) { string val; cin >> val; // ... auto p = find(begin(v), end(v), val); // better // ... } A well-designed library expresses intent (what is to be done, rather than just how something is being done) far better than direct use of language features. A C++ programmer should know the basics of the standard library, and use it where appropriate. Any programmer should know the basics of the foundation libraries of the project being worked on, and use them appropriately. Any programmer using these guidelines should know the guidelines support library , and use it appropriately.","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#example_1","text":"change_speed(double s); // bad: what does s signify? // ... change_speed(2.3); A better approach is to be explicit about the meaning of the double (new speed or delta on old speed?) and the unit used: change_speed(Speed s); // better: the meaning of s is specified // ... change_speed(2.3); // error: no unit change_speed(23m / 10s); // meters per second We could have accepted a plain (unit-less) double as a delta, but that would have been error-prone. If we wanted both absolute speed and deltas, we would have defined a Delta type.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement","text":"Very hard in general. use const consistently (check if member functions modify their object; check if functions modify arguments passed by pointer or reference) flag uses of casts (casts neuter the type system) detect code that mimics the standard library (hard)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#p2-write-in-iso-standard-c","text":"","title":"P.2: Write in ISO Standard C++"},{"location":"cppcg/CppCoreGuidelines/#reason_1","text":"This is a set of guidelines for writing ISO Standard C++.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note","text":"There are environments where extensions are necessary, e.g., to access system resources. In such cases, localize the use of necessary extensions and control their use with non-core Coding Guidelines. If possible, build interfaces that encapsulate the extensions so they can be turned off or compiled away on systems that do not support those extensions. Extensions often do not have rigorously defined semantics. Even extensions that are common and implemented by multiple compilers may have slightly different behaviors and edge case behavior as a direct result of not having a rigorous standard definition. With sufficient use of any such extension, expected portability will be impacted.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_1","text":"Using valid ISO C++ does not guarantee portability (let alone correctness). Avoid dependence on undefined behavior (e.g., undefined order of evaluation ) and be aware of constructs with implementation defined meaning (e.g., sizeof(int) ).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_2","text":"There are environments where restrictions on use of standard C++ language or library features are necessary, e.g., to avoid dynamic memory allocation as required by aircraft control software standards. In such cases, control their (dis)use with an extension of these Coding Guidelines customized to the specific environment.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_1","text":"Use an up-to-date C++ compiler (currently C++17, C++14, or C++11) with a set of options that do not accept extensions.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#p3-express-intent","text":"","title":"P.3: Express intent"},{"location":"cppcg/CppCoreGuidelines/#reason_2","text":"Unless the intent of some code is stated (e.g., in names or comments), it is impossible to tell whether the code does what it is supposed to do.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_2","text":"gsl::index i = 0; while (i < v.size()) { // ... do something with v[i] ... } The intent of \u201cjust\u201d looping over the elements of v is not expressed here. The implementation detail of an index is exposed (so that it might be misused), and i outlives the scope of the loop, which may or may not be intended. The reader cannot know from just this section of code. Better: for (const auto& x : v) { /* do something with the value of x */ } Now, there is no explicit mention of the iteration mechanism, and the loop operates on a reference to const elements so that accidental modification cannot happen. If modification is desired, say so: for (auto& x : v) { /* modify x */ } For more details about for-statements, see ES.71 . Sometimes better still, use a named algorithm. This example uses the for_each from the Ranges TS because it directly expresses the intent: for_each(v, [](int x) { /* do something with the value of x */ }); for_each(par, v, [](int x) { /* do something with the value of x */ }); The last variant makes it clear that we are not interested in the order in which the elements of v are handled. A programmer should be familiar with The guidelines support library The ISO C++ Standard Library Whatever foundation libraries are used for the current project(s)","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_3","text":"Alternative formulation: Say what should be done, rather than just how it should be done.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_4","text":"Some language constructs express intent better than others.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_3","text":"If two int s are meant to be the coordinates of a 2D point, say so: draw_line(int, int, int, int); // obscure draw_line(Point, Point); // clearer","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_2","text":"Look for common patterns for which there are better alternatives simple for loops vs. range- for loops f(T*, int) interfaces vs. f(span<T>) interfaces loop variables in too large a scope naked new and delete functions with many parameters of built-in types There is a huge scope for cleverness and semi-automated program transformation.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#p4-ideally-a-program-should-be-statically-type-safe","text":"","title":"P.4: Ideally, a program should be statically type safe"},{"location":"cppcg/CppCoreGuidelines/#reason_3","text":"Ideally, a program would be completely statically (compile-time) type safe. Unfortunately, that is not possible. Problem areas: unions casts array decay range errors narrowing conversions","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_5","text":"These areas are sources of serious problems (e.g., crashes and security violations). We try to provide alternative techniques.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_3","text":"We can ban, restrain, or detect the individual problem categories separately, as required and feasible for individual programs. Always suggest an alternative. For example: unions \u2013 use variant (in C++17) casts \u2013 minimize their use; templates can help array decay \u2013 use span (from the GSL) range errors \u2013 use span narrowing conversions \u2013 minimize their use and use narrow or narrow_cast (from the GSL) where they are necessary","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#p5-prefer-compile-time-checking-to-run-time-checking","text":"","title":"P.5: Prefer compile-time checking to run-time checking"},{"location":"cppcg/CppCoreGuidelines/#reason_4","text":"Code clarity and performance. You don\u2019t need to write error handlers for errors caught at compile time.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_4","text":"// Int is an alias used for integers int bits = 0; // don't: avoidable code for (Int i = 1; i; i <<= 1) ++bits; if (bits < 32) cerr << \"Int too small\\n\"; This example fails to achieve what it is trying to achieve (because overflow is undefined) and should be replaced with a simple static_assert : // Int is an alias used for integers static_assert(sizeof(Int) >= 4); // do: compile-time check Or better still just use the type system and replace Int with int32_t .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_5","text":"void read(int* p, int n); // read max n integers into *p int a[100]; read(a, 1000); // bad, off the end better void read(span<int> r); // read into the range of integers r int a[100]; read(a); // better: let the compiler figure out the number of elements Alternative formulation : Don\u2019t postpone to run time what can be done well at compile time.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_4","text":"Look for pointer arguments. Look for run-time checks for range violations.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#p6-what-cannot-be-checked-at-compile-time-should-be-checkable-at-run-time","text":"","title":"P.6: What cannot be checked at compile time should be checkable at run time"},{"location":"cppcg/CppCoreGuidelines/#reason_5","text":"Leaving hard-to-detect errors in a program is asking for crashes and bad results.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_6","text":"Ideally, we catch all errors (that are not errors in the programmer\u2019s logic) at either compile time or run time. It is impossible to catch all errors at compile time and often not affordable to catch all remaining errors at run time. However, we should endeavor to write programs that in principle can be checked, given sufficient resources (analysis programs, run-time checks, machine resources, time).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad_1","text":"// separately compiled, possibly dynamically loaded extern void f(int* p); void g(int n) { // bad: the number of elements is not passed to f() f(new int[n]); } Here, a crucial bit of information (the number of elements) has been so thoroughly \u201cobscured\u201d that static analysis is probably rendered infeasible and dynamic checking can be very difficult when f() is part of an ABI so that we cannot \u201cinstrument\u201d that pointer. We could embed helpful information into the free store, but that requires global changes to a system and maybe to the compiler. What we have here is a design that makes error detection very hard.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-bad_2","text":"We can of course pass the number of elements along with the pointer: // separately compiled, possibly dynamically loaded extern void f2(int* p, int n); void g2(int n) { f2(new int[n], m); // bad: a wrong number of elements can be passed to f() } Passing the number of elements as an argument is better (and far more common) than just passing the pointer and relying on some (unstated) convention for knowing or discovering the number of elements. However (as shown), a simple typo can introduce a serious error. The connection between the two arguments of f2() is conventional, rather than explicit. Also, it is implicit that f2() is supposed to delete its argument (or did the caller make a second mistake?).","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-bad_3","text":"The standard library resource management pointers fail to pass the size when they point to an object: // separately compiled, possibly dynamically loaded // NB: this assumes the calling code is ABI-compatible, using a // compatible C++ compiler and the same stdlib implementation extern void f3(unique_ptr<int[]>, int n); void g3(int n) { f3(make_unique<int[]>(n), m); // bad: pass ownership and size separately }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_6","text":"We need to pass the pointer and the number of elements as an integral object: extern void f4(vector<int>&); // separately compiled, possibly dynamically loaded extern void f4(span<int>); // separately compiled, possibly dynamically loaded // NB: this assumes the calling code is ABI-compatible, using a // compatible C++ compiler and the same stdlib implementation void g3(int n) { vector<int> v(n); f4(v); // pass a reference, retain ownership f4(span<int>{v}); // pass a view, retain ownership } This design carries the number of elements along as an integral part of an object, so that errors are unlikely and dynamic (run-time) checking is always feasible, if not always affordable.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_7","text":"How do we transfer both ownership and all information needed for validating use? vector<int> f5(int n) // OK: move { vector<int> v(n); // ... initialize v ... return v; } unique_ptr<int[]> f6(int n) // bad: loses n { auto p = make_unique<int[]>(n); // ... initialize *p ... return p; } owner<int*> f7(int n) // bad: loses n and we might forget to delete { owner<int*> p = new int[n]; // ... initialize *p ... return p; }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_8","text":"??? show how possible checks are avoided by interfaces that pass polymorphic base classes around, when they actually know what they need? Or strings as \u201cfree-style\u201d options","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_5","text":"Flag (pointer, count)-style interfaces (this will flag a lot of examples that can\u2019t be fixed for compatibility reasons) ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#p7-catch-run-time-errors-early","text":"","title":"P.7: Catch run-time errors early"},{"location":"cppcg/CppCoreGuidelines/#reason_6","text":"Avoid \u201cmysterious\u201d crashes. Avoid errors leading to (possibly unrecognized) wrong results.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_9","text":"void increment1(int* p, int n) // bad: error-prone { for (int i = 0; i < n; ++i) ++p[i]; } void use1(int m) { const int n = 10; int a[n] = {}; // ... increment1(a, m); // maybe typo, maybe m <= n is supposed // but assume that m == 20 // ... } Here we made a small error in use1 that will lead to corrupted data or a crash. The (pointer, count)-style interface leaves increment1() with no realistic way of defending itself against out-of-range errors. If we could check subscripts for out of range access, then the error would not be discovered until p[10] was accessed. We could check earlier and improve the code: void increment2(span<int> p) { for (int& x : p) ++x; } void use2(int m) { const int n = 10; int a[n] = {}; // ... increment2({a, m}); // maybe typo, maybe m <= n is supposed // ... } Now, m <= n can be checked at the point of call (early) rather than later. If all we had was a typo so that we meant to use n as the bound, the code could be further simplified (eliminating the possibility of an error): void use3(int m) { const int n = 10; int a[n] = {}; // ... increment2(a); // the number of elements of a need not be repeated // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_4","text":"Don\u2019t repeatedly check the same value. Don\u2019t pass structured data as strings: Date read_date(istream& is); // read date from istream Date extract_date(const string& s); // extract date from string void user1(const string& date) // manipulate date { auto d = extract_date(date); // ... } void user2() { Date d = read_date(cin); // ... user1(d.to_string()); // ... } The date is validated twice (by the Date constructor) and passed as a character string (unstructured data).","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_10","text":"Excess checking can be costly. There are cases where checking early is dumb because you may not ever need the value, or may only need part of the value that is more easily checked than the whole. Similarly, don\u2019t add validity checks that change the asymptotic behavior of your interface (e.g., don\u2019t add a O(n) check to an interface with an average complexity of O(1) ). class Jet { // Physics says: e * e < x * x + y * y + z * z float x; float y; float z; float e; public: Jet(float x, float y, float z, float e) :x(x), y(y), z(z), e(e) { // Should I check here that the values are physically meaningful? } float m() const { // Should I handle the degenerate case here? return sqrt(x * x + y * y + z * z - e * e); } ??? }; The physical law for a jet ( e * e < x * x + y * y + z * z ) is not an invariant because of the possibility for measurement errors. ???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_6","text":"Look at pointers and arrays: Do range-checking early and not repeatedly Look at conversions: Eliminate or mark narrowing conversions Look for unchecked values coming from input Look for structured data (objects of classes with invariants) being converted into strings ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#p8-dont-leak-any-resources","text":"","title":"P.8: Don't leak any resources"},{"location":"cppcg/CppCoreGuidelines/#reason_7","text":"Even a slow growth in resources will, over time, exhaust the availability of those resources. This is particularly important for long-running programs, but is an essential piece of responsible programming behavior.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_5","text":"void f(char* name) { FILE* input = fopen(name, \"r\"); // ... if (something) return; // bad: if something == true, a file handle is leaked // ... fclose(input); } Prefer RAII : void f(char* name) { ifstream input {name}; // ... if (something) return; // OK: no leak // ... } See also : The resource management section","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_7","text":"A leak is colloquially \u201canything that isn\u2019t cleaned up.\u201d The more important classification is \u201canything that can no longer be cleaned up.\u201d For example, allocating an object on the heap and then losing the last pointer that points to that allocation. This rule should not be taken as requiring that allocations within long-lived objects must be returned during program shutdown. For example, relying on system guaranteed cleanup such as file closing and memory deallocation upon process shutdown can simplify code. However, relying on abstractions that implicitly clean up can be as simple, and often safer.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_8","text":"Enforcing the lifetime safety profile eliminates leaks. When combined with resource safety provided by RAII , it eliminates the need for \u201cgarbage collection\u201d (by generating no garbage). Combine this with enforcement of the type and bounds profiles and you get complete type- and resource-safety, guaranteed by tools.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_7","text":"Look at pointers: Classify them into non-owners (the default) and owners. Where feasible, replace owners with standard-library resource handles (as in the example above). Alternatively, mark an owner as such using owner from the GSL . Look for naked new and delete Look for known resource allocating functions returning raw pointers (such as fopen , malloc , and strdup )","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#p9-dont-waste-time-or-space","text":"","title":"P.9: Don't waste time or space"},{"location":"cppcg/CppCoreGuidelines/#reason_8","text":"This is C++.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_9","text":"Time and space that you spend well to achieve a goal (e.g., speed of development, resource safety, or simplification of testing) is not wasted. \u201cAnother benefit of striving for efficiency is that the process forces you to understand the problem in more depth.\u201d - Alex Stepanov","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad_6","text":"struct X { char ch; int i; string s; char ch2; X& operator=(const X& a); X(const X&); }; X waste(const char* p) { if (!p) throw Nullptr_error{}; int n = strlen(p); auto buf = new char[n]; if (!buf) throw Allocation_error{}; for (int i = 0; i < n; ++i) buf[i] = p[i]; // ... manipulate buffer ... X x; x.ch = 'a'; x.s = string(n); // give x.s space for *p for (gsl::index i = 0; i < x.s.size(); ++i) x.s[i] = buf[i]; // copy buf into x.s delete[] buf; return x; } void driver() { X x = waste(\"Typical argument\"); // ... } Yes, this is a caricature, but we have seen every individual mistake in production code, and worse. Note that the layout of X guarantees that at least 6 bytes (and most likely more) are wasted. The spurious definition of copy operations disables move semantics so that the return operation is slow (please note that the Return Value Optimization, RVO, is not guaranteed here). The use of new and delete for buf is redundant; if we really needed a local string, we should use a local string . There are several more performance bugs and gratuitous complication.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-bad_7","text":"void lower(zstring s) { for (int i = 0; i < strlen(s); ++i) s[i] = tolower(s[i]); } This is actually an example from production code. We can see that in our condition we have i < strlen(s) . This expression will be evaluated on every iteration of the loop, which means that strlen must walk through string every loop to discover its length. While the string contents are changing, it\u2019s assumed that toLower will not affect the length of the string, so it\u2019s better to cache the length outside the loop and not incur that cost each iteration.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_10","text":"An individual example of waste is rarely significant, and where it is significant, it is typically easily eliminated by an expert. However, waste spread liberally across a code base can easily be significant and experts are not always as available as we would like. The aim of this rule (and the more specific rules that support it) is to eliminate most waste related to the use of C++ before it happens. After that, we can look at waste related to algorithms and requirements, but that is beyond the scope of these guidelines.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_8","text":"Many more specific rules aim at the overall goals of simplicity and elimination of gratuitous waste. Flag an unused return value from a user-defined non-defaulted postfix operator++ or operator-- function. Prefer using the prefix form instead. (Note: \u201cUser-defined non-defaulted\u201d is intended to reduce noise. Review this enforcement if it\u2019s still too noisy in practice.)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#p10-prefer-immutable-data-to-mutable-data","text":"","title":"P.10: Prefer immutable data to mutable data"},{"location":"cppcg/CppCoreGuidelines/#reason_9","text":"It is easier to reason about constants than about variables. Something immutable cannot change unexpectedly. Sometimes immutability enables better optimization. You can\u2019t have a data race on a constant. See Con: Constants and immutability","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#p11-encapsulate-messy-constructs-rather-than-spreading-through-the-code","text":"","title":"P.11: Encapsulate messy constructs, rather than spreading through the code"},{"location":"cppcg/CppCoreGuidelines/#reason_10","text":"Messy code is more likely to hide bugs and harder to write. A good interface is easier and safer to use. Messy, low-level code breeds more such code.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_11","text":"int sz = 100; int* p = (int*) malloc(sizeof(int) * sz); int count = 0; // ... for (;;) { // ... read an int into x, exit loop if end of file is reached ... // ... check that x is valid ... if (count == sz) p = (int*) realloc(p, sizeof(int) * sz * 2); p[count++] = x; // ... } This is low-level, verbose, and error-prone. For example, we \u201cforgot\u201d to test for memory exhaustion. Instead, we could use vector : vector<int> v; v.reserve(100); // ... for (int x; cin >> x; ) { // ... check that x is valid ... v.push_back(x); }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_11","text":"The standards library and the GSL are examples of this philosophy. For example, instead of messing with the arrays, unions, cast, tricky lifetime issues, gsl::owner , etc., that are needed to implement key abstractions, such as vector , span , lock_guard , and future , we use the libraries designed and implemented by people with more time and expertise than we usually have. Similarly, we can and should design and implement more specialized libraries, rather than leaving the users (often ourselves) with the challenge of repeatedly getting low-level code well. This is a variant of the subset of superset principle that underlies these guidelines.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_9","text":"Look for \u201cmessy code\u201d such as complex pointer manipulation and casting outside the implementation of abstractions.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#p12-use-supporting-tools-as-appropriate","text":"","title":"P.12: Use supporting tools as appropriate"},{"location":"cppcg/CppCoreGuidelines/#reason_11","text":"There are many things that are done better \u201cby machine\u201d. Computers don\u2019t tire or get bored by repetitive tasks. We typically have better things to do than repeatedly do routine tasks.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_12","text":"Run a static analyzer to verify that your code follows the guidelines you want it to follow.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_12","text":"See Static analysis tools Concurrency tools Testing tools There are many other kinds of tools, such as source code repositories, build tools, etc., but those are beyond the scope of these guidelines.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_13","text":"Be careful not to become dependent on over-elaborate or over-specialized tool chains. Those can make your otherwise portable code non-portable.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#p13-use-support-libraries-as-appropriate","text":"","title":"P.13: Use support libraries as appropriate"},{"location":"cppcg/CppCoreGuidelines/#reason_12","text":"Using a well-designed, well-documented, and well-supported library saves time and effort; its quality and documentation are likely to be greater than what you could do if the majority of your time must be spent on an implementation. The cost (time, effort, money, etc.) of a library can be shared over many users. A widely used library is more likely to be kept up-to-date and ported to new systems than an individual application. Knowledge of a widely-used library can save time on other/future projects. So, if a suitable library exists for your application domain, use it.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_13","text":"std::sort(begin(v), end(v), std::greater<>()); Unless you are an expert in sorting algorithms and have plenty of time, this is more likely to be correct and to run faster than anything you write for a specific application. You need a reason not to use the standard library (or whatever foundational libraries your application uses) rather than a reason to use it.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_14","text":"By default use The ISO C++ Standard Library The Guidelines Support Library","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_15","text":"If no well-designed, well-documented, and well-supported library exists for an important domain, maybe you should design and implement it, and then use it.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#i-interfaces","text":"An interface is a contract between two parts of a program. Precisely stating what is expected of a supplier of a service and a user of that service is essential. Having good (easy-to-understand, encouraging efficient use, not error-prone, supporting testing, etc.) interfaces is probably the most important single aspect of code organization. Interface rule summary: I.1: Make interfaces explicit I.2: Avoid non- const global variables I.3: Avoid singletons I.4: Make interfaces precisely and strongly typed I.5: State preconditions (if any) I.6: Prefer Expects() for expressing preconditions I.7: State postconditions I.8: Prefer Ensures() for expressing postconditions I.9: If an interface is a template, document its parameters using concepts I.10: Use exceptions to signal a failure to perform a required task I.11: Never transfer ownership by a raw pointer ( T* ) or reference ( T& ) I.12: Declare a pointer that must not be null as not_null I.13: Do not pass an array as a single pointer I.22: Avoid complex initialization of global objects I.23: Keep the number of function arguments low I.24: Avoid adjacent unrelated parameters of the same type I.25: Prefer abstract classes as interfaces to class hierarchies I.26: If you want a cross-compiler ABI, use a C-style subset I.27: For stable library ABI, consider the Pimpl idiom I.30: Encapsulate rule violations See also : F: Functions C.concrete: Concrete types C.hier: Class hierarchies C.over: Overloading and overloaded operators C.con: Containers and other resource handles E: Error handling T: Templates and generic programming","title":"I: Interfaces"},{"location":"cppcg/CppCoreGuidelines/#i1-make-interfaces-explicit","text":"","title":"I.1: Make interfaces explicit"},{"location":"cppcg/CppCoreGuidelines/#reason_13","text":"Correctness. Assumptions not stated in an interface are easily overlooked and hard to test.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_8","text":"Controlling the behavior of a function through a global (namespace scope) variable (a call mode) is implicit and potentially confusing. For example: int round(double d) { return (round_up) ? ceil(d) : d; // don't: \"invisible\" dependency } It will not be obvious to a caller that the meaning of two calls of round(7.2) might give different results.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#exception","text":"Sometimes we control the details of a set of operations by an environment variable, e.g., normal vs. verbose output or debug vs. optimized. The use of a non-local control is potentially confusing, but controls only implementation details of otherwise fixed semantics.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#example-bad_9","text":"Reporting through non-local variables (e.g., errno ) is easily ignored. For example: // don't: no test of printf's return value fprintf(connection, \"logging: %d %d %d\\n\", x, y, s); What if the connection goes down so that no logging output is produced? See I.???. Alternative : Throw an exception. An exception cannot be ignored. Alternative formulation : Avoid passing information across an interface through non-local or implicit state. Note that non- const member functions pass information to other member functions through their object\u2019s state. Alternative formulation : An interface should be a function or a set of functions. Functions can be template functions and sets of functions can be classes or class templates.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_10","text":"(Simple) A function should not make control-flow decisions based on the values of variables declared at namespace scope. (Simple) A function should not write to variables declared at namespace scope.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i2-avoid-non-const-global-variables","text":"","title":"I.2: Avoid non-const global variables"},{"location":"cppcg/CppCoreGuidelines/#reason_14","text":"Non- const global variables hide dependencies and make the dependencies subject to unpredictable changes.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_14","text":"struct Data { // ... lots of stuff ... } data; // non-const data void compute() // don't { // ... use data ... } void output() // don't { // ... use data ... } Who else might modify data ?","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_16","text":"Global constants are useful.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_17","text":"The rule against global variables applies to namespace scope variables as well. Alternative : If you use global (more generally namespace scope) data to avoid copying, consider passing the data as an object by reference to const . Another solution is to define the data as the state of some object and the operations as member functions. Warning : Beware of data races: If one thread can access nonlocal data (or data passed by reference) while another thread executes the callee, we can have a data race. Every pointer or reference to mutable data is a potential data race.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_18","text":"You cannot have a race condition on immutable data. References : See the rules for calling functions .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_19","text":"The rule is \u201cavoid\u201d, not \u201cdon\u2019t use.\u201d Of course there will be (rare) exceptions, such as cin , cout , and cerr .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_11","text":"(Simple) Report all non- const variables declared at namespace scope.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i3-avoid-singletons","text":"","title":"I.3: Avoid singletons"},{"location":"cppcg/CppCoreGuidelines/#reason_15","text":"Singletons are basically complicated global objects in disguise.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_15","text":"class Singleton { // ... lots of stuff to ensure that only one Singleton object is created, // that it is initialized properly, etc. }; There are many variants of the singleton idea. That\u2019s part of the problem.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_20","text":"If you don\u2019t want a global object to change, declare it const or constexpr .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exception_1","text":"You can use the simplest \u201csingleton\u201d (so simple that it is often not considered a singleton) to get initialization on first use, if any: X& myX() { static X my_x {3}; return my_x; } This is one of the most effective solutions to problems related to initialization order. In a multi-threaded environment, the initialization of the static object does not introduce a race condition (unless you carelessly access a shared object from within its constructor). Note that the initialization of a local static does not imply a race condition. However, if the destruction of X involves an operation that needs to be synchronized we must use a less simple solution. For example: X& myX() { static auto p = new X {3}; return *p; // potential leak } Now someone must delete that object in some suitably thread-safe way. That\u2019s error-prone, so we don\u2019t use that technique unless myX is in multi-threaded code, that X object needs to be destroyed (e.g., because it releases a resource), and X \u2018s destructor\u2019s code needs to be synchronized. If you, as many do, define a singleton as a class for which only one object is created, functions like myX are not singletons, and this useful technique is not an exception to the no-singleton rule.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_12","text":"Very hard in general. Look for classes with names that include singleton . Look for classes for which only a single object is created (by counting objects or by examining constructors). If a class X has a public static function that contains a function-local static of the class\u2019 type X and returns a pointer or reference to it, ban that.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i4-make-interfaces-precisely-and-strongly-typed","text":"","title":"I.4: Make interfaces precisely and strongly typed"},{"location":"cppcg/CppCoreGuidelines/#reason_16","text":"Types are the simplest and best documentation, improve legibility due to their well-defined meaning, and are checked at compile time. Also, precisely typed code is often optimized better.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-dont","text":"Consider: void pass(void* data); // weak and under qualified type void* is suspicious Callers are unsure what types are allowed and if the data may be mutated as const is not specified. Note all pointer types implicitly convert to void*, so it is easy for callers to provide this value. The callee must static_cast data to an unverified type to use it. That is error-prone and verbose. Only use const void* for passing in data in designs that are indescribable in C++. Consider using a variant or a pointer to base instead. Alternative : Often, a template parameter can eliminate the void* turning it into a T* or T& . For generic code these T s can be general or concept constrained template parameters.","title":"Example, don't"},{"location":"cppcg/CppCoreGuidelines/#example-bad_10","text":"Consider: draw_rect(100, 200, 100, 500); // what do the numbers specify? draw_rect(p.x, p.y, 10, 20); // what units are 10 and 20 in? It is clear that the caller is describing a rectangle, but it is unclear what parts they relate to. Also, an int can carry arbitrary forms of information, including values of many units, so we must guess about the meaning of the four int s. Most likely, the first two are an x , y coordinate pair, but what are the last two? Comments and parameter names can help, but we could be explicit: void draw_rectangle(Point top_left, Point bottom_right); void draw_rectangle(Point top_left, Size height_width); draw_rectangle(p, Point{10, 20}); // two corners draw_rectangle(p, Size{10, 20}); // one corner and a (height, width) pair Obviously, we cannot catch all errors through the static type system (e.g., the fact that a first argument is supposed to be a top-left point is left to convention (naming and comments)).","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-bad_11","text":"Consider: set_settings(true, false, 42); // what do the numbers specify? The parameter types and their values do not communicate what settings are being specified or what those values mean. This design is more explicit, safe and legible: alarm_settings s{}; s.enabled = true; s.displayMode = alarm_settings::mode::spinning_light; s.frequency = alarm_settings::every_10_seconds; set_settings(s); For the case of a set of boolean values consider using a flags enum; a pattern that expresses a set of boolean values. enable_lamp_options(lamp_option::on | lamp_option::animate_state_transitions);","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-bad_12","text":"In the following example, it is not clear from the interface what time_to_blink means: Seconds? Milliseconds? void blink_led(int time_to_blink) // bad -- the unit is ambiguous { // ... // do something with time_to_blink // ... } void use() { blink_led(2); }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_1","text":"std::chrono::duration types (C++11) helps making the unit of time duration explicit. void blink_led(milliseconds time_to_blink) // good -- the unit is explicit { // ... // do something with time_to_blink // ... } void use() { blink_led(1500ms); } The function can also be written in such a way that it will accept any time duration unit. template<class rep, class period> void blink_led(duration<rep, period> time_to_blink) // good -- accepts any unit { // assuming that millisecond is the smallest relevant unit auto milliseconds_to_blink = duration_cast<milliseconds>(time_to_blink); // ... // do something with milliseconds_to_blink // ... } void use() { blink_led(2s); blink_led(1500ms); }","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#enforcement_13","text":"(Simple) Report the use of void* as a parameter or return type. (Simple) Report the use of more than one bool parameter. (Hard to do well) Look for functions that use too many primitive type arguments.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i5-state-preconditions-if-any","text":"","title":"I.5: State preconditions (if any)"},{"location":"cppcg/CppCoreGuidelines/#reason_17","text":"Arguments have meaning that may constrain their proper use in the callee.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_16","text":"Consider: double sqrt(double x); Here x must be nonnegative. The type system cannot (easily and naturally) express that, so we must use other means. For example: double sqrt(double x); // x must be nonnegative Some preconditions can be expressed as assertions. For example: double sqrt(double x) { Expects(x >= 0); /* ... */ } Ideally, that Expects(x >= 0) should be part of the interface of sqrt() but that\u2019s not easily done. For now, we place it in the definition (function body). References : Expects() is described in GSL .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_21","text":"Prefer a formal specification of requirements, such as Expects(p); . If that is infeasible, use English text in comments, such as // the sequence [p:q) is ordered using < .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_22","text":"Most member functions have as a precondition that some class invariant holds. That invariant is established by a constructor and must be reestablished upon exit by every member function called from outside the class. We don\u2019t need to mention it for each member function.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_14","text":"(Not enforceable) See also : The rules for passing pointers. ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i6-prefer-expects-for-expressing-preconditions","text":"","title":"I.6: Prefer Expects() for expressing preconditions"},{"location":"cppcg/CppCoreGuidelines/#reason_18","text":"To make it clear that the condition is a precondition and to enable tool use.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_17","text":"int area(int height, int width) { Expects(height > 0 && width > 0); // good if (height <= 0 || width <= 0) my_error(); // obscure // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_23","text":"Preconditions can be stated in many ways, including comments, if -statements, and assert() . This can make them hard to distinguish from ordinary code, hard to update, hard to manipulate by tools, and may have the wrong semantics (do you always want to abort in debug mode and check nothing in productions runs?).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_24","text":"Preconditions should be part of the interface rather than part of the implementation, but we don\u2019t yet have the language facilities to do that. Once language support becomes available (e.g., see the contract proposal ) we will adopt the standard version of preconditions, postconditions, and assertions.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_25","text":"Expects() can also be used to check a condition in the middle of an algorithm.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_26","text":"No, using unsigned is not a good way to sidestep the problem of ensuring that a value is nonnegative .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_15","text":"(Not enforceable) Finding the variety of ways preconditions can be asserted is not feasible. Warning about those that can be easily identified ( assert() ) has questionable value in the absence of a language facility.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i7-state-postconditions","text":"","title":"I.7: State postconditions"},{"location":"cppcg/CppCoreGuidelines/#reason_19","text":"To detect misunderstandings about the result and possibly catch erroneous implementations.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_13","text":"Consider: int area(int height, int width) { return height * width; } // bad Here, we (incautiously) left out the precondition specification, so it is not explicit that height and width must be positive. We also left out the postcondition specification, so it is not obvious that the algorithm ( height * width ) is wrong for areas larger than the largest integer. Overflow can happen. Consider using: int area(int height, int width) { auto res = height * width; Ensures(res > 0); return res; }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-bad_14","text":"Consider a famous security bug: void f() // problematic { char buffer[MAX]; // ... memset(buffer, 0, sizeof(buffer)); } There was no postcondition stating that the buffer should be cleared and the optimizer eliminated the apparently redundant memset() call: void f() // better { char buffer[MAX]; // ... memset(buffer, 0, sizeof(buffer)); Ensures(buffer[0] == 0); }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_27","text":"Postconditions are often informally stated in a comment that states the purpose of a function; Ensures() can be used to make this more systematic, visible, and checkable.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_28","text":"Postconditions are especially important when they relate to something that is not directly reflected in a returned result, such as a state of a data structure used.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_18","text":"Consider a function that manipulates a Record , using a mutex to avoid race conditions: mutex m; void manipulate(Record& r) // don't { m.lock(); // ... no m.unlock() ... } Here, we \u201cforgot\u201d to state that the mutex should be released, so we don\u2019t know if the failure to ensure release of the mutex was a bug or a feature. Stating the postcondition would have made it clear: void manipulate(Record& r) // postcondition: m is unlocked upon exit { m.lock(); // ... no m.unlock() ... } The bug is now obvious (but only to a human reading comments). Better still, use RAII to ensure that the postcondition (\u201cthe lock must be released\u201d) is enforced in code: void manipulate(Record& r) // best { lock_guard<mutex> _ {m}; // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_29","text":"Ideally, postconditions are stated in the interface/declaration so that users can easily see them. Only postconditions related to the users can be stated in the interface. Postconditions related only to internal state belongs in the definition/implementation.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_16","text":"(Not enforceable) This is a philosophical guideline that is infeasible to check directly in the general case. Domain specific checkers (like lock-holding checkers) exist for many toolchains.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i8-prefer-ensures-for-expressing-postconditions","text":"","title":"I.8: Prefer Ensures() for expressing postconditions"},{"location":"cppcg/CppCoreGuidelines/#reason_20","text":"To make it clear that the condition is a postcondition and to enable tool use.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_19","text":"void f() { char buffer[MAX]; // ... memset(buffer, 0, MAX); Ensures(buffer[0] == 0); }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_30","text":"Postconditions can be stated in many ways, including comments, if -statements, and assert() . This can make them hard to distinguish from ordinary code, hard to update, hard to manipulate by tools, and may have the wrong semantics. Alternative : Postconditions of the form \u201cthis resource must be released\u201d are best expressed by RAII .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_31","text":"Ideally, that Ensures should be part of the interface, but that\u2019s not easily done. For now, we place it in the definition (function body). Once language support becomes available (e.g., see the contract proposal ) we will adopt the standard version of preconditions, postconditions, and assertions.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_17","text":"(Not enforceable) Finding the variety of ways postconditions can be asserted is not feasible. Warning about those that can be easily identified ( assert() ) has questionable value in the absence of a language facility.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i9-if-an-interface-is-a-template-document-its-parameters-using-concepts","text":"","title":"I.9: If an interface is a template, document its parameters using concepts"},{"location":"cppcg/CppCoreGuidelines/#reason_21","text":"Make the interface precisely specified and compile-time checkable in the (not so distant) future.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_20","text":"Use the ISO Concepts TS style of requirements specification. For example: template<typename Iter, typename Val> // requires InputIterator<Iter> && EqualityComparable<ValueType<Iter>>, Val> Iter find(Iter first, Iter last, Val v) { // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_32","text":"Soon (maybe in 2018), most compilers will be able to check requires clauses once the // is removed. Concepts are supported in GCC 6.1 and later. See also : Generic programming and concepts .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_18","text":"(Not yet enforceable) A language facility is under specification. When the language facility is available, warn if any non-variadic template parameter is not constrained by a concept (in its declaration or mentioned in a requires clause).","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i10-use-exceptions-to-signal-a-failure-to-perform-a-required-task","text":"","title":"I.10: Use exceptions to signal a failure to perform a required task"},{"location":"cppcg/CppCoreGuidelines/#reason_22","text":"It should not be possible to ignore an error because that could leave the system or a computation in an undefined (or unexpected) state. This is a major source of errors.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_21","text":"int printf(const char* ...); // bad: return negative number if output fails template <class F, class ...Args> // good: throw system_error if unable to start the new thread explicit thread(F&& f, Args&&... args);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_33","text":"What is an error? An error means that the function cannot achieve its advertised purpose (including establishing postconditions). Calling code that ignores an error could lead to wrong results or undefined systems state. For example, not being able to connect to a remote server is not by itself an error: the server can refuse a connection for all kinds of reasons, so the natural thing is to return a result that the caller should always check. However, if failing to make a connection is considered an error, then a failure should throw an exception.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exception_2","text":"Many traditional interface functions (e.g., UNIX signal handlers) use error codes (e.g., errno ) to report what are really status codes, rather than errors. You don\u2019t have a good alternative to using such, so calling these does not violate the rule.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#alternative","text":"If you can\u2019t use exceptions (e.g., because your code is full of old-style raw-pointer use or because there are hard-real-time constraints), consider using a style that returns a pair of values: int val; int error_code; tie(val, error_code) = do_something(); if (error_code) { // ... handle the error or exit ... } // ... use val ... This style unfortunately leads to uninitialized variables. Since C++17 the \u201cstructured bindings\u201d feature can be used to initialize variables directly from the return value: auto [val, error_code] = do_something(); if (error_code) { // ... handle the error or exit ... } // ... use val ...","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#note_34","text":"We don\u2019t consider \u201cperformance\u201d a valid reason not to use exceptions. Often, explicit error checking and handling consume as much time and space as exception handling. Often, cleaner code yields better performance with exceptions (simplifying the tracing of paths through the program and their optimization). A good rule for performance critical code is to move checking outside the critical part of the code ( checking ). In the longer term, more regular code gets better optimized. Always carefully measure before making performance claims. See also : I.5 and I.7 for reporting precondition and postcondition violations.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_19","text":"(Not enforceable) This is a philosophical guideline that is infeasible to check directly. Look for errno .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i11-never-transfer-ownership-by-a-raw-pointer-t-or-reference-t","text":"","title":"I.11: Never transfer ownership by a raw pointer (T*) or reference (T&amp;)"},{"location":"cppcg/CppCoreGuidelines/#reason_23","text":"If there is any doubt whether the caller or the callee owns an object, leaks or premature destruction will occur.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_22","text":"Consider: X* compute(args) // don't { X* res = new X{}; // ... return res; } Who deletes the returned X ? The problem would be harder to spot if compute returned a reference. Consider returning the result by value (use move semantics if the result is large): vector<double> compute(args) // good { vector<double> res(10000); // ... return res; } Alternative : Pass ownership using a \u201csmart pointer\u201d, such as unique_ptr (for exclusive ownership) and shared_ptr (for shared ownership). However, that is less elegant and often less efficient than returning the object itself, so use smart pointers only if reference semantics are needed. Alternative : Sometimes older code can\u2019t be modified because of ABI compatibility requirements or lack of resources. In that case, mark owning pointers using owner from the guidelines support library : owner<X*> compute(args) // It is now clear that ownership is transferred { owner<X*> res = new X{}; // ... return res; } This tells analysis tools that res is an owner. That is, its value must be delete d or transferred to another owner, as is done here by the return . owner is used similarly in the implementation of resource handles.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_35","text":"Every object passed as a raw pointer (or iterator) is assumed to be owned by the caller, so that its lifetime is handled by the caller. Viewed another way: ownership transferring APIs are relatively rare compared to pointer-passing APIs, so the default is \u201cno ownership transfer.\u201d See also : Argument passing , use of smart pointer arguments , and value return .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_20","text":"(Simple) Warn on delete of a raw pointer that is not an owner<T> . Suggest use of standard-library resource handle or use of owner<T> . (Simple) Warn on failure to either reset or explicitly delete an owner pointer on every code path. (Simple) Warn if the return value of new or a function call with an owner return value is assigned to a raw pointer or non- owner reference.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i12-declare-a-pointer-that-must-not-be-null-as-not_null","text":"","title":"I.12: Declare a pointer that must not be null as not_null"},{"location":"cppcg/CppCoreGuidelines/#reason_24","text":"To help avoid dereferencing nullptr errors. To improve performance by avoiding redundant checks for nullptr .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_23","text":"int length(const char* p); // it is not clear whether length(nullptr) is valid length(nullptr); // OK? int length(not_null<const char*> p); // better: we can assume that p cannot be nullptr int length(const char* p); // we must assume that p can be nullptr By stating the intent in source, implementers and tools can provide better diagnostics, such as finding some classes of errors through static analysis, and perform optimizations, such as removing branches and null tests.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_36","text":"not_null is defined in the guidelines support library .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_37","text":"The assumption that the pointer to char pointed to a C-style string (a zero-terminated string of characters) was still implicit, and a potential source of confusion and errors. Use czstring in preference to const char* . // we can assume that p cannot be nullptr // we can assume that p points to a zero-terminated array of characters int length(not_null<zstring> p); Note: length() is, of course, std::strlen() in disguise.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_21","text":"(Simple) ((Foundation)) If a function checks a pointer parameter against nullptr before access, on all control-flow paths, then warn it should be declared not_null . (Complex) If a function with pointer return value ensures it is not nullptr on all return paths, then warn the return type should be declared not_null .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i13-do-not-pass-an-array-as-a-single-pointer","text":"","title":"I.13: Do not pass an array as a single pointer"},{"location":"cppcg/CppCoreGuidelines/#reason_25","text":"(pointer, size)-style interfaces are error-prone. Also, a plain pointer (to array) must rely on some convention to allow the callee to determine the size.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_24","text":"Consider: void copy_n(const T* p, T* q, int n); // copy from [p:p+n) to [q:q+n) What if there are fewer than n elements in the array pointed to by q ? Then, we overwrite some probably unrelated memory. What if there are fewer than n elements in the array pointed to by p ? Then, we read some probably unrelated memory. Either is undefined behavior and a potentially very nasty bug.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#alternative_1","text":"Consider using explicit spans: void copy(span<const T> r, span<T> r2); // copy r to r2","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#example-bad_15","text":"Consider: void draw(Shape* p, int n); // poor interface; poor code Circle arr[10]; // ... draw(arr, 10); Passing 10 as the n argument may be a mistake: the most common convention is to assume [0:n) but that is nowhere stated. Worse is that the call of draw() compiled at all: there was an implicit conversion from array to pointer (array decay) and then another implicit conversion from Circle to Shape . There is no way that draw() can safely iterate through that array: it has no way of knowing the size of the elements. Alternative : Use a support class that ensures that the number of elements is correct and prevents dangerous implicit conversions. For example: void draw2(span<Circle>); Circle arr[10]; // ... draw2(span<Circle>(arr)); // deduce the number of elements draw2(arr); // deduce the element type and array size void draw3(span<Shape>); draw3(arr); // error: cannot convert Circle[10] to span<Shape> This draw2() passes the same amount of information to draw() , but makes the fact that it is supposed to be a range of Circle s explicit. See ???.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#exception_3","text":"Use zstring and czstring to represent C-style, zero-terminated strings. But when doing so, use std::string_view or string_span from the GSL to prevent range errors.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_22","text":"(Simple) ((Bounds)) Warn for any expression that would rely on implicit conversion of an array type to a pointer type. Allow exception for zstring/czstring pointer types. (Simple) ((Bounds)) Warn for any arithmetic operation on an expression of pointer type that results in a value of pointer type. Allow exception for zstring/czstring pointer types.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i22-avoid-complex-initialization-of-global-objects","text":"","title":"I.22: Avoid complex initialization of global objects"},{"location":"cppcg/CppCoreGuidelines/#reason_26","text":"Complex initialization can lead to undefined order of execution.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_25","text":"// file1.c extern const X x; const Y y = f(x); // read x; write y // file2.c extern const Y y; const X x = g(y); // read y; write x Since x and y are in different translation units the order of calls to f() and g() is undefined; one will access an uninitialized const . This shows that the order-of-initialization problem for global (namespace scope) objects is not limited to global variables .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_38","text":"Order of initialization problems become particularly difficult to handle in concurrent code. It is usually best to avoid global (namespace scope) objects altogether.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_23","text":"Flag initializers of globals that call non- constexpr functions Flag initializers of globals that access extern objects","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i23-keep-the-number-of-function-arguments-low","text":"","title":"I.23: Keep the number of function arguments low"},{"location":"cppcg/CppCoreGuidelines/#reason_27","text":"Having many arguments opens opportunities for confusion. Passing lots of arguments is often costly compared to alternatives.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#discussion","text":"The two most common reasons why functions have too many parameters are: Missing an abstraction. There is an abstraction missing, so that a compound value is being passed as individual elements instead of as a single object that enforces an invariant. This not only expands the parameter list, but it leads to errors because the component values are no longer protected by an enforced invariant. Violating \u201cone function, one responsibility.\u201d The function is trying to do more than one job and should probably be refactored.","title":"Discussion"},{"location":"cppcg/CppCoreGuidelines/#example_26","text":"The standard-library merge() is at the limit of what we can comfortably handle: template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare> OutputIterator merge(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp); Note that this is because of problem 1 above \u2013 missing abstraction. Instead of passing a range (abstraction), STL passed iterator pairs (unencapsulated component values). Here, we have four template arguments and six function arguments. To simplify the most frequent and simplest uses, the comparison argument can be defaulted to < : template<class InputIterator1, class InputIterator2, class OutputIterator> OutputIterator merge(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result); This doesn\u2019t reduce the total complexity, but it reduces the surface complexity presented to many users. To really reduce the number of arguments, we need to bundle the arguments into higher-level abstractions: template<class InputRange1, class InputRange2, class OutputIterator> OutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result); Grouping arguments into \u201cbundles\u201d is a general technique to reduce the number of arguments and to increase the opportunities for checking. Alternatively, we could use concepts (as defined by the ISO TS) to define the notion of three types that must be usable for merging: Mergeable{In1, In2, Out} OutputIterator merge(In1 r1, In2 r2, Out result);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_27","text":"The safety Profiles recommend replacing void f(int* some_ints, int some_ints_length); // BAD: C style, unsafe with void f(gsl::span<int> some_ints); // GOOD: safe, bounds-checked Here, using an abstraction has safety and robustness benefits, and naturally also reduces the number of parameters.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_39","text":"How many parameters are too many? Try to use fewer than four (4) parameters. There are functions that are best expressed with four individual parameters, but not many. Alternative : Use better abstraction: Group arguments into meaningful objects and pass the objects (by value or by reference). Alternative : Use default arguments or overloads to allow the most common forms of calls to be done with fewer arguments.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_24","text":"Warn when a function declares two iterators (including pointers) of the same type instead of a range or a view. (Not enforceable) This is a philosophical guideline that is infeasible to check directly.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i24-avoid-adjacent-unrelated-parameters-of-the-same-type","text":"","title":"I.24: Avoid adjacent unrelated parameters of the same type"},{"location":"cppcg/CppCoreGuidelines/#reason_28","text":"Adjacent arguments of the same type are easily swapped by mistake.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_16","text":"Consider: void copy_n(T* p, T* q, int n); // copy from [p:p + n) to [q:q + n) This is a nasty variant of a K&R C-style interface. It is easy to reverse the \u201cto\u201d and \u201cfrom\u201d arguments. Use const for the \u201cfrom\u201d argument: void copy_n(const T* p, T* q, int n); // copy from [p:p + n) to [q:q + n)","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#exception_4","text":"If the order of the parameters is not important, there is no problem: int max(int a, int b);","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#alternative_2","text":"Don\u2019t pass arrays as pointers, pass an object representing a range (e.g., a span ): void copy_n(span<const T> p, span<T> q); // copy from p to q","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#alternative_3","text":"Define a struct as the parameter type and name the fields for those parameters accordingly: struct SystemParams { string config_file; string output_path; seconds timeout; }; void initialize(SystemParams p); This tends to make invocations of this clear to future readers, as the parameters are often filled in by name at the call site.","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#enforcement_25","text":"(Simple) Warn if two consecutive parameters share the same type.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i25-prefer-abstract-classes-as-interfaces-to-class-hierarchies","text":"","title":"I.25: Prefer abstract classes as interfaces to class hierarchies"},{"location":"cppcg/CppCoreGuidelines/#reason_29","text":"Abstract classes are more likely to be stable than base classes with state.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_17","text":"You just knew that Shape would turn up somewhere :-) class Shape { // bad: interface class loaded with data public: Point center() const { return c; } virtual void draw() const; virtual void rotate(int); // ... private: Point c; vector<Point> outline; Color col; }; This will force every derived class to compute a center \u2013 even if that\u2019s non-trivial and the center is never used. Similarly, not every Shape has a Color , and many Shape s are best represented without an outline defined as a sequence of Point s. Abstract classes were invented to discourage users from writing such classes: class Shape { // better: Shape is a pure interface public: virtual Point center() const = 0; // pure virtual functions virtual void draw() const = 0; virtual void rotate(int) = 0; // ... // ... no data members ... // ... virtual ~Shape() = default; };","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_26","text":"(Simple) Warn if a pointer/reference to a class C is assigned to a pointer/reference to a base of C and the base class contains data members.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i26-if-you-want-a-cross-compiler-abi-use-a-c-style-subset","text":"","title":"I.26: If you want a cross-compiler ABI, use a C-style subset"},{"location":"cppcg/CppCoreGuidelines/#reason_30","text":"Different compilers implement different binary layouts for classes, exception handling, function names, and other implementation details.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#exception_5","text":"Common ABIs are emerging on some platforms freeing you from the more draconian restrictions.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#note_40","text":"If you use a single compiler, you can use full C++ in interfaces. That may require recompilation after an upgrade to a new compiler version.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_27","text":"(Not enforceable) It is difficult to reliably identify where an interface forms part of an ABI.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i27-for-stable-library-abi-consider-the-pimpl-idiom","text":"","title":"I.27: For stable library ABI, consider the Pimpl idiom"},{"location":"cppcg/CppCoreGuidelines/#reason_31","text":"Because private data members participate in class layout and private member functions participate in overload resolution, changes to those implementation details require recompilation of all users of a class that uses them. A non-polymorphic interface class holding a pointer to implementation (Pimpl) can isolate the users of a class from changes in its implementation at the cost of an indirection.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_28","text":"interface (widget.h) class widget { class impl; std::unique_ptr<impl> pimpl; public: void draw(); // public API that will be forwarded to the implementation widget(int); // defined in the implementation file ~widget(); // defined in the implementation file, where impl is a complete type widget(widget&&) = default; widget(const widget&) = delete; widget& operator=(widget&&); // defined in the implementation file widget& operator=(const widget&) = delete; }; implementation (widget.cpp) class widget::impl { int n; // private data public: void draw(const widget& w) { /* ... */ } impl(int n) : n(n) {} }; void widget::draw() { pimpl->draw(*this); } widget::widget(int n) : pimpl{std::make_unique<impl>(n)} {} widget::~widget() = default; widget& widget::operator=(widget&&) = default;","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#notes","text":"See GOTW #100 and cppreference for the trade-offs and additional implementation details associated with this idiom.","title":"Notes"},{"location":"cppcg/CppCoreGuidelines/#enforcement_28","text":"(Not enforceable) It is difficult to reliably identify where an interface forms part of an ABI.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#i30-encapsulate-rule-violations","text":"","title":"I.30: Encapsulate rule violations"},{"location":"cppcg/CppCoreGuidelines/#reason_32","text":"To keep code simple and safe. Sometimes, ugly, unsafe, or error-prone techniques are necessary for logical or performance reasons. If so, keep them local, rather than \u201cinfecting\u201d interfaces so that larger groups of programmers have to be aware of the subtleties. Implementation complexity should, if at all possible, not leak through interfaces into user code.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_29","text":"Consider a program that, depending on some form of input (e.g., arguments to main ), should consume input from a file, from the command line, or from standard input. We might write bool owned; owner<istream*> inp; switch (source) { case std_in: owned = false; inp = &cin; break; case command_line: owned = true; inp = new istringstream{argv[2]}; break; case file: owned = true; inp = new ifstream{argv[2]}; break; } istream& in = *inp; This violated the rule against uninitialized variables , the rule against ignoring ownership , and the rule against magic constants . In particular, someone has to remember to somewhere write if (owned) delete inp; We could handle this particular example by using unique_ptr with a special deleter that does nothing for cin , but that\u2019s complicated for novices (who can easily encounter this problem) and the example is an example of a more general problem where a property that we would like to consider static (here, ownership) needs infrequently be addressed at run time. The common, most frequent, and safest examples can be handled statically, so we don\u2019t want to add cost and complexity to those. But we must also cope with the uncommon, less-safe, and necessarily more expensive cases. Such examples are discussed in [Str15] . So, we write a class class Istream { [[gsl::suppress(lifetime)]] public: enum Opt { from_line = 1 }; Istream() { } Istream(zstring p) :owned{true}, inp{new ifstream{p}} {} // read from file Istream(zstring p, Opt) :owned{true}, inp{new istringstream{p}} {} // read from command line ~Istream() { if (owned) delete inp; } operator istream& () { return *inp; } private: bool owned = false; istream* inp = &cin; }; Now, the dynamic nature of istream ownership has been encapsulated. Presumably, a bit of checking for potential errors would be added in real code.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_29","text":"Hard, it is hard to decide what rule-breaking code is essential Flag rule suppression that enable rule-violations to cross interfaces","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f-functions","text":"A function specifies an action or a computation that takes the system from one consistent state to the next. It is the fundamental building block of programs. It should be possible to name a function meaningfully, to specify the requirements of its argument, and clearly state the relationship between the arguments and the result. An implementation is not a specification. Try to think about what a function does as well as about how it does it. Functions are the most critical part in most interfaces, so see the interface rules. Function rule summary: Function definition rules: F.1: \u201cPackage\u201d meaningful operations as carefully named functions F.2: A function should perform a single logical operation F.3: Keep functions short and simple F.4: If a function may have to be evaluated at compile time, declare it constexpr F.5: If a function is very small and time-critical, declare it inline F.6: If your function may not throw, declare it noexcept F.7: For general use, take T* or T& arguments rather than smart pointers F.8: Prefer pure functions F.9: Unused parameters should be unnamed Parameter passing expression rules: F.15: Prefer simple and conventional ways of passing information F.16: For \u201cin\u201d parameters, pass cheaply-copied types by value and others by reference to const F.17: For \u201cin-out\u201d parameters, pass by reference to non- const F.18: For \u201cwill-move-from\u201d parameters, pass by X&& and std::move the parameter F.19: For \u201cforward\u201d parameters, pass by TP&& and only std::forward the parameter F.20: For \u201cout\u201d output values, prefer return values to output parameters F.21: To return multiple \u201cout\u201d values, prefer returning a struct or tuple F.60: Prefer T* over T& when \u201cno argument\u201d is a valid option Parameter passing semantic rules: F.22: Use T* or owner<T*> to designate a single object F.23: Use a not_null<T> to indicate that \u201cnull\u201d is not a valid value F.24: Use a span<T> or a span_p<T> to designate a half-open sequence F.25: Use a zstring or a not_null<zstring> to designate a C-style string F.26: Use a unique_ptr<T> to transfer ownership where a pointer is needed F.27: Use a shared_ptr<T> to share ownership Value return semantic rules: F.42: Return a T* to indicate a position (only) F.43: Never (directly or indirectly) return a pointer or a reference to a local object F.44: Return a T& when copy is undesirable and \u201creturning no object\u201d isn\u2019t needed F.45: Don\u2019t return a T&& F.46: int is the return type for main() F.47: Return T& from assignment operators F.48: Don\u2019t return std::move(local) Other function rules: F.50: Use a lambda when a function won\u2019t do (to capture local variables, or to write a local function) F.51: Where there is a choice, prefer default arguments over overloading F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread F.54: If you capture this , capture all variables explicitly (no default capture) F.55: Don\u2019t use va_arg arguments Functions have strong similarities to lambdas and function objects. See also : C.lambdas: Function objects and lambdas","title":"F: Functions"},{"location":"cppcg/CppCoreGuidelines/#fdef-function-definitions","text":"A function definition is a function declaration that also specifies the function\u2019s implementation, the function body.","title":"F.def: Function definitions"},{"location":"cppcg/CppCoreGuidelines/#f1-package-meaningful-operations-as-carefully-named-functions","text":"","title":"F.1: \"Package\" meaningful operations as carefully named functions"},{"location":"cppcg/CppCoreGuidelines/#reason_33","text":"Factoring out common code makes code more readable, more likely to be reused, and limit errors from complex code. If something is a well-specified action, separate it out from its surrounding code and give it a name.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-dont_1","text":"void read_and_print(istream& is) // read and print an int { int x; if (is >> x) cout << \"the int is \" << x << '\\n'; else cerr << \"no int on input\\n\"; } Almost everything is wrong with read_and_print . It reads, it writes (to a fixed ostream ), it writes error messages (to a fixed ostream ), it handles only int s. There is nothing to reuse, logically separate operations are intermingled and local variables are in scope after the end of their logical use. For a tiny example, this looks OK, but if the input operation, the output operation, and the error handling had been more complicated the tangled mess could become hard to understand.","title":"Example, don't"},{"location":"cppcg/CppCoreGuidelines/#note_41","text":"If you write a non-trivial lambda that potentially can be used in more than one place, give it a name by assigning it to a (usually non-local) variable.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_30","text":"sort(a, b, [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); }); Naming that lambda breaks up the expression into its logical parts and provides a strong hint to the meaning of the lambda. auto lessT = [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); }; sort(a, b, lessT); find_if(a, b, lessT); The shortest code is not always the best for performance or maintainability.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_6","text":"Loop bodies, including lambdas used as loop bodies, rarely need to be named. However, large loop bodies (e.g., dozens of lines or dozens of pages) can be a problem. The rule Keep functions short and simple implies \u201cKeep loop bodies short.\u201d Similarly, lambdas used as callback arguments are sometimes non-trivial, yet unlikely to be reusable.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_30","text":"See Keep functions short and simple Flag identical and very similar lambdas used in different places.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f2-a-function-should-perform-a-single-logical-operation","text":"","title":"F.2: A function should perform a single logical operation"},{"location":"cppcg/CppCoreGuidelines/#reason_34","text":"A function that performs a single operation is simpler to understand, test, and reuse.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_31","text":"Consider: void read_and_print() // bad { int x; cin >> x; // check for errors cout << x << \"\\n\"; } This is a monolith that is tied to a specific input and will never find another (different) use. Instead, break functions up into suitable logical parts and parameterize: int read(istream& is) // better { int x; is >> x; // check for errors return x; } void print(ostream& os, int x) { os << x << \"\\n\"; } These can now be combined where needed: void read_and_print() { auto x = read(cin); print(cout, x); } If there was a need, we could further templatize read() and print() on the data type, the I/O mechanism, the response to errors, etc. Example: auto read = [](auto& input, auto& value) // better { input >> value; // check for errors }; auto print(auto& output, const auto& value) { output << value << \"\\n\"; }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_31","text":"Consider functions with more than one \u201cout\u201d parameter suspicious. Use return values instead, including tuple for multiple return values. Consider \u201clarge\u201d functions that don\u2019t fit on one editor screen suspicious. Consider factoring such a function into smaller well-named suboperations. Consider functions with 7 or more parameters suspicious.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f3-keep-functions-short-and-simple","text":"","title":"F.3: Keep functions short and simple"},{"location":"cppcg/CppCoreGuidelines/#reason_35","text":"Large functions are hard to read, more likely to contain complex code, and more likely to have variables in larger than minimal scopes. Functions with complex control structures are more likely to be long and more likely to hide logical errors","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_32","text":"Consider: double simple_func(double val, int flag1, int flag2) // simple_func: takes a value and calculates the expected ASIC output, // given the two mode flags. { double intermediate; if (flag1 > 0) { intermediate = func1(val); if (flag2 % 2) intermediate = sqrt(intermediate); } else if (flag1 == -1) { intermediate = func1(-val); if (flag2 % 2) intermediate = sqrt(-intermediate); flag1 = -flag1; } if (abs(flag2) > 10) { intermediate = func2(intermediate); } switch (flag2 / 10) { case 1: if (flag1 == -1) return finalize(intermediate, 1.171); break; case 2: return finalize(intermediate, 13.1); default: break; } return finalize(intermediate, 0.); } This is too complex. How would you know if all possible alternatives have been correctly handled? Yes, it breaks other rules also. We can refactor: double func1_muon(double val, int flag) { // ??? } double func1_tau(double val, int flag1, int flag2) { // ??? } double simple_func(double val, int flag1, int flag2) // simple_func: takes a value and calculates the expected ASIC output, // given the two mode flags. { if (flag1 > 0) return func1_muon(val, flag2); if (flag1 == -1) // handled by func1_tau: flag1 = -flag1; return func1_tau(-val, flag1, flag2); return 0.; }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_42","text":"\u201cIt doesn\u2019t fit on a screen\u201d is often a good practical definition of \u201cfar too large.\u201d One-to-five-line functions should be considered normal.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_43","text":"Break large functions up into smaller cohesive and named functions. Small simple functions are easily inlined where the cost of a function call is significant.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_32","text":"Flag functions that do not \u201cfit on a screen.\u201d How big is a screen? Try 60 lines by 140 characters; that\u2019s roughly the maximum that\u2019s comfortable for a book page. Flag functions that are too complex. How complex is too complex? You could use cyclomatic complexity. Try \u201cmore than 10 logical path through.\u201d Count a simple switch as one path.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f4-if-a-function-may-have-to-be-evaluated-at-compile-time-declare-it-constexpr","text":"","title":"F.4: If a function may have to be evaluated at compile time, declare it constexpr"},{"location":"cppcg/CppCoreGuidelines/#reason_36","text":"constexpr is needed to tell the compiler to allow compile-time evaluation.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_33","text":"The (in)famous factorial: constexpr int fac(int n) { constexpr int max_exp = 17; // constexpr enables max_exp to be used in Expects Expects(0 <= n && n < max_exp); // prevent silliness and overflow int x = 1; for (int i = 2; i <= n; ++i) x *= i; return x; } This is C++14. For C++11, use a recursive formulation of fac() .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_44","text":"constexpr does not guarantee compile-time evaluation; it just guarantees that the function can be evaluated at compile time for constant expression arguments if the programmer requires it or the compiler decides to do so to optimize. constexpr int min(int x, int y) { return x < y ? x : y; } void test(int v) { int m1 = min(-1, 2); // probably compile-time evaluation constexpr int m2 = min(-1, 2); // compile-time evaluation int m3 = min(-1, v); // run-time evaluation constexpr int m4 = min(-1, v); // error: cannot evaluate at compile time }","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_45","text":"Don\u2019t try to make all functions constexpr . Most computation is best done at run time.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_46","text":"Any API that may eventually depend on high-level run-time configuration or business logic should not be made constexpr . Such customization can not be evaluated by the compiler, and any constexpr functions that depended upon that API would have to be refactored or drop constexpr .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_33","text":"Impossible and unnecessary. The compiler gives an error if a non- constexpr function is called where a constant is required.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f5-if-a-function-is-very-small-and-time-critical-declare-it-inline","text":"","title":"F.5: If a function is very small and time-critical, declare it inline"},{"location":"cppcg/CppCoreGuidelines/#reason_37","text":"Some optimizers are good at inlining without hints from the programmer, but don\u2019t rely on it. Measure! Over the last 40 years or so, we have been promised compilers that can inline better than humans without hints from humans. We are still waiting. Specifying inline encourages the compiler to do a better job.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_34","text":"inline string cat(const string& s, const string& s2) { return s + s2; }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_7","text":"Do not put an inline function in what is meant to be a stable interface unless you are certain that it will not change. An inline function is part of the ABI.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#note_47","text":"constexpr implies inline .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_48","text":"Member functions defined in-class are inline by default.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exception_8","text":"Template functions (incl. template member functions) are normally defined in headers and therefore inline.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_34","text":"Flag inline functions that are more than three statements and could have been declared out of line (such as class member functions).","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f6-if-your-function-may-not-throw-declare-it-noexcept","text":"","title":"F.6: If your function may not throw, declare it noexcept"},{"location":"cppcg/CppCoreGuidelines/#reason_38","text":"If an exception is not supposed to be thrown, the program cannot be assumed to cope with the error and should be terminated as soon as possible. Declaring a function noexcept helps optimizers by reducing the number of alternative execution paths. It also speeds up the exit after failure.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_35","text":"Put noexcept on every function written completely in C or in any other language without exceptions. The C++ Standard Library does that implicitly for all functions in the C Standard Library.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_49","text":"constexpr functions can throw when evaluated at run time, so you may need noexcept for some of those.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_36","text":"You can use noexcept even on functions that can throw: vector<string> collect(istream& is) noexcept { vector<string> res; for (string s; is >> s;) res.push_back(s); return res; } If collect() runs out of memory, the program crashes. Unless the program is crafted to survive memory exhaustion, that may be just the right thing to do; terminate() may generate suitable error log information (but after memory runs out it is hard to do anything clever).","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_50","text":"You must be aware of the execution environment that your code is running when deciding whether to tag a function noexcept , especially because of the issue of throwing and allocation. Code that is intended to be perfectly general (like the standard library and other utility code of that sort) needs to support environments where a bad_alloc exception may be handled meaningfully. However, most programs and execution environments cannot meaningfully handle a failure to allocate, and aborting the program is the cleanest and simplest response to an allocation failure in those cases. If you know that your application code cannot respond to an allocation failure, it may be appropriate to add noexcept even on functions that allocate. Put another way: In most programs, most functions can throw (e.g., because they use new , call functions that do, or use library functions that reports failure by throwing), so don\u2019t just sprinkle noexcept all over the place without considering whether the possible exceptions can be handled. noexcept is most useful (and most clearly correct) for frequently used, low-level functions.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_51","text":"Destructors, swap functions, move operations, and default constructors should never throw. See also C.44 .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_35","text":"Flag functions that are not noexcept , yet cannot throw. Flag throwing swap , move , destructors, and default constructors.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f7-for-general-use-take-t-or-t-arguments-rather-than-smart-pointers","text":"","title":"F.7: For general use, take T* or T&amp; arguments rather than smart pointers"},{"location":"cppcg/CppCoreGuidelines/#reason_39","text":"Passing a smart pointer transfers or shares ownership and should only be used when ownership semantics are intended (see R.30 ). Passing by smart pointer restricts the use of a function to callers that use smart pointers. Passing a shared smart pointer (e.g., std::shared_ptr ) implies a run-time cost.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_37","text":"// accepts any int* void f(int*); // can only accept ints for which you want to transfer ownership void g(unique_ptr<int>); // can only accept ints for which you are willing to share ownership void g(shared_ptr<int>); // doesn't change ownership, but requires a particular ownership of the caller void h(const unique_ptr<int>&); // accepts any int void h(int&);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_18","text":"// callee void f(shared_ptr<widget>& w) { // ... use(*w); // only use of w -- the lifetime is not used at all // ... }; See further in R.30 .","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_52","text":"We can catch dangling pointers statically, so we don\u2019t need to rely on resource management to avoid violations from dangling pointers. See also : Prefer T* over T& when \u201cno argument\u201d is a valid option Smart pointer rule summary","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_36","text":"Flag a parameter of a smart pointer type (a type that overloads operator-> or operator* ) for which the ownership semantics are not used; that is copyable but never copied/moved from or movable but never moved and that is never modified or passed along to another function that could do so.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f8-prefer-pure-functions","text":"","title":"F.8: Prefer pure functions"},{"location":"cppcg/CppCoreGuidelines/#reason_40","text":"Pure functions are easier to reason about, sometimes easier to optimize (and even parallelize), and sometimes can be memoized.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_38","text":"template<class T> auto square(T t) { return t * t; }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_37","text":"Not possible.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f9-unused-parameters-should-be-unnamed","text":"","title":"F.9: Unused parameters should be unnamed"},{"location":"cppcg/CppCoreGuidelines/#reason_41","text":"Readability. Suppression of unused parameter warnings.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_39","text":"X* find(map<Blob>& m, const string& s, Hint); // once upon a time, a hint was used","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_53","text":"Allowing parameters to be unnamed was introduced in the early 1980 to address this problem.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_38","text":"Flag named unused parameters.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#fcall-parameter-passing","text":"There are a variety of ways to pass parameters to a function and to return values.","title":"F.call: Parameter passing"},{"location":"cppcg/CppCoreGuidelines/#f15-prefer-simple-and-conventional-ways-of-passing-information","text":"","title":"F.15: Prefer simple and conventional ways of passing information"},{"location":"cppcg/CppCoreGuidelines/#reason_42","text":"Using \u201cunusual and clever\u201d techniques causes surprises, slows understanding by other programmers, and encourages bugs. If you really feel the need for an optimization beyond the common techniques, measure to ensure that it really is an improvement, and document/comment because the improvement may not be portable. The following tables summarize the advice in the following Guidelines, F.16-21. Normal parameter passing: Advanced parameter passing: Use the advanced techniques only after demonstrating need, and document that need in a comment.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#f16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const","text":"","title":"F.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to const"},{"location":"cppcg/CppCoreGuidelines/#reason_43","text":"Both let the caller know that a function will not modify the argument, and both allow initialization by rvalues. What is \u201ccheap to copy\u201d depends on the machine architecture, but two or three words (doubles, pointers, references) are usually best passed by value. When copying is cheap, nothing beats the simplicity and safety of copying, and for small objects (up to two or three words) it is also faster than passing by reference because it does not require an extra indirection to access from the function.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_40","text":"void f1(const string& s); // OK: pass by reference to const; always cheap void f2(string s); // bad: potentially expensive void f3(int x); // OK: Unbeatable void f4(const int& x); // bad: overhead on access in f4() For advanced uses (only), where you really need to optimize for rvalues passed to \u201cinput-only\u201d parameters: If the function is going to unconditionally move from the argument, take it by && . See F.18 . If the function is going to keep a copy of the argument, in addition to passing by const& (for lvalues), add an overload that passes the parameter by && (for rvalues) and in the body std::move s it to its destination. Essentially this overloads a \u201cwill-move-from\u201d; see F.18 . In special cases, such as multiple \u201cinput + copy\u201d parameters, consider using perfect forwarding. See F.19 .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_41","text":"int multiply(int, int); // just input ints, pass by value // suffix is input-only but not as cheap as an int, pass by const& string& concatenate(string&, const string& suffix); void sink(unique_ptr<widget>); // input only, and moves ownership of the widget Avoid \u201cesoteric techniques\u201d such as: Passing arguments as T&& \u201cfor efficiency\u201d. Most rumors about performance advantages from passing by && are false or brittle (but see F.18 and F.19 ). Returning const T& from assignments and similar operations (see F.47 .)","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_42","text":"Assuming that Matrix has move operations (possibly by keeping its elements in a std::vector ): Matrix operator+(const Matrix& a, const Matrix& b) { Matrix res; // ... fill res with the sum ... return res; } Matrix x = m1 + m2; // move constructor y = m3 + m3; // move assignment","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#notes_1","text":"The return value optimization doesn\u2019t handle the assignment case, but the move assignment does. A reference may be assumed to refer to a valid object (language rule). There is no (legitimate) \u201cnull reference.\u201d If you need the notion of an optional value, use a pointer, std::optional , or a special value used to denote \u201cno value.\u201d","title":"Notes"},{"location":"cppcg/CppCoreGuidelines/#enforcement_39","text":"(Simple) ((Foundation)) Warn when a parameter being passed by value has a size greater than 2 * sizeof(void*) . Suggest using a reference to const instead. (Simple) ((Foundation)) Warn when a parameter passed by reference to const has a size less than 2 * sizeof(void*) . Suggest passing by value instead. (Simple) ((Foundation)) Warn when a parameter passed by reference to const is move d.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f17-for-in-out-parameters-pass-by-reference-to-non-const","text":"","title":"F.17: For \"in-out\" parameters, pass by reference to non-const"},{"location":"cppcg/CppCoreGuidelines/#reason_44","text":"This makes it clear to callers that the object is assumed to be modified.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_43","text":"void update(Record& r); // assume that update writes to r","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_54","text":"A T& argument can pass information into a function as well as out of it. Thus T& could be an in-out-parameter. That can in itself be a problem and a source of errors: void f(string& s) { s = \"New York\"; // non-obvious error } void g() { string buffer = \".................................\"; f(buffer); // ... } Here, the writer of g() is supplying a buffer for f() to fill, but f() simply replaces it (at a somewhat higher cost than a simple copy of the characters). A bad logic error can happen if the writer of g() incorrectly assumes the size of the buffer .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_40","text":"(Moderate) ((Foundation)) Warn about functions regarding reference to non- const parameters that do not write to them. (Simple) ((Foundation)) Warn when a non- const parameter being passed by reference is move d.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f18-for-will-move-from-parameters-pass-by-x-and-stdmove-the-parameter","text":"","title":"F.18: For \"will-move-from\" parameters, pass by X&amp;&amp; and std::move the parameter"},{"location":"cppcg/CppCoreGuidelines/#reason_45","text":"It\u2019s efficient and eliminates bugs at the call site: X&& binds to rvalues, which requires an explicit std::move at the call site if passing an lvalue.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_44","text":"void sink(vector<int>&& v) { // sink takes ownership of whatever the argument owned // usually there might be const accesses of v here store_somewhere(std::move(v)); // usually no more use of v here; it is moved-from } Note that the std::move(v) makes it possible for store_somewhere() to leave v in a moved-from state. That could be dangerous .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_9","text":"Unique owner types that are move-only and cheap-to-move, such as unique_ptr , can also be passed by value which is simpler to write and achieves the same effect. Passing by value does generate one extra (cheap) move operation, but prefer simplicity and clarity first. For example: template <class T> void sink(std::unique_ptr<T> p) { // use p ... possibly std::move(p) onward somewhere else } // p gets destroyed","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_41","text":"Flag all X&& parameters (where X is not a template type parameter name) where the function body uses them without std::move . Flag access to moved-from objects. Don\u2019t conditionally move from objects","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f19-for-forward-parameters-pass-by-tp-and-only-stdforward-the-parameter","text":"","title":"F.19: For \"forward\" parameters, pass by TP&amp;&amp; and only std::forward the parameter"},{"location":"cppcg/CppCoreGuidelines/#reason_46","text":"If the object is to be passed onward to other code and not directly used by this function, we want to make this function agnostic to the argument const -ness and rvalue-ness. In that case, and only that case, make the parameter TP&& where TP is a template type parameter \u2013 it both ignores and preserves const -ness and rvalue-ness. Therefore any code that uses a TP&& is implicitly declaring that it itself doesn\u2019t care about the variable\u2019s const -ness and rvalue-ness (because it is ignored), but that intends to pass the value onward to other code that does care about const -ness and rvalue-ness (because it is preserved). When used as a parameter TP&& is safe because any temporary objects passed from the caller will live for the duration of the function call. A parameter of type TP&& should essentially always be passed onward via std::forward in the body of the function.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_45","text":"template <class F, class... Args> inline auto invoke(F f, Args&&... args) { return f(forward<Args>(args)...); } ??? calls ???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_42","text":"Flag a function that takes a TP&& parameter (where TP is a template type parameter name) and does anything with it other than std::forward ing it exactly once on every static path.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f20-for-out-output-values-prefer-return-values-to-output-parameters","text":"","title":"F.20: For \"out\" output values, prefer return values to output parameters"},{"location":"cppcg/CppCoreGuidelines/#reason_47","text":"A return value is self-documenting, whereas a & could be either in-out or out-only and is liable to be misused. This includes large objects like standard containers that use implicit move operations for performance and to avoid explicit memory management. If you have multiple values to return, use a tuple or similar multi-member type.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_46","text":"// OK: return pointers to elements with the value x vector<const int*> find_all(const vector<int>&, int x); // Bad: place pointers to elements with value x in-out void find_all(const vector<int>&, vector<const int*>& out, int x);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_55","text":"A struct of many (individually cheap-to-move) elements may be in aggregate expensive to move. It is not recommended to return a const value. Such older advice is now obsolete; it does not add value, and it interferes with move semantics. const vector<int> fct(); // bad: that \"const\" is more trouble than it is worth vector<int> g(const vector<int>& vx) { // ... fct() = vx; // prevented by the \"const\" // ... return fct(); // expensive copy: move semantics suppressed by the \"const\" } The argument for adding const to a return value is that it prevents (very rare) accidental access to a temporary. The argument against is prevents (very frequent) use of move semantics.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exceptions","text":"For non-value types, such as types in an inheritance hierarchy, return the object by unique_ptr or shared_ptr . If a type is expensive to move (e.g., array<BigPOD> ), consider allocating it on the free store and return a handle (e.g., unique_ptr ), or passing it in a reference to non- const target object to fill (to be used as an out-parameter). To reuse an object that carries capacity (e.g., std::string , std::vector ) across multiple calls to the function in an inner loop: treat it as an in/out parameter and pass by reference .","title":"Exceptions"},{"location":"cppcg/CppCoreGuidelines/#example_47","text":"struct Package { // exceptional case: expensive-to-move object char header[16]; char load[2024 - 16]; }; Package fill(); // Bad: large return value void fill(Package&); // OK int val(); // OK void val(int&); // Bad: Is val reading its argument","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_43","text":"Flag reference to non- const parameters that are not read before being written to and are a type that could be cheaply returned; they should be \u201cout\u201d return values. Flag returning a const value. To fix: Remove const to return a non- const value instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f21-to-return-multiple-out-values-prefer-returning-a-struct-or-tuple","text":"","title":"F.21: To return multiple \"out\" values, prefer returning a struct or tuple"},{"location":"cppcg/CppCoreGuidelines/#reason_48","text":"A return value is self-documenting as an \u201coutput-only\u201d value. Note that C++ does have multiple return values, by convention of using a tuple (including pair ), possibly with the extra convenience of tie at the call site. Prefer using a named struct where there are semantics to the returned value. Otherwise, a nameless tuple is useful in generic code.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_48","text":"// BAD: output-only parameter documented in a comment int f(const string& input, /*output only*/ string& output_data) { // ... output_data = something(); return status; } // GOOD: self-documenting tuple<int, string> f(const string& input) { // ... return make_tuple(status, something()); } C++98\u2019s standard library already used this style, because a pair is like a two-element tuple . For example, given a set<string> my_set , consider: // C++98 result = my_set.insert(\"Hello\"); if (result.second) do_something_with(result.first); // workaround With C++11 we can write this, putting the results directly in existing local variables: Sometype iter; // default initialize if we haven't already Someothertype success; // used these variables for some other purpose tie(iter, success) = my_set.insert(\"Hello\"); // normal return value if (success) do_something_with(iter); With C++17 we are able to use \u201cstructured bindings\u201d to declare and initialize the multiple variables: if (auto [ iter, success ] = my_set.insert(\"Hello\"); success) do_something_with(iter);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_10","text":"Sometimes, we need to pass an object to a function to manipulate its state. In such cases, passing the object by reference T& is usually the right technique. Explicitly passing an in-out parameter back out again as a return value is often not necessary. For example: istream& operator>>(istream& is, string& s); // much like std::operator>>() for (string s; cin >> s; ) { // do something with line } Here, both s and cin are used as in-out parameters. We pass cin by (non- const ) reference to be able to manipulate its state. We pass s to avoid repeated allocations. By reusing s (passed by reference), we allocate new memory only when we need to expand s \u2018s capacity. This technique is sometimes called the \u201ccaller-allocated out\u201d pattern and is particularly useful for types, such as string and vector , that needs to do free store allocations. To compare, if we passed out all values as return values, we would something like this: pair<istream&, string> get_string(istream& is); // not recommended { string s; is >> s; return {is, s}; } for (auto p = get_string(cin); p.first; ) { // do something with p.second } We consider that significantly less elegant with significantly less performance. For a truly strict reading of this rule (F.21), the exception isn\u2019t really an exception because it relies on in-out parameters, rather than the plain out parameters mentioned in the rule. However, we prefer to be explicit, rather than subtle.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#note_56","text":"In many cases, it may be useful to return a specific, user-defined type. For example: struct Distance { int value; int unit = 1; // 1 means meters }; Distance d1 = measure(obj1); // access d1.value and d1.unit auto d2 = measure(obj2); // access d2.value and d2.unit auto [value, unit] = measure(obj3); // access value and unit; somewhat redundant // to people who know measure() auto [x, y] = measure(obj4); // don't; it's likely to be confusing The overly-generic pair and tuple should be used only when the value returned represents independent entities rather than an abstraction. Another example, use a specific type along the lines of variant<T, error_code> , rather than using the generic tuple .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_44","text":"Output parameters should be replaced by return values. An output parameter is one that the function writes to, invokes a non- const member function, or passes on as a non- const .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f22-use-t-or-ownert-to-designate-a-single-object","text":"","title":"F.22: Use T* or owner&lt;T*&gt; to designate a single object"},{"location":"cppcg/CppCoreGuidelines/#reason_49","text":"Readability: it makes the meaning of a plain pointer clear. Enables significant tool support.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_57","text":"In traditional C and C++ code, plain T* is used for many weakly-related purposes, such as: Identify a (single) object (not to be deleted by this function) Point to an object allocated on the free store (and delete it later) Hold the nullptr Identify a C-style string (zero-terminated array of characters) Identify an array with a length specified separately Identify a location in an array This makes it hard to understand what the code does and is supposed to do. It complicates checking and tool support.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_49","text":"void use(int* p, int n, char* s, int* q) { p[n - 1] = 666; // Bad: we don't know if p points to n elements; // assume it does not or use span<int> cout << s; // Bad: we don't know if that s points to a zero-terminated array of char; // assume it does not or use zstring delete q; // Bad: we don't know if *q is allocated on the free store; // assume it does not or use owner } better void use2(span<int> p, zstring s, owner<int*> q) { p[p.size() - 1] = 666; // OK, a range error can be caught cout << s; // OK delete q; // OK }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_58","text":"owner<T*> represents ownership, zstring represents a C-style string. Also : Assume that a T* obtained from a smart pointer to T (e.g., unique_ptr<T> ) points to a single element. See also : Support library See also : Do not pass an array as a single pointer","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_45","text":"(Simple) ((Bounds)) Warn for any arithmetic operation on an expression of pointer type that results in a value of pointer type.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f23-use-a-not_nullt-to-indicate-that-null-is-not-a-valid-value","text":"","title":"F.23: Use a not_null&lt;T&gt; to indicate that \"null\" is not a valid value"},{"location":"cppcg/CppCoreGuidelines/#reason_50","text":"Clarity. A function with a not_null<T> parameter makes it clear that the caller of the function is responsible for any nullptr checks that may be necessary. Similarly, a function with a return value of not_null<T> makes it clear that the caller of the function does not need to check for nullptr .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_50","text":"not_null<T*> makes it obvious to a reader (human or machine) that a test for nullptr is not necessary before dereference. Additionally, when debugging, owner<T*> and not_null<T> can be instrumented to check for correctness. Consider: int length(Record* p); When I call length(p) should I check if p is nullptr first? Should the implementation of length() check if p is nullptr ? // it is the caller's job to make sure p != nullptr int length(not_null<Record*> p); // the implementor of length() must assume that p == nullptr is possible int length(Record* p);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_59","text":"A not_null<T*> is assumed not to be the nullptr ; a T* may be the nullptr ; both can be represented in memory as a T* (so no run-time overhead is implied).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_60","text":"not_null is not just for built-in pointers. It works for unique_ptr , shared_ptr , and other pointer-like types.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_46","text":"(Simple) Warn if a raw pointer is dereferenced without being tested against nullptr (or equivalent) within a function, suggest it is declared not_null instead. (Simple) Error if a raw pointer is sometimes dereferenced after first being tested against nullptr (or equivalent) within the function and sometimes is not. (Simple) Warn if a not_null pointer is tested against nullptr within a function.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f24-use-a-spant-or-a-span_pt-to-designate-a-half-open-sequence","text":"","title":"F.24: Use a span&lt;T&gt; or a span_p&lt;T&gt; to designate a half-open sequence"},{"location":"cppcg/CppCoreGuidelines/#reason_51","text":"Informal/non-explicit ranges are a source of errors.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_51","text":"X* find(span<X> r, const X& v); // find v in r vector<X> vec; // ... auto p = find({vec.begin(), vec.end()}, X{}); // find X{} in vec","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_61","text":"Ranges are extremely common in C++ code. Typically, they are implicit and their correct use is very hard to ensure. In particular, given a pair of arguments (p, n) designating an array [p:p+n) , it is in general impossible to know if there really are n elements to access following *p . span<T> and span_p<T> are simple helper classes designating a [p:q) range and a range starting with p and ending with the first element for which a predicate is true, respectively.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_52","text":"A span represents a range of elements, but how do we manipulate elements of that range? void f(span<int> s) { // range traversal (guaranteed correct) for (int x : s) cout << x << '\\n'; // C-style traversal (potentially checked) for (gsl::index i = 0; i < s.size(); ++i) cout << s[i] << '\\n'; // random access (potentially checked) s[7] = 9; // extract pointers (potentially checked) std::sort(&s[0], &s[s.size() / 2]); }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_62","text":"A span<T> object does not own its elements and is so small that it can be passed by value. Passing a span object as an argument is exactly as efficient as passing a pair of pointer arguments or passing a pointer and an integer count. See also : Support library","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_47","text":"(Complex) Warn where accesses to pointer parameters are bounded by other parameters that are integral types and suggest they could use span instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f25-use-a-zstring-or-a-not_nullzstring-to-designate-a-c-style-string","text":"","title":"F.25: Use a zstring or a not_null&lt;zstring&gt; to designate a C-style string"},{"location":"cppcg/CppCoreGuidelines/#reason_52","text":"C-style strings are ubiquitous. They are defined by convention: zero-terminated arrays of characters. We must distinguish C-style strings from a pointer to a single character or an old-fashioned pointer to an array of characters. If you don\u2019t need null termination, use string_view .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_53","text":"Consider: int length(const char* p); When I call length(s) should I check if s is nullptr first? Should the implementation of length() check if p is nullptr ? // the implementor of length() must assume that p == nullptr is possible int length(zstring p); // it is the caller's job to make sure p != nullptr int length(not_null<zstring> p);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_63","text":"zstring does not represent ownership. See also : Support library","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#f26-use-a-unique_ptrt-to-transfer-ownership-where-a-pointer-is-needed","text":"","title":"F.26: Use a unique_ptr&lt;T&gt; to transfer ownership where a pointer is needed"},{"location":"cppcg/CppCoreGuidelines/#reason_53","text":"Using unique_ptr is the cheapest way to pass a pointer safely. See also : C.50 regarding when to return a shared_ptr from a factory.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_54","text":"unique_ptr<Shape> get_shape(istream& is) // assemble shape from input stream { auto kind = read_header(is); // read header and identify the next shape on input switch (kind) { case kCircle: return make_unique<Circle>(is); case kTriangle: return make_unique<Triangle>(is); // ... } }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_64","text":"You need to pass a pointer rather than an object if what you are transferring is an object from a class hierarchy that is to be used through an interface (base class).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_48","text":"(Simple) Warn if a function returns a locally allocated raw pointer. Suggest using either unique_ptr or shared_ptr instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f27-use-a-shared_ptrt-to-share-ownership","text":"","title":"F.27: Use a shared_ptr&lt;T&gt; to share ownership"},{"location":"cppcg/CppCoreGuidelines/#reason_54","text":"Using std::shared_ptr is the standard way to represent shared ownership. That is, the last owner deletes the object.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_55","text":"shared_ptr<const Image> im { read_image(somewhere) }; std::thread t0 {shade, args0, top_left, im}; std::thread t1 {shade, args1, top_right, im}; std::thread t2 {shade, args2, bottom_left, im}; std::thread t3 {shade, args3, bottom_right, im}; // detach threads // last thread to finish deletes the image","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_65","text":"Prefer a unique_ptr over a shared_ptr if there is never more than one owner at a time. shared_ptr is for shared ownership. Note that pervasive use of shared_ptr has a cost (atomic operations on the shared_ptr \u2018s reference count have a measurable aggregate cost).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#alternative_4","text":"Have a single object own the shared object (e.g. a scoped object) and destroy that (preferably implicitly) when all users have completed.","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#enforcement_49","text":"(Not enforceable) This is a too complex pattern to reliably detect.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f60-prefer-t-over-t-when-no-argument-is-a-valid-option","text":"","title":"F.60: Prefer T* over T&amp; when \"no argument\" is a valid option"},{"location":"cppcg/CppCoreGuidelines/#reason_55","text":"A pointer ( T* ) can be a nullptr and a reference ( T& ) cannot, there is no valid \u201cnull reference\u201d. Sometimes having nullptr as an alternative to indicated \u201cno object\u201d is useful, but if it is not, a reference is notationally simpler and might yield better code.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_56","text":"string zstring_to_string(zstring p) // zstring is a char*; that is a C-style string { if (!p) return string{}; // p might be nullptr; remember to check return string{p}; } void print(const vector<int>& r) { // r refers to a vector<int>; no check needed }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_66","text":"It is possible, but not valid C++ to construct a reference that is essentially a nullptr (e.g., T* p = nullptr; T& r = (T&)*p; ). That error is very uncommon.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_67","text":"If you prefer the pointer notation ( -> and/or * vs. . ), not_null<T*> provides the same guarantee as T& .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_50","text":"Flag ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f42-return-a-t-to-indicate-a-position-only","text":"","title":"F.42: Return a T* to indicate a position (only)"},{"location":"cppcg/CppCoreGuidelines/#reason_56","text":"That\u2019s what pointers are good for. Returning a T* to transfer ownership is a misuse.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_57","text":"Node* find(Node* t, const string& s) // find s in a binary tree of Nodes { if (!t || t->name == s) return t; if ((auto p = find(t->left, s))) return p; if ((auto p = find(t->right, s))) return p; return nullptr; } If it isn\u2019t the nullptr , the pointer returned by find indicates a Node holding s . Importantly, that does not imply a transfer of ownership of the pointed-to object to the caller.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_68","text":"Positions can also be transferred by iterators, indices, and references. A reference is often a superior alternative to a pointer if there is no need to use nullptr or if the object referred to should not change .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_69","text":"Do not return a pointer to something that is not in the caller\u2019s scope; see F.43 . See also : discussion of dangling pointer prevention","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_51","text":"Flag delete , std::free() , etc. applied to a plain T* . Only owners should be deleted. Flag new , malloc() , etc. assigned to a plain T* . Only owners should be responsible for deletion.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f43-never-directly-or-indirectly-return-a-pointer-or-a-reference-to-a-local-object","text":"","title":"F.43: Never (directly or indirectly) return a pointer or a reference to a local object"},{"location":"cppcg/CppCoreGuidelines/#reason_57","text":"To avoid the crashes and data corruption that can result from the use of such a dangling pointer.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_19","text":"After the return from a function its local objects no longer exist: int* f() { int fx = 9; return &fx; // BAD } void g(int* p) // looks innocent enough { int gx; cout << \"*p == \" << *p << '\\n'; *p = 999; cout << \"gx == \" << gx << '\\n'; } void h() { int* p = f(); int z = *p; // read from abandoned stack frame (bad) g(p); // pass pointer to abandoned stack frame to function (bad) } Here on one popular implementation I got the output: *p == 999 gx == 999 I expected that because the call of g() reuses the stack space abandoned by the call of f() so *p refers to the space now occupied by gx . Imagine what would happen if fx and gx were of different types. Imagine what would happen if fx or gx was a type with an invariant. Imagine what would happen if more that dangling pointer was passed around among a larger set of functions. Imagine what a cracker could do with that dangling pointer. Fortunately, most (all?) modern compilers catch and warn against this simple case.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_70","text":"This applies to references as well: int& f() { int x = 7; // ... return x; // Bad: returns reference to object that is about to be destroyed }","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_71","text":"This applies only to non- static local variables. All static variables are (as their name indicates) statically allocated, so that pointers to them cannot dangle.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad_20","text":"Not all examples of leaking a pointer to a local variable are that obvious: int* glob; // global variables are bad in so many ways template<class T> void steal(T x) { glob = x(); // BAD } void f() { int i = 99; steal([&] { return &i; }); } int main() { f(); cout << *glob << '\\n'; } Here I managed to read the location abandoned by the call of f . The pointer stored in glob could be used much later and cause trouble in unpredictable ways.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_72","text":"The address of a local variable can be \u201creturned\u201d/leaked by a return statement, by a T& out-parameter, as a member of a returned object, as an element of a returned array, and more.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_73","text":"Similar examples can be constructed \u201cleaking\u201d a pointer from an inner scope to an outer one; such examples are handled equivalently to leaks of pointers out of a function. A slightly different variant of the problem is placing pointers in a container that outlives the objects pointed to. See also : Another way of getting dangling pointers is pointer invalidation . It can be detected/prevented with similar techniques.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_52","text":"Compilers tend to catch return of reference to locals and could in many cases catch return of pointers to locals. Static analysis can catch many common patterns of the use of pointers indicating positions (thus eliminating dangling pointers)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f44-return-a-t-when-copy-is-undesirable-and-returning-no-object-isnt-needed","text":"","title":"F.44: Return a T&amp; when copy is undesirable and \"returning no object\" isn't needed"},{"location":"cppcg/CppCoreGuidelines/#reason_58","text":"The language guarantees that a T& refers to an object, so that testing for nullptr isn\u2019t necessary. See also : The return of a reference must not imply transfer of ownership: discussion of dangling pointer prevention and discussion of ownership .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_58","text":"class Car { array<wheel, 4> w; // ... public: wheel& get_wheel(int i) { Expects(i < w.size()); return w[i]; } // ... }; void use() { Car c; wheel& w0 = c.get_wheel(0); // w0 has the same lifetime as c }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_53","text":"Flag functions where no return expression could yield nullptr","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f45-dont-return-a-t","text":"","title":"F.45: Don't return a T&amp;&amp;"},{"location":"cppcg/CppCoreGuidelines/#reason_59","text":"It\u2019s asking to return a reference to a destroyed temporary object. A && is a magnet for temporary objects.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_59","text":"A returned rvalue reference goes out of scope at the end of the full expression to which it is returned: auto&& x = max(0, 1); // OK, so far foo(x); // Undefined behavior This kind of use is a frequent source of bugs, often incorrectly reported as a compiler bug. An implementer of a function should avoid setting such traps for users. The lifetime safety profile will (when completely implemented) catch such problems.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_60","text":"Returning an rvalue reference is fine when the reference to the temporary is being passed \u201cdownward\u201d to a callee; then, the temporary is guaranteed to outlive the function call (see F.18 and F.19 ). However, it\u2019s not fine when passing such a reference \u201cupward\u201d to a larger caller scope. For passthrough functions that pass in parameters (by ordinary reference or by perfect forwarding) and want to return values, use simple auto return type deduction (not auto&& ). Assume that F returns by value: template<class F> auto&& wrapper(F f) { log_call(typeid(f)); // or whatever instrumentation return f(); // BAD: returns a reference to a temporary } Better: template<class F> auto wrapper(F f) { log_call(typeid(f)); // or whatever instrumentation return f(); // OK }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_11","text":"std::move and std::forward do return && , but they are just casts \u2013 used by convention only in expression contexts where a reference to a temporary object is passed along within the same expression before the temporary is destroyed. We don\u2019t know of any other good examples of returning && .","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_54","text":"Flag any use of && as a return type, except in std::move and std::forward .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f46-int-is-the-return-type-for-main","text":"","title":"F.46: int is the return type for main()"},{"location":"cppcg/CppCoreGuidelines/#reason_60","text":"It\u2019s a language rule, but violated through \u201clanguage extensions\u201d so often that it is worth mentioning. Declaring main (the one global main of a program) void limits portability.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_61","text":"void main() { /* ... */ }; // bad, not C++ int main() { std::cout << \"This is the way to do it\\n\"; }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_74","text":"We mention this only because of the persistence of this error in the community.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_55","text":"The compiler should do it If the compiler doesn\u2019t do it, let tools flag it","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f47-return-t-from-assignment-operators","text":"","title":"F.47: Return T&amp; from assignment operators"},{"location":"cppcg/CppCoreGuidelines/#reason_61","text":"The convention for operator overloads (especially on value types) is for operator=(const T&) to perform the assignment and then return (non- const ) *this . This ensures consistency with standard-library types and follows the principle of \u201cdo as the ints do.\u201d","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_75","text":"Historically there was some guidance to make the assignment operator return const T& . This was primarily to avoid code of the form (a = b) = c \u2013 such code is not common enough to warrant violating consistency with standard types.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_62","text":"class Foo { public: ... Foo& operator=(const Foo& rhs) { // Copy members. ... return *this; } };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_56","text":"This should be enforced by tooling by checking the return type (and return value) of any assignment operator.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f48-dont-return-stdmovelocal","text":"","title":"F.48: Don't return std::move(local)"},{"location":"cppcg/CppCoreGuidelines/#reason_62","text":"With guaranteed copy elision, it is now almost always a pessimization to expressly use std::move in a return statement.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_21","text":"S f() { S result; return std::move(result); }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_2","text":"S f() { S result; return result; }","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#enforcement_57","text":"This should be enforced by tooling by checking the return expression .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f50-use-a-lambda-when-a-function-wont-do-to-capture-local-variables-or-to-write-a-local-function","text":"","title":"F.50: Use a lambda when a function won't do (to capture local variables, or to write a local function)"},{"location":"cppcg/CppCoreGuidelines/#reason_63","text":"Functions can\u2019t capture local variables or be defined at local scope; if you need those things, prefer a lambda where possible, and a handwritten function object where not. On the other hand, lambdas and function objects don\u2019t overload; if you need to overload, prefer a function (the workarounds to make lambdas overload are ornate). If either will work, prefer writing a function; use the simplest tool necessary.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_63","text":"// writing a function that should only take an int or a string // -- overloading is natural void f(int); void f(const string&); // writing a function object that needs to capture local state and appear // at statement or expression scope -- a lambda is natural vector<work> v = lots_of_work(); for (int tasknum = 0; tasknum < max; ++tasknum) { pool.run([=, &v]{ /* ... ... process 1 / max - th of v, the tasknum - th chunk ... */ }); } pool.join();","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_12","text":"Generic lambdas offer a concise way to write function templates and so can be useful even when a normal function template would do equally well with a little more syntax. This advantage will probably disappear in the future once all functions gain the ability to have Concept parameters.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_58","text":"Warn on use of a named non-generic lambda (e.g., auto x = [](int i){ /*...*/; }; ) that captures nothing and appears at global scope. Write an ordinary function instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f51-where-there-is-a-choice-prefer-default-arguments-over-overloading","text":"","title":"F.51: Where there is a choice, prefer default arguments over overloading"},{"location":"cppcg/CppCoreGuidelines/#reason_64","text":"Default arguments simply provide alternative interfaces to a single implementation. There is no guarantee that a set of overloaded functions all implement the same semantics. The use of default arguments can avoid code replication.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_76","text":"There is a choice between using default argument and overloading when the alternatives are from a set of arguments of the same types. For example: void print(const string& s, format f = {}); as opposed to void print(const string& s); // use default format void print(const string& s, format f); There is not a choice when a set of functions are used to do a semantically equivalent operation to a set of types. For example: void print(const char&); void print(int); void print(zstring);","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#see-also","text":"Default arguments for virtual functions","title":"See also"},{"location":"cppcg/CppCoreGuidelines/#enforcement_59","text":"Warn on an overload set where the overloads have a common prefix of parameters (e.g., f(int) , f(int, const string&) , f(int, const string&, double) ). (Note: Review this enforcement if it\u2019s too noisy in practice.)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f52-prefer-capturing-by-reference-in-lambdas-that-will-be-used-locally-including-passed-to-algorithms","text":"","title":"F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms"},{"location":"cppcg/CppCoreGuidelines/#reason_65","text":"For efficiency and correctness, you nearly always want to capture by reference when using the lambda locally. This includes when writing or calling parallel algorithms that are local because they join before returning.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#discussion_1","text":"The efficiency consideration is that most types are cheaper to pass by reference than by value. The correctness consideration is that many calls want to perform side effects on the original object at the call site (see example below). Passing by value prevents this.","title":"Discussion"},{"location":"cppcg/CppCoreGuidelines/#note_77","text":"Unfortunately, there is no simple way to capture by reference to const to get the efficiency for a local call but also prevent side effects.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_64","text":"Here, a large object (a network message) is passed to an iterative algorithm, and is it not efficient or correct to copy the message (which may not be copyable): std::for_each(begin(sockets), end(sockets), [&message](auto& socket) { socket.send(message); });","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_65","text":"This is a simple three-stage parallel pipeline. Each stage object encapsulates a worker thread and a queue, has a process function to enqueue work, and in its destructor automatically blocks waiting for the queue to empty before ending the thread. void send_packets(buffers& bufs) { stage encryptor([] (buffer& b){ encrypt(b); }); stage compressor([&](buffer& b){ compress(b); encryptor.process(b); }); stage decorator([&](buffer& b){ decorate(b); compressor.process(b); }); for (auto& b : bufs) { decorator.process(b); } } // automatically blocks waiting for pipeline to finish","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_60","text":"Flag a lambda that captures by reference, but is used other than locally within the function scope or passed to a function by reference. (Note: This rule is an approximation, but does flag passing by pointer as those are more likely to be stored by the callee, writing to a heap location accessed via a parameter, returning the lambda, etc. The Lifetime rules will also provide general rules that flag escaping pointers and references including via lambdas.)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f53-avoid-capturing-by-reference-in-lambdas-that-will-be-used-nonlocally-including-returned-stored-on-the-heap-or-passed-to-another-thread","text":"","title":"F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread"},{"location":"cppcg/CppCoreGuidelines/#reason_66","text":"Pointers and references to locals shouldn\u2019t outlive their scope. Lambdas that capture by reference are just another place to store a reference to a local object, and shouldn\u2019t do so if they (or a copy) outlive the scope.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_22","text":"int local = 42; // Want a reference to local. // Note, that after program exits this scope, // local no longer exists, therefore // process() call will have undefined behavior! thread_pool.queue_work([&]{ process(local); });","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_3","text":"int local = 42; // Want a copy of local. // Since a copy of local is made, it will // always be available for the call. thread_pool.queue_work([=]{ process(local); });","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#enforcement_61","text":"(Simple) Warn when capture-list contains a reference to a locally declared variable (Complex) Flag when capture-list contains a reference to a locally declared variable and the lambda is passed to a non- const and non-local context","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f54-if-you-capture-this-capture-all-variables-explicitly-no-default-capture","text":"","title":"F.54: If you capture this, capture all variables explicitly (no default capture)"},{"location":"cppcg/CppCoreGuidelines/#reason_67","text":"It\u2019s confusing. Writing [=] in a member function appears to capture by value, but actually captures data members by reference because it actually captures the invisible this pointer by value. If you meant to do that, write this explicitly.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_66","text":"class My_class { int x = 0; // ... void f() { int i = 0; // ... auto lambda = [=]{ use(i, x); }; // BAD: \"looks like\" copy/value capture // [&] has identical semantics and copies the this pointer under the current rules // [=,this] and [&,this] are not much better, and confusing x = 42; lambda(); // calls use(0, 42); x = 43; lambda(); // calls use(0, 43); // ... auto lambda2 = [i, this]{ use(i, x); }; // ok, most explicit and least confusing // ... } };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_78","text":"This is under active discussion in standardization, and may be addressed in a future version of the standard by adding a new capture mode or possibly adjusting the meaning of [=] . For now, just be explicit.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_62","text":"Flag any lambda capture-list that specifies a default capture and also captures this (whether explicitly or via default capture)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#f55-dont-use-va_arg-arguments","text":"","title":"F.55: Don't use va_arg arguments"},{"location":"cppcg/CppCoreGuidelines/#reason_68","text":"Reading from a va_arg assumes that the correct type was actually passed. Passing to varargs assumes the correct type will be read. This is fragile because it cannot generally be enforced to be safe in the language and so relies on programmer discipline to get it right.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_67","text":"int sum(...) { // ... while (/*...*/) result += va_arg(list, int); // BAD, assumes it will be passed ints // ... } sum(3, 2); // ok sum(3.14159, 2.71828); // BAD, undefined template<class ...Args> auto sum(Args... args) { // GOOD, and much more flexible return (... + args); // note: C++17 \"fold expression\" } sum(3, 2); // ok: 5 sum(3.14159, 2.71828); // ok: ~5.85987","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#alternatives","text":"overloading variadic templates variant arguments initializer_list (homogeneous)","title":"Alternatives"},{"location":"cppcg/CppCoreGuidelines/#note_79","text":"Declaring a ... parameter is sometimes useful for techniques that don\u2019t involve actual argument passing, notably to declare \u201ctake-anything\u201d functions so as to disable \u201ceverything else\u201d in an overload set or express a catchall case in a template metaprogram.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_63","text":"Issue a diagnostic for using va_list , va_start , or va_arg . Issue a diagnostic for passing an argument to a vararg parameter of a function that does not offer an overload for a more specific type in the position of the vararg. To fix: Use a different function, or [[suppress(types)]] .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c-classes-and-class-hierarchies","text":"A class is a user-defined type, for which a programmer can define the representation, operations, and interfaces. Class hierarchies are used to organize related classes into hierarchical structures. Class rule summary: C.1: Organize related data into structures ( struct s or class es) C.2: Use class if the class has an invariant; use struct if the data members can vary independently C.3: Represent the distinction between an interface and an implementation using a class C.4: Make a function a member only if it needs direct access to the representation of a class C.5: Place helper functions in the same namespace as the class they support C.7: Don\u2019t define a class or enum and declare a variable of its type in the same statement C.8: Use class rather than struct if any member is non-public C.9: Minimize exposure of members Subsections: C.concrete: Concrete types C.ctor: Constructors, assignments, and destructors C.con: Containers and other resource handles C.lambdas: Function objects and lambdas C.hier: Class hierarchies (OOP) C.over: Overloading and overloaded operators C.union: Unions","title":"C: Classes and class hierarchies"},{"location":"cppcg/CppCoreGuidelines/#c1-organize-related-data-into-structures-structs-or-classes","text":"","title":"C.1: Organize related data into structures (structs or classes)"},{"location":"cppcg/CppCoreGuidelines/#reason_69","text":"Ease of comprehension. If data is related (for fundamental reasons), that fact should be reflected in code.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_68","text":"void draw(int x, int y, int x2, int y2); // BAD: unnecessary implicit relationships void draw(Point from, Point to); // better","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_80","text":"A simple class without virtual functions implies no space or time overhead.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_81","text":"From a language perspective class and struct differ only in the default visibility of their members.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_64","text":"Probably impossible. Maybe a heuristic looking for data items used together is possible.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c2-use-class-if-the-class-has-an-invariant-use-struct-if-the-data-members-can-vary-independently","text":"","title":"C.2: Use class if the class has an invariant; use struct if the data members can vary independently"},{"location":"cppcg/CppCoreGuidelines/#reason_70","text":"Readability. Ease of comprehension. The use of class alerts the programmer to the need for an invariant. This is a useful convention.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_82","text":"An invariant is a logical condition for the members of an object that a constructor must establish for the public member functions to assume. After the invariant is established (typically by a constructor) every member function can be called for the object. An invariant can be stated informally (e.g., in a comment) or more formally using Expects . If all data members can vary independently of each other, no invariant is possible.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_69","text":"struct Pair { // the members can vary independently string name; int volume; }; but: class Date { public: // validate that {yy, mm, dd} is a valid date and initialize Date(int yy, Month mm, char dd); // ... private: int y; Month m; char d; // day };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_83","text":"If a class has any private data, a user cannot completely initialize an object without the use of a constructor. Hence, the class definer will provide a constructor and must specify its meaning. This effectively means the definer need to define an invariant. See also : define a class with private data as class Prefer to place the interface first in a class minimize exposure of members Avoid protected data","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_65","text":"Look for struct s with all data private and class es with public members.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c3-represent-the-distinction-between-an-interface-and-an-implementation-using-a-class","text":"","title":"C.3: Represent the distinction between an interface and an implementation using a class"},{"location":"cppcg/CppCoreGuidelines/#reason_71","text":"An explicit distinction between interface and implementation improves readability and simplifies maintenance.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_70","text":"class Date { // ... some representation ... public: Date(); // validate that {yy, mm, dd} is a valid date and initialize Date(int yy, Month mm, char dd); int day() const; Month month() const; // ... }; For example, we can now change the representation of a Date without affecting its users (recompilation is likely, though).","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_84","text":"Using a class in this way to represent the distinction between interface and implementation is of course not the only way. For example, we can use a set of declarations of freestanding functions in a namespace, an abstract base class, or a template function with concepts to represent an interface. The most important issue is to explicitly distinguish between an interface and its implementation \u201cdetails.\u201d Ideally, and typically, an interface is far more stable than its implementation(s).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_66","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c4-make-a-function-a-member-only-if-it-needs-direct-access-to-the-representation-of-a-class","text":"","title":"C.4: Make a function a member only if it needs direct access to the representation of a class"},{"location":"cppcg/CppCoreGuidelines/#reason_72","text":"Less coupling than with member functions, fewer functions that can cause trouble by modifying object state, reduces the number of functions that needs to be modified after a change in representation.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_71","text":"class Date { // ... relatively small interface ... }; // helper functions: Date next_weekday(Date); bool operator==(Date, Date); The \u201chelper functions\u201d have no need for direct access to the representation of a Date .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_85","text":"This rule becomes even better if C++ gets \u201cuniform function call\u201d .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exception_13","text":"The language requires virtual functions to be members, and not all virtual functions directly access data. In particular, members of an abstract class rarely do. Note multi-methods .","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#exception_14","text":"The language requires operators = , () , [] , and -> to be members.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#exception_15","text":"An overload set may have some members that do not directly access private data: class Foobar { public: void foo(long x) { /* manipulate private data */ } void foo(double x) { foo(std::lround(x)); } // ... private: // ... };","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#exception_16","text":"Similarly, a set of functions may be designed to be used in a chain: x.scale(0.5).rotate(45).set_color(Color::red); Typically, some but not all of such functions directly access private data.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_67","text":"Look for non- virtual member functions that do not touch data members directly. The snag is that many member functions that do not need to touch data members directly do. Ignore virtual functions. Ignore functions that are part of an overload set out of which at least one function accesses private members. Ignore functions returning this .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c5-place-helper-functions-in-the-same-namespace-as-the-class-they-support","text":"","title":"C.5: Place helper functions in the same namespace as the class they support"},{"location":"cppcg/CppCoreGuidelines/#reason_73","text":"A helper function is a function (usually supplied by the writer of a class) that does not need direct access to the representation of the class, yet is seen as part of the useful interface to the class. Placing them in the same namespace as the class makes their relationship to the class obvious and allows them to be found by argument dependent lookup.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_72","text":"namespace Chrono { // here we keep time-related services class Time { /* ... */ }; class Date { /* ... */ }; // helper functions: bool operator==(Date, Date); Date next_weekday(Date); // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_86","text":"This is especially important for overloaded operators .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_68","text":"Flag global functions taking argument types from a single namespace.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c7-dont-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement","text":"","title":"C.7: Don't define a class or enum and declare a variable of its type in the same statement"},{"location":"cppcg/CppCoreGuidelines/#reason_74","text":"Mixing a type definition and the definition of another entity in the same declaration is confusing and unnecessary.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_23","text":"struct Data { /*...*/ } data{ /*...*/ };","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_4","text":"struct Data { /*...*/ }; Data data{ /*...*/ };","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#enforcement_69","text":"Flag if the } of a class or enumeration definition is not followed by a ; . The ; is missing.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c8-use-class-rather-than-struct-if-any-member-is-non-public","text":"","title":"C.8: Use class rather than struct if any member is non-public"},{"location":"cppcg/CppCoreGuidelines/#reason_75","text":"Readability. To make it clear that something is being hidden/abstracted. This is a useful convention.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_24","text":"struct Date { int d, m; Date(int i, Month m); // ... lots of functions ... private: int y; // year }; There is nothing wrong with this code as far as the C++ language rules are concerned, but nearly everything is wrong from a design perspective. The private data is hidden far from the public data. The data is split in different parts of the class declaration. Different parts of the data have different access. All of this decreases readability and complicates maintenance.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_87","text":"Prefer to place the interface first in a class, see NL.16 .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_70","text":"Flag classes declared with struct if there is a private or protected member.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c9-minimize-exposure-of-members","text":"","title":"C.9: Minimize exposure of members"},{"location":"cppcg/CppCoreGuidelines/#reason_76","text":"Encapsulation. Information hiding. Minimize the chance of unintended access. This simplifies maintenance.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_73","text":"template<typename T, typename U> struct pair { T a; U b; // ... }; Whatever we do in the // -part, an arbitrary user of a pair can arbitrarily and independently change its a and b . In a large code base, we cannot easily find which code does what to the members of pair . This may be exactly what we want, but if we want to enforce a relation among members, we need to make them private and enforce that relation (invariant) through constructors and member functions. For example: class Distance { public: // ... double meters() const { return magnitude*unit; } void set_unit(double u) { // ... check that u is a factor of 10 ... // ... change magnitude appropriately ... unit = u; } // ... private: double magnitude; double unit; // 1 is meters, 1000 is kilometers, 0.001 is millimeters, etc. };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_88","text":"If the set of direct users of a set of variables cannot be easily determined, the type or usage of that set cannot be (easily) changed/improved. For public and protected data, that\u2019s usually the case.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_74","text":"A class can provide two interfaces to its users. One for derived classes ( protected ) and one for general users ( public ). For example, a derived class might be allowed to skip a run-time check because it has already guaranteed correctness: class Foo { public: int bar(int x) { check(x); return do_bar(x); } // ... protected: int do_bar(int x); // do some operation on the data // ... private: // ... data ... }; class Dir : public Foo { //... int mem(int x, int y) { /* ... do something ... */ return do_bar(x + y); // OK: derived class can bypass check } }; void user(Foo& x) { int r1 = x.bar(1); // OK, will check int r2 = x.do_bar(2); // error: would bypass check // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_89","text":"protected data is a bad idea .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_90","text":"Prefer the order public members before protected members before private members see .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_71","text":"Flag protected data . Flag mixtures of public and private data","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cconcrete-concrete-types","text":"One ideal for a class is to be a regular type. That means roughly \u201cbehaves like an int .\u201d A concrete type is the simplest kind of class. A value of regular type can be copied and the result of a copy is an independent object with the same value as the original. If a concrete type has both = and == , a = b should result in a == b being true . Concrete classes without assignment and equality can be defined, but they are (and should be) rare. The C++ built-in types are regular, and so are standard-library classes, such as string , vector , and map . Concrete types are also often referred to as value types to distinguish them from types used as part of a hierarchy. Concrete type rule summary: C.10: Prefer concrete types over class hierarchies C.11: Make concrete types regular","title":"C.concrete: Concrete types"},{"location":"cppcg/CppCoreGuidelines/#c10-prefer-concrete-types-over-class-hierarchies","text":"","title":"C.10: Prefer concrete types over class hierarchies"},{"location":"cppcg/CppCoreGuidelines/#reason_77","text":"A concrete type is fundamentally simpler than a hierarchy: easier to design, easier to implement, easier to use, easier to reason about, smaller, and faster. You need a reason (use cases) for using a hierarchy.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_75","text":"class Point1 { int x, y; // ... operations ... // ... no virtual functions ... }; class Point2 { int x, y; // ... operations, some virtual ... virtual ~Point2(); }; void use() { Point1 p11 {1, 2}; // make an object on the stack Point1 p12 {p11}; // a copy auto p21 = make_unique<Point2>(1, 2); // make an object on the free store auto p22 = p21->clone(); // make a copy // ... } If a class can be part of a hierarchy, we (in real code if not necessarily in small examples) must manipulate its objects through pointers or references. That implies more memory overhead, more allocations and deallocations, and more run-time overhead to perform the resulting indirections.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_91","text":"Concrete types can be stack-allocated and be members of other classes.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_92","text":"The use of indirection is fundamental for run-time polymorphic interfaces. The allocation/deallocation overhead is not (that\u2019s just the most common case). We can use a base class as the interface of a scoped object of a derived class. This is done where dynamic allocation is prohibited (e.g. hard-real-time) and to provide a stable interface to some kinds of plug-ins.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_72","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c11-make-concrete-types-regular","text":"","title":"C.11: Make concrete types regular"},{"location":"cppcg/CppCoreGuidelines/#reason_78","text":"Regular types are easier to understand and reason about than types that are not regular (irregularities requires extra effort to understand and use).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_76","text":"struct Bundle { string name; vector<Record> vr; }; bool operator==(const Bundle& a, const Bundle& b) { return a.name == b.name && a.vr == b.vr; } Bundle b1 { \"my bundle\", {r1, r2, r3}}; Bundle b2 = b1; if (!(b1 == b2)) error(\"impossible!\"); b2.name = \"the other bundle\"; if (b1 == b2) error(\"No!\"); In particular, if a concrete type has an assignment also give it an equals operator so that a = b implies a == b .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_93","text":"Handles for resources that cannot be cloned, e.g., a scoped_lock for a mutex , resemble concrete types in that they most often are stack-allocated. However, objects of such types typically cannot be copied (instead, they can usually be moved), so they can\u2019t be regular ; instead, they tend to be semiregular . Often, such types are referred to as \u201cmove-only types\u201d.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_73","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cctor-constructors-assignments-and-destructors","text":"These functions control the lifecycle of objects: creation, copy, move, and destruction. Define constructors to guarantee and simplify initialization of classes. These are default operations : a default constructor: X() a copy constructor: X(const X&) a copy assignment: operator=(const X&) a move constructor: X(X&&) a move assignment: operator=(X&&) a destructor: ~X() By default, the compiler defines each of these operations if it is used, but the default can be suppressed. The default operations are a set of related operations that together implement the lifecycle semantics of an object. By default, C++ treats classes as value-like types, but not all types are value-like. Set of default operations rules: C.20: If you can avoid defining any default operations, do C.21: If you define or =delete any default operation, define or =delete them all C.22: Make default operations consistent Destructor rules: C.30: Define a destructor if a class needs an explicit action at object destruction C.31: All resources acquired by a class must be released by the class\u2019s destructor C.32: If a class has a raw pointer ( T* ) or reference ( T& ), consider whether it might be owning C.33: If a class has an owning pointer member, define or =delete a destructor C.35: A base class destructor should be either public and virtual, or protected and nonvirtual C.36: A destructor may not fail C.37: Make destructors noexcept Constructor rules: C.40: Define a constructor if a class has an invariant C.41: A constructor should create a fully initialized object C.42: If a constructor cannot construct a valid object, throw an exception C.43: Ensure that a copyable (value type) class has a default constructor C.44: Prefer default constructors to be simple and non-throwing C.45: Don\u2019t define a default constructor that only initializes data members; use member initializers instead C.46: By default, declare single-argument constructors explicit C.47: Define and initialize member variables in the order of member declaration C.48: Prefer in-class initializers to member initializers in constructors for constant initializers C.49: Prefer initialization to assignment in constructors C.50: Use a factory function if you need \u201cvirtual behavior\u201d during initialization C.51: Use delegating constructors to represent common actions for all constructors of a class C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization Copy and move rules: C.60: Make copy assignment non- virtual , take the parameter by const& , and return by non- const& C.61: A copy operation should copy C.62: Make copy assignment safe for self-assignment C.63: Make move assignment non- virtual , take the parameter by && , and return by non- const& C.64: A move operation should move and leave its source in a valid state C.65: Make move assignment safe for self-assignment C.66: Make move operations noexcept C.67: A polymorphic class should suppress copying Other default operations rules: C.80: Use =default if you have to be explicit about using the default semantics C.81: Use =delete when you want to disable default behavior (without wanting an alternative) C.82: Don\u2019t call virtual functions in constructors and destructors C.83: For value-like types, consider providing a noexcept swap function C.84: A swap may not fail C.85: Make swap noexcept C.86: Make == symmetric with respect of operand types and noexcept C.87: Beware of == on base classes C.89: Make a hash noexcept","title":"C.ctor: Constructors, assignments, and destructors"},{"location":"cppcg/CppCoreGuidelines/#cdefop-default-operations","text":"By default, the language supplies the default operations with their default semantics. However, a programmer can disable or replace these defaults.","title":"C.defop: Default Operations"},{"location":"cppcg/CppCoreGuidelines/#c20-if-you-can-avoid-defining-default-operations-do","text":"","title":"C.20: If you can avoid defining default operations, do"},{"location":"cppcg/CppCoreGuidelines/#reason_79","text":"It\u2019s the simplest and gives the cleanest semantics.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_77","text":"struct Named_map { public: // ... no default operations declared ... private: string name; map<int, int> rep; }; Named_map nm; // default construct Named_map nm2 {nm}; // copy construct Since std::map and string have all the special functions, no further work is needed.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_94","text":"This is known as \u201cthe rule of zero\u201d.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_74","text":"(Not enforceable) While not enforceable, a good static analyzer can detect patterns that indicate a possible improvement to meet this rule. For example, a class with a (pointer, size) pair of member and a destructor that delete s the pointer could probably be converted to a vector .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c21-if-you-define-or-delete-any-default-operation-define-or-delete-them-all","text":"","title":"C.21: If you define or =delete any default operation, define or =delete them all"},{"location":"cppcg/CppCoreGuidelines/#reason_80","text":"The special member functions are the default constructor, copy constructor, copy assignment operator, move constructor, move assignment operator, and destructor. The semantics of the special functions are closely related, so if one needs to be declared, the odds are that others need consideration too. Declaring any special member function except a default constructor, even as =default or =delete , will suppress the implicit declaration of a move constructor and move assignment operator. Declaring a move constructor or move assignment operator, even as =default or =delete , will cause an implicitly generated copy constructor or implicitly generated copy assignment operator to be defined as deleted. So as soon as any of the special functions is declared, the others should all be declared to avoid unwanted effects like turning all potential moves into more expensive copies, or making a class move-only.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_25","text":"struct M2 { // bad: incomplete set of default operations public: // ... // ... no copy or move operations ... ~M2() { delete[] rep; } private: pair<int, int>* rep; // zero-terminated set of pairs }; void use() { M2 x; M2 y; // ... x = y; // the default assignment // ... } Given that \u201cspecial attention\u201d was needed for the destructor (here, to deallocate), the likelihood that copy and move assignment (both will implicitly destroy an object) are correct is low (here, we would get double deletion).","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_95","text":"This is known as \u201cthe rule of five\u201d or \u201cthe rule of six\u201d, depending on whether you count the default constructor.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_96","text":"If you want a default implementation of a default operation (while defining another), write =default to show you\u2019re doing so intentionally for that function. If you don\u2019t want a default operation, suppress it with =delete .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-good_5","text":"When a destructor needs to be declared just to make it virtual , it can be defined as defaulted. To avoid suppressing the implicit move operations they must also be declared, and then to avoid the class becoming move-only (and not copyable) the copy operations must be declared: class AbstractBase { public: virtual ~AbstractBase() = default; AbstractBase(const AbstractBase&) = default; AbstractBase& operator=(const AbstractBase&) = default; AbstractBase(AbstractBase&&) = default; AbstractBase& operator=(AbstractBase&&) = default; }; Alternatively to prevent slicing as per C.67 , the copy and move operations can all be deleted: class ClonableBase { public: virtual unique_ptr<ClonableBase> clone() const; virtual ~ClonableBase() = default; ClonableBase(const ClonableBase&) = delete; ClonableBase& operator=(const ClonableBase&) = delete; ClonableBase(ClonableBase&&) = delete; ClonableBase& operator=(ClonableBase&&) = delete; }; Defining only the move operations or only the copy operations would have the same effect here, but stating the intent explicitly for each special member makes it more obvious to the reader.","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#note_97","text":"Compilers enforce much of this rule and ideally warn about any violation.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_98","text":"Relying on an implicitly generated copy operation in a class with a destructor is deprecated.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_99","text":"Writing the six special member functions can be error prone. Note their argument types: class X { public: // ... virtual ~X() = default; // destructor (virtual if X is meant to be a base class) X(const X&) = default; // copy constructor X& operator=(const X&) = default; // copy assignment X(X&&) = default; // move constructor X& operator=(X&&) = default; // move assignment }; A minor mistake (such as a misspelling, leaving out a const , using & instead of && , or leaving out a special function) can lead to errors or warnings. To avoid the tedium and the possibility of errors, try to follow the rule of zero .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_75","text":"(Simple) A class should have a declaration (even a =delete one) for either all or none of the special functions.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c22-make-default-operations-consistent","text":"","title":"C.22: Make default operations consistent"},{"location":"cppcg/CppCoreGuidelines/#reason_81","text":"The default operations are conceptually a matched set. Their semantics are interrelated. Users will be surprised if copy/move construction and copy/move assignment do logically different things. Users will be surprised if constructors and destructors do not provide a consistent view of resource management. Users will be surprised if copy and move don\u2019t reflect the way constructors and destructors work.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_26","text":"class Silly { // BAD: Inconsistent copy operations class Impl { // ... }; shared_ptr<Impl> p; public: Silly(const Silly& a) : p{a.p} { *p = *a.p; } // deep copy Silly& operator=(const Silly& a) { p = a.p; } // shallow copy // ... }; These operations disagree about copy semantics. This will lead to confusion and bugs.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_76","text":"(Complex) A copy/move constructor and the corresponding copy/move assignment operator should write to the same member variables at the same level of dereference. (Complex) Any member variables written in a copy/move constructor should also be initialized by all other constructors. (Complex) If a copy/move constructor performs a deep copy of a member variable, then the destructor should modify the member variable. (Complex) If a destructor is modifying a member variable, that member variable should be written in any copy/move constructors or assignment operators.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cdtor-destructors","text":"\u201cDoes this class need a destructor?\u201d is a surprisingly powerful design question. For most classes the answer is \u201cno\u201d either because the class holds no resources or because destruction is handled by the rule of zero ; that is, its members can take care of themselves as concerns destruction. If the answer is \u201cyes\u201d, much of the design of the class follows (see the rule of five ).","title":"C.dtor: Destructors"},{"location":"cppcg/CppCoreGuidelines/#c30-define-a-destructor-if-a-class-needs-an-explicit-action-at-object-destruction","text":"","title":"C.30: Define a destructor if a class needs an explicit action at object destruction"},{"location":"cppcg/CppCoreGuidelines/#reason_82","text":"A destructor is implicitly invoked at the end of an object\u2019s lifetime. If the default destructor is sufficient, use it. Only define a non-default destructor if a class needs to execute code that is not already part of its members\u2019 destructors.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_78","text":"template<typename A> struct final_action { // slightly simplified A act; final_action(A a) :act{a} {} ~final_action() { act(); } }; template<typename A> final_action<A> finally(A act) // deduce action type { return final_action<A>{act}; } void test() { auto act = finally([]{ cout << \"Exit test\\n\"; }); // establish exit action // ... if (something) return; // act done here // ... } // act done here The whole purpose of final_action is to get a piece of code (usually a lambda) executed upon destruction.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_100","text":"There are two general categories of classes that need a user-defined destructor: A class with a resource that is not already represented as a class with a destructor, e.g., a vector or a transaction class. A class that exists primarily to execute an action upon destruction, such as a tracer or final_action .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad_27","text":"class Foo { // bad; use the default destructor public: // ... ~Foo() { s = \"\"; i = 0; vi.clear(); } // clean up private: string s; int i; vector<int> vi; }; The default destructor does it better, more efficiently, and can\u2019t get it wrong.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_101","text":"If the default destructor is needed, but its generation has been suppressed (e.g., by defining a move constructor), use =default .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_77","text":"Look for likely \u201cimplicit resources\u201d, such as pointers and references. Look for classes with destructors even though all their data members have destructors.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c31-all-resources-acquired-by-a-class-must-be-released-by-the-classs-destructor","text":"","title":"C.31: All resources acquired by a class must be released by the class's destructor"},{"location":"cppcg/CppCoreGuidelines/#reason_83","text":"Prevention of resource leaks, especially in error cases.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_102","text":"For resources represented as classes with a complete set of default operations, this happens automatically.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_79","text":"class X { ifstream f; // may own a file // ... no default operations defined or =deleted ... }; X \u2018s ifstream implicitly closes any file it may have open upon destruction of its X .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_28","text":"class X2 { // bad FILE* f; // may own a file // ... no default operations defined or =deleted ... }; X2 may leak a file handle.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_103","text":"What about a sockets that won\u2019t close? A destructor, close, or cleanup operation should never fail . If it does nevertheless, we have a problem that has no really good solution. For starters, the writer of a destructor does not know why the destructor is called and cannot \u201crefuse to act\u201d by throwing an exception. See discussion . To make the problem worse, many \u201cclose/release\u201d operations are not retryable. Many have tried to solve this problem, but no general solution is known. If at all possible, consider failure to close/cleanup a fundamental design error and terminate.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_104","text":"A class can hold pointers and references to objects that it does not own. Obviously, such objects should not be delete d by the class\u2019s destructor. For example: Preprocessor pp { /* ... */ }; Parser p { pp, /* ... */ }; Type_checker tc { p, /* ... */ }; Here p refers to pp but does not own it.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_78","text":"(Simple) If a class has pointer or reference member variables that are owners (e.g., deemed owners by using gsl::owner ), then they should be referenced in its destructor. (Hard) Determine if pointer or reference member variables are owners when there is no explicit statement of ownership (e.g., look into the constructors).","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c32-if-a-class-has-a-raw-pointer-t-or-reference-t-consider-whether-it-might-be-owning","text":"","title":"C.32: If a class has a raw pointer (T*) or reference (T&amp;), consider whether it might be owning"},{"location":"cppcg/CppCoreGuidelines/#reason_84","text":"There is a lot of code that is non-specific about ownership.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_80","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_105","text":"If the T* or T& is owning, mark it owning . If the T* is not owning, consider marking it ptr . This will aid documentation and analysis.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_79","text":"Look at the initialization of raw member pointers and member references and see if an allocation is used.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c33-if-a-class-has-an-owning-pointer-member-define-a-destructor","text":"","title":"C.33: If a class has an owning pointer member, define a destructor"},{"location":"cppcg/CppCoreGuidelines/#reason_85","text":"An owned object must be deleted upon destruction of the object that owns it.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_81","text":"A pointer member may represent a resource. A T* should not do so , but in older code, that\u2019s common. Consider a T* a possible owner and therefore suspect. template<typename T> class Smart_ptr { T* p; // BAD: vague about ownership of *p // ... public: // ... no user-defined default operations ... }; void use(Smart_ptr<int> p1) { // error: p2.p leaked (if not nullptr and not owned by some other code) auto p2 = p1; } Note that if you define a destructor, you must define or delete all default operations : template<typename T> class Smart_ptr2 { T* p; // BAD: vague about ownership of *p // ... public: // ... no user-defined copy operations ... ~Smart_ptr2() { delete p; } // p is an owner! }; void use(Smart_ptr2<int> p1) { auto p2 = p1; // error: double deletion } The default copy operation will just copy the p1.p into p2.p leading to a double destruction of p1.p . Be explicit about ownership: template<typename T> class Smart_ptr3 { owner<T*> p; // OK: explicit about ownership of *p // ... public: // ... // ... copy and move operations ... ~Smart_ptr3() { delete p; } }; void use(Smart_ptr3<int> p1) { auto p2 = p1; // OK: no double deletion }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_106","text":"Often the simplest way to get a destructor is to replace the pointer with a smart pointer (e.g., std::unique_ptr ) and let the compiler arrange for proper destruction to be done implicitly.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_107","text":"Why not just require all owning pointers to be \u201csmart pointers\u201d? That would sometimes require non-trivial code changes and may affect ABIs.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_80","text":"A class with a pointer data member is suspect. A class with an owner<T> should define its default operations.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c35-a-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-nonvirtual","text":"","title":"C.35: A base class destructor should be either public and virtual, or protected and nonvirtual"},{"location":"cppcg/CppCoreGuidelines/#reason_86","text":"To prevent undefined behavior. If the destructor is public, then calling code can attempt to destroy a derived class object through a base class pointer, and the result is undefined if the base class\u2019s destructor is non-virtual. If the destructor is protected, then calling code cannot destroy through a base class pointer and the destructor does not need to be virtual; it does need to be protected, not private, so that derived destructors can invoke it. In general, the writer of a base class does not know the appropriate action to be done upon destruction.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#discussion_2","text":"See this in the Discussion section .","title":"Discussion"},{"location":"cppcg/CppCoreGuidelines/#example-bad_29","text":"struct Base { // BAD: implicitly has a public nonvirtual destructor virtual void f(); }; struct D : Base { string s {\"a resource needing cleanup\"}; ~D() { /* ... do some cleanup ... */ } // ... }; void use() { unique_ptr<Base> p = make_unique<D>(); // ... } // p's destruction calls ~Base(), not ~D(), which leaks D::s and possibly more","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_108","text":"A virtual function defines an interface to derived classes that can be used without looking at the derived classes. If the interface allows destroying, it should be safe to do so.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_109","text":"A destructor must be nonprivate or it will prevent using the type: class X { ~X(); // private destructor // ... }; void use() { X a; // error: cannot destroy auto p = make_unique<X>(); // error: cannot destroy }","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exception_17","text":"We can imagine one case where you could want a protected virtual destructor: When an object of a derived type (and only of such a type) should be allowed to destroy another object (not itself) through a pointer to base. We haven\u2019t seen such a case in practice, though.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_81","text":"A class with any virtual functions should have a destructor that is either public and virtual or else protected and nonvirtual.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c36-a-destructor-may-not-fail","text":"","title":"C.36: A destructor may not fail"},{"location":"cppcg/CppCoreGuidelines/#reason_87","text":"In general we do not know how to write error-free code if a destructor should fail. The standard library requires that all classes it deals with have destructors that do not exit by throwing.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_82","text":"class X { public: ~X() noexcept; // ... }; X::~X() noexcept { // ... if (cannot_release_a_resource) terminate(); // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_110","text":"Many have tried to devise a fool-proof scheme for dealing with failure in destructors. None have succeeded to come up with a general scheme. This can be a real practical problem: For example, what about a socket that won\u2019t close? The writer of a destructor does not know why the destructor is called and cannot \u201crefuse to act\u201d by throwing an exception. See discussion . To make the problem worse, many \u201cclose/release\u201d operations are not retryable. If at all possible, consider failure to close/cleanup a fundamental design error and terminate.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_111","text":"Declare a destructor noexcept . That will ensure that it either completes normally or terminate the program.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_112","text":"If a resource cannot be released and the program may not fail, try to signal the failure to the rest of the system somehow (maybe even by modifying some global state and hope something will notice and be able to take care of the problem). Be fully aware that this technique is special-purpose and error-prone. Consider the \u201cmy connection will not close\u201d example. Probably there is a problem at the other end of the connection and only a piece of code responsible for both ends of the connection can properly handle the problem. The destructor could send a message (somehow) to the responsible part of the system, consider that to have closed the connection, and return normally.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_113","text":"If a destructor uses operations that may fail, it can catch exceptions and in some cases still complete successfully (e.g., by using a different clean-up mechanism from the one that threw an exception).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_82","text":"(Simple) A destructor should be declared noexcept if it could throw.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c37-make-destructors-noexcept","text":"","title":"C.37: Make destructors noexcept"},{"location":"cppcg/CppCoreGuidelines/#reason_88","text":"A destructor may not fail . If a destructor tries to exit with an exception, it\u2019s a bad design error and the program had better terminate.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_114","text":"A destructor (either user-defined or compiler-generated) is implicitly declared noexcept (independently of what code is in its body) if all of the members of its class have noexcept destructors. By explicitly marking destructors noexcept , an author guards against the destructor becoming implicitly noexcept(false) through the addition or modification of a class member.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_83","text":"Not all destructors are noexcept by default; one throwing member poisons the whole class hierarchy struct X { Details x; // happens to have a throwing destructor // ... ~X() { } // implicitly noexcept(false); aka can throw }; So, if in doubt, declare a destructor noexcept.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_115","text":"Why not then declare all destructors noexcept? Because that would in many cases \u2013 especially simple cases \u2013 be distracting clutter.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_83","text":"(Simple) A destructor should be declared noexcept if it could throw.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cctor-constructors","text":"A constructor defines how an object is initialized (constructed).","title":"C.ctor: Constructors"},{"location":"cppcg/CppCoreGuidelines/#c40-define-a-constructor-if-a-class-has-an-invariant","text":"","title":"C.40: Define a constructor if a class has an invariant"},{"location":"cppcg/CppCoreGuidelines/#reason_89","text":"That\u2019s what constructors are for.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_84","text":"class Date { // a Date represents a valid date // in the January 1, 1900 to December 31, 2100 range Date(int dd, int mm, int yy) :d{dd}, m{mm}, y{yy} { if (!is_valid(d, m, y)) throw Bad_date{}; // enforce invariant } // ... private: int d, m, y; }; It is often a good idea to express the invariant as an Ensures on the constructor.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_116","text":"A constructor can be used for convenience even if a class does not have an invariant. For example: struct Rec { string s; int i {0}; Rec(const string& ss) : s{ss} {} Rec(int ii) :i{ii} {} }; Rec r1 {7}; Rec r2 {\"Foo bar\"};","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_117","text":"The C++11 initializer list rule eliminates the need for many constructors. For example: struct Rec2{ string s; int i; Rec2(const string& ss, int ii = 0) :s{ss}, i{ii} {} // redundant }; Rec2 r1 {\"Foo\", 7}; Rec2 r2 {\"Bar\"}; The Rec2 constructor is redundant. Also, the default for int would be better done as a member initializer . See also : construct valid object and constructor throws .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_84","text":"Flag classes with user-defined copy operations but no constructor (a user-defined copy is a good indicator that the class has an invariant)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c41-a-constructor-should-create-a-fully-initialized-object","text":"","title":"C.41: A constructor should create a fully initialized object"},{"location":"cppcg/CppCoreGuidelines/#reason_90","text":"A constructor establishes the invariant for a class. A user of a class should be able to assume that a constructed object is usable.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_30","text":"class X1 { FILE* f; // call init() before any other function // ... public: X1() {} void init(); // initialize f void read(); // read from f // ... }; void f() { X1 file; file.read(); // crash or bad read! // ... file.init(); // too late // ... } Compilers do not read comments.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#exception_18","text":"If a valid object cannot conveniently be constructed by a constructor, use a factory function .","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_85","text":"(Simple) Every constructor should initialize every member variable (either explicitly, via a delegating ctor call or via default construction). (Unknown) If a constructor has an Ensures contract, try to see if it holds as a postcondition.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#note_118","text":"If a constructor acquires a resource (to create a valid object), that resource should be released by the destructor . The idiom of having constructors acquire resources and destructors release them is called RAII (\u201cResource Acquisition Is Initialization\u201d).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#c42-if-a-constructor-cannot-construct-a-valid-object-throw-an-exception","text":"","title":"C.42: If a constructor cannot construct a valid object, throw an exception"},{"location":"cppcg/CppCoreGuidelines/#reason_91","text":"Leaving behind an invalid object is asking for trouble.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_85","text":"class X2 { FILE* f; // ... public: X2(const string& name) :f{fopen(name.c_str(), \"r\")} { if (!f) throw runtime_error{\"could not open\" + name}; // ... } void read(); // read from f // ... }; void f() { X2 file {\"Zeno\"}; // throws if file isn't open file.read(); // fine // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_31","text":"class X3 { // bad: the constructor leaves a non-valid object behind FILE* f; // call is_valid() before any other function bool valid; // ... public: X3(const string& name) :f{fopen(name.c_str(), \"r\")}, valid{false} { if (f) valid = true; // ... } bool is_valid() { return valid; } void read(); // read from f // ... }; void f() { X3 file {\"Heraclides\"}; file.read(); // crash or bad read! // ... if (file.is_valid()) { file.read(); // ... } else { // ... handle error ... } // ... }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_119","text":"For a variable definition (e.g., on the stack or as a member of another object) there is no explicit function call from which an error code could be returned. Leaving behind an invalid object and relying on users to consistently check an is_valid() function before use is tedious, error-prone, and inefficient.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exception_19","text":"There are domains, such as some hard-real-time systems (think airplane controls) where (without additional tool support) exception handling is not sufficiently predictable from a timing perspective. There the is_valid() technique must be used. In such cases, check is_valid() consistently and immediately to simulate RAII .","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#alternative_5","text":"If you feel tempted to use some \u201cpost-constructor initialization\u201d or \u201ctwo-stage initialization\u201d idiom, try not to do that. If you really have to, look at factory functions .","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#note_120","text":"One reason people have used init() functions rather than doing the initialization work in a constructor has been to avoid code replication. Delegating constructors and default member initialization do that better. Another reason has been to delay initialization until an object is needed; the solution to that is often not to declare a variable until it can be properly initialized","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_86","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c43-ensure-that-a-copyable-value-type-class-has-a-default-constructor","text":"","title":"C.43: Ensure that a copyable (value type) class has a default constructor"},{"location":"cppcg/CppCoreGuidelines/#reason_92","text":"Many language and library facilities rely on default constructors to initialize their elements, e.g. T a[10] and std::vector<T> v(10) . A default constructor often simplifies the task of defining a suitable moved-from state for a type that is also copyable.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_121","text":"A value type is a class that is copyable (and usually also comparable). It is closely related to the notion of Regular type from EoP and the Palo Alto TR .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_86","text":"class Date { // BAD: no default constructor public: Date(int dd, int mm, int yyyy); // ... }; vector<Date> vd1(1000); // default Date needed here vector<Date> vd2(1000, Date{Month::October, 7, 1885}); // alternative The default constructor is only auto-generated if there is no user-declared constructor, hence it\u2019s impossible to initialize the vector vd1 in the example above. The absence of a default value can cause surprises for users and complicate its use, so if one can be reasonably defined, it should be. Date is chosen to encourage thought: There is no \u201cnatural\u201d default date (the big bang is too far back in time to be useful for most people), so this example is non-trivial. {0, 0, 0} is not a valid date in most calendar systems, so choosing that would be introducing something like floating-point\u2019s NaN . However, most realistic Date classes have a \u201cfirst date\u201d (e.g. January 1, 1970 is popular), so making that the default is usually trivial. class Date { public: Date(int dd, int mm, int yyyy); Date() = default; // [See also](#Rc-default) // ... private: int dd = 1; int mm = 1; int yyyy = 1970; // ... }; vector<Date> vd1(1000);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_122","text":"A class with members that all have default constructors implicitly gets a default constructor: struct X { string s; vector<int> v; }; X x; // means X{{}, {}}; that is the empty string and the empty vector Beware that built-in types are not properly default constructed: struct X { string s; int i; }; void f() { X x; // x.s is initialized to the empty string; x.i is uninitialized cout << x.s << ' ' << x.i << '\\n'; ++x.i; } Statically allocated objects of built-in types are by default initialized to 0 , but local built-in variables are not. Beware that your compiler may default initialize local built-in variables, whereas an optimized build will not. Thus, code like the example above may appear to work, but it relies on undefined behavior. Assuming that you want initialization, an explicit default initialization can help: struct X { string s; int i {}; // default initialize (to 0) };","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#notes_2","text":"Classes that don\u2019t have a reasonable default construction are usually not copyable either, so they don\u2019t fall under this guideline. For example, a base class is not a value type (base classes should not be copyable) and so does not necessarily need a default constructor: // Shape is an abstract base class, not a copyable value type. // It may or may not need a default constructor. struct Shape { virtual void draw() = 0; virtual void rotate(int) = 0; // =delete copy/move functions // ... }; A class that must acquire a caller-provided resource during construction often cannot have a default constructor, but it does not fall under this guideline because such a class is usually not copyable anyway: // std::lock_guard is not a copyable value type. // It does not have a default constructor. lock_guard g {mx}; // guard the mutex mx lock_guard g2; // error: guarding nothing A class that has a \u201cspecial state\u201d that must be handled separately from other states by member functions or users causes extra work (and most likely more errors). Such a type can naturally use the special state as a default constructed value, whether or not it is copyable: // std::ofstream is not a copyable value type. // It does happen to have a default constructor // that goes along with a special \"not open\" state. ofstream out {\"Foobar\"}; // ... out << log(time, transaction); Similar special-state types that are copyable, such as copyable smart pointers that have the special state \u201c==nullptr\u201d, should use the special state as their default constructed value. However, it is preferable to have a default constructor default to a meaningful state such as std::string s \"\" and std::vector s {} .","title":"Notes"},{"location":"cppcg/CppCoreGuidelines/#enforcement_87","text":"Flag classes that are copyable by = without a default constructor Flag classes that are comparable with == but not copyable","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c44-prefer-default-constructors-to-be-simple-and-non-throwing","text":"","title":"C.44: Prefer default constructors to be simple and non-throwing"},{"location":"cppcg/CppCoreGuidelines/#reason_93","text":"Being able to set a value to \u201cthe default\u201d without operations that might fail simplifies error handling and reasoning about move operations.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-problematic","text":"template<typename T> // elem points to space-elem element allocated using new class Vector0 { public: Vector0() :Vector0{0} {} Vector0(int n) :elem{new T[n]}, space{elem + n}, last{elem} {} // ... private: own<T*> elem; T* space; T* last; }; This is nice and general, but setting a Vector0 to empty after an error involves an allocation, which may fail. Also, having a default Vector represented as {new T[0], 0, 0} seems wasteful. For example, Vector0<int> v[100] costs 100 allocations.","title":"Example, problematic"},{"location":"cppcg/CppCoreGuidelines/#example_87","text":"template<typename T> // elem is nullptr or elem points to space-elem element allocated using new class Vector1 { public: // sets the representation to {nullptr, nullptr, nullptr}; doesn't throw Vector1() noexcept {} Vector1(int n) :elem{new T[n]}, space{elem + n}, last{elem} {} // ... private: own<T*> elem = nullptr; T* space = nullptr; T* last = nullptr; }; Using {nullptr, nullptr, nullptr} makes Vector1{} cheap, but a special case and implies run-time checks. Setting a Vector1 to empty after detecting an error is trivial.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_88","text":"Flag throwing default constructors","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c45-dont-define-a-default-constructor-that-only-initializes-data-members-use-in-class-member-initializers-instead","text":"","title":"C.45: Don't define a default constructor that only initializes data members; use in-class member initializers instead"},{"location":"cppcg/CppCoreGuidelines/#reason_94","text":"Using in-class member initializers lets the compiler generate the function for you. The compiler-generated function can be more efficient.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_32","text":"class X1 { // BAD: doesn't use member initializers string s; int i; public: X1() :s{\"default\"}, i{1} { } // ... };","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_88","text":"class X2 { string s = \"default\"; int i = 1; public: // use compiler-generated default constructor // ... };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_89","text":"(Simple) A default constructor should do more than just initialize member variables with constants.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c46-by-default-declare-single-argument-constructors-explicit","text":"","title":"C.46: By default, declare single-argument constructors explicit"},{"location":"cppcg/CppCoreGuidelines/#reason_95","text":"To avoid unintended conversions.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_33","text":"class String { // ... public: String(int); // BAD // ... }; String s = 10; // surprise: string of size 10","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#exception_20","text":"If you really want an implicit conversion from the constructor argument type to the class type, don\u2019t use explicit : class Complex { // ... public: Complex(double d); // OK: we want a conversion from d to {d, 0} // ... }; Complex z = 10.7; // unsurprising conversion See also : Discussion of implicit conversions","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#note_123","text":"Copy and move constructors should not be made explicit because they do not perform conversions. Explicit copy/move constructors make passing and returning by value difficult.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_90","text":"(Simple) Single-argument constructors should be declared explicit . Good single argument non- explicit constructors are rare in most code bases. Warn for all that are not on a \u201cpositive list\u201d.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c47-define-and-initialize-member-variables-in-the-order-of-member-declaration","text":"","title":"C.47: Define and initialize member variables in the order of member declaration"},{"location":"cppcg/CppCoreGuidelines/#reason_96","text":"To minimize confusion and errors. That is the order in which the initialization happens (independent of the order of member initializers).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_34","text":"class Foo { int m1; int m2; public: Foo(int x) :m2{x}, m1{++x} { } // BAD: misleading initializer order // ... }; Foo x(1); // surprise: x.m1 == x.m2 == 2","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_91","text":"(Simple) A member initializer list should mention the members in the same order they are declared. See also : Discussion","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c48-prefer-in-class-initializers-to-member-initializers-in-constructors-for-constant-initializers","text":"","title":"C.48: Prefer in-class initializers to member initializers in constructors for constant initializers"},{"location":"cppcg/CppCoreGuidelines/#reason_97","text":"Makes it explicit that the same value is expected to be used in all constructors. Avoids repetition. Avoids maintenance problems. It leads to the shortest and most efficient code.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_35","text":"class X { // BAD int i; string s; int j; public: X() :i{666}, s{\"qqq\"} { } // j is uninitialized X(int ii) :i{ii} {} // s is \"\" and j is uninitialized // ... }; How would a maintainer know whether j was deliberately uninitialized (probably a poor idea anyway) and whether it was intentional to give s the default value \"\" in one case and qqq in another (almost certainly a bug)? The problem with j (forgetting to initialize a member) often happens when a new member is added to an existing class.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_89","text":"class X2 { int i {666}; string s {\"qqq\"}; int j {0}; public: X2() = default; // all members are initialized to their defaults X2(int ii) :i{ii} {} // s and j initialized to their defaults // ... }; Alternative : We can get part of the benefits from default arguments to constructors, and that is not uncommon in older code. However, that is less explicit, causes more arguments to be passed, and is repetitive when there is more than one constructor: class X3 { // BAD: inexplicit, argument passing overhead int i; string s; int j; public: X3(int ii = 666, const string& ss = \"qqq\", int jj = 0) :i{ii}, s{ss}, j{jj} { } // all members are initialized to their defaults // ... };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_92","text":"(Simple) Every constructor should initialize every member variable (either explicitly, via a delegating ctor call or via default construction). (Simple) Default arguments to constructors suggest an in-class initializer may be more appropriate.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c49-prefer-initialization-to-assignment-in-constructors","text":"","title":"C.49: Prefer initialization to assignment in constructors"},{"location":"cppcg/CppCoreGuidelines/#reason_98","text":"An initialization explicitly states that initialization, rather than assignment, is done and can be more elegant and efficient. Prevents \u201cuse before set\u201d errors.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-good_6","text":"class A { // Good string s1; public: A(czstring p) : s1{p} { } // GOOD: directly construct (and the C-string is explicitly named) // ... };","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#example-bad_36","text":"class B { // BAD string s1; public: B(const char* p) { s1 = p; } // BAD: default constructor followed by assignment // ... }; class C { // UGLY, aka very bad int* p; public: C() { cout << *p; p = new int{10}; } // accidental use before initialized // ... };","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-better-still","text":"Instead of those const char* s we could use gsl::string_span or (in C++17) std::string_view as a more general way to present arguments to a function : class D { // Good string s1; public: A(string_view v) : s1{v} { } // GOOD: directly construct // ... };","title":"Example, better still"},{"location":"cppcg/CppCoreGuidelines/#c50-use-a-factory-function-if-you-need-virtual-behavior-during-initialization","text":"","title":"C.50: Use a factory function if you need \"virtual behavior\" during initialization"},{"location":"cppcg/CppCoreGuidelines/#reason_99","text":"If the state of a base class object must depend on the state of a derived part of the object, we need to use a virtual function (or equivalent) while minimizing the window of opportunity to misuse an imperfectly constructed object.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_124","text":"The return type of the factory should normally be unique_ptr by default; if some uses are shared, the caller can move the unique_ptr into a shared_ptr . However, if the factory author knows that all uses of the returned object will be shared uses, return shared_ptr and use make_shared in the body to save an allocation.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad_37","text":"class B { public: B() { /* ... */ f(); // BAD: C.82: Don't call virtual functions in constructors and destructors /* ... */ } virtual void f() = 0; };","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_90","text":"class B { protected: class Token {}; public: explicit B(Token) { /* ... */ } // create an imperfectly initialized object virtual void f() = 0; template<class T> static shared_ptr<T> create() // interface for creating shared objects { auto p = make_shared<T>(typename T::Token{}); p->post_initialize(); return p; } protected: virtual void post_initialize() // called right after construction { /* ... */ f(); /* ... */ } // GOOD: virtual dispatch is safe }; class D : public B { // some derived class protected: class Token {}; public: explicit D(Token) : B{ B::Token{} } {} void f() override { /* ... */ }; protected: template<class T> friend shared_ptr<T> B::create(); }; shared_ptr<D> p = D::create<D>(); // creating a D object make_shared requires that the constructor is public. By requiring a protected Token the constructor cannot be publicly called anymore, so we avoid an incompletely constructed object escaping into the wild. By providing the factory function create() , we make construction (on the free store) convenient.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_125","text":"Conventional factory functions allocate on the free store, rather than on the stack or in an enclosing object. See also : Discussion","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#c51-use-delegating-constructors-to-represent-common-actions-for-all-constructors-of-a-class","text":"","title":"C.51: Use delegating constructors to represent common actions for all constructors of a class"},{"location":"cppcg/CppCoreGuidelines/#reason_100","text":"To avoid repetition and accidental differences.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_38","text":"class Date { // BAD: repetitive int d; Month m; int y; public: Date(int dd, Month mm, year yy) :d{dd}, m{mm}, y{yy} { if (!valid(d, m, y)) throw Bad_date{}; } Date(int dd, Month mm) :d{dd}, m{mm} y{current_year()} { if (!valid(d, m, y)) throw Bad_date{}; } // ... }; The common action gets tedious to write and may accidentally not be common.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_91","text":"class Date2 { int d; Month m; int y; public: Date2(int dd, Month mm, year yy) :d{dd}, m{mm}, y{yy} { if (!valid(d, m, y)) throw Bad_date{}; } Date2(int dd, Month mm) :Date2{dd, mm, current_year()} {} // ... }; See also : If the \u201crepeated action\u201d is a simple initialization, consider an in-class member initializer .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_93","text":"(Moderate) Look for similar constructor bodies.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c52-use-inheriting-constructors-to-import-constructors-into-a-derived-class-that-does-not-need-further-explicit-initialization","text":"","title":"C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization"},{"location":"cppcg/CppCoreGuidelines/#reason_101","text":"If you need those constructors for a derived class, re-implementing them is tedious and error-prone.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_92","text":"std::vector has a lot of tricky constructors, so if I want my own vector , I don\u2019t want to reimplement them: class Rec { // ... data and lots of nice constructors ... }; class Oper : public Rec { using Rec::Rec; // ... no data members ... // ... lots of nice utility functions ... };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_39","text":"struct Rec2 : public Rec { int x; using Rec::Rec; }; Rec2 r {\"foo\", 7}; int val = r.x; // uninitialized","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_94","text":"Make sure that every member of the derived class is initialized.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#ccopy-copy-and-move","text":"Value types should generally be copyable, but interfaces in a class hierarchy should not. Resource handles may or may not be copyable. Types can be defined to move for logical as well as performance reasons.","title":"C.copy: Copy and move"},{"location":"cppcg/CppCoreGuidelines/#c60-make-copy-assignment-non-virtual-take-the-parameter-by-const-and-return-by-non-const","text":"","title":"C.60: Make copy assignment non-virtual, take the parameter by const&amp;, and return by non-const&amp;"},{"location":"cppcg/CppCoreGuidelines/#reason_102","text":"It is simple and efficient. If you want to optimize for rvalues, provide an overload that takes a && (see F.18 ).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_93","text":"class Foo { public: Foo& operator=(const Foo& x) { // GOOD: no need to check for self-assignment (other than performance) auto tmp = x; swap(tmp); // see C.83 return *this; } // ... }; Foo a; Foo b; Foo f(); a = b; // assign lvalue: copy a = f(); // assign rvalue: potentially move","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_126","text":"The swap implementation technique offers the strong guarantee .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_94","text":"But what if you can get significantly better performance by not making a temporary copy? Consider a simple Vector intended for a domain where assignment of large, equal-sized Vector s is common. In this case, the copy of elements implied by the swap implementation technique could cause an order of magnitude increase in cost: template<typename T> class Vector { public: Vector& operator=(const Vector&); // ... private: T* elem; int sz; }; Vector& Vector::operator=(const Vector& a) { if (a.sz > sz) { // ... use the swap technique, it can't be bettered ... return *this; } // ... copy sz elements from *a.elem to elem ... if (a.sz < sz) { // ... destroy the surplus elements in *this and adjust size ... } return *this; } By writing directly to the target elements, we will get only the basic guarantee rather than the strong guarantee offered by the swap technique. Beware of self-assignment . Alternatives : If you think you need a virtual assignment operator, and understand why that\u2019s deeply problematic, don\u2019t call it operator= . Make it a named function like virtual void assign(const Foo&) . See copy constructor vs. clone() .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_95","text":"(Simple) An assignment operator should not be virtual. Here be dragons! (Simple) An assignment operator should return T& to enable chaining, not alternatives like const T& which interfere with composability and putting objects in containers. (Moderate) An assignment operator should (implicitly or explicitly) invoke all base and member assignment operators. Look at the destructor to determine if the type has pointer semantics or value semantics.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c61-a-copy-operation-should-copy","text":"","title":"C.61: A copy operation should copy"},{"location":"cppcg/CppCoreGuidelines/#reason_103","text":"That is the generally assumed semantics. After x = y , we should have x == y . After a copy x and y can be independent objects (value semantics, the way non-pointer built-in types and the standard-library types work) or refer to a shared object (pointer semantics, the way pointers work).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_95","text":"class X { // OK: value semantics public: X(); X(const X&); // copy X void modify(); // change the value of X // ... ~X() { delete[] p; } private: T* p; int sz; }; bool operator==(const X& a, const X& b) { return a.sz == b.sz && equal(a.p, a.p + a.sz, b.p, b.p + b.sz); } X::X(const X& a) :p{new T[a.sz]}, sz{a.sz} { copy(a.p, a.p + sz, p); } X x; X y = x; if (x != y) throw Bad{}; x.modify(); if (x == y) throw Bad{}; // assume value semantics","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_96","text":"class X2 { // OK: pointer semantics public: X2(); X2(const X2&) = default; // shallow copy ~X2() = default; void modify(); // change the pointed-to value // ... private: T* p; int sz; }; bool operator==(const X2& a, const X2& b) { return a.sz == b.sz && a.p == b.p; } X2 x; X2 y = x; if (x != y) throw Bad{}; x.modify(); if (x != y) throw Bad{}; // assume pointer semantics","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_127","text":"Prefer value semantics unless you are building a \u201csmart pointer\u201d. Value semantics is the simplest to reason about and what the standard-library facilities expect.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_96","text":"(Not enforceable)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c62-make-copy-assignment-safe-for-self-assignment","text":"","title":"C.62: Make copy assignment safe for self-assignment"},{"location":"cppcg/CppCoreGuidelines/#reason_104","text":"If x = x changes the value of x , people will be surprised and bad errors will occur (often including leaks).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_97","text":"The standard-library containers handle self-assignment elegantly and efficiently: std::vector<int> v = {3, 1, 4, 1, 5, 9}; v = v; // the value of v is still {3, 1, 4, 1, 5, 9}","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_128","text":"The default assignment generated from members that handle self-assignment correctly handles self-assignment. struct Bar { vector<pair<int, int>> v; map<string, int> m; string s; }; Bar b; // ... b = b; // correct and efficient","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_129","text":"You can handle self-assignment by explicitly testing for self-assignment, but often it is faster and more elegant to cope without such a test (e.g., using swap ). class Foo { string s; int i; public: Foo& operator=(const Foo& a); // ... }; Foo& Foo::operator=(const Foo& a) // OK, but there is a cost { if (this == &a) return *this; s = a.s; i = a.i; return *this; } This is obviously safe and apparently efficient. However, what if we do one self-assignment per million assignments? That\u2019s about a million redundant tests (but since the answer is essentially always the same, the computer\u2019s branch predictor will guess right essentially every time). Consider: Foo& Foo::operator=(const Foo& a) // simpler, and probably much better { s = a.s; i = a.i; return *this; } std::string is safe for self-assignment and so are int . All the cost is carried by the (rare) case of self-assignment.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_97","text":"(Simple) Assignment operators should not contain the pattern if (this == &a) return *this; ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c63-make-move-assignment-non-virtual-take-the-parameter-by-and-return-by-non-const","text":"","title":"C.63: Make move assignment non-virtual, take the parameter by &amp;&amp;, and return by non-const &amp;"},{"location":"cppcg/CppCoreGuidelines/#reason_105","text":"It is simple and efficient. See : The rule for copy-assignment .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#enforcement_98","text":"Equivalent to what is done for copy-assignment . (Simple) An assignment operator should not be virtual. Here be dragons! (Simple) An assignment operator should return T& to enable chaining, not alternatives like const T& which interfere with composability and putting objects in containers. (Moderate) A move assignment operator should (implicitly or explicitly) invoke all base and member move assignment operators.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c64-a-move-operation-should-move-and-leave-its-source-in-a-valid-state","text":"","title":"C.64: A move operation should move and leave its source in a valid state"},{"location":"cppcg/CppCoreGuidelines/#reason_106","text":"That is the generally assumed semantics. After y = std::move(x) the value of y should be the value x had and x should be in a valid state.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_98","text":"template<typename T> class X { // OK: value semantics public: X(); X(X&& a) noexcept; // move X void modify(); // change the value of X // ... ~X() { delete[] p; } private: T* p; int sz; }; X::X(X&& a) :p{a.p}, sz{a.sz} // steal representation { a.p = nullptr; // set to \"empty\" a.sz = 0; } void use() { X x{}; // ... X y = std::move(x); x = X{}; // OK } // OK: x can be destroyed","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_130","text":"Ideally, that moved-from should be the default value of the type. Ensure that unless there is an exceptionally good reason not to. However, not all types have a default value and for some types establishing the default value can be expensive. The standard requires only that the moved-from object can be destroyed. Often, we can easily and cheaply do better: The standard library assumes that it is possible to assign to a moved-from object. Always leave the moved-from object in some (necessarily specified) valid state.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_131","text":"Unless there is an exceptionally strong reason not to, make x = std::move(y); y = z; work with the conventional semantics.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_99","text":"(Not enforceable) Look for assignments to members in the move operation. If there is a default constructor, compare those assignments to the initializations in the default constructor.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c65-make-move-assignment-safe-for-self-assignment","text":"","title":"C.65: Make move assignment safe for self-assignment"},{"location":"cppcg/CppCoreGuidelines/#reason_107","text":"If x = x changes the value of x , people will be surprised and bad errors may occur. However, people don\u2019t usually directly write a self-assignment that turn into a move, but it can occur. However, std::swap is implemented using move operations so if you accidentally do swap(a, b) where a and b refer to the same object, failing to handle self-move could be a serious and subtle error.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_99","text":"class Foo { string s; int i; public: Foo& operator=(Foo&& a); // ... }; Foo& Foo::operator=(Foo&& a) noexcept // OK, but there is a cost { if (this == &a) return *this; // this line is redundant s = std::move(a.s); i = a.i; return *this; } The one-in-a-million argument against if (this == &a) return *this; tests from the discussion of self-assignment is even more relevant for self-move.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_132","text":"There is no known general way of avoiding an if (this == &a) return *this; test for a move assignment and still get a correct answer (i.e., after x = x the value of x is unchanged).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_133","text":"The ISO standard guarantees only a \u201cvalid but unspecified\u201d state for the standard-library containers. Apparently this has not been a problem in about 10 years of experimental and production use. Please contact the editors if you find a counter example. The rule here is more caution and insists on complete safety.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_100","text":"Here is a way to move a pointer without a test (imagine it as code in the implementation a move assignment): // move from other.ptr to this->ptr T* temp = other.ptr; other.ptr = nullptr; delete ptr; ptr = temp;","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_100","text":"(Moderate) In the case of self-assignment, a move assignment operator should not leave the object holding pointer members that have been delete d or set to nullptr . (Not enforceable) Look at the use of standard-library container types (incl. string ) and consider them safe for ordinary (not life-critical) uses.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c66-make-move-operations-noexcept","text":"","title":"C.66: Make move operations noexcept"},{"location":"cppcg/CppCoreGuidelines/#reason_108","text":"A throwing move violates most people\u2019s reasonably assumptions. A non-throwing move will be used more efficiently by standard-library and language facilities.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_101","text":"template<typename T> class Vector { // ... Vector(Vector&& a) noexcept :elem{a.elem}, sz{a.sz} { a.sz = 0; a.elem = nullptr; } Vector& operator=(Vector&& a) noexcept { elem = a.elem; sz = a.sz; a.sz = 0; a.elem = nullptr; } // ... public: T* elem; int sz; }; These operations do not throw.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_40","text":"template<typename T> class Vector2 { // ... Vector2(Vector2&& a) { *this = a; } // just use the copy Vector2& operator=(Vector2&& a) { *this = a; } // just use the copy // ... public: T* elem; int sz; }; This Vector2 is not just inefficient, but since a vector copy requires allocation, it can throw.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_101","text":"(Simple) A move operation should be marked noexcept .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c67-a-polymorphic-class-should-suppress-copying","text":"","title":"C.67: A polymorphic class should suppress copying"},{"location":"cppcg/CppCoreGuidelines/#reason_109","text":"A polymorphic class is a class that defines or inherits at least one virtual function. It is likely that it will be used as a base class for other derived classes with polymorphic behavior. If it is accidentally passed by value, with the implicitly generated copy constructor and assignment, we risk slicing: only the base portion of a derived object will be copied, and the polymorphic behavior will be corrupted.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_41","text":"class B { // BAD: polymorphic base class doesn't suppress copying public: virtual char m() { return 'B'; } // ... nothing about copy operations, so uses default ... }; class D : public B { public: char m() override { return 'D'; } // ... }; void f(B& b) { auto b2 = b; // oops, slices the object; b2.m() will return 'B' } D d; f(d);","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_102","text":"class B { // GOOD: polymorphic class suppresses copying public: B(const B&) = delete; B& operator=(const B&) = delete; virtual char m() { return 'B'; } // ... }; class D : public B { public: char m() override { return 'D'; } // ... }; void f(B& b) { auto b2 = b; // ok, compiler will detect inadvertent copying, and protest } D d; f(d);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_134","text":"If you need to create deep copies of polymorphic objects, use clone() functions: see C.130 .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exception_21","text":"Classes that represent exception objects need both to be polymorphic and copy-constructible.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_102","text":"Flag a polymorphic class with a non-deleted copy operation. Flag an assignment of polymorphic class objects.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cother-other-default-operation-rules","text":"In addition to the operations for which the language offer default implementations, there are a few operations that are so foundational that it rules for their definition are needed: comparisons, swap , and hash .","title":"C.other: Other default operation rules"},{"location":"cppcg/CppCoreGuidelines/#c80-use-default-if-you-have-to-be-explicit-about-using-the-default-semantics","text":"","title":"C.80: Use =default if you have to be explicit about using the default semantics"},{"location":"cppcg/CppCoreGuidelines/#reason_110","text":"The compiler is more likely to get the default semantics right and you cannot implement these functions better than the compiler.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_103","text":"class Tracer { string message; public: Tracer(const string& m) : message{m} { cerr << \"entering \" << message << '\\n'; } ~Tracer() { cerr << \"exiting \" << message << '\\n'; } Tracer(const Tracer&) = default; Tracer& operator=(const Tracer&) = default; Tracer(Tracer&&) = default; Tracer& operator=(Tracer&&) = default; }; Because we defined the destructor, we must define the copy and move operations. The = default is the best and simplest way of doing that.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_42","text":"class Tracer2 { string message; public: Tracer2(const string& m) : message{m} { cerr << \"entering \" << message << '\\n'; } ~Tracer2() { cerr << \"exiting \" << message << '\\n'; } Tracer2(const Tracer2& a) : message{a.message} {} Tracer2& operator=(const Tracer2& a) { message = a.message; return *this; } Tracer2(Tracer2&& a) :message{a.message} {} Tracer2& operator=(Tracer2&& a) { message = a.message; return *this; } }; Writing out the bodies of the copy and move operations is verbose, tedious, and error-prone. A compiler does it better.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_103","text":"(Moderate) The body of a special operation should not have the same accessibility and semantics as the compiler-generated version, because that would be redundant","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c81-use-delete-when-you-want-to-disable-default-behavior-without-wanting-an-alternative","text":"","title":"C.81: Use =delete when you want to disable default behavior (without wanting an alternative)"},{"location":"cppcg/CppCoreGuidelines/#reason_111","text":"In a few cases, a default operation is not desirable.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_104","text":"class Immortal { public: ~Immortal() = delete; // do not allow destruction // ... }; void use() { Immortal ugh; // error: ugh cannot be destroyed Immortal* p = new Immortal{}; delete p; // error: cannot destroy *p }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_105","text":"A unique_ptr can be moved, but not copied. To achieve that its copy operations are deleted. To avoid copying it is necessary to =delete its copy operations from lvalues: template <class T, class D = default_delete<T>> class unique_ptr { public: // ... constexpr unique_ptr() noexcept; explicit unique_ptr(pointer p) noexcept; // ... unique_ptr(unique_ptr&& u) noexcept; // move constructor // ... unique_ptr(const unique_ptr&) = delete; // disable copy from lvalue // ... }; unique_ptr<int> make(); // make \"something\" and return it by moving void f() { unique_ptr<int> pi {}; auto pi2 {pi}; // error: no move constructor from lvalue auto pi3 {make()}; // OK, move: the result of make() is an rvalue } Note that deleted functions should be public.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_104","text":"The elimination of a default operation is (should be) based on the desired semantics of the class. Consider such classes suspect, but maintain a \u201cpositive list\u201d of classes where a human has asserted that the semantics is correct.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c82-dont-call-virtual-functions-in-constructors-and-destructors","text":"","title":"C.82: Don't call virtual functions in constructors and destructors"},{"location":"cppcg/CppCoreGuidelines/#reason_112","text":"The function called will be that of the object constructed so far, rather than a possibly overriding function in a derived class. This can be most confusing. Worse, a direct or indirect call to an unimplemented pure virtual function from a constructor or destructor results in undefined behavior.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_43","text":"class Base { public: virtual void f() = 0; // not implemented virtual void g(); // implemented with Base version virtual void h(); // implemented with Base version virtual ~Base(); // implemented with Base version }; class Derived : public Base { public: void g() override; // provide Derived implementation void h() final; // provide Derived implementation Derived() { // BAD: attempt to call an unimplemented virtual function f(); // BAD: will call Derived::g, not dispatch further virtually g(); // GOOD: explicitly state intent to call only the visible version Derived::g(); // ok, no qualification needed, h is final h(); } }; Note that calling a specific explicitly qualified function is not a virtual call even if the function is virtual . See also factory functions for how to achieve the effect of a call to a derived class function without risking undefined behavior.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_135","text":"There is nothing inherently wrong with calling virtual functions from constructors and destructors. The semantics of such calls is type safe. However, experience shows that such calls are rarely needed, easily confuse maintainers, and become a source of errors when used by novices.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_105","text":"Flag calls of virtual functions from constructors and destructors.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c83-for-value-like-types-consider-providing-a-noexcept-swap-function","text":"","title":"C.83: For value-like types, consider providing a noexcept swap function"},{"location":"cppcg/CppCoreGuidelines/#reason_113","text":"A swap can be handy for implementing a number of idioms, from smoothly moving objects around to implementing assignment easily to providing a guaranteed commit function that enables strongly error-safe calling code. Consider using swap to implement copy assignment in terms of copy construction. See also destructors, deallocation, and swap must never fail .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-good_7","text":"class Foo { // ... public: void swap(Foo& rhs) noexcept { m1.swap(rhs.m1); std::swap(m2, rhs.m2); } private: Bar m1; int m2; }; Providing a nonmember swap function in the same namespace as your type for callers\u2019 convenience. void swap(Foo& a, Foo& b) { a.swap(b); }","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#enforcement_106","text":"(Simple) A class without virtual functions should have a swap member function declared. (Simple) When a class has a swap member function, it should be declared noexcept .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c84-a-swap-function-may-not-fail","text":"","title":"C.84: A swap function may not fail"},{"location":"cppcg/CppCoreGuidelines/#reason_114","text":"swap is widely used in ways that are assumed never to fail and programs cannot easily be written to work correctly in the presence of a failing swap . The standard-library containers and algorithms will not work correctly if a swap of an element type fails.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_44","text":"void swap(My_vector& x, My_vector& y) { auto tmp = x; // copy elements x = y; y = tmp; } This is not just slow, but if a memory allocation occurs for the elements in tmp , this swap may throw and would make STL algorithms fail if used with them.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_107","text":"(Simple) When a class has a swap member function, it should be declared noexcept .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c85-make-swap-noexcept","text":"","title":"C.85: Make swap noexcept"},{"location":"cppcg/CppCoreGuidelines/#reason_115","text":"A swap may not fail . If a swap tries to exit with an exception, it\u2019s a bad design error and the program had better terminate.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#enforcement_108","text":"(Simple) When a class has a swap member function, it should be declared noexcept .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c86-make-symmetric-with-respect-to-operand-types-and-noexcept","text":"","title":"C.86: Make == symmetric with respect to operand types and noexcept"},{"location":"cppcg/CppCoreGuidelines/#reason_116","text":"Asymmetric treatment of operands is surprising and a source of errors where conversions are possible. == is a fundamental operations and programmers should be able to use it without fear of failure.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_106","text":"struct X { string name; int number; }; bool operator==(const X& a, const X& b) noexcept { return a.name == b.name && a.number == b.number; }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_45","text":"class B { string name; int number; bool operator==(const B& a) const { return name == a.name && number == a.number; } // ... }; B \u2018s comparison accepts conversions for its second operand, but not its first.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_136","text":"If a class has a failure state, like double \u2018s NaN , there is a temptation to make a comparison against the failure state throw. The alternative is to make two failure states compare equal and any valid state compare false against the failure state.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_137","text":"This rule applies to all the usual comparison operators: != , < , <= , > , and >= .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_109","text":"Flag an operator==() for which the argument types differ; same for other comparison operators: != , < , <= , > , and >= . Flag member operator==() s; same for other comparison operators: != , < , <= , > , and >= .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c87-beware-of-on-base-classes","text":"","title":"C.87: Beware of == on base classes"},{"location":"cppcg/CppCoreGuidelines/#reason_117","text":"It is really hard to write a foolproof and useful == for a hierarchy.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_46","text":"class B { string name; int number; virtual bool operator==(const B& a) const { return name == a.name && number == a.number; } // ... }; B \u2018s comparison accepts conversions for its second operand, but not its first. class D :B { char character; virtual bool operator==(const D& a) const { return name == a.name && number == a.number && character == a.character; } // ... }; B b = ... D d = ... b == d; // compares name and number, ignores d's character d == b; // error: no == defined D d2; d == d2; // compares name, number, and character B& b2 = d2; b2 == d; // compares name and number, ignores d2's and d's character Of course there are ways of making == work in a hierarchy, but the naive approaches do not scale","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_138","text":"This rule applies to all the usual comparison operators: != , < , <= , > , and >= .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_110","text":"Flag a virtual operator==() ; same for other comparison operators: != , < , <= , > , and >= .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c89-make-a-hash-noexcept","text":"","title":"C.89: Make a hash noexcept"},{"location":"cppcg/CppCoreGuidelines/#reason_118","text":"Users of hashed containers use hash indirectly and don\u2019t expect simple access to throw. It\u2019s a standard-library requirement.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_47","text":"template<> struct hash<My_type> { // thoroughly bad hash specialization using result_type = size_t; using argument_type = My_type; size_t operator() (const My_type & x) const { size_t xs = x.s.size(); if (xs < 4) throw Bad_My_type{}; // \"Nobody expects the Spanish inquisition!\" return hash<size_t>()(x.s.size()) ^ trim(x.s); } }; int main() { unordered_map<My_type, int> m; My_type mt{ \"asdfg\" }; m[mt] = 7; cout << m[My_type{ \"asdfg\" }] << '\\n'; } If you have to define a hash specialization, try simply to let it combine standard-library hash specializations with ^ (xor). That tends to work better than \u201ccleverness\u201d for non-specialists.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_111","text":"Flag throwing hash es.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#ccon-containers-and-other-resource-handles","text":"A container is an object holding a sequence of objects of some type; std::vector is the archetypical container. A resource handle is a class that owns a resource; std::vector is the typical resource handle; its resource is its sequence of elements. Summary of container rules: C.100: Follow the STL when defining a container C.101: Give a container value semantics C.102: Give a container move operations C.103: Give a container an initializer list constructor C.104: Give a container a default constructor that sets it to empty ??? C.109: If a resource handle has pointer semantics, provide * and -> See also : Resources","title":"C.con: Containers and other resource handles"},{"location":"cppcg/CppCoreGuidelines/#c100-follow-the-stl-when-defining-a-container","text":"","title":"C.100: Follow the STL when defining a container"},{"location":"cppcg/CppCoreGuidelines/#reason_119","text":"The STL containers are familiar to most C++ programmers and a fundamentally sound design.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_139","text":"There are of course other fundamentally sound design styles and sometimes reasons to depart from the style of the standard library, but in the absence of a solid reason to differ, it is simpler and easier for both implementers and users to follow the standard. In particular, std::vector and std::map provide useful relatively simple models.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_107","text":"// simplified (e.g., no allocators): template<typename T> class Sorted_vector { using value_type = T; // ... iterator types ... Sorted_vector() = default; Sorted_vector(initializer_list<T>); // initializer-list constructor: sort and store Sorted_vector(const Sorted_vector&) = default; Sorted_vector(Sorted_vector&&) = default; Sorted_vector& operator=(const Sorted_vector&) = default; // copy assignment Sorted_vector& operator=(Sorted_vector&&) = default; // move assignment ~Sorted_vector() = default; Sorted_vector(const std::vector<T>& v); // store and sort Sorted_vector(std::vector<T>&& v); // sort and \"steal representation\" const T& operator[](int i) const { return rep[i]; } // no non-const direct access to preserve order void push_back(const T&); // insert in the right place (not necessarily at back) void push_back(T&&); // insert in the right place (not necessarily at back) // ... cbegin(), cend() ... private: std::vector<T> rep; // use a std::vector to hold elements }; template<typename T> bool operator==(const Sorted_vector<T>&, const Sorted_vector<T>&); template<typename T> bool operator!=(const Sorted_vector<T>&, const Sorted_vector<T>&); // ... Here, the STL style is followed, but incompletely. That\u2019s not uncommon. Provide only as much functionality as makes sense for a specific container. The key is to define the conventional constructors, assignments, destructors, and iterators (as meaningful for the specific container) with their conventional semantics. From that base, the container can be expanded as needed. Here, special constructors from std::vector were added.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_112","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c101-give-a-container-value-semantics","text":"","title":"C.101: Give a container value semantics"},{"location":"cppcg/CppCoreGuidelines/#reason_120","text":"Regular objects are simpler to think and reason about than irregular ones. Familiarity.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_140","text":"If meaningful, make a container Regular (the concept). In particular, ensure that an object compares equal to its copy.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_108","text":"void f(const Sorted_vector<string>& v) { Sorted_vector<string> v2 {v}; if (v != v2) cout << \"insanity rules!\\n\"; // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_113","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c102-give-a-container-move-operations","text":"","title":"C.102: Give a container move operations"},{"location":"cppcg/CppCoreGuidelines/#reason_121","text":"Containers tend to get large; without a move constructor and a copy constructor an object can be expensive to move around, thus tempting people to pass pointers to it around and getting into resource management problems.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_109","text":"Sorted_vector<int> read_sorted(istream& is) { vector<int> v; cin >> v; // assume we have a read operation for vectors Sorted_vector<int> sv = v; // sorts return sv; } A user can reasonably assume that returning a standard-like container is cheap.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_114","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c103-give-a-container-an-initializer-list-constructor","text":"","title":"C.103: Give a container an initializer list constructor"},{"location":"cppcg/CppCoreGuidelines/#reason_122","text":"People expect to be able to initialize a container with a set of values. Familiarity.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_110","text":"Sorted_vector<int> sv {1, 3, -1, 7, 0, 0}; // Sorted_vector sorts elements as needed","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_115","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c104-give-a-container-a-default-constructor-that-sets-it-to-empty","text":"","title":"C.104: Give a container a default constructor that sets it to empty"},{"location":"cppcg/CppCoreGuidelines/#reason_123","text":"To make it Regular .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_111","text":"vector<Sorted_sequence<string>> vs(100); // 100 Sorted_sequences each with the value \"\"","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_116","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c109-if-a-resource-handle-has-pointer-semantics-provide-and-","text":"","title":"C.109: If a resource handle has pointer semantics, provide * and -&gt;"},{"location":"cppcg/CppCoreGuidelines/#reason_124","text":"That\u2019s what is expected from pointers. Familiarity.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_112","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_117","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#clambdas-function-objects-and-lambdas","text":"A function object is an object supplying an overloaded () so that you can call it. A lambda expression (colloquially often shortened to \u201ca lambda\u201d) is a notation for generating a function object. Function objects should be cheap to copy (and therefore passed by value ). Summary: F.50: Use a lambda when a function won\u2019t do (to capture local variables, or to write a local function) F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread ES.28: Use lambdas for complex initialization, especially of const variables","title":"C.lambdas: Function objects and lambdas"},{"location":"cppcg/CppCoreGuidelines/#chier-class-hierarchies-oop","text":"A class hierarchy is constructed to represent a set of hierarchically organized concepts (only). Typically base classes act as interfaces. There are two major uses for hierarchies, often named implementation inheritance and interface inheritance. Class hierarchy rule summary: C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only) C.121: If a base class is used as an interface, make it a pure abstract class C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed Designing rules for classes in a hierarchy summary: C.126: An abstract class typically doesn\u2019t need a constructor C.127: A class with a virtual function should have a virtual or protected destructor C.128: Virtual functions should specify exactly one of virtual , override , or final C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance C.130: For making deep copies of polymorphic classes prefer a virtual clone function instead of copy construction/assignment C.131: Avoid trivial getters and setters C.132: Don\u2019t make a function virtual without reason C.133: Avoid protected data C.134: Ensure all non- const data members have the same access level C.135: Use multiple inheritance to represent multiple distinct interfaces C.136: Use multiple inheritance to represent the union of implementation attributes C.137: Use virtual bases to avoid overly general base classes C.138: Create an overload set for a derived class and its bases with using C.139: Use final sparingly C.140: Do not provide different default arguments for a virtual function and an overrider Accessing objects in a hierarchy rule summary: C.145: Access polymorphic objects through pointers and references C.146: Use dynamic_cast where class hierarchy navigation is unavoidable C.147: Use dynamic_cast to a reference type when failure to find the required class is considered an error C.148: Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative C.149: Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new C.150: Use make_unique() to construct objects owned by unique_ptr s C.151: Use make_shared() to construct objects owned by shared_ptr s C.152: Never assign a pointer to an array of derived class objects to a pointer to its base C.153: Prefer virtual function to casting","title":"C.hier: Class hierarchies (OOP)"},{"location":"cppcg/CppCoreGuidelines/#c120-use-class-hierarchies-to-represent-concepts-with-inherent-hierarchical-structure-only","text":"","title":"C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)"},{"location":"cppcg/CppCoreGuidelines/#reason_125","text":"Direct representation of ideas in code eases comprehension and maintenance. Make sure the idea represented in the base class exactly matches all derived types and there is not a better way to express it than using the tight coupling of inheritance. Do not use inheritance when simply having a data member will do. Usually this means that the derived type needs to override a base virtual function or needs access to a protected member.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_113","text":"class DrawableUIElement { public: virtual void render() const = 0; // ... }; class AbstractButton : public DrawableUIElement { public: virtual void onClick() = 0; // ... }; class PushButton : public AbstractButton { void render() const override; void onClick() override; // ... }; class Checkbox : public AbstractButton { // ... };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_48","text":"Do not represent non-hierarchical domain concepts as class hierarchies. template<typename T> class Container { public: // list operations: virtual T& get() = 0; virtual void put(T&) = 0; virtual void insert(Position) = 0; // ... // vector operations: virtual T& operator[](int) = 0; virtual void sort() = 0; // ... // tree operations: virtual void balance() = 0; // ... }; Here most overriding classes cannot implement most of the functions required in the interface well. Thus the base class becomes an implementation burden. Furthermore, the user of Container cannot rely on the member functions actually performing meaningful operations reasonably efficiently; it may throw an exception instead. Thus users have to resort to run-time checking and/or not using this (over)general interface in favor of a particular interface found by a run-time type inquiry (e.g., a dynamic_cast ).","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_118","text":"Look for classes with lots of members that do nothing but throw. Flag every use of a nonpublic base class B where the derived class D does not override a virtual function or access a protected member in B , and B is not one of the following: empty, a template parameter or parameter pack of D , a class template specialized with D .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c121-if-a-base-class-is-used-as-an-interface-make-it-a-pure-abstract-class","text":"","title":"C.121: If a base class is used as an interface, make it a pure abstract class"},{"location":"cppcg/CppCoreGuidelines/#reason_126","text":"A class is more stable (less brittle) if it does not contain data. Interfaces should normally be composed entirely of public pure virtual functions and a default/empty virtual destructor.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_114","text":"class My_interface { public: // ...only pure virtual functions here ... virtual ~My_interface() {} // or =default };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_49","text":"class Goof { public: // ...only pure virtual functions here ... // no virtual destructor }; class Derived : public Goof { string s; // ... }; void use() { unique_ptr<Goof> p {new Derived{\"here we go\"}}; f(p.get()); // use Derived through the Goof interface g(p.get()); // use Derived through the Goof interface } // leak The Derived is delete d through its Goof interface, so its string is leaked. Give Goof a virtual destructor and all is well.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_119","text":"Warn on any class that contains data members and also has an overridable (non- final ) virtual function.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c122-use-abstract-classes-as-interfaces-when-complete-separation-of-interface-and-implementation-is-needed","text":"","title":"C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed"},{"location":"cppcg/CppCoreGuidelines/#reason_127","text":"Such as on an ABI (link) boundary.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_115","text":"struct Device { virtual ~Device() = default; virtual void write(span<const char> outbuf) = 0; virtual void read(span<char> inbuf) = 0; }; class D1 : public Device { // ... data ... void write(span<const char> outbuf) override; void read(span<char> inbuf) override; }; class D2 : public Device { // ... different data ... void write(span<const char> outbuf) override; void read(span<char> inbuf) override; }; A user can now use D1 s and D2 s interchangeably through the interface provided by Device . Furthermore, we can update D1 and D2 in ways that are not binary compatible with older versions as long as all access goes through Device .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_120","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#chierclass-designing-classes-in-a-hierarchy","text":"","title":"C.hierclass: Designing classes in a hierarchy:"},{"location":"cppcg/CppCoreGuidelines/#c126-an-abstract-class-typically-doesnt-need-a-constructor","text":"","title":"C.126: An abstract class typically doesn't need a constructor"},{"location":"cppcg/CppCoreGuidelines/#reason_128","text":"An abstract class typically does not have any data for a constructor to initialize.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_116","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_22","text":"A base class constructor that does work, such as registering an object somewhere, may need a constructor. In extremely rare cases, you might find it reasonable for an abstract class to have a bit of data shared by all derived classes (e.g., use statistics data, debug information, etc.); such classes tend to have constructors. But be warned: Such classes also tend to be prone to requiring virtual inheritance.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_121","text":"Flag abstract classes with constructors.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c127-a-class-with-a-virtual-function-should-have-a-virtual-or-protected-destructor","text":"","title":"C.127: A class with a virtual function should have a virtual or protected destructor"},{"location":"cppcg/CppCoreGuidelines/#reason_129","text":"A class with a virtual function is usually (and in general) used via a pointer to base. Usually, the last user has to call delete on a pointer to base, often via a smart pointer to base, so the destructor should be public and virtual. Less commonly, if deletion through a pointer to base is not intended to be supported, the destructor should be protected and nonvirtual; see C.35 .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_50","text":"struct B { virtual int f() = 0; // ... no user-written destructor, defaults to public nonvirtual ... }; // bad: derived from a class without a virtual destructor struct D : B { string s {\"default\"}; }; void use() { unique_ptr<B> p = make_unique<D>(); // ... } // undefined behavior. May call B::~B only and leak the string","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_141","text":"There are people who don\u2019t follow this rule because they plan to use a class only through a shared_ptr : std::shared_ptr<B> p = std::make_shared<D>(args); Here, the shared pointer will take care of deletion, so no leak will occur from an inappropriate delete of the base. People who do this consistently can get a false positive, but the rule is important \u2013 what if one was allocated using make_unique ? It\u2019s not safe unless the author of B ensures that it can never be misused, such as by making all constructors private and providing a factory function to enforce the allocation with make_shared .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_122","text":"A class with any virtual functions should have a destructor that is either public and virtual or else protected and nonvirtual. Flag delete of a class with a virtual function but no virtual destructor.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final","text":"","title":"C.128: Virtual functions should specify exactly one of virtual, override, or final"},{"location":"cppcg/CppCoreGuidelines/#reason_130","text":"Readability. Detection of mistakes. Writing explicit virtual , override , or final is self-documenting and enables the compiler to catch mismatch of types and/or names between base and derived classes. However, writing more than one of these three is both redundant and a potential source of errors. It\u2019s simple and clear: virtual means exactly and only \u201cthis is a new virtual function.\u201d override means exactly and only \u201cthis is a non-final overrider.\u201d final means exactly and only \u201cthis is a final overrider.\u201d","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_51","text":"struct B { void f1(int); virtual void f2(int) const; virtual void f3(int); // ... }; struct D : B { void f1(int); // bad (hope for a warning): D::f1() hides B::f1() void f2(int) const; // bad (but conventional and valid): no explicit override void f3(double); // bad (hope for a warning): D::f3() hides B::f3() // ... };","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_8","text":"struct Better : B { void f1(int) override; // error (caught): Better::f1() hides B::f1() void f2(int) const override; void f3(double) override; // error (caught): Better::f3() hides B::f3() // ... };","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#discussion_3","text":"We want to eliminate two particular classes of errors: implicit virtual : the programmer intended the function to be implicitly virtual and it is (but readers of the code can\u2019t tell); or the programmer intended the function to be implicitly virtual but it isn\u2019t (e.g., because of a subtle parameter list mismatch); or the programmer did not intend the function to be virtual but it is (because it happens to have the same signature as a virtual in the base class) implicit override : the programmer intended the function to be implicitly an overrider and it is (but readers of the code can\u2019t tell); or the programmer intended the function to be implicitly an overrider but it isn\u2019t (e.g., because of a subtle parameter list mismatch); or the programmer did not intend the function to be an overrider but it is (because it happens to have the same signature as a virtual in the base class \u2013 note this problem arises whether or not the function is explicitly declared virtual, because the programmer may have intended to create either a new virtual function or a new nonvirtual function)","title":"Discussion"},{"location":"cppcg/CppCoreGuidelines/#enforcement_123","text":"Compare virtual function names in base and derived classes and flag uses of the same name that does not override. Flag overrides with neither override nor final . Flag function declarations that use more than one of virtual , override , and final .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c129-when-designing-a-class-hierarchy-distinguish-between-implementation-inheritance-and-interface-inheritance","text":"","title":"C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance"},{"location":"cppcg/CppCoreGuidelines/#reason_131","text":"Implementation details in an interface make the interface brittle; that is, make its users vulnerable to having to recompile after changes in the implementation. Data in a base class increases the complexity of implementing the base and can lead to replication of code.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_142","text":"Definition: interface inheritance is the use of inheritance to separate users from implementations, in particular to allow derived classes to be added and changed without affecting the users of base classes. implementation inheritance is the use of inheritance to simplify implementation of new facilities by making useful operations available for implementers of related new operations (sometimes called \u201cprogramming by difference\u201d). A pure interface class is simply a set of pure virtual functions; see I.25 . In early OOP (e.g., in the 1980s and 1990s), implementation inheritance and interface inheritance were often mixed and bad habits die hard. Even now, mixtures are not uncommon in old code bases and in old-style teaching material. The importance of keeping the two kinds of inheritance increases with the size of a hierarchy (e.g., dozens of derived classes), with the length of time the hierarchy is used (e.g., decades), and with the number of distinct organizations in which a hierarchy is used (e.g., it can be difficult to distribute an update to a base class)","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad_52","text":"class Shape { // BAD, mixed interface and implementation public: Shape(); Shape(Point ce = {0, 0}, Color co = none): cent{ce}, col {co} { /* ... */} Point center() const { return cent; } Color color() const { return col; } virtual void rotate(int) = 0; virtual void move(Point p) { cent = p; redraw(); } virtual void redraw(); // ... private: Point cent; Color col; }; class Circle : public Shape { public: Circle(Point c, int r) :Shape{c}, rad{r} { /* ... */ } // ... private: int rad; }; class Triangle : public Shape { public: Triangle(Point p1, Point p2, Point p3); // calculate center // ... }; Problems: As the hierarchy grows and more data is added to Shape , the constructors get harder to write and maintain. Why calculate the center for the Triangle ? we may never use it. Add a data member to Shape (e.g., drawing style or canvas) and all classes derived from Shape and all code using Shape will need to be reviewed, possibly changed, and probably recompiled. The implementation of Shape::move() is an example of implementation inheritance: we have defined move() once and for all for all derived classes. The more code there is in such base class member function implementations and the more data is shared by placing it in the base, the more benefits we gain - and the less stable the hierarchy is.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_117","text":"This Shape hierarchy can be rewritten using interface inheritance: class Shape { // pure interface public: virtual Point center() const = 0; virtual Color color() const = 0; virtual void rotate(int) = 0; virtual void move(Point p) = 0; virtual void redraw() = 0; // ... }; Note that a pure interface rarely has constructors: there is nothing to construct. class Circle : public Shape { public: Circle(Point c, int r, Color c) :cent{c}, rad{r}, col{c} { /* ... */ } Point center() const override { return cent; } Color color() const override { return col; } // ... private: Point cent; int rad; Color col; }; The interface is now less brittle, but there is more work in implementing the member functions. For example, center has to be implemented by every class derived from Shape .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-dual-hierarchy","text":"How can we gain the benefit of stable hierarchies from implementation hierarchies and the benefit of implementation reuse from implementation inheritance? One popular technique is dual hierarchies. There are many ways of implementing the idea of dual hierarchies; here, we use a multiple-inheritance variant. First we devise a hierarchy of interface classes: class Shape { // pure interface public: virtual Point center() const = 0; virtual Color color() const = 0; virtual void rotate(int) = 0; virtual void move(Point p) = 0; virtual void redraw() = 0; // ... }; class Circle : public virtual Shape { // pure interface public: virtual int radius() = 0; // ... }; To make this interface useful, we must provide its implementation classes (here, named equivalently, but in the Impl namespace): class Impl::Shape : public virtual ::Shape { // implementation public: // constructors, destructor // ... Point center() const override { /* ... */ } Color color() const override { /* ... */ } void rotate(int) override { /* ... */ } void move(Point p) override { /* ... */ } void redraw() override { /* ... */ } // ... }; Now Shape is a poor example of a class with an implementation, but bear with us because this is just a simple example of a technique aimed at more complex hierarchies. class Impl::Circle : public virtual ::Circle, public Impl::Shape { // implementation public: // constructors, destructor int radius() override { /* ... */ } // ... }; And we could extend the hierarchies by adding a Smiley class (:-)): class Smiley : public virtual Circle { // pure interface public: // ... }; class Impl::Smiley : public virtual ::Smiley, public Impl::Circle { // implementation public: // constructors, destructor // ... } There are now two hierarchies: interface: Smiley -> Circle -> Shape implementation: Impl::Smiley -> Impl::Circle -> Impl::Shape Since each implementation is derived from its interface as well as its implementation base class we get a lattice (DAG): Smiley -> Circle -> Shape ^ ^ ^ | | | Impl::Smiley -> Impl::Circle -> Impl::Shape As mentioned, this is just one way to construct a dual hierarchy. The implementation hierarchy can be used directly, rather than through the abstract interface. void work_with_shape(Shape&); int user() { Impl::Smiley my_smiley{ /* args */ }; // create concrete shape // ... my_smiley.some_member(); // use implementation class directly // ... work_with_shape(my_smiley); // use implementation through abstract interface // ... } This can be useful when the implementation class has members that are not offered in the abstract interface or if direct use of a member offers optimization opportunities (e.g., if an implementation member function is final )","title":"Example, dual hierarchy"},{"location":"cppcg/CppCoreGuidelines/#note_143","text":"Another (related) technique for separating interface and implementation is Pimpl .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_144","text":"There is often a choice between offering common functionality as (implemented) base class functions and free-standing functions (in an implementation namespace). Base classes gives a shorter notation and easier access to shared data (in the base) at the cost of the functionality being available only to users of the hierarchy.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_124","text":"Flag a derived to base conversion to a base with both data and virtual functions (except for calls from a derived class member to a base class member) ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c130-for-making-deep-copies-of-polymorphic-classes-prefer-a-virtual-clone-function-instead-of-copy-constructionassignment","text":"","title":"C.130: For making deep copies of polymorphic classes prefer a virtual clone function instead of copy construction/assignment"},{"location":"cppcg/CppCoreGuidelines/#reason_132","text":"Copying a polymorphic class is discouraged due to the slicing problem, see C.67 . If you really need copy semantics, copy deeply: Provide a virtual clone function that will copy the actual most-derived type and return an owning pointer to the new object, and then in derived classes return the derived type (use a covariant return type).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_118","text":"class B { public: virtual owner<B*> clone() = 0; virtual ~B() = default; B(const B&) = delete; B& operator=(const B&) = delete; }; class D : public B { public: owner<D*> clone() override; ~D() override; }; Generally, it is recommended to use smart pointers to represent ownership (see R.20 ). However, because of language rules, the covariant return type cannot be a smart pointer: D::clone can\u2019t return a unique_ptr<D> while B::clone returns unique_ptr<B> . Therefore, you either need to consistently return unique_ptr<B> in all overrides, or use owner<> utility from the Guidelines Support Library .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#c131-avoid-trivial-getters-and-setters","text":"","title":"C.131: Avoid trivial getters and setters"},{"location":"cppcg/CppCoreGuidelines/#reason_133","text":"A trivial getter or setter adds no semantic value; the data item could just as well be public .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_119","text":"class Point { // Bad: verbose int x; int y; public: Point(int xx, int yy) : x{xx}, y{yy} { } int get_x() const { return x; } void set_x(int xx) { x = xx; } int get_y() const { return y; } void set_y(int yy) { y = yy; } // no behavioral member functions }; Consider making such a class a struct \u2013 that is, a behaviorless bunch of variables, all public data and no member functions. struct Point { int x {0}; int y {0}; }; Note that we can put default initializers on member variables: C.49: Prefer initialization to assignment in constructors .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_145","text":"The key to this rule is whether the semantics of the getter/setter are trivial. While it is not a complete definition of \u201ctrivial\u201d, consider whether there would be any difference beyond syntax if the getter/setter was a public data member instead. Examples of non-trivial semantics would be: maintaining a class invariant or converting between an internal type and an interface type.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_125","text":"Flag multiple get and set member functions that simply access a member without additional semantics.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c132-dont-make-a-function-virtual-without-reason","text":"","title":"C.132: Don't make a function virtual without reason"},{"location":"cppcg/CppCoreGuidelines/#reason_134","text":"Redundant virtual increases run-time and object-code size. A virtual function can be overridden and is thus open to mistakes in a derived class. A virtual function ensures code replication in a templated hierarchy.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_53","text":"template<class T> class Vector { public: // ... virtual int size() const { return sz; } // bad: what good could a derived class do? private: T* elem; // the elements int sz; // number of elements }; This kind of \u201cvector\u201d isn\u2019t meant to be used as a base class at all.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_126","text":"Flag a class with virtual functions but no derived classes. Flag a class where all member functions are virtual and have implementations.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c133-avoid-protected-data","text":"","title":"C.133: Avoid protected data"},{"location":"cppcg/CppCoreGuidelines/#reason_135","text":"protected data is a source of complexity and errors. protected data complicates the statement of invariants. protected data inherently violates the guidance against putting data in base classes, which usually leads to having to deal with virtual inheritance as well.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_54","text":"class Shape { public: // ... interface functions ... protected: // data for use in derived classes: Color fill_color; Color edge_color; Style st; }; Now it is up to every derived Shape to manipulate the protected data correctly. This has been popular, but also a major source of maintenance problems. In a large class hierarchy, the consistent use of protected data is hard to maintain because there can be a lot of code, spread over a lot of classes. The set of classes that can touch that data is open: anyone can derive a new class and start manipulating the protected data. Often, it is not possible to examine the complete set of classes, so any change to the representation of the class becomes infeasible. There is no enforced invariant for the protected data; it is much like a set of global variables. The protected data has de facto become global to a large body of code.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_146","text":"Protected data often looks tempting to enable arbitrary improvements through derivation. Often, what you get is unprincipled changes and errors. Prefer private data with a well-specified and enforced invariant. Alternative, and often better, keep data out of any class used as an interface .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_147","text":"Protected member function can be just fine.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_127","text":"Flag classes with protected data.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c134-ensure-all-non-const-data-members-have-the-same-access-level","text":"","title":"C.134: Ensure all non-const data members have the same access level"},{"location":"cppcg/CppCoreGuidelines/#reason_136","text":"Prevention of logical confusion leading to errors. If the non- const data members don\u2019t have the same access level, the type is confused about what it\u2019s trying to do. Is it a type that maintains an invariant or simply a collection of values?","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#discussion_4","text":"The core question is: What code is responsible for maintaining a meaningful/correct value for that variable? There are exactly two kinds of data members: A: Ones that don\u2019t participate in the object\u2019s invariant. Any combination of values for these members is valid. B: Ones that do participate in the object\u2019s invariant. Not every combination of values is meaningful (else there\u2019d be no invariant). Therefore all code that has write access to these variables must know about the invariant, know the semantics, and know (and actively implement and enforce) the rules for keeping the values correct. Data members in category A should just be public (or, more rarely, protected if you only want derived classes to see them). They don\u2019t need encapsulation. All code in the system might as well see and manipulate them. Data members in category B should be private or const . This is because encapsulation is important. To make them non- private and non- const would mean that the object can\u2019t control its own state: An unbounded amount of code beyond the class would need to know about the invariant and participate in maintaining it accurately \u2013 if these data members were public , that would be all calling code that uses the object; if they were protected , it would be all the code in current and future derived classes. This leads to brittle and tightly coupled code that quickly becomes a nightmare to maintain. Any code that inadvertently sets the data members to an invalid or unexpected combination of values would corrupt the object and all subsequent uses of the object. Most classes are either all A or all B: All public : If you\u2019re writing an aggregate bundle-of-variables without an invariant across those variables, then all the variables should be public . By convention, declare such classes struct rather than class All private : If you\u2019re writing a type that maintains an invariant, then all the non- const variables should be private \u2013 it should be encapsulated.","title":"Discussion"},{"location":"cppcg/CppCoreGuidelines/#exception_23","text":"Occasionally classes will mix A and B, usually for debug reasons. An encapsulated object may contain something like non- const debug instrumentation that isn\u2019t part of the invariant and so falls into category A \u2013 it isn\u2019t really part of the object\u2019s value or meaningful observable state either. In that case, the A parts should be treated as A\u2019s (made public , or in rarer cases protected if they should be visible only to derived classes) and the B parts should still be treated like B\u2019s ( private or const ).","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_128","text":"Flag any class that has non- const data members with different access levels.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c135-use-multiple-inheritance-to-represent-multiple-distinct-interfaces","text":"","title":"C.135: Use multiple inheritance to represent multiple distinct interfaces"},{"location":"cppcg/CppCoreGuidelines/#reason_137","text":"Not all classes will necessarily support all interfaces, and not all callers will necessarily want to deal with all operations. Especially to break apart monolithic interfaces into \u201caspects\u201d of behavior supported by a given derived class.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_120","text":"class iostream : public istream, public ostream { // very simplified // ... }; istream provides the interface to input operations; ostream provides the interface to output operations. iostream provides the union of the istream and ostream interfaces and the synchronization needed to allow both on a single stream.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_148","text":"This is a very common use of inheritance because the need for multiple different interfaces to an implementation is common and such interfaces are often not easily or naturally organized into a single-rooted hierarchy.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_149","text":"Such interfaces are typically abstract classes.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_129","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c136-use-multiple-inheritance-to-represent-the-union-of-implementation-attributes","text":"","title":"C.136: Use multiple inheritance to represent the union of implementation attributes"},{"location":"cppcg/CppCoreGuidelines/#reason_138","text":"Some forms of mixins have state and often operations on that state. If the operations are virtual the use of inheritance is necessary, if not using inheritance can avoid boilerplate and forwarding.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_121","text":"class iostream : public istream, public ostream { // very simplified // ... }; istream provides the interface to input operations (and some data); ostream provides the interface to output operations (and some data). iostream provides the union of the istream and ostream interfaces and the synchronization needed to allow both on a single stream.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_150","text":"This a relatively rare use because implementation can often be organized into a single-rooted hierarchy.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_122","text":"Sometimes, an \u201cimplementation attribute\u201d is more like a \u201cmixin\u201d that determine the behavior of an implementation and inject members to enable the implementation of the policies it requires. For example, see std::enable_shared_from_this or various bases from boost.intrusive (e.g. list_base_hook or intrusive_ref_counter ).","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_130","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c137-use-virtual-bases-to-avoid-overly-general-base-classes","text":"","title":"C.137: Use virtual bases to avoid overly general base classes"},{"location":"cppcg/CppCoreGuidelines/#reason_139","text":"Allow separation of shared data and interface. To avoid all shared data to being put into an ultimate base class.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_123","text":"struct Interface { virtual void f(); virtual int g(); // ... no data here ... }; class Utility { // with data void utility1(); virtual void utility2(); // customization point public: int x; int y; }; class Derive1 : public Interface, virtual protected Utility { // override Interface functions // Maybe override Utility virtual functions // ... }; class Derive2 : public Interface, virtual protected Utility { // override Interface functions // Maybe override Utility virtual functions // ... }; Factoring out Utility makes sense if many derived classes share significant \u201cimplementation details.\u201d","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_151","text":"Obviously, the example is too \u201ctheoretical\u201d, but it is hard to find a small realistic example. Interface is the root of an interface hierarchy and Utility is the root of an implementation hierarchy . Here is a slightly more realistic example with an explanation.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_152","text":"Often, linearization of a hierarchy is a better solution.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_131","text":"Flag mixed interface and implementation hierarchies.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c138-create-an-overload-set-for-a-derived-class-and-its-bases-with-using","text":"","title":"C.138: Create an overload set for a derived class and its bases with using"},{"location":"cppcg/CppCoreGuidelines/#reason_140","text":"Without a using declaration, member functions in the derived class hide the entire inherited overload sets.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_55","text":"#include <iostream> class B { public: virtual int f(int i) { std::cout << \"f(int): \"; return i; } virtual double f(double d) { std::cout << \"f(double): \"; return d; } virtual ~B() = default; }; class D: public B { public: int f(int i) override { std::cout << \"f(int): \"; return i + 1; } }; int main() { D d; std::cout << d.f(2) << '\\n'; // prints \"f(int): 3\" std::cout << d.f(2.3) << '\\n'; // prints \"f(int): 3\" }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_9","text":"class D: public B { public: int f(int i) override { std::cout << \"f(int): \"; return i + 1; } using B::f; // exposes f(double) };","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#note_153","text":"This issue affects both virtual and nonvirtual member functions For variadic bases, C++17 introduced a variadic form of the using-declaration, template <class... Ts> struct Overloader : Ts... { using Ts::operator()...; // exposes operator() from every base };","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_132","text":"Diagnose name hiding","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c139-use-final-sparingly","text":"","title":"C.139: Use final sparingly"},{"location":"cppcg/CppCoreGuidelines/#reason_141","text":"Capping a hierarchy with final is rarely needed for logical reasons and can be damaging to the extensibility of a hierarchy.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_56","text":"class Widget { /* ... */ }; // nobody will ever want to improve My_widget (or so you thought) class My_widget final : public Widget { /* ... */ }; class My_improved_widget : public My_widget { /* ... */ }; // error: can't do that","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_154","text":"Not every class is meant to be a base class. Most standard-library classes are examples of that (e.g., std::vector and std::string are not designed to be derived from). This rule is about using final on classes with virtual functions meant to be interfaces for a class hierarchy.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_155","text":"Capping an individual virtual function with final is error-prone as final can easily be overlooked when defining/overriding a set of functions. Fortunately, the compiler catches such mistakes: You cannot re-declare/re-open a final member in a derived class.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_156","text":"Claims of performance improvements from final should be substantiated. Too often, such claims are based on conjecture or experience with other languages. There are examples where final can be important for both logical and performance reasons. One example is a performance-critical AST hierarchy in a compiler or language analysis tool. New derived classes are not added every year and only by library implementers. However, misuses are (or at least have been) far more common.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_133","text":"Flag uses of final .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c140-do-not-provide-different-default-arguments-for-a-virtual-function-and-an-overrider","text":"","title":"C.140: Do not provide different default arguments for a virtual function and an overrider"},{"location":"cppcg/CppCoreGuidelines/#reason_142","text":"That can cause confusion: An overrider does not inherit default arguments.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_57","text":"class Base { public: virtual int multiply(int value, int factor = 2) = 0; virtual ~Base() = default; }; class Derived : public Base { public: int multiply(int value, int factor = 10) override; }; Derived d; Base& b = d; b.multiply(10); // these two calls will call the same function but d.multiply(10); // with different arguments and so different results","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_134","text":"Flag default arguments on virtual functions if they differ between base and derived declarations.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#chier-access-accessing-objects-in-a-hierarchy","text":"","title":"C.hier-access: Accessing objects in a hierarchy"},{"location":"cppcg/CppCoreGuidelines/#c145-access-polymorphic-objects-through-pointers-and-references","text":"","title":"C.145: Access polymorphic objects through pointers and references"},{"location":"cppcg/CppCoreGuidelines/#reason_143","text":"If you have a class with a virtual function, you don\u2019t (in general) know which class provided the function to be used.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_124","text":"struct B { int a; virtual int f(); virtual ~B() = default }; struct D : B { int b; int f() override; }; void use(B b) { D d; B b2 = d; // slice B b3 = b; } void use2() { D d; use(d); // slice } Both d s are sliced.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_24","text":"You can safely access a named polymorphic object in the scope of its definition, just don\u2019t slice it. void use3() { D d; d.f(); // OK }","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#see-also_1","text":"A polymorphic class should suppress copying","title":"See also"},{"location":"cppcg/CppCoreGuidelines/#enforcement_135","text":"Flag all slicing.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c146-use-dynamic_cast-where-class-hierarchy-navigation-is-unavoidable","text":"","title":"C.146: Use dynamic_cast where class hierarchy navigation is unavoidable"},{"location":"cppcg/CppCoreGuidelines/#reason_144","text":"dynamic_cast is checked at run time.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_125","text":"struct B { // an interface virtual void f(); virtual void g(); virtual ~B(); }; struct D : B { // a wider interface void f() override; virtual void h(); }; void user(B* pb) { if (D* pd = dynamic_cast<D*>(pb)) { // ... use D's interface ... } else { // ... make do with B's interface ... } } Use of the other casts can violate type safety and cause the program to access a variable that is actually of type X to be accessed as if it were of an unrelated type Z : void user2(B* pb) // bad { D* pd = static_cast<D*>(pb); // I know that pb really points to a D; trust me // ... use D's interface ... } void user3(B* pb) // unsafe { if (some_condition) { D* pd = static_cast<D*>(pb); // I know that pb really points to a D; trust me // ... use D's interface ... } else { // ... make do with B's interface ... } } void f() { B b; user(&b); // OK user2(&b); // bad error user3(&b); // OK *if* the programmer got the some_condition check right }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_157","text":"Like other casts, dynamic_cast is overused. Prefer virtual functions to casting . Prefer static polymorphism to hierarchy navigation where it is possible (no run-time resolution necessary) and reasonably convenient.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_158","text":"Some people use dynamic_cast where a typeid would have been more appropriate; dynamic_cast is a general \u201cis kind of\u201d operation for discovering the best interface to an object, whereas typeid is a \u201cgive me the exact type of this object\u201d operation to discover the actual type of an object. The latter is an inherently simpler operation that ought to be faster. The latter ( typeid ) is easily hand-crafted if necessary (e.g., if working on a system where RTTI is \u2013 for some reason \u2013 prohibited), the former ( dynamic_cast ) is far harder to implement correctly in general. Consider: struct B { const char* name {\"B\"}; // if pb1->id() == pb2->id() *pb1 is the same type as *pb2 virtual const char* id() const { return name; } // ... }; struct D : B { const char* name {\"D\"}; const char* id() const override { return name; } // ... }; void use() { B* pb1 = new B; B* pb2 = new D; cout << pb1->id(); // \"B\" cout << pb2->id(); // \"D\" if (pb1->id() == \"D\") { // looks innocent D* pd = static_cast<D*>(pb1); // ... } // ... } The result of pb2->id() == \"D\" is actually implementation defined. We added it to warn of the dangers of home-brew RTTI. This code may work as expected for years, just to fail on a new machine, new compiler, or a new linker that does not unify character literals. If you implement your own RTTI, be careful.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exception_25","text":"If your implementation provided a really slow dynamic_cast , you may have to use a workaround. However, all workarounds that cannot be statically resolved involve explicit casting (typically static_cast ) and are error-prone. You will basically be crafting your own special-purpose dynamic_cast . So, first make sure that your dynamic_cast really is as slow as you think it is (there are a fair number of unsupported rumors about) and that your use of dynamic_cast is really performance critical. We are of the opinion that current implementations of dynamic_cast are unnecessarily slow. For example, under suitable conditions, it is possible to perform a dynamic_cast in fast constant time . However, compatibility makes changes difficult even if all agree that an effort to optimize is worthwhile. In very rare cases, if you have measured that the dynamic_cast overhead is material, you have other means to statically guarantee that a downcast will succeed (e.g., you are using CRTP carefully), and there is no virtual inheritance involved, consider tactically resorting static_cast with a prominent comment and disclaimer summarizing this paragraph and that human attention is needed under maintenance because the type system can\u2019t verify correctness. Even so, in our experience such \u201cI know what I\u2019m doing\u201d situations are still a known bug source.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#exception_26","text":"Consider: template<typename B> class Dx : B { // ... };","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_136","text":"Flag all uses of static_cast for downcasts, including C-style casts that perform a static_cast . This rule is part of the type-safety profile .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c147-use-dynamic_cast-to-a-reference-type-when-failure-to-find-the-required-class-is-considered-an-error","text":"","title":"C.147: Use dynamic_cast to a reference type when failure to find the required class is considered an error"},{"location":"cppcg/CppCoreGuidelines/#reason_145","text":"Casting to a reference expresses that you intend to end up with a valid object, so the cast must succeed. dynamic_cast will then throw if it does not succeed.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_126","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_137","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c148-use-dynamic_cast-to-a-pointer-type-when-failure-to-find-the-required-class-is-considered-a-valid-alternative","text":"","title":"C.148: Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative"},{"location":"cppcg/CppCoreGuidelines/#reason_146","text":"The dynamic_cast conversion allows to test whether a pointer is pointing at a polymorphic object that has a given class in its hierarchy. Since failure to find the class merely returns a null value, it can be tested during run time. This allows writing code that can choose alternative paths depending on the results. Contrast with C.147 , where failure is an error, and should not be used for conditional execution.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_127","text":"The example below describes the add function of a Shape_owner that takes ownership of constructed Shape objects. The objects are also sorted into views, according to their geometric attributes. In this example, Shape does not inherit from Geometric_attributes . Only its subclasses do. void add(Shape* const item) { // Ownership is always taken owned_shapes.emplace_back(item); // Check the Geometric_attributes and add the shape to none/one/some/all of the views if (auto even = dynamic_cast<Even_sided*>(item)) { view_of_evens.emplace_back(even); } if (auto trisym = dynamic_cast<Trilaterally_symmetrical*>(item)) { view_of_trisyms.emplace_back(trisym); } }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#notes_3","text":"A failure to find the required class will cause dynamic_cast to return a null value, and de-referencing a null-valued pointer will lead to undefined behavior. Therefore the result of the dynamic_cast should always be treated as if it may contain a null value, and tested.","title":"Notes"},{"location":"cppcg/CppCoreGuidelines/#enforcement_138","text":"(Complex) Unless there is a null test on the result of a dynamic_cast of a pointer type, warn upon dereference of the pointer.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c149-use-unique_ptr-or-shared_ptr-to-avoid-forgetting-to-delete-objects-created-using-new","text":"","title":"C.149: Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new"},{"location":"cppcg/CppCoreGuidelines/#reason_147","text":"Avoid resource leaks.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_128","text":"void use(int i) { auto p = new int {7}; // bad: initialize local pointers with new auto q = make_unique<int>(9); // ok: guarantee the release of the memory-allocated for 9 if (0 < i) return; // maybe return and leak delete p; // too late }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_139","text":"Flag initialization of a naked pointer with the result of a new Flag delete of local variable","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c150-use-make_unique-to-construct-objects-owned-by-unique_ptrs","text":"","title":"C.150: Use make_unique() to construct objects owned by unique_ptrs"},{"location":"cppcg/CppCoreGuidelines/#reason_148","text":"make_unique gives a more concise statement of the construction. It also ensures exception safety in complex expressions.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_129","text":"unique_ptr<Foo> p {new Foo{7}}; // OK: but repetitive auto q = make_unique<Foo>(7); // Better: no repetition of Foo // Not exception-safe: the compiler may interleave the computations of arguments as follows: // // 1. allocate memory for Foo, // 2. construct Foo, // 3. call bar, // 4. construct unique_ptr<Foo>. // // If bar throws, Foo will not be destroyed, and the memory-allocated for it will leak. f(unique_ptr<Foo>(new Foo()), bar()); // Exception-safe: calls to functions are never interleaved. f(make_unique<Foo>(), bar());","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_140","text":"Flag the repetitive usage of template specialization list <Foo> Flag variables declared to be unique_ptr<Foo>","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c151-use-make_shared-to-construct-objects-owned-by-shared_ptrs","text":"","title":"C.151: Use make_shared() to construct objects owned by shared_ptrs"},{"location":"cppcg/CppCoreGuidelines/#reason_149","text":"make_shared gives a more concise statement of the construction. It also gives an opportunity to eliminate a separate allocation for the reference counts, by placing the shared_ptr \u2018s use counts next to its object.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_130","text":"void test() { // OK: but repetitive; and separate allocations for the Bar and shared_ptr's use count shared_ptr<Bar> p {new Bar{7}}; auto q = make_shared<Bar>(7); // Better: no repetition of Bar; one object }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_141","text":"Flag the repetitive usage of template specialization list <Bar> Flag variables declared to be shared_ptr<Bar>","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c152-never-assign-a-pointer-to-an-array-of-derived-class-objects-to-a-pointer-to-its-base","text":"","title":"C.152: Never assign a pointer to an array of derived class objects to a pointer to its base"},{"location":"cppcg/CppCoreGuidelines/#reason_150","text":"Subscripting the resulting base pointer will lead to invalid object access and probably to memory corruption.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_131","text":"struct B { int x; }; struct D : B { int y; }; void use(B*); D a[] = {{1, 2}, {3, 4}, {5, 6}}; B* p = a; // bad: a decays to &a[0] which is converted to a B* p[1].x = 7; // overwrite D[0].y use(a); // bad: a decays to &a[0] which is converted to a B*","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_142","text":"Flag all combinations of array decay and base to derived conversions. Pass an array as a span rather than as a pointer, and don\u2019t let the array name suffer a derived-to-base conversion before getting into the span","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c153-prefer-virtual-function-to-casting","text":"","title":"C.153: Prefer virtual function to casting"},{"location":"cppcg/CppCoreGuidelines/#reason_151","text":"A virtual function call is safe, whereas casting is error-prone. A virtual function call reaches the most derived function, whereas a cast may reach an intermediate class and therefore give a wrong result (especially as a hierarchy is modified during maintenance).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_132","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_143","text":"See C.146 and ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cover-overloading-and-overloaded-operators","text":"You can overload ordinary functions, template functions, and operators. You cannot overload function objects. Overload rule summary: C.160: Define operators primarily to mimic conventional usage C.161: Use nonmember functions for symmetric operators C.162: Overload operations that are roughly equivalent C.163: Overload only for operations that are roughly equivalent C.164: Avoid implicit conversion operators C.165: Use using for customization points C.166: Overload unary & only as part of a system of smart pointers and references C.167: Use an operator for an operation with its conventional meaning C.168: Define overloaded operators in the namespace of their operands C.170: If you feel like overloading a lambda, use a generic lambda","title":"C.over: Overloading and overloaded operators"},{"location":"cppcg/CppCoreGuidelines/#c160-define-operators-primarily-to-mimic-conventional-usage","text":"","title":"C.160: Define operators primarily to mimic conventional usage"},{"location":"cppcg/CppCoreGuidelines/#reason_152","text":"Minimize surprises.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_133","text":"class X { public: // ... X& operator=(const X&); // member function defining assignment friend bool operator==(const X&, const X&); // == needs access to representation // after a = b we have a == b // ... }; Here, the conventional semantics is maintained: Copies compare equal .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_58","text":"X operator+(X a, X b) { return a.v - b.v; } // bad: makes + subtract","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_159","text":"Nonmember operators should be either friends or defined in the same namespace as their operands . Binary operators should treat their operands equivalently .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_144","text":"Possibly impossible.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c161-use-nonmember-functions-for-symmetric-operators","text":"","title":"C.161: Use nonmember functions for symmetric operators"},{"location":"cppcg/CppCoreGuidelines/#reason_153","text":"If you use member functions, you need two. Unless you use a nonmember function for (say) == , a == b and b == a will be subtly different.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_134","text":"bool operator==(Point a, Point b) { return a.x == b.x && a.y == b.y; }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_145","text":"Flag member operator functions.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c162-overload-operations-that-are-roughly-equivalent","text":"","title":"C.162: Overload operations that are roughly equivalent"},{"location":"cppcg/CppCoreGuidelines/#reason_154","text":"Having different names for logically equivalent operations on different argument types is confusing, leads to encoding type information in function names, and inhibits generic programming.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_135","text":"Consider: void print(int a); void print(int a, int base); void print(const string&); These three functions all print their arguments (appropriately). Conversely: void print_int(int a); void print_based(int a, int base); void print_string(const string&); These three functions all print their arguments (appropriately). Adding to the name just introduced verbosity and inhibits generic code.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_146","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c163-overload-only-for-operations-that-are-roughly-equivalent","text":"","title":"C.163: Overload only for operations that are roughly equivalent"},{"location":"cppcg/CppCoreGuidelines/#reason_155","text":"Having the same name for logically different functions is confusing and leads to errors when using generic programming.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_136","text":"Consider: void open_gate(Gate& g); // remove obstacle from garage exit lane void fopen(const char* name, const char* mode); // open file The two operations are fundamentally different (and unrelated) so it is good that their names differ. Conversely: void open(Gate& g); // remove obstacle from garage exit lane void open(const char* name, const char* mode =\"r\"); // open file The two operations are still fundamentally different (and unrelated) but the names have been reduced to their (common) minimum, opening opportunities for confusion. Fortunately, the type system will catch many such mistakes.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_160","text":"Be particularly careful about common and popular names, such as open , move , + , and == .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_147","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c164-avoid-implicit-conversion-operators","text":"","title":"C.164: Avoid implicit conversion operators"},{"location":"cppcg/CppCoreGuidelines/#reason_156","text":"Implicit conversions can be essential (e.g., double to int ) but often cause surprises (e.g., String to C-style string).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_161","text":"Prefer explicitly named conversions until a serious need is demonstrated. By \u201cserious need\u201d we mean a reason that is fundamental in the application domain (such as an integer to complex number conversion) and frequently needed. Do not introduce implicit conversions (through conversion operators or non- explicit constructors) just to gain a minor convenience.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_137","text":"struct S1 { string s; // ... operator char*() { return s.data(); } // BAD, likely to cause surprises }; struct S2 { string s; // ... explicit operator char*() { return s.data(); } }; void f(S1 s1, S2 s2) { char* x1 = s1; // OK, but can cause surprises in many contexts char* x2 = s2; // error (and that's usually a good thing) char* x3 = static_cast<char*>(s2); // we can be explicit (on your head be it) } The surprising and potentially damaging implicit conversion can occur in arbitrarily hard-to spot contexts, e.g., S1 ff(); char* g() { return ff(); } The string returned by ff() is destroyed before the returned pointer into it can be used.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_148","text":"Flag all conversion operators.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c165-use-using-for-customization-points","text":"","title":"C.165: Use using for customization points"},{"location":"cppcg/CppCoreGuidelines/#reason_157","text":"To find function objects and functions defined in a separate namespace to \u201ccustomize\u201d a common function.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_138","text":"Consider swap . It is a general (standard-library) function with a definition that will work for just about any type. However, it is desirable to define specific swap() s for specific types. For example, the general swap() will copy the elements of two vector s being swapped, whereas a good specific implementation will not copy elements at all. namespace N { My_type X { /* ... */ }; void swap(X&, X&); // optimized swap for N::X // ... } void f1(N::X& a, N::X& b) { std::swap(a, b); // probably not what we wanted: calls std::swap() } The std::swap() in f1() does exactly what we asked it to do: it calls the swap() in namespace std . Unfortunately, that\u2019s probably not what we wanted. How do we get N::X considered? void f2(N::X& a, N::X& b) { swap(a, b); // calls N::swap } But that may not be what we wanted for generic code. There, we typically want the specific function if it exists and the general function if not. This is done by including the general function in the lookup for the function: void f3(N::X& a, N::X& b) { using std::swap; // make std::swap available swap(a, b); // calls N::swap if it exists, otherwise std::swap }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_149","text":"Unlikely, except for known customization points, such as swap . The problem is that the unqualified and qualified lookups both have uses.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c166-overload-unary-only-as-part-of-a-system-of-smart-pointers-and-references","text":"","title":"C.166: Overload unary &amp; only as part of a system of smart pointers and references"},{"location":"cppcg/CppCoreGuidelines/#reason_158","text":"The & operator is fundamental in C++. Many parts of the C++ semantics assumes its default meaning.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_139","text":"class Ptr { // a somewhat smart pointer Ptr(X* pp) :p(pp) { /* check */ } X* operator->() { /* check */ return p; } X operator[](int i); X operator*(); private: T* p; }; class X { Ptr operator&() { return Ptr{this}; } // ... };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_162","text":"If you \u201cmess with\u201d operator & be sure that its definition has matching meanings for -> , [] , * , and . on the result type. Note that operator . currently cannot be overloaded so a perfect system is impossible. We hope to remedy that: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf . Note that std::addressof() always yields a built-in pointer.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_150","text":"Tricky. Warn if & is user-defined without also defining -> for the result type.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c167-use-an-operator-for-an-operation-with-its-conventional-meaning","text":"","title":"C.167: Use an operator for an operation with its conventional meaning"},{"location":"cppcg/CppCoreGuidelines/#reason_159","text":"Readability. Convention. Reusability. Support for generic code","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_140","text":"void cout_my_class(const My_class& c) // confusing, not conventional,not generic { std::cout << /* class members here */; } std::ostream& operator<<(std::ostream& os, const my_class& c) // OK { return os << /* class members here */; } By itself, cout_my_class would be OK, but it is not usable/composable with code that rely on the << convention for output: My_class var { /* ... */ }; // ... cout << \"var = \" << var << '\\n';","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_163","text":"There are strong and vigorous conventions for the meaning most operators, such as comparisons ( == , != , < , <= , > , and >= ), arithmetic operations ( + , - , * , / , and % ) access operations ( . , -> , unary * , and [] ) assignment ( = ) Don\u2019t define those unconventionally and don\u2019t invent your own names for them.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_151","text":"Tricky. Requires semantic insight.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c168-define-overloaded-operators-in-the-namespace-of-their-operands","text":"","title":"C.168: Define overloaded operators in the namespace of their operands"},{"location":"cppcg/CppCoreGuidelines/#reason_160","text":"Readability. Ability for find operators using ADL. Avoiding inconsistent definition in different namespaces","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_141","text":"struct S { }; bool operator==(S, S); // OK: in the same namespace as S, and even next to S S s; bool x = (s == s); This is what a default == would do, if we had such defaults.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_142","text":"namespace N { struct S { }; bool operator==(S, S); // OK: in the same namespace as S, and even next to S } N::S s; bool x = (s == s); // finds N::operator==() by ADL","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_59","text":"struct S { }; S s; namespace N { S::operator!(S a) { return true; } S not_s = !s; } namespace M { S::operator!(S a) { return false; } S not_s = !s; } Here, the meaning of !s differs in N and M . This can be most confusing. Remove the definition of namespace M and the confusion is replaced by an opportunity to make the mistake.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_164","text":"If a binary operator is defined for two types that are defined in different namespaces, you cannot follow this rule. For example: Vec::Vector operator*(const Vec::Vector&, const Mat::Matrix&); This may be something best avoided.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#see-also_2","text":"This is a special case of the rule that helper functions should be defined in the same namespace as their class .","title":"See also"},{"location":"cppcg/CppCoreGuidelines/#enforcement_152","text":"Flag operator definitions that are not it the namespace of their operands","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c170-if-you-feel-like-overloading-a-lambda-use-a-generic-lambda","text":"","title":"C.170: If you feel like overloading a lambda, use a generic lambda"},{"location":"cppcg/CppCoreGuidelines/#reason_161","text":"You cannot overload by defining two different lambdas with the same name.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_143","text":"void f(int); void f(double); auto f = [](char); // error: cannot overload variable and function auto g = [](int) { /* ... */ }; auto g = [](double) { /* ... */ }; // error: cannot overload variables auto h = [](auto) { /* ... */ }; // OK","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_153","text":"The compiler catches the attempt to overload a lambda.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cunion-unions","text":"A union is a struct where all members start at the same address so that it can hold only one member at a time. A union does not keep track of which member is stored so the programmer has to get it right; this is inherently error-prone, but there are ways to compensate. A type that is a union plus an indicator of which member is currently held is called a tagged union , a discriminated union , or a variant . Union rule summary: C.180: Use union s to save Memory C.181: Avoid \u201cnaked\u201d union s C.182: Use anonymous union s to implement tagged unions C.183: Don\u2019t use a union for type punning ???","title":"C.union: Unions"},{"location":"cppcg/CppCoreGuidelines/#c180-use-unions-to-save-memory","text":"","title":"C.180: Use unions to save memory"},{"location":"cppcg/CppCoreGuidelines/#reason_162","text":"A union allows a single piece of memory to be used for different types of objects at different times. Consequently, it can be used to save memory when we have several objects that are never used at the same time.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_144","text":"union Value { int x; double d; }; Value v = { 123 }; // now v holds an int cout << v.x << '\\n'; // write 123 v.d = 987.654; // now v holds a double cout << v.d << '\\n'; // write 987.654 But heed the warning: Avoid \u201cnaked\u201d union s","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_145","text":"// Short-string optimization constexpr size_t buffer_size = 16; // Slightly larger than the size of a pointer class Immutable_string { public: Immutable_string(const char* str) : size(strlen(str)) { if (size < buffer_size) strcpy_s(string_buffer, buffer_size, str); else { string_ptr = new char[size + 1]; strcpy_s(string_ptr, size + 1, str); } } ~Immutable_string() { if (size >= buffer_size) delete string_ptr; } const char* get_str() const { return (size < buffer_size) ? string_buffer : string_ptr; } private: // If the string is short enough, we store the string itself // instead of a pointer to the string. union { char* string_ptr; char string_buffer[buffer_size]; }; const size_t size; };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_154","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c181-avoid-naked-unions","text":"","title":"C.181: Avoid \"naked\" unions"},{"location":"cppcg/CppCoreGuidelines/#reason_163","text":"A naked union is a union without an associated indicator which member (if any) it holds, so that the programmer has to keep track. Naked unions are a source of type errors.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_60","text":"union Value { int x; double d; }; Value v; v.d = 987.654; // v holds a double So far, so good, but we can easily misuse the union : cout << v.x << '\\n'; // BAD, undefined behavior: v holds a double, but we read it as an int Note that the type error happened without any explicit cast. When we tested that program the last value printed was 1683627180 which is the integer value for the bit pattern for 987.654 . What we have here is an \u201cinvisible\u201d type error that happens to give a result that could easily look innocent. And, talking about \u201cinvisible\u201d, this code produced no output: v.x = 123; cout << v.d << '\\n'; // BAD: undefined behavior","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#alternative_6","text":"Wrap a union in a class together with a type field. The C++17 variant type (found in <variant> ) does that for you: variant<int, double> v; v = 123; // v holds an int int x = get<int>(v); v = 123.456; // v holds a double w = get<double>(v);","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#enforcement_155","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c182-use-anonymous-unions-to-implement-tagged-unions","text":"","title":"C.182: Use anonymous unions to implement tagged unions"},{"location":"cppcg/CppCoreGuidelines/#reason_164","text":"A well-designed tagged union is type safe. An anonymous union simplifies the definition of a class with a (tag, union) pair.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_146","text":"This example is mostly borrowed from TC++PL4 pp216-218. You can look there for an explanation. The code is somewhat elaborate. Handling a type with user-defined assignment and destructor is tricky. Saving programmers from having to write such code is one reason for including variant in the standard. class Value { // two alternative representations represented as a union private: enum class Tag { number, text }; Tag type; // discriminant union { // representation (note: anonymous union) int i; string s; // string has default constructor, copy operations, and destructor }; public: struct Bad_entry { }; // used for exceptions ~Value(); Value& operator=(const Value&); // necessary because of the string variant Value(const Value&); // ... int number() const; string text() const; void set_number(int n); void set_text(const string&); // ... }; int Value::number() const { if (type != Tag::number) throw Bad_entry{}; return i; } string Value::text() const { if (type != Tag::text) throw Bad_entry{}; return s; } void Value::set_number(int n) { if (type == Tag::text) { s.~string(); // explicitly destroy string type = Tag::number; } i = n; } void Value::set_text(const string& ss) { if (type == Tag::text) s = ss; else { new(&s) string{ss}; // placement new: explicitly construct string type = Tag::text; } } Value& Value::operator=(const Value& e) // necessary because of the string variant { if (type == Tag::text && e.type == Tag::text) { s = e.s; // usual string assignment return *this; } if (type == Tag::text) s.~string(); // explicit destroy switch (e.type) { case Tag::number: i = e.i; break; case Tag::text: new(&s) string(e.s); // placement new: explicit construct } type = e.type; return *this; } Value::~Value() { if (type == Tag::text) s.~string(); // explicit destroy }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_156","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c183-dont-use-a-union-for-type-punning","text":"","title":"C.183: Don't use a union for type punning"},{"location":"cppcg/CppCoreGuidelines/#reason_165","text":"It is undefined behavior to read a union member with a different type from the one with which it was written. Such punning is invisible, or at least harder to spot than using a named cast. Type punning using a union is a source of errors.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_61","text":"union Pun { int x; unsigned char c[sizeof(int)]; }; The idea of Pun is to be able to look at the character representation of an int . void bad(Pun& u) { u.x = 'x'; cout << u.c[0] << '\\n'; // undefined behavior } If you wanted to see the bytes of an int , use a (named) cast: void if_you_must_pun(int& x) { auto p = reinterpret_cast<unsigned char*>(&x); cout << p[0] << '\\n'; // OK; better // ... } Accessing the result of an reinterpret_cast to a different type from the objects declared type is defined behavior (even though reinterpret_cast is discouraged), but at least we can see that something tricky is going on.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_165","text":"Unfortunately, union s are commonly used for type punning. We don\u2019t consider \u201csometimes, it works as expected\u201d a strong argument. C++17 introduced a distinct type std::byte to facilitate operations on raw object representation. Use that type instead of unsigned char or char for these operations.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_157","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#enum-enumerations","text":"Enumerations are used to define sets of integer values and for defining types for such sets of values. There are two kind of enumerations, \u201cplain\u201d enum s and class enum s. Enumeration rule summary: Enum.1: Prefer enumerations over macros Enum.2: Use enumerations to represent sets of related named constants Enum.3: Prefer enum class es over \u201cplain\u201d enum s Enum.4: Define operations on enumerations for safe and simple use Enum.5: Don\u2019t use ALL_CAPS for enumerators Enum.6: Avoid unnamed enumerations Enum.7: Specify the underlying type of an enumeration only when necessary Enum.8: Specify enumerator values only when necessary","title":"Enum: Enumerations"},{"location":"cppcg/CppCoreGuidelines/#enum1-prefer-enumerations-over-macros","text":"","title":"Enum.1: Prefer enumerations over macros"},{"location":"cppcg/CppCoreGuidelines/#reason_166","text":"Macros do not obey scope and type rules. Also, macro names are removed during preprocessing and so usually don\u2019t appear in tools like debuggers.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_147","text":"First some bad old code: // webcolors.h (third party header) #define RED 0xFF0000 #define GREEN 0x00FF00 #define BLUE 0x0000FF // productinfo.h // The following define product subtypes based on color #define RED 0 #define PURPLE 1 #define BLUE 2 int webby = BLUE; // webby == 2; probably not what was desired Instead use an enum : enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF }; enum class Product_info { red = 0, purple = 1, blue = 2 }; int webby = blue; // error: be specific Web_color webby = Web_color::blue; We used an enum class to avoid name clashes.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_158","text":"Flag macros that define integer values.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#enum2-use-enumerations-to-represent-sets-of-related-named-constants","text":"","title":"Enum.2: Use enumerations to represent sets of related named constants"},{"location":"cppcg/CppCoreGuidelines/#reason_167","text":"An enumeration shows the enumerators to be related and can be a named type.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_148","text":"enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_166","text":"Switching on an enumeration is common and the compiler can warn against unusual patterns of case labels. For example: enum class Product_info { red = 0, purple = 1, blue = 2 }; void print(Product_info inf) { switch (inf) { case Product_info::red: cout << \"red\"; break; case Product_info::purple: cout << \"purple\"; break; } } Such off-by-one switch -statements are often the results of an added enumerator and insufficient testing.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_159","text":"Flag switch -statements where the case s cover most but not all enumerators of an enumeration. Flag switch -statements where the case s cover a few enumerators of an enumeration, but has no default .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#enum3-prefer-class-enums-over-plain-enums","text":"","title":"Enum.3: Prefer class enums over \"plain\" enums"},{"location":"cppcg/CppCoreGuidelines/#reason_168","text":"To minimize surprises: traditional enums convert to int too readily.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_149","text":"void Print_color(int color); enum Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF }; enum Product_info { Red = 0, Purple = 1, Blue = 2 }; Web_color webby = Web_color::blue; // Clearly at least one of these calls is buggy. Print_color(webby); Print_color(Product_info::Blue); Instead use an enum class : void Print_color(int color); enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF }; enum class Product_info { red = 0, purple = 1, blue = 2 }; Web_color webby = Web_color::blue; Print_color(webby); // Error: cannot convert Web_color to int. Print_color(Product_info::Red); // Error: cannot convert Product_info to int.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_160","text":"(Simple) Warn on any non-class enum definition.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#enum4-define-operations-on-enumerations-for-safe-and-simple-use","text":"","title":"Enum.4: Define operations on enumerations for safe and simple use"},{"location":"cppcg/CppCoreGuidelines/#reason_169","text":"Convenience of use and avoidance of errors.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_150","text":"enum Day { mon, tue, wed, thu, fri, sat, sun }; Day& operator++(Day& d) { return d = (d == Day::sun) ? Day::mon : static_cast<Day>(static_cast<int>(d)+1); } Day today = Day::sat; Day tomorrow = ++today; The use of a static_cast is not pretty, but Day& operator++(Day& d) { return d = (d == Day::sun) ? Day::mon : Day{++d}; // error } is an infinite recursion, and writing it without a cast, using a switch on all cases is long-winded.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_161","text":"Flag repeated expressions cast back into an enumeration.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#enum5-dont-use-all_caps-for-enumerators","text":"","title":"Enum.5: Don't use ALL_CAPS for enumerators"},{"location":"cppcg/CppCoreGuidelines/#reason_170","text":"Avoid clashes with macros.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_62","text":"// webcolors.h (third party header) #define RED 0xFF0000 #define GREEN 0x00FF00 #define BLUE 0x0000FF // productinfo.h // The following define product subtypes based on color enum class Product_info { RED, PURPLE, BLUE }; // syntax error","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_162","text":"Flag ALL_CAPS enumerators.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#enum6-avoid-unnamed-enumerations","text":"","title":"Enum.6: Avoid unnamed enumerations"},{"location":"cppcg/CppCoreGuidelines/#reason_171","text":"If you can\u2019t name an enumeration, the values are not related","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_63","text":"enum { red = 0xFF0000, scale = 4, is_signed = 1 }; Such code is not uncommon in code written before there were convenient alternative ways of specifying integer constants.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#alternative_7","text":"Use constexpr values instead. For example: constexpr int red = 0xFF0000; constexpr short scale = 4; constexpr bool is_signed = true;","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#enforcement_163","text":"Flag unnamed enumerations.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#enum7-specify-the-underlying-type-of-an-enumeration-only-when-necessary","text":"","title":"Enum.7: Specify the underlying type of an enumeration only when necessary"},{"location":"cppcg/CppCoreGuidelines/#reason_172","text":"The default is the easiest to read and write. int is the default integer type. int is compatible with C enum s.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_151","text":"enum class Direction : char { n, s, e, w, ne, nw, se, sw }; // underlying type saves space enum class Web_color : int32_t { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF }; // underlying type is redundant","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_167","text":"Specifying the underlying type is necessary in forward declarations of enumerations: enum Flags : char; void f(Flags); // .... enum flags : char { /* ... */ };","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_164","text":"????","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#enum8-specify-enumerator-values-only-when-necessary","text":"","title":"Enum.8: Specify enumerator values only when necessary"},{"location":"cppcg/CppCoreGuidelines/#reason_173","text":"It\u2019s the simplest. It avoids duplicate enumerator values. The default gives a consecutive set of values that is good for switch -statement implementations.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_152","text":"enum class Col1 { red, yellow, blue }; enum class Col2 { red = 1, yellow = 2, blue = 2 }; // typo enum class Month { jan = 1, feb, mar, apr, may, jun, jul, august, sep, oct, nov, dec }; // starting with 1 is conventional enum class Base_flag { dec = 1, oct = dec << 1, hex = dec << 2 }; // set of bits Specifying values is necessary to match conventional values (e.g., Month ) and where consecutive values are undesirable (e.g., to get separate bits as in Base_flag ).","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_165","text":"Flag duplicate enumerator values Flag explicitly specified all-consecutive enumerator values","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r-resource-management","text":"This section contains rules related to resources. A resource is anything that must be acquired and (explicitly or implicitly) released, such as memory, file handles, sockets, and locks. The reason it must be released is typically that it can be in short supply, so even delayed release may do harm. The fundamental aim is to ensure that we don\u2019t leak any resources and that we don\u2019t hold a resource longer than we need to. An entity that is responsible for releasing a resource is called an owner. There are a few cases where leaks can be acceptable or even optimal: If you are writing a program that simply produces an output based on an input and the amount of memory needed is proportional to the size of the input, the optimal strategy (for performance and ease of programming) is sometimes simply never to delete anything. If you have enough memory to handle your largest input, leak away, but be sure to give a good error message if you are wrong. Here, we ignore such cases. Resource management rule summary: R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization) R.2: In interfaces, use raw pointers to denote individual objects (only) R.3: A raw pointer (a T* ) is non-owning R.4: A raw reference (a T& ) is non-owning R.5: Prefer scoped objects, don\u2019t heap-allocate unnecessarily R.6: Avoid non- const global variables Allocation and deallocation rule summary: R.10: Avoid malloc() and free() R.11: Avoid calling new and delete explicitly R.12: Immediately give the result of an explicit resource allocation to a manager object R.13: Perform at most one explicit resource allocation in a single expression statement R.14: Avoid [] parameters, prefer span R.15: Always overload matched allocation/deallocation pairs Smart pointer rule summary: R.20: Use unique_ptr or shared_ptr to represent ownership R.21: Prefer unique_ptr over shared_ptr unless you need to share ownership R.22: Use make_shared() to make shared_ptr s R.23: Use make_unique() to make unique_ptr s R.24: Use std::weak_ptr to break cycles of shared_ptr s R.30: Take smart pointers as parameters only to explicitly express lifetime semantics R.31: If you have non- std smart pointers, follow the basic pattern from std R.32: Take a unique_ptr<widget> parameter to express that a function assumes ownership of a widget R.33: Take a unique_ptr<widget>& parameter to express that a function reseats the widget R.34: Take a shared_ptr<widget> parameter to express that a function is part owner R.35: Take a shared_ptr<widget>& parameter to express that a function might reseat the shared pointer R.36: Take a const shared_ptr<widget>& parameter to express that it might retain a reference count to the object ??? R.37: Do not pass a pointer or reference obtained from an aliased smart pointer","title":"R: Resource management"},{"location":"cppcg/CppCoreGuidelines/#r1-manage-resources-automatically-using-resource-handles-and-raii-resource-acquisition-is-initialization","text":"","title":"R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)"},{"location":"cppcg/CppCoreGuidelines/#reason_174","text":"To avoid leaks and the complexity of manual resource management. C++\u2019s language-enforced constructor/destructor symmetry mirrors the symmetry inherent in resource acquire/release function pairs such as fopen / fclose , lock / unlock , and new / delete . Whenever you deal with a resource that needs paired acquire/release function calls, encapsulate that resource in an object that enforces pairing for you \u2013 acquire the resource in its constructor, and release it in its destructor.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_64","text":"Consider: void send(X* x, cstring_span destination) { auto port = open_port(destination); my_mutex.lock(); // ... send(port, x); // ... my_mutex.unlock(); close_port(port); delete x; } In this code, you have to remember to unlock , close_port , and delete on all paths, and do each exactly once. Further, if any of the code marked ... throws an exception, then x is leaked and my_mutex remains locked.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_153","text":"Consider: void send(unique_ptr<X> x, cstring_span destination) // x owns the X { Port port{destination}; // port owns the PortHandle lock_guard<mutex> guard{my_mutex}; // guard owns the lock // ... send(port, x); // ... } // automatically unlocks my_mutex and deletes the pointer in x Now all resource cleanup is automatic, performed once on all paths whether or not there is an exception. As a bonus, the function now advertises that it takes over ownership of the pointer. What is Port ? A handy wrapper that encapsulates the resource: class Port { PortHandle port; public: Port(cstring_span destination) : port{open_port(destination)} { } ~Port() { close_port(port); } operator PortHandle() { return port; } // port handles can't usually be cloned, so disable copying and assignment if necessary Port(const Port&) = delete; Port& operator=(const Port&) = delete; };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_168","text":"Where a resource is \u201cill-behaved\u201d in that it isn\u2019t represented as a class with a destructor, wrap it in a class or use finally See also : RAII","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#r2-in-interfaces-use-raw-pointers-to-denote-individual-objects-only","text":"","title":"R.2: In interfaces, use raw pointers to denote individual objects (only)"},{"location":"cppcg/CppCoreGuidelines/#reason_175","text":"Arrays are best represented by a container type (e.g., vector (owning)) or a span (non-owning). Such containers and views hold sufficient information to do range checking.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_65","text":"void f(int* p, int n) // n is the number of elements in p[] { // ... p[2] = 7; // bad: subscript raw pointer // ... } The compiler does not read comments, and without reading other code you do not know whether p really points to n elements. Use a span instead.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_154","text":"void g(int* p, int fmt) // print *p using format #fmt { // ... uses *p and p[0] only ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_27","text":"C-style strings are passed as single pointers to a zero-terminated sequence of characters. Use zstring rather than char* to indicate that you rely on that convention.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#note_169","text":"Many current uses of pointers to a single element could be references. However, where nullptr is a possible value, a reference may not be a reasonable alternative.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_166","text":"Flag pointer arithmetic (including ++ ) on a pointer that is not part of a container, view, or iterator. This rule would generate a huge number of false positives if applied to an older code base. Flag array names passed as simple pointers","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r3-a-raw-pointer-a-t-is-non-owning","text":"","title":"R.3: A raw pointer (a T*) is non-owning"},{"location":"cppcg/CppCoreGuidelines/#reason_176","text":"There is nothing (in the C++ standard or in most code) to say otherwise and most raw pointers are non-owning. We want owning pointers identified so that we can reliably and efficiently delete the objects pointed to by owning pointers.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_155","text":"void f() { int* p1 = new int{7}; // bad: raw owning pointer auto p2 = make_unique<int>(7); // OK: the int is owned by a unique pointer // ... } The unique_ptr protects against leaks by guaranteeing the deletion of its object (even in the presence of exceptions). The T* does not.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_156","text":"template<typename T> class X { // ... public: T* p; // bad: it is unclear whether p is owning or not T* q; // bad: it is unclear whether q is owning or not }; We can fix that problem by making ownership explicit: template<typename T> class X2 { // ... public: owner<T*> p; // OK: p is owning T* q; // OK: q is not owning };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_28","text":"A major class of exception is legacy code, especially code that must remain compilable as C or interface with C and C-style C++ through ABIs. The fact that there are billions of lines of code that violate this rule against owning T* s cannot be ignored. We\u2019d love to see program transformation tools turning 20-year-old \u201clegacy\u201d code into shiny modern code, we encourage the development, deployment and use of such tools, we hope the guidelines will help the development of such tools, and we even contributed (and contribute) to the research and development in this area. However, it will take time: \u201clegacy code\u201d is generated faster than we can renovate old code, and so it will be for a few years. This code cannot all be rewritten (ever assuming good code transformation software), especially not soon. This problem cannot be solved (at scale) by transforming all owning pointers to unique_ptr s and shared_ptr s, partly because we need/use owning \u201craw pointers\u201d as well as simple pointers in the implementation of our fundamental resource handles. For example, common vector implementations have one owning pointer and two non-owning pointers. Many ABIs (and essentially all interfaces to C code) use T* s, some of them owning. Some interfaces cannot be simply annotated with owner because they need to remain compilable as C (although this would be a rare good use for a macro, that expands to owner in C++ mode only).","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#note_170","text":"owner<T*> has no default semantics beyond T* . It can be used without changing any code using it and without affecting ABIs. It is simply an indicator to programmers and analysis tools. For example, if an owner<T*> is a member of a class, that class better have a destructor that delete s it.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad_66","text":"Returning a (raw) pointer imposes a lifetime management uncertainty on the caller; that is, who deletes the pointed-to object? Gadget* make_gadget(int n) { auto p = new Gadget{n}; // ... return p; } void caller(int n) { auto p = make_gadget(n); // remember to delete p // ... delete p; } In addition to suffering from the problem from leak , this adds a spurious allocation and deallocation operation, and is needlessly verbose. If Gadget is cheap to move out of a function (i.e., is small or has an efficient move operation), just return it \u201cby value\u201d (see \u201cout\u201d return values ): Gadget make_gadget(int n) { Gadget g{n}; // ... return g; }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_171","text":"This rule applies to factory functions.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_172","text":"If pointer semantics are required (e.g., because the return type needs to refer to a base class of a class hierarchy (an interface)), return a \u201csmart pointer.\u201d","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_167","text":"(Simple) Warn on delete of a raw pointer that is not an owner<T> . (Moderate) Warn on failure to either reset or explicitly delete an owner<T> pointer on every code path. (Simple) Warn if the return value of new is assigned to a raw pointer. (Simple) Warn if a function returns an object that was allocated within the function but has a move constructor. Suggest considering returning it by value instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r4-a-raw-reference-a-t-is-non-owning","text":"","title":"R.4: A raw reference (a T&amp;) is non-owning"},{"location":"cppcg/CppCoreGuidelines/#reason_177","text":"There is nothing (in the C++ standard or in most code) to say otherwise and most raw references are non-owning. We want owners identified so that we can reliably and efficiently delete the objects pointed to by owning pointers.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_157","text":"void f() { int& r = *new int{7}; // bad: raw owning reference // ... delete &r; // bad: violated the rule against deleting raw pointers } See also : The raw pointer rule","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_168","text":"See the raw pointer rule","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r5-prefer-scoped-objects-dont-heap-allocate-unnecessarily","text":"","title":"R.5: Prefer scoped objects, don't heap-allocate unnecessarily"},{"location":"cppcg/CppCoreGuidelines/#reason_178","text":"A scoped object is a local object, a global object, or a member. This implies that there is no separate allocation and deallocation cost in excess of that already used for the containing scope or object. The members of a scoped object are themselves scoped and the scoped object\u2019s constructor and destructor manage the members\u2019 lifetimes.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_158","text":"The following example is inefficient (because it has unnecessary allocation and deallocation), vulnerable to exception throws and returns in the ... part (leading to leaks), and verbose: void f(int n) { auto p = new Gadget{n}; // ... delete p; } Instead, use a local variable: void f(int n) { Gadget g{n}; // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_169","text":"(Moderate) Warn if an object is allocated and then deallocated on all paths within a function. Suggest it should be a local auto stack object instead. (Simple) Warn if a local Unique_pointer or Shared_pointer is not moved, copied, reassigned or reset before its lifetime ends.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r6-avoid-non-const-global-variables","text":"","title":"R.6: Avoid non-const global variables"},{"location":"cppcg/CppCoreGuidelines/#reason_179","text":"Global variables can be accessed from everywhere so they can introduce surprising dependencies between apparently unrelated objects. They are a notable source of errors. Warning : The initialization of global objects is not totally ordered. If you use a global object initialize it with a constant. Note that it is possible to get undefined initialization order even for const objects.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#exception_29","text":"A global object is often better than a singleton.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#exception_30","text":"An immutable ( const ) global does not introduce the problems we try to avoid by banning global objects.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_170","text":"(??? NM: Obviously we can warn about non- const statics \u2026 do we want to?)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#ralloc-allocation-and-deallocation","text":"","title":"R.alloc: Allocation and deallocation"},{"location":"cppcg/CppCoreGuidelines/#r10-avoid-malloc-and-free","text":"","title":"R.10: Avoid malloc() and free()"},{"location":"cppcg/CppCoreGuidelines/#reason_180","text":"malloc() and free() do not support construction and destruction, and do not mix well with new and delete .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_159","text":"class Record { int id; string name; // ... }; void use() { // p1 may be nullptr // *p1 is not initialized; in particular, // that string isn't a string, but a string-sized bag of bits Record* p1 = static_cast<Record*>(malloc(sizeof(Record))); auto p2 = new Record; // unless an exception is thrown, *p2 is default initialized auto p3 = new(nothrow) Record; // p3 may be nullptr; if not, *p3 is default initialized // ... delete p1; // error: cannot delete object allocated by malloc() free(p2); // error: cannot free() object allocated by new } In some implementations that delete and that free() might work, or maybe they will cause run-time errors.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_31","text":"There are applications and sections of code where exceptions are not acceptable. Some of the best such examples are in life-critical hard-real-time code. Beware that many bans on exception use are based on superstition (bad) or by concerns for older code bases with unsystematic resource management (unfortunately, but sometimes necessary). In such cases, consider the nothrow versions of new .","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_171","text":"Flag explicit use of malloc and free .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r11-avoid-calling-new-and-delete-explicitly","text":"","title":"R.11: Avoid calling new and delete explicitly"},{"location":"cppcg/CppCoreGuidelines/#reason_181","text":"The pointer returned by new should belong to a resource handle (that can call delete ). If the pointer returned by new is assigned to a plain/naked pointer, the object can be leaked.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_173","text":"In a large program, a naked delete (that is a delete in application code, rather than part of code devoted to resource management) is a likely bug: if you have N delete s, how can you be certain that you don\u2019t need N+1 or N-1? The bug may be latent: it may emerge only during maintenance. If you have a naked new , you probably need a naked delete somewhere, so you probably have a bug.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_172","text":"(Simple) Warn on any explicit use of new and delete . Suggest using make_unique instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r12-immediately-give-the-result-of-an-explicit-resource-allocation-to-a-manager-object","text":"","title":"R.12: Immediately give the result of an explicit resource allocation to a manager object"},{"location":"cppcg/CppCoreGuidelines/#reason_182","text":"If you don\u2019t, an exception or a return may lead to a leak.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_67","text":"void f(const string& name) { FILE* f = fopen(name, \"r\"); // open the file vector<char> buf(1024); auto _ = finally([f] { fclose(f); }); // remember to close the file // ... } The allocation of buf may fail and leak the file handle.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_160","text":"void f(const string& name) { ifstream f{name}; // open the file vector<char> buf(1024); // ... } The use of the file handle (in ifstream ) is simple, efficient, and safe.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_173","text":"Flag explicit allocations used to initialize pointers (problem: how many direct resource allocations can we recognize?)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r13-perform-at-most-one-explicit-resource-allocation-in-a-single-expression-statement","text":"","title":"R.13: Perform at most one explicit resource allocation in a single expression statement"},{"location":"cppcg/CppCoreGuidelines/#reason_183","text":"If you perform two explicit resource allocations in one statement, you could leak resources because the order of evaluation of many subexpressions, including function arguments, is unspecified.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_161","text":"void fun(shared_ptr<Widget> sp1, shared_ptr<Widget> sp2); This fun can be called like this: // BAD: potential leak fun(shared_ptr<Widget>(new Widget(a, b)), shared_ptr<Widget>(new Widget(c, d))); This is exception-unsafe because the compiler may reorder the two expressions building the function\u2019s two arguments. In particular, the compiler can interleave execution of the two expressions: Memory allocation (by calling operator new ) could be done first for both objects, followed by attempts to call the two Widget constructors. If one of the constructor calls throws an exception, then the other object\u2019s memory will never be released! This subtle problem has a simple solution: Never perform more than one explicit resource allocation in a single expression statement. For example: shared_ptr<Widget> sp1(new Widget(a, b)); // Better, but messy fun(sp1, new Widget(c, d)); The best solution is to avoid explicit allocation entirely use factory functions that return owning objects: fun(make_shared<Widget>(a, b), make_shared<Widget>(c, d)); // Best Write your own factory wrapper if there is not one already.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_174","text":"Flag expressions with multiple explicit resource allocations (problem: how many direct resource allocations can we recognize?)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r14-avoid-parameters-prefer-span","text":"","title":"R.14: Avoid [] parameters, prefer span"},{"location":"cppcg/CppCoreGuidelines/#reason_184","text":"An array decays to a pointer, thereby losing its size, opening the opportunity for range errors. Use span to preserve size information.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_162","text":"void f(int[]); // not recommended void f(int*); // not recommended for multiple objects // (a pointer should point to a single object, do not subscript) void f(gsl::span<int>); // good, recommended","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_175","text":"Flag [] parameters. Use span instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r15-always-overload-matched-allocationdeallocation-pairs","text":"","title":"R.15: Always overload matched allocation/deallocation pairs"},{"location":"cppcg/CppCoreGuidelines/#reason_185","text":"Otherwise you get mismatched operations and chaos.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_163","text":"class X { // ... void* operator new(size_t s); void operator delete(void*); // ... };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_174","text":"If you want memory that cannot be deallocated, =delete the deallocation operation. Don\u2019t leave it undeclared.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_176","text":"Flag incomplete pairs.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#rsmart-smart-pointers","text":"","title":"R.smart: Smart pointers"},{"location":"cppcg/CppCoreGuidelines/#r20-use-unique_ptr-or-shared_ptr-to-represent-ownership","text":"","title":"R.20: Use unique_ptr or shared_ptr to represent ownership"},{"location":"cppcg/CppCoreGuidelines/#reason_186","text":"They can prevent resource leaks.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_164","text":"Consider: void f() { X x; X* p1 { new X }; // see also ??? unique_ptr<T> p2 { new X }; // unique ownership; see also ??? shared_ptr<T> p3 { new X }; // shared ownership; see also ??? auto p4 = make_unique<X>(); // unique_ownership, preferable to the explicit use \"new\" auto p5 = make_shared<X>(); // shared ownership, preferable to the explicit use \"new\" } This will leak the object used to initialize p1 (only).","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_177","text":"(Simple) Warn if the return value of new or a function call with return value of pointer type is assigned to a raw pointer.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r21-prefer-unique_ptr-over-shared_ptr-unless-you-need-to-share-ownership","text":"","title":"R.21: Prefer unique_ptr over shared_ptr unless you need to share ownership"},{"location":"cppcg/CppCoreGuidelines/#reason_187","text":"A unique_ptr is conceptually simpler and more predictable (you know when destruction happens) and faster (you don\u2019t implicitly maintain a use count).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_68","text":"This needlessly adds and maintains a reference count. void f() { shared_ptr<Base> base = make_shared<Derived>(); // use base locally, without copying it -- refcount never exceeds 1 } // destroy base","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_165","text":"This is more efficient: void f() { unique_ptr<Base> base = make_unique<Derived>(); // use base locally } // destroy base","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_178","text":"(Simple) Warn if a function uses a Shared_pointer with an object allocated within the function, but never returns the Shared_pointer or passes it to a function requiring a Shared_pointer& . Suggest using unique_ptr instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r22-use-make_shared-to-make-shared_ptrs","text":"","title":"R.22: Use make_shared() to make shared_ptrs"},{"location":"cppcg/CppCoreGuidelines/#reason_188","text":"If you first make an object and then give it to a shared_ptr constructor, you (most likely) do one more allocation (and later deallocation) than if you use make_shared() because the reference counts must be allocated separately from the object.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_166","text":"Consider: shared_ptr<X> p1 { new X{2} }; // bad auto p = make_shared<X>(2); // good The make_shared() version mentions X only once, so it is usually shorter (as well as faster) than the version with the explicit new .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_179","text":"(Simple) Warn if a shared_ptr is constructed from the result of new rather than make_shared .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r23-use-make_unique-to-make-unique_ptrs","text":"","title":"R.23: Use make_unique() to make unique_ptrs"},{"location":"cppcg/CppCoreGuidelines/#reason_189","text":"For convenience and consistency with shared_ptr .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_175","text":"make_unique() is C++14, but widely available (as well as simple to write).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_180","text":"(Simple) Warn if a unique_ptr is constructed from the result of new rather than make_unique .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r24-use-stdweak_ptr-to-break-cycles-of-shared_ptrs","text":"","title":"R.24: Use std::weak_ptr to break cycles of shared_ptrs"},{"location":"cppcg/CppCoreGuidelines/#reason_190","text":"shared_ptr \u2018s rely on use counting and the use count for a cyclic structure never goes to zero, so we need a mechanism to be able to destroy a cyclic structure.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_167","text":"#include <memory> class bar; class foo { public: explicit foo(const std::shared_ptr<bar>& forward_reference) : forward_reference_(forward_reference) { } private: std::shared_ptr<bar> forward_reference_; }; class bar { public: explicit bar(const std::weak_ptr<foo>& back_reference) : back_reference_(back_reference) { } void do_something() { if (auto shared_back_reference = back_reference_.lock()) { // Use *shared_back_reference } } private: std::weak_ptr<foo> back_reference_; };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_176","text":"??? (HS: A lot of people say \u201cto break cycles\u201d, while I think \u201ctemporary shared ownership\u201d is more to the point.) ???(BS: breaking cycles is what you must do; temporarily sharing ownership is how you do it. You could \u201ctemporarily share ownership\u201d simply by using another shared_ptr .)","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_181","text":"??? probably impossible. If we could statically detect cycles, we wouldn\u2019t need weak_ptr","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r30-take-smart-pointers-as-parameters-only-to-explicitly-express-lifetime-semantics","text":"","title":"R.30: Take smart pointers as parameters only to explicitly express lifetime semantics"},{"location":"cppcg/CppCoreGuidelines/#reason_191","text":"Accepting a smart pointer to a widget is wrong if the function just needs the widget itself. It should be able to accept any widget object, not just ones whose lifetimes are managed by a particular kind of smart pointer. A function that does not manipulate lifetime should take raw pointers or references instead.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_69","text":"// callee void f(shared_ptr<widget>& w) { // ... use(*w); // only use of w -- the lifetime is not used at all // ... }; // caller shared_ptr<widget> my_widget = /* ... */; f(my_widget); widget stack_widget; f(stack_widget); // error","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_10","text":"// callee void f(widget& w) { // ... use(w); // ... }; // caller shared_ptr<widget> my_widget = /* ... */; f(*my_widget); widget stack_widget; f(stack_widget); // ok -- now this works","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#enforcement_182","text":"(Simple) Warn if a function takes a parameter of a smart pointer type (that overloads operator-> or operator* ) that is copyable but the function only calls any of: operator* , operator-> or get() . Suggest using a T* or T& instead. Flag a parameter of a smart pointer type (a type that overloads operator-> or operator* ) that is copyable/movable but never copied/moved from in the function body, and that is never modified, and that is not passed along to another function that could do so. That means the ownership semantics are not used. Suggest using a T* or T& instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r31-if-you-have-non-std-smart-pointers-follow-the-basic-pattern-from-std","text":"","title":"R.31: If you have non-std smart pointers, follow the basic pattern from std"},{"location":"cppcg/CppCoreGuidelines/#reason_192","text":"The rules in the following section also work for other kinds of third-party and custom smart pointers and are very useful for diagnosing common smart pointer errors that cause performance and correctness problems. You want the rules to work on all the smart pointers you use. Any type (including primary template or specialization) that overloads unary * and -> is considered a smart pointer: If it is copyable, it is recognized as a reference-counted shared_ptr . If it is not copyable, it is recognized as a unique unique_ptr .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_168","text":"// use Boost's intrusive_ptr #include <boost/intrusive_ptr.hpp> void f(boost::intrusive_ptr<widget> p) // error under rule 'sharedptrparam' { p->foo(); } // use Microsoft's CComPtr #include <atlbase.h> void f(CComPtr<widget> p) // error under rule 'sharedptrparam' { p->foo(); } Both cases are an error under the sharedptrparam guideline : p is a Shared_pointer , but nothing about its sharedness is used here and passing it by value is a silent pessimization; these functions should accept a smart pointer only if they need to participate in the widget\u2019s lifetime management. Otherwise they should accept a widget* , if it can be nullptr . Otherwise, and ideally, the function should accept a widget& . These smart pointers match the Shared_pointer concept, so these guideline enforcement rules work on them out of the box and expose this common pessimization.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#r32-take-a-unique_ptrwidget-parameter-to-express-that-a-function-assumes-ownership-of-a-widget","text":"","title":"R.32: Take a unique_ptr&lt;widget&gt; parameter to express that a function assumes ownership of a widget"},{"location":"cppcg/CppCoreGuidelines/#reason_193","text":"Using unique_ptr in this way both documents and enforces the function call\u2019s ownership transfer.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_169","text":"void sink(unique_ptr<widget>); // takes ownership of the widget void uses(widget*); // just uses the widget","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_70","text":"void thinko(const unique_ptr<widget>&); // usually not what you want","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_183","text":"(Simple) Warn if a function takes a Unique_pointer<T> parameter by lvalue reference and does not either assign to it or call reset() on it on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Unique_pointer<T> parameter by reference to const . Suggest taking a const T* or const T& instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r33-take-a-unique_ptrwidget-parameter-to-express-that-a-function-reseats-thewidget","text":"","title":"R.33: Take a unique_ptr&lt;widget&gt;&amp; parameter to express that a function reseats thewidget"},{"location":"cppcg/CppCoreGuidelines/#reason_194","text":"Using unique_ptr in this way both documents and enforces the function call\u2019s reseating semantics.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_177","text":"\u201creseat\u201d means \u201cmaking a pointer or a smart pointer refer to a different object.\u201d","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_170","text":"void reseat(unique_ptr<widget>&); // \"will\" or \"might\" reseat pointer","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_71","text":"void thinko(const unique_ptr<widget>&); // usually not what you want","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_184","text":"(Simple) Warn if a function takes a Unique_pointer<T> parameter by lvalue reference and does not either assign to it or call reset() on it on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Unique_pointer<T> parameter by reference to const . Suggest taking a const T* or const T& instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r34-take-a-shared_ptrwidget-parameter-to-express-that-a-function-is-part-owner","text":"","title":"R.34: Take a shared_ptr&lt;widget&gt; parameter to express that a function is part owner"},{"location":"cppcg/CppCoreGuidelines/#reason_195","text":"This makes the function\u2019s ownership sharing explicit.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-good_11","text":"void share(shared_ptr<widget>); // share -- \"will\" retain refcount void may_share(const shared_ptr<widget>&); // \"might\" retain refcount void reseat(shared_ptr<widget>&); // \"might\" reseat ptr","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#enforcement_185","text":"(Simple) Warn if a function takes a Shared_pointer<T> parameter by lvalue reference and does not either assign to it or call reset() on it on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Shared_pointer<T> by value or by reference to const and does not copy or move it to another Shared_pointer on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Shared_pointer<T> by rvalue reference. Suggesting taking it by value instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r35-take-a-shared_ptrwidget-parameter-to-express-that-a-function-might-reseat-the-shared-pointer","text":"","title":"R.35: Take a shared_ptr&lt;widget&gt;&amp; parameter to express that a function might reseat the shared pointer"},{"location":"cppcg/CppCoreGuidelines/#reason_196","text":"This makes the function\u2019s reseating explicit.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_178","text":"\u201creseat\u201d means \u201cmaking a reference or a smart pointer refer to a different object.\u201d","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-good_12","text":"void share(shared_ptr<widget>); // share -- \"will\" retain refcount void reseat(shared_ptr<widget>&); // \"might\" reseat ptr void may_share(const shared_ptr<widget>&); // \"might\" retain refcount","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#enforcement_186","text":"(Simple) Warn if a function takes a Shared_pointer<T> parameter by lvalue reference and does not either assign to it or call reset() on it on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Shared_pointer<T> by value or by reference to const and does not copy or move it to another Shared_pointer on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Shared_pointer<T> by rvalue reference. Suggesting taking it by value instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r36-take-a-const-shared_ptrwidget-parameter-to-express-that-it-might-retain-a-reference-count-to-the-object","text":"","title":"R.36: Take a const shared_ptr&lt;widget&gt;&amp; parameter to express that it might retain a reference count to the object ???"},{"location":"cppcg/CppCoreGuidelines/#reason_197","text":"This makes the function\u2019s ??? explicit.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-good_13","text":"void share(shared_ptr<widget>); // share -- \"will\" retain refcount void reseat(shared_ptr<widget>&); // \"might\" reseat ptr void may_share(const shared_ptr<widget>&); // \"might\" retain refcount","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#enforcement_187","text":"(Simple) Warn if a function takes a Shared_pointer<T> parameter by lvalue reference and does not either assign to it or call reset() on it on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Shared_pointer<T> by value or by reference to const and does not copy or move it to another Shared_pointer on at least one code path. Suggest taking a T* or T& instead. (Simple) ((Foundation)) Warn if a function takes a Shared_pointer<T> by rvalue reference. Suggesting taking it by value instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#r37-do-not-pass-a-pointer-or-reference-obtained-from-an-aliased-smart-pointer","text":"","title":"R.37: Do not pass a pointer or reference obtained from an aliased smart pointer"},{"location":"cppcg/CppCoreGuidelines/#reason_198","text":"Violating this rule is the number one cause of losing reference counts and finding yourself with a dangling pointer. Functions should prefer to pass raw pointers and references down call chains. At the top of the call tree where you obtain the raw pointer or reference from a smart pointer that keeps the object alive. You need to be sure that the smart pointer cannot inadvertently be reset or reassigned from within the call tree below.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_179","text":"To do this, sometimes you need to take a local copy of a smart pointer, which firmly keeps the object alive for the duration of the function and the call tree.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_171","text":"Consider this code: // global (static or heap), or aliased local ... shared_ptr<widget> g_p = ...; void f(widget& w) { g(); use(w); // A } void g() { g_p = ...; // oops, if this was the last shared_ptr to that widget, destroys the widget } The following should not pass code review: void my_code() { // BAD: passing pointer or reference obtained from a nonlocal smart pointer // that could be inadvertently reset somewhere inside f or it callees f(*g_p); // BAD: same reason, just passing it as a \"this\" pointer g_p->func(); } The fix is simple \u2013 take a local copy of the pointer to \u201ckeep a ref count\u201d for your call tree: void my_code() { // cheap: 1 increment covers this entire function and all the call trees below us auto pin = g_p; // GOOD: passing pointer or reference obtained from a local unaliased smart pointer f(*pin); // GOOD: same reason pin->func(); }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_188","text":"(Simple) Warn if a pointer or reference obtained from a smart pointer variable ( Unique_pointer or Shared_pointer ) that is nonlocal, or that is local but potentially aliased, is used in a function call. If the smart pointer is a Shared_pointer then suggest taking a local copy of the smart pointer and obtain a pointer or reference from that instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es-expressions-and-statements","text":"Expressions and statements are the lowest and most direct way of expressing actions and computation. Declarations in local scopes are statements. For naming, commenting, and indentation rules, see NL: Naming and layout . General rules: ES.1: Prefer the standard library to other libraries and to \u201chandcrafted code\u201d ES.2: Prefer suitable abstractions to direct use of language features Declaration rules: ES.5: Keep scopes small ES.6: Declare names in for-statement initializers and conditions to limit scope ES.7: Keep common and local names short, and keep uncommon and nonlocal names longer ES.8: Avoid similar-looking names ES.9: Avoid ALL_CAPS names ES.10: Declare one name (only) per declaration ES.11: Use auto to avoid redundant repetition of type names ES.12: Do not reuse names in nested scopes ES.20: Always initialize an object ES.21: Don\u2019t introduce a variable (or constant) before you need to use it ES.22: Don\u2019t declare a variable until you have a value to initialize it with ES.23: Prefer the {} -initializer syntax ES.24: Use a unique_ptr<T> to hold pointers ES.25: Declare an object const or constexpr unless you want to modify its value later on ES.26: Don\u2019t use a variable for two unrelated purposes ES.27: Use std::array or stack_array for arrays on the stack ES.28: Use lambdas for complex initialization, especially of const variables ES.30: Don\u2019t use macros for program text manipulation ES.31: Don\u2019t use macros for constants or \u201cfunctions\u201d ES.32: Use ALL_CAPS for all macro names ES.33: If you must use macros, give them unique names ES.34: Don\u2019t define a (C-style) variadic function Expression rules: ES.40: Avoid complicated expressions ES.41: If in doubt about operator precedence, parenthesize ES.42: Keep use of pointers simple and straightforward ES.43: Avoid expressions with undefined order of evaluation ES.44: Don\u2019t depend on order of evaluation of function arguments ES.45: Avoid \u201cmagic constants\u201d; use symbolic constants ES.46: Avoid narrowing conversions ES.47: Use nullptr rather than 0 or NULL ES.48: Avoid casts ES.49: If you must use a cast, use a named cast ES.50: Don\u2019t cast away const ES.55: Avoid the need for range checking ES.56: Write std::move() only when you need to explicitly move an object to another scope ES.60: Avoid new and delete outside resource management functions ES.61: Delete arrays using delete[] and non-arrays using delete ES.62: Don\u2019t compare pointers into different arrays ES.63: Don\u2019t slice ES.64: Use the T{e} notation for construction ES.65: Don\u2019t dereference an invalid pointer Statement rules: ES.70: Prefer a switch -statement to an if -statement when there is a choice ES.71: Prefer a range- for -statement to a for -statement when there is a choice ES.72: Prefer a for -statement to a while -statement when there is an obvious loop variable ES.73: Prefer a while -statement to a for -statement when there is no obvious loop variable ES.74: Prefer to declare a loop variable in the initializer part of a for -statement ES.75: Avoid do -statements ES.76: Avoid goto ES.77: Minimize the use of break and continue in loops ES.78: Always end a non-empty case with a break ES.79: Use default to handle common cases (only) ES.84: Don\u2019t try to declare a local variable with no name ES.85: Make empty statements visible ES.86: Avoid modifying loop control variables inside the body of raw for-loops ES.87: Don\u2019t add redundant == or != to conditions Arithmetic rules: ES.100: Don\u2019t mix signed and unsigned arithmetic ES.101: Use unsigned types for bit manipulation ES.102: Use signed types for arithmetic ES.103: Don\u2019t overflow ES.104: Don\u2019t underflow ES.105: Don\u2019t divide by zero ES.106: Don\u2019t try to avoid negative values by using unsigned ES.107: Don\u2019t use unsigned for subscripts, prefer gsl::index","title":"ES: Expressions and statements"},{"location":"cppcg/CppCoreGuidelines/#es1-prefer-the-standard-library-to-other-libraries-and-to-handcrafted-code","text":"","title":"ES.1: Prefer the standard library to other libraries and to \"handcrafted code\""},{"location":"cppcg/CppCoreGuidelines/#reason_199","text":"Code using a library can be much easier to write than code working directly with language features, much shorter, tend to be of a higher level of abstraction, and the library code is presumably already tested. The ISO C++ Standard Library is among the most widely known and best tested libraries. It is available as part of all C++ implementations.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_172","text":"auto sum = accumulate(begin(a), end(a), 0.0); // good a range version of accumulate would be even better: auto sum = accumulate(v, 0.0); // better but don\u2019t hand-code a well-known algorithm: int max = v.size(); // bad: verbose, purpose unstated double sum = 0.0; for (int i = 0; i < max; ++i) sum = sum + v[i];","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_32","text":"Large parts of the standard library rely on dynamic allocation (free store). These parts, notably the containers but not the algorithms, are unsuitable for some hard-real-time and embedded applications. In such cases, consider providing/using similar facilities, e.g., a standard-library-style container implemented using a pool allocator.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_189","text":"Not easy. ??? Look for messy loops, nested loops, long functions, absence of function calls, lack of use of non-built-in types. Cyclomatic complexity?","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es2-prefer-suitable-abstractions-to-direct-use-of-language-features","text":"","title":"ES.2: Prefer suitable abstractions to direct use of language features"},{"location":"cppcg/CppCoreGuidelines/#reason_200","text":"A \u201csuitable abstraction\u201d (e.g., library or class) is closer to the application concepts than the bare language, leads to shorter and clearer code, and is likely to be better tested.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_173","text":"vector<string> read1(istream& is) // good { vector<string> res; for (string s; is >> s;) res.push_back(s); return res; } The more traditional and lower-level near-equivalent is longer, messier, harder to get right, and most likely slower: char** read2(istream& is, int maxelem, int maxstring, int* nread) // bad: verbose and incomplete { auto res = new char*[maxelem]; int elemcount = 0; while (is && elemcount < maxelem) { auto s = new char[maxstring]; is.read(s, maxstring); res[elemcount++] = s; } nread = &elemcount; return res; } Once the checking for overflow and error handling has been added that code gets quite messy, and there is the problem remembering to delete the returned pointer and the C-style strings that array contains.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_190","text":"Not easy. ??? Look for messy loops, nested loops, long functions, absence of function calls, lack of use of non-built-in types. Cyclomatic complexity?","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#esdcl-declarations","text":"A declaration is a statement. A declaration introduces a name into a scope and may cause the construction of a named object.","title":"ES.dcl: Declarations"},{"location":"cppcg/CppCoreGuidelines/#es5-keep-scopes-small","text":"","title":"ES.5: Keep scopes small"},{"location":"cppcg/CppCoreGuidelines/#reason_201","text":"Readability. Minimize resource retention. Avoid accidental misuse of value. Alternative formulation : Don\u2019t declare a name in an unnecessarily large scope.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_174","text":"void use() { int i; // bad: i is needlessly accessible after loop for (i = 0; i < 20; ++i) { /* ... */ } // no intended use of i here for (int i = 0; i < 20; ++i) { /* ... */ } // good: i is local to for-loop if (auto pc = dynamic_cast<Circle*>(ps)) { // good: pc is local to if-statement // ... deal with Circle ... } else { // ... handle error ... } }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_72","text":"void use(const string& name) { string fn = name + \".txt\"; ifstream is {fn}; Record r; is >> r; // ... 200 lines of code without intended use of fn or is ... } This function is by most measure too long anyway, but the point is that the resources used by fn and the file handle held by is are retained for much longer than needed and that unanticipated use of is and fn could happen later in the function. In this case, it might be a good idea to factor out the read: Record load_record(const string& name) { string fn = name + \".txt\"; ifstream is {fn}; Record r; is >> r; return r; } void use(const string& name) { Record r = load_record(name); // ... 200 lines of code ... }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_191","text":"Flag loop variable declared outside a loop and not used after the loop Flag when expensive resources, such as file handles and locks are not used for N-lines (for some suitable N)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es6-declare-names-in-for-statement-initializers-and-conditions-to-limit-scope","text":"","title":"ES.6: Declare names in for-statement initializers and conditions to limit scope"},{"location":"cppcg/CppCoreGuidelines/#reason_202","text":"Readability. Minimize resource retention.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_175","text":"void use() { for (string s; cin >> s;) v.push_back(s); for (int i = 0; i < 20; ++i) { // good: i is local to for-loop // ... } if (auto pc = dynamic_cast<Circle*>(ps)) { // good: pc is local to if-statement // ... deal with Circle ... } else { // ... handle error ... } }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_192","text":"Flag loop variables declared before the loop and not used after the loop (hard) Flag loop variables declared before the loop and used after the loop for an unrelated purpose.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#c17-and-c20-example","text":"Note: C++17 and C++20 also add if , switch , and range- for initializer statements. These require C++17 and C++20 support. map<int, string> mymap; if (auto result = mymap.insert(value); result.second) { // insert succeeded, and result is valid for this block use(result.first); // ok // ... } // result is destroyed here","title":"C++17 and C++20 example"},{"location":"cppcg/CppCoreGuidelines/#c17-and-c20-enforcement-if-using-a-c17-or-c20-compiler","text":"Flag selection/loop variables declared before the body and not used after the body (hard) Flag selection/loop variables declared before the body and used after the body for an unrelated purpose.","title":"C++17 and C++20 enforcement (if using a C++17 or C++20 compiler)"},{"location":"cppcg/CppCoreGuidelines/#es7-keep-common-and-local-names-short-and-keep-uncommon-and-nonlocal-names-longer","text":"","title":"ES.7: Keep common and local names short, and keep uncommon and nonlocal names longer"},{"location":"cppcg/CppCoreGuidelines/#reason_203","text":"Readability. Lowering the chance of clashes between unrelated non-local names.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_176","text":"Conventional short, local names increase readability: template<typename T> // good void print(ostream& os, const vector<T>& v) { for (gsl::index i = 0; i < v.size(); ++i) os << v[i] << '\\n'; } An index is conventionally called i and there is no hint about the meaning of the vector in this generic function, so v is as good name as any. Compare template<typename Element_type> // bad: verbose, hard to read void print(ostream& target_stream, const vector<Element_type>& current_vector) { for (gsl::index current_element_index = 0; current_element_index < current_vector.size(); ++current_element_index ) target_stream << current_vector[current_element_index] << '\\n'; } Yes, it is a caricature, but we have seen worse.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_177","text":"Unconventional and short non-local names obscure code: void use1(const string& s) { // ... tt(s); // bad: what is tt()? // ... } Better, give non-local entities readable names: void use1(const string& s) { // ... trim_tail(s); // better // ... } Here, there is a chance that the reader knows what trim_tail means and that the reader can remember it after looking it up.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_73","text":"Argument names of large functions are de facto non-local and should be meaningful: void complicated_algorithm(vector<Record>& vr, const vector<int>& vi, map<string, int>& out) // read from events in vr (marking used Records) for the indices in // vi placing (name, index) pairs into out { // ... 500 lines of code using vr, vi, and out ... } We recommend keeping functions short, but that rule isn\u2019t universally adhered to and naming should reflect that.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_193","text":"Check length of local and non-local names. Also take function length into account.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es8-avoid-similar-looking-names","text":"","title":"ES.8: Avoid similar-looking names"},{"location":"cppcg/CppCoreGuidelines/#reason_204","text":"Code clarity and readability. Too-similar names slow down comprehension and increase the likelihood of error.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_74","text":"if (readable(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) surprise();","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-bad_75","text":"Do not declare a non-type with the same name as a type in the same scope. This removes the need to disambiguate with a keyword such as struct or enum . It also removes a source of errors, as struct X can implicitly declare X if lookup fails. struct foo { int n; }; struct foo foo(); // BAD, foo is a type already in scope struct foo x = foo(); // requires disambiguation","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#exception_33","text":"Antique header files might declare non-types and types with the same name in the same scope.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_194","text":"Check names against a list of known confusing letter and digit combinations. Flag a declaration of a variable, function, or enumerator that hides a class or enumeration declared in the same scope.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es9-avoid-all_caps-names","text":"","title":"ES.9: Avoid ALL_CAPS names"},{"location":"cppcg/CppCoreGuidelines/#reason_205","text":"Such names are commonly used for macros. Thus, ALL_CAPS name are vulnerable to unintended macro substitution.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_178","text":"// somewhere in some header: #define NE != // somewhere else in some other header: enum Coord { N, NE, NW, S, SE, SW, E, W }; // somewhere third in some poor programmer's .cpp: switch (direction) { case N: // ... case NE: // ... // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_180","text":"Do not use ALL_CAPS for constants just because constants used to be macros.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_195","text":"Flag all uses of ALL CAPS. For older code, accept ALL CAPS for macro names and flag all non-ALL-CAPS macro names.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es10-declare-one-name-only-per-declaration","text":"","title":"ES.10: Declare one name (only) per declaration"},{"location":"cppcg/CppCoreGuidelines/#reason_206","text":"One declaration per line increases readability and avoids mistakes related to the C/C++ grammar. It also leaves room for a more descriptive end-of-line comment.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_76","text":"char *p, c, a[7], *pp[7], **aa[10]; // yuck!","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#exception_34","text":"A function declaration can contain several function argument declarations.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#exception_35","text":"A structured binding (C++17) is specifically designed to introduce several variables: auto [iter, inserted] = m.insert_or_assign(k, val); if (inserted) { /* new entry was inserted */ }","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#example_179","text":"template <class InputIterator, class Predicate> bool any_of(InputIterator first, InputIterator last, Predicate pred); or better using concepts: bool any_of(InputIterator first, InputIterator last, Predicate pred);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_180","text":"double scalbn(double x, int n); // OK: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2 or: double scalbn( // better: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2 double x, // base value int n // exponent ); or: // better: base * pow(FLT_RADIX, exponent); FLT_RADIX is usually 2 double scalbn(double base, int exponent);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_181","text":"int a = 7, b = 9, c, d = 10, e = 3; In a long list of declarators it is easy to overlook an uninitialized variable.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_196","text":"Flag variable and constant declarations with multiple declarators (e.g., int* p, q; )","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es11-use-auto-to-avoid-redundant-repetition-of-type-names","text":"","title":"ES.11: Use auto to avoid redundant repetition of type names"},{"location":"cppcg/CppCoreGuidelines/#reason_207","text":"Simple repetition is tedious and error-prone. When you use auto , the name of the declared entity is in a fixed position in the declaration, increasing readability. In a template function declaration the return type can be a member type.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_182","text":"Consider: auto p = v.begin(); // vector<int>::iterator auto h = t.future(); auto q = make_unique<int[]>(s); auto f = [](int x){ return x + 10; }; In each case, we save writing a longish, hard-to-remember type that the compiler already knows but a programmer could get wrong.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_183","text":"template<class T> auto Container<T>::first() -> Iterator; // Container<T>::Iterator","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_36","text":"Avoid auto for initializer lists and in cases where you know exactly which type you want and where an initializer might require conversion.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#example_184","text":"auto lst = { 1, 2, 3 }; // lst is an initializer list auto x{1}; // x is an int (in C++17; initializer_list in C++11)","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_181","text":"When concepts become available, we can (and should) be more specific about the type we are deducing: // ... ForwardIterator p = algo(x, y, z);","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-c17","text":"auto [ quotient, remainder ] = div(123456, 73); // break out the members of the div_t result","title":"Example (C++17)"},{"location":"cppcg/CppCoreGuidelines/#enforcement_197","text":"Flag redundant repetition of type names in a declaration.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es12-do-not-reuse-names-in-nested-scopes","text":"","title":"ES.12: Do not reuse names in nested scopes"},{"location":"cppcg/CppCoreGuidelines/#reason_208","text":"It is easy to get confused about which variable is used. Can cause maintenance problems.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_77","text":"int d = 0; // ... if (cond) { // ... d = 9; // ... } else { // ... int d = 7; // ... d = value_to_be_returned; // ... } return d; If this is a large if -statement, it is easy to overlook that a new d has been introduced in the inner scope. This is a known source of bugs. Sometimes such reuse of a name in an inner scope is called \u201cshadowing\u201d.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_182","text":"Shadowing is primarily a problem when functions are too large and too complex.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_185","text":"Shadowing of function arguments in the outermost block is disallowed by the language: void f(int x) { int x = 4; // error: reuse of function argument name if (x) { int x = 7; // allowed, but bad // ... } }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_78","text":"Reuse of a member name as a local variable can also be a problem: struct S { int m; void f(int x); }; void S::f(int x) { m = 7; // assign to member if (x) { int m = 9; // ... m = 99; // assign to local variable // ... } }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#exception_37","text":"We often reuse function names from a base class in a derived class: struct B { void f(int); }; struct D : B { void f(double); using B::f; }; This is error-prone. For example, had we forgotten the using declaration, a call d.f(1) would not have found the int version of f . ??? Do we need a specific rule about shadowing/hiding in class hierarchies?","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_198","text":"Flag reuse of a name in nested local scopes Flag reuse of a member name as a local variable in a member function Flag reuse of a global name as a local variable or a member name Flag reuse of a base class member name in a derived class (except for function names)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es20-always-initialize-an-object","text":"","title":"ES.20: Always initialize an object"},{"location":"cppcg/CppCoreGuidelines/#reason_209","text":"Avoid used-before-set errors and their associated undefined behavior. Avoid problems with comprehension of complex initialization. Simplify refactoring.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_186","text":"void use(int arg) { int i; // bad: uninitialized variable // ... i = 7; // initialize i } No, i = 7 does not initialize i ; it assigns to it. Also, i can be read in the ... part. Better: void use(int arg) // OK { int i = 7; // OK: initialized string s; // OK: default initialized // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_183","text":"The always initialize rule is deliberately stronger than the an object must be set before used language rule. The latter, more relaxed rule, catches the technical bugs, but: It leads to less readable code It encourages people to declare names in greater than necessary scopes It leads to harder to read code It leads to logic bugs by encouraging complex code It hampers refactoring The always initialize rule is a style rule aimed to improve maintainability as well as a rule protecting against used-before-set errors.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_187","text":"Here is an example that is often considered to demonstrate the need for a more relaxed rule for initialization widget i; // \"widget\" a type that's expensive to initialize, possibly a large POD widget j; if (cond) { // bad: i and j are initialized \"late\" i = f1(); j = f2(); } else { i = f3(); j = f4(); } This cannot trivially be rewritten to initialize i and j with initializers. Note that for types with a default constructor, attempting to postpone initialization simply leads to a default initialization followed by an assignment. A popular reason for such examples is \u201cefficiency\u201d, but a compiler that can detect whether we made a used-before-set error can also eliminate any redundant double initialization. Assuming that there is a logical connection between i and j , that connection should probably be expressed in code: pair<widget, widget> make_related_widgets(bool x) { return (x) ? {f1(), f2()} : {f3(), f4() }; } auto [i, j] = make_related_widgets(cond); // C++17","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_184","text":"Complex initialization has been popular with clever programmers for decades. It has also been a major source of errors and complexity. Many such errors are introduced during maintenance years after the initial implementation.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_188","text":"This rule covers member variables. class X { public: X(int i, int ci) : m2{i}, cm2{ci} {} // ... private: int m1 = 7; int m2; int m3; const int cm1 = 7; const int cm2; const int cm3; }; The compiler will flag the uninitialized cm3 because it is a const , but it will not catch the lack of initialization of m3 . Usually, a rare spurious member initialization is worth the absence of errors from lack of initialization and often an optimizer can eliminate a redundant initialization (e.g., an initialization that occurs immediately before an assignment).","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_38","text":"If you are declaring an object that is just about to be initialized from input, initializing it would cause a double initialization. However, beware that this may leave uninitialized data beyond the input \u2013 and that has been a fertile source of errors and security breaches: constexpr int max = 8 * 1024; int buf[max]; // OK, but suspicious: uninitialized f.read(buf, max); The cost of initializing that array could be significant in some situations. However, such examples do tend to leave uninitialized variables accessible, so they should be treated with suspicion. constexpr int max = 8 * 1024; int buf[max] = {}; // zero all elements; better in some situations f.read(buf, max); When feasible use a library function that is known not to overflow. For example: string s; // s is default initialized to \"\" cin >> s; // s expands to hold the string Don\u2019t consider simple variables that are targets for input operations exceptions to this rule: int i; // bad // ... cin >> i; In the not uncommon case where the input target and the input operation get separated (as they should not) the possibility of used-before-set opens up. int i2 = 0; // better, assuming that zero is an acceptable value for i2 // ... cin >> i2; A good optimizer should know about input operations and eliminate the redundant operation.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#example_189","text":"Using a value representing \u201cuninitialized\u201d is a symptom of a problem and not a solution: widget i = uninit; // bad widget j = uninit; // ... use(i); // possibly used before set // ... if (cond) { // bad: i and j are initialized \"late\" i = f1(); j = f2(); } else { i = f3(); j = f4(); } Now the compiler cannot even simply detect a used-before-set. Further, we\u2019ve introduced complexity in the state space for widget: which operations are valid on an uninit widget and which are not?","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_185","text":"Sometimes, a lambda can be used as an initializer to avoid an uninitialized variable: error_code ec; Value v = [&] { auto p = get_value(); // get_value() returns a pair<error_code, Value> ec = p.first; return p.second; }(); or maybe: Value v = [] { auto p = get_value(); // get_value() returns a pair<error_code, Value> if (p.first) throw Bad_value{p.first}; return p.second; }(); See also : ES.28","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_199","text":"Flag every uninitialized variable. Don\u2019t flag variables of user-defined types with default constructors. Check that an uninitialized buffer is written into immediately after declaration. Passing an uninitialized variable as a reference to non- const argument can be assumed to be a write into the variable.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es21-dont-introduce-a-variable-or-constant-before-you-need-to-use-it","text":"","title":"ES.21: Don't introduce a variable (or constant) before you need to use it"},{"location":"cppcg/CppCoreGuidelines/#reason_210","text":"Readability. To limit the scope in which the variable can be used.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_190","text":"int x = 7; // ... no use of x here ... ++x;","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_200","text":"Flag declarations that are distant from their first use.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es22-dont-declare-a-variable-until-you-have-a-value-to-initialize-it-with","text":"","title":"ES.22: Don't declare a variable until you have a value to initialize it with"},{"location":"cppcg/CppCoreGuidelines/#reason_211","text":"Readability. Limit the scope in which a variable can be used. Don\u2019t risk used-before-set. Initialization is often more efficient than assignment.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_79","text":"string s; // ... no use of s here ... s = \"what a waste\";","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-bad_80","text":"SomeLargeType var; // ugly CaMeLcAsEvArIaBlE if (cond) // some non-trivial condition Set(&var); else if (cond2 || !cond3) { var = Set2(3.14); } else { var = 0; for (auto& e : something) var += e; } // use var; that this isn't done too early can be enforced statically with only control flow This would be fine if there was a default initialization for SomeLargeType that wasn\u2019t too expensive. Otherwise, a programmer might very well wonder if every possible path through the maze of conditions has been covered. If not, we have a \u201cuse before set\u201d bug. This is a maintenance trap. For initializers of moderate complexity, including for const variables, consider using a lambda to express the initializer; see ES.28 .","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_201","text":"Flag declarations with default initialization that are assigned to before they are first read. Flag any complicated computation after an uninitialized variable and before its use.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es23-prefer-the-initializer-syntax","text":"","title":"ES.23: Prefer the {}-initializer syntax"},{"location":"cppcg/CppCoreGuidelines/#reason_212","text":"Prefer {} . The rules for {} initialization are simpler, more general, less ambiguous, and safer than for other forms of initialization. Use = only when you are sure that there can be no narrowing conversions. For built-in arithmetic types, use = only with auto . Avoid () initialization, which allows parsing ambiguities.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_191","text":"int x {f(99)}; int y = x; vector<int> v = {1, 2, 3, 4, 5, 6};","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_39","text":"For containers, there is a tradition for using {...} for a list of elements and (...) for sizes: vector<int> v1(10); // vector of 10 elements with the default value 0 vector<int> v2{10}; // vector of 1 element with the value 10 vector<int> v3(1, 2); // vector of 1 element with the value 2 vector<int> v4{1, 2}; // vector of 2 element with the values 1 and 2","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#note_186","text":"{} -initializers do not allow narrowing conversions (and that is usually a good thing) and allow explicit constructors (which is fine, we\u2019re intentionally initializing a new variable).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_192","text":"int x {7.9}; // error: narrowing int y = 7.9; // OK: y becomes 7. Hope for a compiler warning int z = gsl::narrow_cast<int>(7.9); // OK: you asked for it","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_187","text":"{} initialization can be used for nearly all initialization; other forms of initialization can\u2019t: auto p = new vector<int> {1, 2, 3, 4, 5}; // initialized vector D::D(int a, int b) :m{a, b} { // member initializer (e.g., m might be a pair) // ... }; X var {}; // initialize var to be empty struct S { int m {7}; // default initializer for a member // ... }; For that reason, {} -initialization is often called \u201cuniform initialization\u201d (though there unfortunately are a few irregularities left).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_188","text":"Initialization of a variable declared using auto with a single value, e.g., {v} , had surprising results until C++17. The C++17 rules are somewhat less surprising: auto x1 {7}; // x1 is an int with the value 7 auto x2 = {7}; // x2 is an initializer_list<int> with an element 7 auto x11 {7, 8}; // error: two initializers auto x22 = {7, 8}; // x22 is an initializer_list<int> with elements 7 and 8 Use ={...} if you really want an initializer_list<T> auto fib10 = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55}; // fib10 is a list","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_189","text":"={} gives copy initialization whereas {} gives direct initialization. Like the distinction between copy-initialization and direct-initialization itself, this can lead to surprises. {} accepts explicit constructors; ={} does not. For example: struct Z { explicit Z() {} }; Z z1{}; // OK: direct initialization, so we use explicit constructor Z z2 = {}; // error: copy initialization, so we cannot use the explicit constructor Use plain {} -initialization unless you specifically want to disable explicit constructors.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_193","text":"template<typename T> void f() { T x1(1); // T initialized with 1 T x0(); // bad: function declaration (often a mistake) T y1 {1}; // T initialized with 1 T y0 {}; // default initialized T // ... } See also : Discussion","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_202","text":"Flag uses of = to initialize arithmetic types where narrowing occurs. Flag uses of () initialization syntax that are actually declarations. (Many compilers should warn on this already.)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es24-use-a-unique_ptrt-to-hold-pointers","text":"","title":"ES.24: Use a unique_ptr&lt;T&gt; to hold pointers"},{"location":"cppcg/CppCoreGuidelines/#reason_213","text":"Using std::unique_ptr is the simplest way to avoid leaks. It is reliable, it makes the type system do much of the work to validate ownership safety, it increases readability, and it has zero or near zero run-time cost.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_194","text":"void use(bool leak) { auto p1 = make_unique<int>(7); // OK int* p2 = new int{7}; // bad: might leak // ... no assignment to p2 ... if (leak) return; // ... no assignment to p2 ... vector<int> v(7); v.at(7) = 0; // exception thrown // ... } If leak == true the object pointed to by p2 is leaked and the object pointed to by p1 is not. The same is the case when at() throws.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_203","text":"Look for raw pointers that are targets of new , malloc() , or functions that may return such pointers.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es25-declare-an-object-const-or-constexpr-unless-you-want-to-modify-its-value-later-on","text":"","title":"ES.25: Declare an object const or constexpr unless you want to modify its value later on"},{"location":"cppcg/CppCoreGuidelines/#reason_214","text":"That way you can\u2019t change the value by mistake. That way may offer the compiler optimization opportunities.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_195","text":"void f(int n) { const int bufmax = 2 * n + 2; // good: we can't change bufmax by accident int xmax = n; // suspicious: is xmax intended to change? // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_204","text":"Look to see if a variable is actually mutated, and flag it if not. Unfortunately, it may be impossible to detect when a non- const was not intended to vary (vs when it merely did not vary).","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es26-dont-use-a-variable-for-two-unrelated-purposes","text":"","title":"ES.26: Don't use a variable for two unrelated purposes"},{"location":"cppcg/CppCoreGuidelines/#reason_215","text":"Readability and safety.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_81","text":"void use() { int i; for (i = 0; i < 20; ++i) { /* ... */ } for (i = 0; i < 200; ++i) { /* ... */ } // bad: i recycled }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_190","text":"As an optimization, you may want to reuse a buffer as a scratch pad, but even then prefer to limit the variable\u2019s scope as much as possible and be careful not to cause bugs from data left in a recycled buffer as this is a common source of security bugs. void write_to_file() { std::string buffer; // to avoid reallocations on every loop iteration for (auto& o : objects) { // First part of the work. generate_first_string(buffer, o); write_to_file(buffer); // Second part of the work. generate_second_string(buffer, o); write_to_file(buffer); // etc... } }","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_205","text":"Flag recycled variables.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es27-use-stdarray-or-stack_array-for-arrays-on-the-stack","text":"","title":"ES.27: Use std::array or stack_array for arrays on the stack"},{"location":"cppcg/CppCoreGuidelines/#reason_216","text":"They are readable and don\u2019t implicitly convert to pointers. They are not confused with non-standard extensions of built-in arrays.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_82","text":"const int n = 7; int m = 9; void f() { int a1[n]; int a2[m]; // error: not ISO C++ // ... }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_191","text":"The definition of a1 is legal C++ and has always been. There is a lot of such code. It is error-prone, though, especially when the bound is non-local. Also, it is a \u201cpopular\u201d source of errors (buffer overflow, pointers from array decay, etc.). The definition of a2 is C but not C++ and is considered a security risk","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_196","text":"const int n = 7; int m = 9; void f() { array<int, n> a1; stack_array<int> a2(m); // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_206","text":"Flag arrays with non-constant bounds (C-style VLAs) Flag arrays with non-local constant bounds","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es28-use-lambdas-for-complex-initialization-especially-of-const-variables","text":"","title":"ES.28: Use lambdas for complex initialization, especially of const variables"},{"location":"cppcg/CppCoreGuidelines/#reason_217","text":"It nicely encapsulates local initialization, including cleaning up scratch variables needed only for the initialization, without needing to create a needless nonlocal yet nonreusable function. It also works for variables that should be const but only after some initialization work.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_83","text":"widget x; // should be const, but: for (auto i = 2; i <= N; ++i) { // this could be some x += some_obj.do_something_with(i); // arbitrarily long code } // needed to initialize x // from here, x should be const, but we can't say so in code in this style","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_14","text":"const widget x = [&]{ widget val; // assume that widget has a default constructor for (auto i = 2; i <= N; ++i) { // this could be some val += some_obj.do_something_with(i); // arbitrarily long code } // needed to initialize x return val; }();","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#example_197","text":"string var = [&]{ if (!in) return \"\"; // default string s; for (char c : in >> c) s += toupper(c); return s; }(); // note () If at all possible, reduce the conditions to a simple set of alternatives (e.g., an enum ) and don\u2019t mix up selection and initialization.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_207","text":"Hard. At best a heuristic. Look for an uninitialized variable followed by a loop assigning to it.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es30-dont-use-macros-for-program-text-manipulation","text":"","title":"ES.30: Don't use macros for program text manipulation"},{"location":"cppcg/CppCoreGuidelines/#reason_218","text":"Macros are a major source of bugs. Macros don\u2019t obey the usual scope and type rules. Macros ensure that the human reader sees something different from what the compiler sees. Macros complicate tool building.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_84","text":"#define Case break; case /* BAD */ This innocuous-looking macro makes a single lower case c instead of a C into a bad flow-control bug.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_192","text":"This rule does not ban the use of macros for \u201cconfiguration control\u201d use in #ifdef s, etc. In the future, modules are likely to eliminate the need for macros in configuration control.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_193","text":"This rule is meant to also discourage use of # for stringification and ## for concatenation. As usual for macros, there are uses that are \u201cmostly harmless\u201d, but even these can create problems for tools, such as auto completers, static analyzers, and debuggers. Often the desire to use fancy macros is a sign of an overly complex design. Also, # and ## encourages the definition and use of macros: #define CAT(a, b) a ## b #define STRINGIFY(a) #a void f(int x, int y) { string CAT(x, y) = \"asdf\"; // BAD: hard for tools to handle (and ugly) string sx2 = STRINGIFY(x); // ... } There are workarounds for low-level string manipulation using macros. For example: string s = \"asdf\" \"lkjh\"; // ordinary string literal concatenation enum E { a, b }; template<int x> constexpr const char* stringify() { switch (x) { case a: return \"a\"; case b: return \"b\"; } } void f(int x, int y) { string sx = stringify<x>(); // ... } This is not as convenient as a macro to define, but as easy to use, has zero overhead, and is typed and scoped. In the future, static reflection is likely to eliminate the last needs for the preprocessor for program text manipulation.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_208","text":"Scream when you see a macro that isn\u2019t just used for source control (e.g., #ifdef )","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es31-dont-use-macros-for-constants-or-functions","text":"","title":"ES.31: Don't use macros for constants or \"functions\""},{"location":"cppcg/CppCoreGuidelines/#reason_219","text":"Macros are a major source of bugs. Macros don\u2019t obey the usual scope and type rules. Macros don\u2019t obey the usual rules for argument passing. Macros ensure that the human reader sees something different from what the compiler sees. Macros complicate tool building.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_85","text":"#define PI 3.14 #define SQUARE(a, b) (a * b) Even if we hadn\u2019t left a well-known bug in SQUARE there are much better behaved alternatives; for example: constexpr double pi = 3.14; template<typename T> T square(T a, T b) { return a * b; }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_209","text":"Scream when you see a macro that isn\u2019t just used for source control (e.g., #ifdef )","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es32-use-all_caps-for-all-macro-names","text":"","title":"ES.32: Use ALL_CAPS for all macro names"},{"location":"cppcg/CppCoreGuidelines/#reason_220","text":"Convention. Readability. Distinguishing macros.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_198","text":"#define forever for (;;) /* very BAD */ #define FOREVER for (;;) /* Still evil, but at least visible to humans */","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_210","text":"Scream when you see a lower case macro.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es33-if-you-must-use-macros-give-them-unique-names","text":"","title":"ES.33: If you must use macros, give them unique names"},{"location":"cppcg/CppCoreGuidelines/#reason_221","text":"Macros do not obey scope rules.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_199","text":"#define MYCHAR /* BAD, will eventually clash with someone else's MYCHAR*/ #define ZCORP_CHAR /* Still evil, but less likely to clash */","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_194","text":"Avoid macros if you can: ES.30 , ES.31 , and ES.32 . However, there are billions of lines of code littered with macros and a long tradition for using and overusing macros. If you are forced to use macros, use long names and supposedly unique prefixes (e.g., your organization\u2019s name) to lower the likelihood of a clash.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_211","text":"Warn against short macro names.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es34-dont-define-a-c-style-variadic-function","text":"","title":" ES.34: Don't define a (C-style) variadic function"},{"location":"cppcg/CppCoreGuidelines/#reason_222","text":"Not type safe. Requires messy cast-and-macro-laden code to get working right.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_200","text":"#include <cstdarg> // \"severity\" followed by a zero-terminated list of char*s; write the C-style strings to cerr void error(int severity ...) { va_list ap; // a magic type for holding arguments va_start(ap, severity); // arg startup: \"severity\" is the first argument of error() for (;;) { // treat the next var as a char*; no checking: a cast in disguise char* p = va_arg(ap, char*); if (!p) break; cerr << p << ' '; } va_end(ap); // arg cleanup (don't forget this) cerr << '\\n'; if (severity) exit(severity); } void use() { error(7, \"this\", \"is\", \"an\", \"error\", nullptr); error(7); // crash error(7, \"this\", \"is\", \"an\", \"error\"); // crash const char* is = \"is\"; string an = \"an\"; error(7, \"this\", \"is\", an, \"error\"); // crash } Alternative : Overloading. Templates. Variadic templates. #include <iostream> void error(int severity) { std::cerr << '\\n'; std::exit(severity); } template <typename T, typename... Ts> constexpr void error(int severity, T head, Ts... tail) { std::cerr << head; error(severity, tail...); } void use() { error(7); // No crash! error(5, \"this\", \"is\", \"not\", \"an\", \"error\"); // No crash! std::string an = \"an\"; error(7, \"this\", \"is\", \"not\", an, \"error\"); // No crash! error(5, \"oh\", \"no\", nullptr); // Compile error! No need for nullptr. }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_195","text":"This is basically the way printf is implemented.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_212","text":"Flag definitions of C-style variadic functions. Flag #include <cstdarg> and #include <stdarg.h>","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#esexpr-expressions","text":"Expressions manipulate values.","title":"ES.expr: Expressions"},{"location":"cppcg/CppCoreGuidelines/#es40-avoid-complicated-expressions","text":"","title":"ES.40: Avoid complicated expressions"},{"location":"cppcg/CppCoreGuidelines/#reason_223","text":"Complicated expressions are error-prone.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_201","text":"// bad: assignment hidden in subexpression while ((c = getc()) != -1) // bad: two non-local variables assigned in sub-expressions while ((cin >> c1, cin >> c2), c1 == c2) // better, but possibly still too complicated for (char c1, c2; cin >> c1 >> c2 && c1 == c2;) // OK: if i and j are not aliased int x = ++i + ++j; // OK: if i != j and i != k v[i] = v[j] + v[k]; // bad: multiple assignments \"hidden\" in subexpressions x = a + (b = f()) + (c = g()) * 7; // bad: relies on commonly misunderstood precedence rules x = a & b + c * d && e ^ f == 7; // bad: undefined behavior x = x++ + x++ + ++x; Some of these expressions are unconditionally bad (e.g., they rely on undefined behavior). Others are simply so complicated and/or unusual that even good programmers could misunderstand them or overlook a problem when in a hurry.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_196","text":"C++17 tightens up the rules for the order of evaluation (left-to-right except right-to-left in assignments, and the order of evaluation of function arguments is unspecified; see ES.43 ), but that doesn\u2019t change the fact that complicated expressions are potentially confusing.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_197","text":"A programmer should know and use the basic rules for expressions.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_202","text":"x = k * y + z; // OK auto t1 = k * y; // bad: unnecessarily verbose x = t1 + z; if (0 <= x && x < max) // OK auto t1 = 0 <= x; // bad: unnecessarily verbose auto t2 = x < max; if (t1 && t2) // ...","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_213","text":"Tricky. How complicated must an expression be to be considered complicated? Writing computations as statements with one operation each is also confusing. Things to consider: side effects: side effects on multiple non-local variables (for some definition of non-local) can be suspect, especially if the side effects are in separate subexpressions writes to aliased variables more than N operators (and what should N be?) reliance of subtle precedence rules uses undefined behavior (can we catch all undefined behavior?) implementation defined behavior? ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es41-if-in-doubt-about-operator-precedence-parenthesize","text":"","title":"ES.41: If in doubt about operator precedence, parenthesize"},{"location":"cppcg/CppCoreGuidelines/#reason_224","text":"Avoid errors. Readability. Not everyone has the operator table memorized.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_203","text":"const unsigned int flag = 2; unsigned int a = flag; if (a & flag != 0) // bad: means a&(flag != 0) Note: We recommend that programmers know their precedence table for the arithmetic operations, the logical operations, but consider mixing bitwise logical operations with other operators in need of parentheses. if ((a & flag) != 0) // OK: works as intended","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_198","text":"You should know enough not to need parentheses for: if (a < 0 || a <= max) { // ... }","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_214","text":"Flag combinations of bitwise-logical operators and other operators. Flag assignment operators not as the leftmost operator. ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es42-keep-use-of-pointers-simple-and-straightforward","text":"","title":"ES.42: Keep use of pointers simple and straightforward"},{"location":"cppcg/CppCoreGuidelines/#reason_225","text":"Complicated pointer manipulation is a major source of errors.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_199","text":"Use gsl::span instead. Pointers should only refer to single objects . Pointer arithmetic is fragile and easy to get wrong, the source of many, many bad bugs and security violations. span is a bounds-checked, safe type for accessing arrays of data. Access into an array with known bounds using a constant as a subscript can be validated by the compiler.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad_86","text":"void f(int* p, int count) { if (count < 2) return; int* q = p + 1; // BAD ptrdiff_t d; int n; d = (p - &n); // OK d = (q - p); // OK int n = *p++; // BAD if (count < 6) return; p[4] = 1; // BAD p[count - 1] = 2; // BAD use(&p[0], 3); // BAD }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_15","text":"void f(span<int> a) // BETTER: use span in the function declaration { if (a.size() < 2) return; int n = a[0]; // OK span<int> q = a.subspan(1); // OK if (a.size() < 6) return; a[4] = 1; // OK a[a.size() - 1] = 2; // OK use(a.data(), 3); // OK }","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#note_200","text":"Subscripting with a variable is difficult for both tools and humans to validate as safe. span is a run-time bounds-checked, safe type for accessing arrays of data. at() is another alternative that ensures single accesses are bounds-checked. If iterators are needed to access an array, use the iterators from a span constructed over the array.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad_87","text":"void f(array<int, 10> a, int pos) { a[pos / 2] = 1; // BAD a[pos - 1] = 2; // BAD a[-1] = 3; // BAD (but easily caught by tools) -- no replacement, just don't do this a[10] = 4; // BAD (but easily caught by tools) -- no replacement, just don't do this }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_16","text":"Use a span : void f1(span<int, 10> a, int pos) // A1: Change parameter type to use span { a[pos / 2] = 1; // OK a[pos - 1] = 2; // OK } void f2(array<int, 10> arr, int pos) // A2: Add local span and use that { span<int> a = {arr.data(), pos}; a[pos / 2] = 1; // OK a[pos - 1] = 2; // OK } Use at() : void f3(array<int, 10> a, int pos) // ALTERNATIVE B: Use at() for access { at(a, pos / 2) = 1; // OK at(a, pos - 1) = 2; // OK }","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#example-bad_88","text":"void f() { int arr[COUNT]; for (int i = 0; i < COUNT; ++i) arr[i] = i; // BAD, cannot use non-constant indexer }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_17","text":"Use a span : void f1() { int arr[COUNT]; span<int> av = arr; for (int i = 0; i < COUNT; ++i) av[i] = i; } Use a span and range- for : void f1a() { int arr[COUNT]; span<int, COUNT> av = arr; int i = 0; for (auto& e : av) e = i++; } Use at() for access: void f2() { int arr[COUNT]; for (int i = 0; i < COUNT; ++i) at(arr, i) = i; } Use a range- for : void f3() { int arr[COUNT]; int i = 0; for (auto& e : arr) e = i++; }","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#note_201","text":"Tooling can offer rewrites of array accesses that involve dynamic index expressions to use at() instead: static int a[10]; void f(int i, int j) { a[i + j] = 12; // BAD, could be rewritten as ... at(a, i + j) = 12; // OK -- bounds-checked }","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_204","text":"Turning an array into a pointer (as the language does essentially always) removes opportunities for checking, so avoid it void g(int* p); void f() { int a[5]; g(a); // BAD: are we trying to pass an array? g(&a[0]); // OK: passing one object } If you want to pass an array, say so: void g(int* p, size_t length); // old (dangerous) code void g1(span<int> av); // BETTER: get g() changed. void f2() { int a[5]; span<int> av = a; g(av.data(), av.size()); // OK, if you have no choice g1(a); // OK -- no decay here, instead use implicit span ctor }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_215","text":"Flag any arithmetic operation on an expression of pointer type that results in a value of pointer type. Flag any indexing expression on an expression or variable of array type (either static array or std::array ) where the indexer is not a compile-time constant expression with a value between 0 and the upper bound of the array. Flag any expression that would rely on implicit conversion of an array type to a pointer type. This rule is part of the bounds-safety profile .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es43-avoid-expressions-with-undefined-order-of-evaluation","text":"","title":"ES.43: Avoid expressions with undefined order of evaluation"},{"location":"cppcg/CppCoreGuidelines/#reason_226","text":"You have no idea what such code does. Portability. Even if it does something sensible for you, it may do something different on another compiler (e.g., the next release of your compiler) or with a different optimizer setting.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_202","text":"C++17 tightens up the rules for the order of evaluation: left-to-right except right-to-left in assignments, and the order of evaluation of function arguments is unspecified. However, remember that your code may be compiled with a pre-C++17 compiler (e.g., through cut-and-paste) so don\u2019t be too clever.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_205","text":"v[i] = ++i; // the result is undefined A good rule of thumb is that you should not read a value twice in an expression where you write to it.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_216","text":"Can be detected by a good analyzer.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es44-dont-depend-on-order-of-evaluation-of-function-arguments","text":"","title":"ES.44: Don't depend on order of evaluation of function arguments"},{"location":"cppcg/CppCoreGuidelines/#reason_227","text":"Because that order is unspecified.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_203","text":"C++17 tightens up the rules for the order of evaluation, but the order of evaluation of function arguments is still unspecified.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_206","text":"int i = 0; f(++i, ++i); The call will most likely be f(0, 1) or f(1, 0) , but you don\u2019t know which. Technically, the behavior is undefined. In C++17, this code does not have undefined behavior, but it is still not specified which argument is evaluated first.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_207","text":"Overloaded operators can lead to order of evaluation problems: f1()->m(f2()); // m(f1(), f2()) cout << f1() << f2(); // operator<<(operator<<(cout, f1()), f2()) In C++17, these examples work as expected (left to right) and assignments are evaluated right to left (just as =\u2019s binding is right-to-left) f1() = f2(); // undefined behavior in C++14; in C++17, f2() is evaluated before f1()","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_217","text":"Can be detected by a good analyzer.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es45-avoid-magic-constants-use-symbolic-constants","text":"","title":"ES.45: Avoid \"magic constants\"; use symbolic constants"},{"location":"cppcg/CppCoreGuidelines/#reason_228","text":"Unnamed constants embedded in expressions are easily overlooked and often hard to understand:","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_208","text":"for (int m = 1; m <= 12; ++m) // don't: magic constant 12 cout << month[m] << '\\n'; No, we don\u2019t all know that there are 12 months, numbered 1..12, in a year. Better: // months are indexed 1..12 constexpr int first_month = 1; constexpr int last_month = 12; for (int m = first_month; m <= last_month; ++m) // better cout << month[m] << '\\n'; Better still, don\u2019t expose constants: for (auto m : month) cout << m << '\\n';","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_218","text":"Flag literals in code. Give a pass to 0 , 1 , nullptr , \\n , \"\" , and others on a positive list.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es46-avoid-lossy-narrowing-truncating-arithmetic-conversions","text":"","title":"ES.46: Avoid lossy (narrowing, truncating) arithmetic conversions"},{"location":"cppcg/CppCoreGuidelines/#reason_229","text":"A narrowing conversion destroys information, often unexpectedly so.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_89","text":"A key example is basic narrowing: double d = 7.9; int i = d; // bad: narrowing: i becomes 7 i = (int) d; // bad: we're going to claim this is still not explicit enough void f(int x, long y, double d) { char c1 = x; // bad: narrowing char c2 = y; // bad: narrowing char c3 = d; // bad: narrowing }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_204","text":"The guidelines support library offers a narrow_cast operation for specifying that narrowing is acceptable and a narrow (\u201cnarrow if\u201d) that throws an exception if a narrowing would throw away information: i = narrow_cast<int>(d); // OK (you asked for it): narrowing: i becomes 7 i = narrow<int>(d); // OK: throws narrowing_error We also include lossy arithmetic casts, such as from a negative floating point type to an unsigned integral type: double d = -7.9; unsigned u = 0; u = d; // BAD u = narrow_cast<unsigned>(d); // OK (you asked for it): u becomes 4294967289 u = narrow<unsigned>(d); // OK: throws narrowing_error","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_219","text":"A good analyzer can detect all narrowing conversions. However, flagging all narrowing conversions will lead to a lot of false positives. Suggestions: Flag all floating-point to integer conversions (maybe only float -> char and double -> int . Here be dragons! we need data). Flag all long -> char (I suspect int -> char is very common. Here be dragons! we need data). Consider narrowing conversions for function arguments especially suspect.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es47-use-nullptr-rather-than-0-or-null","text":"","title":"ES.47: Use nullptr rather than 0 or NULL"},{"location":"cppcg/CppCoreGuidelines/#reason_230","text":"Readability. Minimize surprises: nullptr cannot be confused with an int . nullptr also has a well-specified (very restrictive) type, and thus works in more scenarios where type deduction might do the wrong thing on NULL or 0 .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_209","text":"Consider: void f(int); void f(char*); f(0); // call f(int) f(nullptr); // call f(char*)","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_220","text":"Flag uses of 0 and NULL for pointers. The transformation may be helped by simple program transformation.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es48-avoid-casts","text":"","title":"ES.48: Avoid casts"},{"location":"cppcg/CppCoreGuidelines/#reason_231","text":"Casts are a well-known source of errors. Make some optimizations unreliable.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_90","text":"double d = 2; auto p = (long*)&d; auto q = (long long*)&d; cout << d << ' ' << *p << ' ' << *q << '\\n'; What would you think this fragment prints? The result is at best implementation defined. I got 2 0 4611686018427387904 Adding *q = 666; cout << d << ' ' << *p << ' ' << *q << '\\n'; I got 3.29048e-321 666 666 Surprised? I\u2019m just glad I didn\u2019t crash the program.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_205","text":"Programmers who write casts typically assume that they know what they are doing, or that writing a cast makes the program \u201ceasier to read\u201d. In fact, they often disable the general rules for using values. Overload resolution and template instantiation usually pick the right function if there is a right function to pick. If there is not, maybe there ought to be, rather than applying a local fix (cast).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_206","text":"Casts are necessary in a systems programming language. For example, how else would we get the address of a device register into a pointer? However, casts are seriously overused as well as a major source of errors.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_207","text":"If you feel the need for a lot of casts, there may be a fundamental design problem.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exception_40","text":"Casting to (void) is the Standard-sanctioned way to turn off [[nodiscard]] warnings. If you are calling a function with a [[nodiscard]] return and you deliberately want to discard the result, first think hard about whether that is really a good idea (there is usually a good reason the author of the function or of the return type used [[nodiscard]] in the first place), but if you still think it\u2019s appropriate and your code reviewer agrees, write (void) to turn off the warning.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#alternatives_1","text":"Casts are widely (mis) used. Modern C++ has rules and constructs that eliminate the need for casts in many contexts, such as Use templates Use std::variant Rely on the well-defined, safe, implicit conversions between pointer types","title":"Alternatives"},{"location":"cppcg/CppCoreGuidelines/#enforcement_221","text":"Force the elimination of C-style casts, except on a function with a [[nodiscard]] return. Warn if there are many functional style casts (there is an obvious problem in quantifying \u2018many\u2019). The type profile bans reinterpret_cast . Warn against identity casts between pointer types, where the source and target types are the same (#Pro-type-identitycast). Warn if a pointer cast could be implicit .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es49-if-you-must-use-a-cast-use-a-named-cast","text":"","title":"ES.49: If you must use a cast, use a named cast"},{"location":"cppcg/CppCoreGuidelines/#reason_232","text":"Readability. Error avoidance. Named casts are more specific than a C-style or functional cast, allowing the compiler to catch some errors. The named casts are: static_cast const_cast reinterpret_cast dynamic_cast std::move // move(x) is an rvalue reference to x std::forward // forward<T>(x) is an rvalue or an lvalue reference to x depending on T gsl::narrow_cast // narrow_cast<T>(x) is static_cast<T>(x) gsl::narrow // narrow<T>(x) is static_cast<T>(x) if static_cast<T>(x) == x or it throws narrowing_error","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_210","text":"class B { /* ... */ }; class D { /* ... */ }; template<typename D> D* upcast(B* pb) { D* pd0 = pb; // error: no implicit conversion from B* to D* D* pd1 = (D*)pb; // legal, but what is done? D* pd2 = static_cast<D*>(pb); // error: D is not derived from B D* pd3 = reinterpret_cast<D*>(pb); // OK: on your head be it! D* pd4 = dynamic_cast<D*>(pb); // OK: return nullptr // ... } The example was synthesized from real-world bugs where D used to be derived from B , but someone refactored the hierarchy. The C-style cast is dangerous because it can do any kind of conversion, depriving us of any protection from mistakes (now or in the future).","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_208","text":"When converting between types with no information loss (e.g. from float to double or int64 from int32 ), brace initialization may be used instead. double d {some_float}; int64_t i {some_int32}; This makes it clear that the type conversion was intended and also prevents conversions between types that might result in loss of precision. (It is a compilation error to try to initialize a float from a double in this fashion, for example.)","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_209","text":"reinterpret_cast can be essential, but the essential uses (e.g., turning a machine address into pointer) are not type safe: auto p = reinterpret_cast<Device_register>(0x800); // inherently dangerous","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_222","text":"Flag C-style and functional casts. The type profile bans reinterpret_cast . The type profile warns when using static_cast between arithmetic types.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es50-dont-cast-away-const","text":"","title":"ES.50: Don't cast away const"},{"location":"cppcg/CppCoreGuidelines/#reason_233","text":"It makes a lie out of const . If the variable is actually declared const , the result of \u201ccasting away const \u201d is undefined behavior.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_91","text":"void f(const int& x) { const_cast<int&>(x) = 42; // BAD } static int i = 0; static const int j = 0; f(i); // silent side effect f(j); // undefined behavior","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_211","text":"Sometimes, you may be tempted to resort to const_cast to avoid code duplication, such as when two accessor functions that differ only in const -ness have similar implementations. For example: class Bar; class Foo { public: // BAD, duplicates logic Bar& get_bar() { /* complex logic around getting a non-const reference to my_bar */ } const Bar& get_bar() const { /* same complex logic around getting a const reference to my_bar */ } private: Bar my_bar; }; Instead, prefer to share implementations. Normally, you can just have the non- const function call the const function. However, when there is complex logic this can lead to the following pattern that still resorts to a const_cast : class Foo { public: // not great, non-const calls const version but resorts to const_cast Bar& get_bar() { return const_cast<Bar&>(static_cast<const Foo&>(*this).get_bar()); } const Bar& get_bar() const { /* the complex logic around getting a const reference to my_bar */ } private: Bar my_bar; }; Although this pattern is safe when applied correctly, because the caller must have had a non- const object to begin with, it\u2019s not ideal because the safety is hard to enforce automatically as a checker rule. Instead, prefer to put the common code in a common helper function \u2013 and make it a template so that it deduces const . This doesn\u2019t use any const_cast at all: class Foo { public: // good Bar& get_bar() { return get_bar_impl(*this); } const Bar& get_bar() const { return get_bar_impl(*this); } private: Bar my_bar; template<class T> // good, deduces whether T is const or non-const static auto get_bar_impl(T& t) -> decltype(t.get_bar()) { /* the complex logic around getting a possibly-const reference to my_bar */ } };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_41","text":"You may need to cast away const when calling const -incorrect functions. Prefer to wrap such functions in inline const -correct wrappers to encapsulate the cast in one place.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#example_212","text":"Sometimes, \u201ccast away const \u201d is to allow the updating of some transient information of an otherwise immutable object. Examples are caching, memoization, and precomputation. Such examples are often handled as well or better using mutable or an indirection than with a const_cast . Consider keeping previously computed results around for a costly operation: int compute(int x); // compute a value for x; assume this to be costly class Cache { // some type implementing a cache for an int->int operation public: pair<bool, int> find(int x) const; // is there a value for x? void set(int x, int v); // make y the value for x // ... private: // ... }; class X { public: int get_val(int x) { auto p = cache.find(x); if (p.first) return p.second; int val = compute(x); cache.set(x, val); // insert value for x return val; } // ... private: Cache cache; }; Here, get_val() is logically constant, so we would like to make it a const member. To do this we still need to mutate cache , so people sometimes resort to a const_cast : class X { // Suspicious solution based on casting public: int get_val(int x) const { auto p = cache.find(x); if (p.first) return p.second; int val = compute(x); const_cast<Cache&>(cache).set(x, val); // ugly return val; } // ... private: Cache cache; }; Fortunately, there is a better solution: State that cache is mutable even for a const object: class X { // better solution public: int get_val(int x) const { auto p = cache.find(x); if (p.first) return p.second; int val = compute(x); cache.set(x, val); return val; } // ... private: mutable Cache cache; }; An alternative solution would be to store a pointer to the cache : class X { // OK, but slightly messier solution public: int get_val(int x) const { auto p = cache->find(x); if (p.first) return p.second; int val = compute(x); cache->set(x, val); return val; } // ... private: unique_ptr<Cache> cache; }; That solution is the most flexible, but requires explicit construction and destruction of *cache (most likely in the constructor and destructor of X ). In any variant, we must guard against data races on the cache in multi-threaded code, possibly using a std::mutex .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_223","text":"Flag const_cast s. This rule is part of the type-safety profile for the related Profile.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es55-avoid-the-need-for-range-checking","text":"","title":"ES.55: Avoid the need for range checking"},{"location":"cppcg/CppCoreGuidelines/#reason_234","text":"Constructs that cannot overflow do not overflow (and usually run faster):","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_213","text":"for (auto& x : v) // print all elements of v cout << x << '\\n'; auto p = find(v, x); // find x in v","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_224","text":"Look for explicit range checks and heuristically suggest alternatives.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es56-write-stdmove-only-when-you-need-to-explicitly-move-an-object-to-another-scope","text":"","title":"ES.56: Write std::move() only when you need to explicitly move an object to another scope"},{"location":"cppcg/CppCoreGuidelines/#reason_235","text":"We move, rather than copy, to avoid duplication and for improved performance. A move typically leaves behind an empty object ( C.64 ), which can be surprising or even dangerous, so we try to avoid moving from lvalues (they might be accessed later).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#notes_4","text":"Moving is done implicitly when the source is an rvalue (e.g., value in a return treatment or a function result), so don\u2019t pointlessly complicate code in those cases by writing move explicitly. Instead, write short functions that return values, and both the function\u2019s return and the caller\u2019s accepting of the return will be optimized naturally. In general, following the guidelines in this document (including not making variables\u2019 scopes needlessly large, writing short functions that return values, returning local variables) help eliminate most need for explicit std::move . Explicit move is needed to explicitly move an object to another scope, notably to pass it to a \u201csink\u201d function and in the implementations of the move operations themselves (move constructor, move assignment operator) and swap operations.","title":"Notes"},{"location":"cppcg/CppCoreGuidelines/#example-bad_92","text":"void sink(X&& x); // sink takes ownership of x void user() { X x; // error: cannot bind an lvalue to a rvalue reference sink(x); // OK: sink takes the contents of x, x must now be assumed to be empty sink(std::move(x)); // ... // probably a mistake use(x); } Usually, a std::move() is used as an argument to a && parameter. And after you do that, assume the object has been moved from (see C.64 ) and don\u2019t read its state again until you first set it to a new value. void f() { string s1 = \"supercalifragilisticexpialidocious\"; string s2 = s1; // ok, takes a copy assert(s1 == \"supercalifragilisticexpialidocious\"); // ok // bad, if you want to keep using s1's value string s3 = move(s1); // bad, assert will likely fail, s1 likely changed assert(s1 == \"supercalifragilisticexpialidocious\"); }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_214","text":"void sink(unique_ptr<widget> p); // pass ownership of p to sink() void f() { auto w = make_unique<widget>(); // ... sink(std::move(w)); // ok, give to sink() // ... sink(w); // Error: unique_ptr is carefully designed so that you cannot copy it }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#notes_5","text":"std::move() is a cast to && in disguise; it doesn\u2019t itself move anything, but marks a named object as a candidate that can be moved from. The language already knows the common cases where objects can be moved from, especially when returning values from functions, so don\u2019t complicate code with redundant std::move() \u2018s. Never write std::move() just because you\u2019ve heard \u201cit\u2019s more efficient.\u201d In general, don\u2019t believe claims of \u201cefficiency\u201d without data (???). In general, don\u2019t complicate your code without reason (??)","title":"Notes"},{"location":"cppcg/CppCoreGuidelines/#example-bad_93","text":"vector<int> make_vector() { vector<int> result; // ... load result with data return std::move(result); // bad; just write \"return result;\" } Never write return move(local_variable); , because the language already knows the variable is a move candidate. Writing move in this code won\u2019t help, and can actually be detrimental because on some compilers it interferes with RVO (the return value optimization) by creating an additional reference alias to the local variable.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-bad_94","text":"vector<int> v = std::move(make_vector()); // bad; the std::move is entirely redundant Never write move on a returned value such as x = move(f()); where f returns by value. The language already knows that a returned value is a temporary object that can be moved from.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_215","text":"void mover(X&& x) { call_something(std::move(x)); // ok call_something(std::forward<X>(x)); // bad, don't std::forward an rvalue reference call_something(x); // suspicious, why not std::move? } template<class T> void forwarder(T&& t) { call_something(std::move(t)); // bad, don't std::move a forwarding reference call_something(std::forward<T>(t)); // ok call_something(t); // suspicious, why not std::forward? }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_225","text":"Flag use of std::move(x) where x is an rvalue or the language will already treat it as an rvalue, including return std::move(local_variable); and std::move(f()) on a function that returns by value. Flag functions taking an S&& parameter if there is no const S& overload to take care of lvalues. Flag a std::move s argument passed to a parameter, except when the parameter type is one of the following: an X&& rvalue reference; a T&& forwarding reference where T is a template parameter type; or by value and the type is move-only. Flag when std::move is applied to a forwarding reference ( T&& where T is a template parameter type). Use std::forward instead. Flag when std::move is applied to other than an rvalue reference. (More general case of the previous rule to cover the non-forwarding cases.) Flag when std::forward is applied to an rvalue reference ( X&& where X is a concrete type). Use std::move instead. Flag when std::forward is applied to other than a forwarding reference. (More general case of the previous rule to cover the non-moving cases.) Flag when an object is potentially moved from and the next operation is a const operation; there should first be an intervening non- const operation, ideally assignment, to first reset the object\u2019s value.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es60-avoid-new-and-delete-outside-resource-management-functions","text":"","title":"ES.60: Avoid new and delete outside resource management functions"},{"location":"cppcg/CppCoreGuidelines/#reason_236","text":"Direct resource management in application code is error-prone and tedious.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_210","text":"This is also known as the rule of \u201cNo naked new !\u201d","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad_95","text":"void f(int n) { auto p = new X[n]; // n default constructed Xs // ... delete[] p; } There can be code in the ... part that causes the delete never to happen. See also : R: Resource management","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_226","text":"Flag naked new s and naked delete s.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es61-delete-arrays-using-delete-and-non-arrays-using-delete","text":"","title":"ES.61: Delete arrays using delete[] and non-arrays using delete"},{"location":"cppcg/CppCoreGuidelines/#reason_237","text":"That\u2019s what the language requires and mistakes can lead to resource release errors and/or memory corruption.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_96","text":"void f(int n) { auto p = new X[n]; // n default constructed Xs // ... delete p; // error: just delete the object p, rather than delete the array p[] }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_211","text":"This example not only violates the no naked new rule as in the previous example, it has many more problems.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_227","text":"If the new and the delete are in the same scope, mistakes can be flagged. If the new and the delete are in a constructor/destructor pair, mistakes can be flagged.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es62-dont-compare-pointers-into-different-arrays","text":"","title":"ES.62: Don't compare pointers into different arrays"},{"location":"cppcg/CppCoreGuidelines/#reason_238","text":"The result of doing so is undefined.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_97","text":"void f() { int a1[7]; int a2[9]; if (&a1[5] < &a2[7]) {} // bad: undefined if (0 < &a1[5] - &a2[7]) {} // bad: undefined }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_212","text":"This example has many more problems.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_228","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es63-dont-slice","text":"","title":"ES.63: Don't slice"},{"location":"cppcg/CppCoreGuidelines/#reason_239","text":"Slicing \u2013 that is, copying only part of an object using assignment or initialization \u2013 most often leads to errors because the object was meant to be considered as a whole. In the rare cases where the slicing was deliberate the code can be surprising.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_216","text":"class Shape { /* ... */ }; class Circle : public Shape { /* ... */ Point c; int r; }; Circle c {{0, 0}, 42}; Shape s {c}; // copy construct only the Shape part of Circle s = c; // or copy assign only the Shape part of Circle void assign(const Shape& src, Shape& dest) { dest = src; } Circle c2 {{1, 1}, 43}; assign(c, c2); // oops, not the whole state is transferred assert(c == c2); // if we supply copying, we should also provide comparison, // but this will likely return false The result will be meaningless because the center and radius will not be copied from c into s . The first defense against this is to define the base class Shape not to allow this .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#alternative_8","text":"If you mean to slice, define an explicit operation to do so. This saves readers from confusion. For example: class Smiley : public Circle { public: Circle copy_circle(); // ... }; Smiley sm { /* ... */ }; Circle c1 {sm}; // ideally prevented by the definition of Circle Circle c2 {sm.copy_circle()};","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#enforcement_229","text":"Warn against slicing.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es64-use-the-tenotation-for-construction","text":"","title":"ES.64: Use the T{e}notation for construction"},{"location":"cppcg/CppCoreGuidelines/#reason_240","text":"The T{e} construction syntax makes it explicit that construction is desired. The T{e} construction syntax doesn\u2019t allow narrowing. T{e} is the only safe and general expression for constructing a value of type T from an expression e . The casts notations T(e) and (T)e are neither safe nor general.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_217","text":"For built-in types, the construction notation protects against narrowing and reinterpretation void use(char ch, int i, double d, char* p, long long lng) { int x1 = int{ch}; // OK, but redundant int x2 = int{d}; // error: double->int narrowing; use a cast if you need to int x3 = int{p}; // error: pointer to->int; use a reinterpret_cast if you really need to int x4 = int{lng}; // error: long long->int narrowing; use a cast if you need to int y1 = int(ch); // OK, but redundant int y2 = int(d); // bad: double->int narrowing; use a cast if you need to int y3 = int(p); // bad: pointer to->int; use a reinterpret_cast if you really need to int y4 = int(lng); // bad: long long->int narrowing; use a cast if you need to int z1 = (int)ch; // OK, but redundant int z2 = (int)d; // bad: double->int narrowing; use a cast if you need to int z3 = (int)p; // bad: pointer to->int; use a reinterpret_cast if you really need to int z4 = (int)lng; // bad: long long->int narrowing; use a cast if you need to } The integer to/from pointer conversions are implementation defined when using the T(e) or (T)e notations, and non-portable between platforms with different integer and pointer sizes.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_213","text":"Avoid casts (explicit type conversion) and if you must prefer named casts .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_214","text":"When unambiguous, the T can be left out of T{e} . complex<double> f(complex<double>); auto z = f({2*pi, 1});","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_215","text":"The construction notation is the most general initializer notation .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exception_42","text":"std::vector and other containers were defined before we had {} as a notation for construction. Consider: vector<string> vs {10}; // ten empty strings vector<int> vi1 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // ten elements 1..10 vector<int> vi2 {10}; // one element with the value 10 How do we get a vector of 10 default initialized int s? vector<int> v3(10); // ten elements with value 0 The use of () rather than {} for number of elements is conventional (going back to the early 1980s), hard to change, but still a design error: for a container where the element type can be confused with the number of elements, we have an ambiguity that must be resolved. The conventional resolution is to interpret {10} as a list of one element and use (10) to distinguish a size. This mistake need not be repeated in new code. We can define a type to represent the number of elements: struct Count { int n; }; template<typename T> class Vector { public: Vector(Count n); // n default-initialized elements Vector(initializer_list<T> init); // init.size() elements // ... }; Vector<int> v1{10}; Vector<int> v2{Count{10}}; Vector<Count> v3{Count{10}}; // yes, there is still a very minor problem The main problem left is to find a suitable name for Count .","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_230","text":"Flag the C-style (T)e and functional-style T(e) casts.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es65-dont-dereference-an-invalid-pointer","text":"","title":"ES.65: Don't dereference an invalid pointer"},{"location":"cppcg/CppCoreGuidelines/#reason_241","text":"Dereferencing an invalid pointer, such as nullptr , is undefined behavior, typically leading to immediate crashes, wrong results, or memory corruption.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_216","text":"This rule is an obvious and well-known language rule, but can be hard to follow. It takes good coding style, library support, and static analysis to eliminate violations without major overhead. This is a major part of the discussion of C++\u2019s resource- and type-safety model . See also : Use RAII to avoid lifetime problems. Use unique_ptr to avoid lifetime problems. Use shared_ptr to avoid lifetime problems. Use references when nullptr isn\u2019t a possibility. Use not_null to catch unexpected nullptr early. Use the bounds profile to avoid range errors.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_218","text":"void f() { int x = 0; int* p = &x; if (condition()) { int y = 0; p = &y; } // invalidates p *p = 42; // BAD, p might be invalid if the branch was taken } To resolve the problem, either extend the lifetime of the object the pointer is intended to refer to, or shorten the lifetime of the pointer (move the dereference to before the pointed-to object\u2019s lifetime ends). void f1() { int x = 0; int* p = &x; int y = 0; if (condition()) { p = &y; } *p = 42; // OK, p points to x or y and both are still in scope } Unfortunately, most invalid pointer problems are harder to spot and harder to fix.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_219","text":"void f(int* p) { int x = *p; // BAD: how do we know that p is valid? } There is a huge amount of such code. Most works \u2013 after lots of testing \u2013 but in isolation it is impossible to tell whether p could be the nullptr . Consequently, this is also a major source of errors. There are many approaches to dealing with this potential problem: void f1(int* p) // deal with nullptr { if (!p) { // deal with nullptr (allocate, return, throw, make p point to something, whatever } int x = *p; } There are two potential problems with testing for nullptr : it is not always obvious what to do what to do if we find nullptr the test can be redundant and/or relatively expensive it is not obvious if the test is to protect against a violation or part of the required logic. void f2(int* p) // state that p is not supposed to be nullptr { assert(p); int x = *p; } This would carry a cost only when the assertion checking was enabled and would give a compiler/analyzer useful information. This would work even better if/when C++ gets direct support for contracts: void f3(int* p) // state that p is not supposed to be nullptr [[expects: p]] { int x = *p; } Alternatively, we could use gsl::not_null to ensure that p is not the nullptr . void f(not_null<int*> p) { int x = *p; } These remedies take care of nullptr only. Remember that there are other ways of getting an invalid pointer.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_220","text":"void f(int* p) // old code, doesn't use owner { delete p; } void g() // old code: uses naked new { auto q = new int{7}; f(q); int x = *q; // BAD: dereferences invalid pointer }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_221","text":"void f() { vector<int> v(10); int* p = &v[5]; v.push_back(99); // could reallocate v's elements int x = *p; // BAD: dereferences potentially invalid pointer }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_231","text":"This rule is part of the lifetime safety profile Flag a dereference of a pointer that points to an object that has gone out of scope Flag a dereference of a pointer that may have been invalidated by assigning a nullptr Flag a dereference of a pointer that may have been invalidated by a delete Flag a dereference to a pointer to a container element that may have been invalidated by dereference","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#esstmt-statements","text":"Statements control the flow of control (except for function calls and exception throws, which are expressions).","title":"ES.stmt: Statements"},{"location":"cppcg/CppCoreGuidelines/#es70-prefer-a-switch-statement-to-an-if-statement-when-there-is-a-choice","text":"","title":"ES.70: Prefer a switch-statement to an if-statement when there is a choice"},{"location":"cppcg/CppCoreGuidelines/#reason_242","text":"Readability. Efficiency: A switch compares against constants and is usually better optimized than a series of tests in an if - then - else chain. A switch enables some heuristic consistency checking. For example, have all values of an enum been covered? If not, is there a default ?","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_222","text":"void use(int n) { switch (n) { // good case 0: // ... break; case 7: // ... break; default: // ... break; } } rather than: void use2(int n) { if (n == 0) // bad: if-then-else chain comparing against a set of constants // ... else if (n == 7) // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_232","text":"Flag if - then - else chains that check against constants (only).","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es71-prefer-a-range-for-statement-to-a-for-statement-when-there-is-a-choice","text":"","title":"ES.71: Prefer a range-for-statement to a for-statement when there is a choice"},{"location":"cppcg/CppCoreGuidelines/#reason_243","text":"Readability. Error prevention. Efficiency.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_223","text":"for (gsl::index i = 0; i < v.size(); ++i) // bad cout << v[i] << '\\n'; for (auto p = v.begin(); p != v.end(); ++p) // bad cout << *p << '\\n'; for (auto& x : v) // OK cout << x << '\\n'; for (gsl::index i = 1; i < v.size(); ++i) // touches two elements: can't be a range-for cout << v[i] + v[i - 1] << '\\n'; for (gsl::index i = 0; i < v.size(); ++i) // possible side effect: can't be a range-for cout << f(v, &v[i]) << '\\n'; for (gsl::index i = 0; i < v.size(); ++i) { // body messes with loop variable: can't be a range-for if (i % 2 == 0) continue; // skip even elements else cout << v[i] << '\\n'; } A human or a good static analyzer may determine that there really isn\u2019t a side effect on v in f(v, &v[i]) so that the loop can be rewritten. \u201cMessing with the loop variable\u201d in the body of a loop is typically best avoided.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_217","text":"Don\u2019t use expensive copies of the loop variable of a range- for loop: for (string s : vs) // ... This will copy each elements of vs into s . Better: for (string& s : vs) // ... Better still, if the loop variable isn\u2019t modified or copied: for (const string& s : vs) // ...","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_233","text":"Look at loops, if a traditional loop just looks at each element of a sequence, and there are no side effects on what it does with the elements, rewrite the loop to a ranged- for loop.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es72-prefer-a-for-statement-to-a-while-statement-when-there-is-an-obvious-loop-variable","text":"","title":"ES.72: Prefer a for-statement to a while-statement when there is an obvious loop variable"},{"location":"cppcg/CppCoreGuidelines/#reason_244","text":"Readability: the complete logic of the loop is visible \u201cup front\u201d. The scope of the loop variable can be limited.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_224","text":"for (gsl::index i = 0; i < vec.size(); i++) { // do work }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_98","text":"int i = 0; while (i < vec.size()) { // do work i++; }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_234","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es73-prefer-a-while-statement-to-a-for-statement-when-there-is-no-obvious-loop-variable","text":"","title":"ES.73: Prefer a while-statement to a for-statement when there is no obvious loop variable"},{"location":"cppcg/CppCoreGuidelines/#reason_245","text":"Readability.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_225","text":"int events = 0; for (; wait_for_event(); ++events) { // bad, confusing // ... } The \u201cevent loop\u201d is misleading because the events counter has nothing to do with the loop condition ( wait_for_event() ). Better int events = 0; while (wait_for_event()) { // better ++events; // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_235","text":"Flag actions in for -initializers and for -increments that do not relate to the for -condition.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es74-prefer-to-declare-a-loop-variable-in-the-initializer-part-of-a-for-statement","text":"","title":"ES.74: Prefer to declare a loop variable in the initializer part of a for-statement"},{"location":"cppcg/CppCoreGuidelines/#reason_246","text":"Limit the loop variable visibility to the scope of the loop. Avoid using the loop variable for other purposes after the loop.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_226","text":"for (int i = 0; i < 100; ++i) { // GOOD: i var is visible only inside the loop // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-dont_2","text":"int j; // BAD: j is visible outside the loop for (j = 0; j < 100; ++j) { // ... } // j is still visible here and isn't needed See also : Don\u2019t use a variable for two unrelated purposes","title":"Example, don't"},{"location":"cppcg/CppCoreGuidelines/#example_227","text":"for (string s; cin >> s; ) { cout << s << '\\n'; }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_236","text":"Warn when a variable modified inside the for -statement is declared outside the loop and not being used outside the loop. Discussion : Scoping the loop variable to the loop body also helps code optimizers greatly. Recognizing that the induction variable is only accessible in the loop body unblocks optimizations such as hoisting, strength reduction, loop-invariant code motion, etc.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es75-avoid-do-statements","text":"","title":"ES.75: Avoid do-statements"},{"location":"cppcg/CppCoreGuidelines/#reason_247","text":"Readability, avoidance of errors. The termination condition is at the end (where it can be overlooked) and the condition is not checked the first time through.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_228","text":"int x; do { cin >> x; // ... } while (x < 0);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_218","text":"Yes, there are genuine examples where a do -statement is a clear statement of a solution, but also many bugs.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_237","text":"Flag do -statements.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es76-avoid-goto","text":"","title":"ES.76: Avoid goto"},{"location":"cppcg/CppCoreGuidelines/#reason_248","text":"Readability, avoidance of errors. There are better control structures for humans; goto is for machine generated code.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#exception_43","text":"Breaking out of a nested loop. In that case, always jump forwards. for (int i = 0; i < imax; ++i) for (int j = 0; j < jmax; ++j) { if (a[i][j] > elem_max) goto finished; // ... } finished: // ...","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#example-bad_99","text":"There is a fair amount of use of the C goto-exit idiom: void f() { // ... goto exit; // ... goto exit; // ... exit: // ... common cleanup code ... } This is an ad-hoc simulation of destructors. Declare your resources with handles with destructors that clean up. If for some reason you cannot handle all cleanup with destructors for the variables used, consider gsl::finally() as a cleaner and more reliable alternative to goto exit","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_238","text":"Flag goto . Better still flag all goto s that do not jump from a nested loop to the statement immediately after a nest of loops.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es77-minimize-the-use-of-break-and-continue-in-loops","text":"","title":"ES.77: Minimize the use of break and continue in loops"},{"location":"cppcg/CppCoreGuidelines/#reason_249","text":"In a non-trivial loop body, it is easy to overlook a break or a continue . A break in a loop has a dramatically different meaning than a break in a switch -statement (and you can have switch -statement in a loop and a loop in a switch -case).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_229","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#alternative_9","text":"Often, a loop that requires a break is a good candidate for a function (algorithm), in which case the break becomes a return . ??? Often, a loop that uses continue can equivalently and as clearly be expressed by an if -statement. ???","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#note_219","text":"If you really need to break out a loop, a break is typically better than alternatives such as modifying the loop variable or a goto :","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_239","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es78-always-end-a-non-empty-case-with-a-break","text":"","title":"ES.78: Always end a non-empty case with a break"},{"location":"cppcg/CppCoreGuidelines/#reason_250","text":"Accidentally leaving out a break is a fairly common bug. A deliberate fallthrough can be a maintenance hazard and should be rare and explicit.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_230","text":"switch (eventType) { case Information: update_status_bar(); break; case Warning: write_event_log(); // Bad - implicit fallthrough case Error: display_error_window(); break; } Multiple case labels of a single statement is OK: switch (x) { case 'a': case 'b': case 'f': do_something(x); break; }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exceptions_1","text":"In rare cases if fallthrough is deemed appropriate, be explicit and use the [[fallthrough]] annotation: switch (eventType) { case Information: update_status_bar(); break; case Warning: write_event_log(); [[fallthrough]]; case Error: display_error_window(); break; }","title":"Exceptions"},{"location":"cppcg/CppCoreGuidelines/#note_220","text":"","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_240","text":"Flag all implicit fallthroughs from non-empty case s.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es79-use-default-to-handle-common-cases-only","text":"","title":"ES.79: Use default to handle common cases (only)"},{"location":"cppcg/CppCoreGuidelines/#reason_251","text":"Code clarity. Improved opportunities for error detection.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_231","text":"enum E { a, b, c , d }; void f1(E x) { switch (x) { case a: do_something(); break; case b: do_something_else(); break; default: take_the_default_action(); break; } } Here it is clear that there is a default action and that cases a and b are special.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_232","text":"But what if there is no default action and you mean to handle only specific cases? In that case, have an empty default or else it is impossible to know if you meant to handle all cases: void f2(E x) { switch (x) { case a: do_something(); break; case b: do_something_else(); break; default: // do nothing for the rest of the cases break; } } If you leave out the default , a maintainer and/or a compiler may reasonably assume that you intended to handle all cases: void f2(E x) { switch (x) { case a: do_something(); break; case b: case c: do_something_else(); break; } } Did you forget case d or deliberately leave it out? Forgetting a case typically happens when a case is added to an enumeration and the person doing so fails to add it to every switch over the enumerators.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_241","text":"Flag switch -statements over an enumeration that don\u2019t handle all enumerators and do not have a default . This may yield too many false positives in some code bases; if so, flag only switch es that handle most but not all cases (that was the strategy of the very first C++ compiler).","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es84-dont-try-to-declare-a-local-variable-with-no-name","text":"","title":"ES.84: Don't try to declare a local variable with no name"},{"location":"cppcg/CppCoreGuidelines/#reason_252","text":"There is no such thing. What looks to a human like a variable without a name is to the compiler a statement consisting of a temporary that immediately goes out of scope.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_100","text":"void f() { lock<mutex>{mx}; // Bad // ... } This declares an unnamed lock object that immediately goes out of scope at the point of the semicolon. This is not an uncommon mistake. In particular, this particular example can lead to hard-to find race conditions.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_221","text":"Unnamed function arguments are fine.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_242","text":"Flag statements that are just a temporary.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es85-make-empty-statements-visible","text":"","title":"ES.85: Make empty statements visible"},{"location":"cppcg/CppCoreGuidelines/#reason_253","text":"Readability.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_233","text":"for (i = 0; i < max; ++i); // BAD: the empty statement is easily overlooked v[i] = f(v[i]); for (auto x : v) { // better // nothing } v[i] = f(v[i]);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_243","text":"Flag empty statements that are not blocks and don\u2019t contain comments.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es86-avoid-modifying-loop-control-variables-inside-the-body-of-raw-for-loops","text":"","title":"ES.86: Avoid modifying loop control variables inside the body of raw for-loops"},{"location":"cppcg/CppCoreGuidelines/#reason_254","text":"The loop control up front should enable correct reasoning about what is happening inside the loop. Modifying loop counters in both the iteration-expression and inside the body of the loop is a perennial source of surprises and bugs.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_234","text":"for (int i = 0; i < 10; ++i) { // no updates to i -- ok } for (int i = 0; i < 10; ++i) { // if (/* something */) ++i; // BAD // } bool skip = false; for (int i = 0; i < 10; ++i) { if (skip) { skip = false; continue; } // if (/* something */) skip = true; // Better: using two variables for two concepts. // }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_244","text":"Flag variables that are potentially updated (have a non- const use) in both the loop control iteration-expression and the loop body.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es87-dont-add-redundant-or-to-conditions","text":"","title":"ES.87: Don't add redundant == or != to conditions"},{"location":"cppcg/CppCoreGuidelines/#reason_255","text":"Doing so avoids verbosity and eliminates some opportunities for mistakes. Helps make style consistent and conventional.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_235","text":"By definition, a condition in an if -statement, while -statement, or a for -statement selects between true and false . A numeric value is compared to 0 and a pointer value to nullptr . // These all mean \"if `p` is not `nullptr`\" if (p) { ... } // good if (p != 0) { ... } // redundant `!=0`; bad: don't use 0 for pointers if (p != nullptr) { ... } // redundant `!=nullptr`, not recommended Often, if (p) is read as \u201cif p is valid\u201d which is a direct expression of the programmers intent, whereas if (p != nullptr) would be a long-winded workaround.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_236","text":"This rule is especially useful when a declaration is used as a condition if (auto pc = dynamic_cast<Circle>(ps)) { ... } // execute if ps points to a kind of Circle, good if (auto pc = dynamic_cast<Circle>(ps); pc != nullptr) { ... } // not recommended","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_237","text":"Note that implicit conversions to bool are applied in conditions. For example: for (string s; cin >> s; ) v.push_back(s); This invokes istream \u2018s operator bool() .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_222","text":"Explicit comparison of an integer to 0 is in general not redundant. The reason is that (as opposed to pointers and Booleans) an integer often has more than two reasonable values. Furthermore 0 (zero) is often used to indicate success. Consequently, it is best to be specific about the comparison. void f(int i) { if (i) // suspect // ... if (i == success) // possibly better // ... } Always remember that an integer can have more than two values.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad_101","text":"It has been noted that if(strcmp(p1, p2)) { ... } // are the two C-style strings equal? (mistake!) is a common beginners error. If you use C-style strings, you must know the <cstring> functions well. Being verbose and writing if(strcmp(p1, p2) != 0) { ... } // are the two C-style strings equal? (mistake!) would not in itself save you.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_223","text":"The opposite condition is most easily expressed using a negation: // These all mean \"if `p` is `nullptr`\" if (!p) { ... } // good if (p == 0) { ... } // redundant `== 0`; bad: don't use `0` for pointers if (p == nullptr) { ... } // redundant `== nullptr`, not recommended","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_245","text":"Easy, just check for redundant use of != and == in conditions.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#arithmetic","text":"","title":"Arithmetic"},{"location":"cppcg/CppCoreGuidelines/#es100-dont-mix-signed-and-unsigned-arithmetic","text":"","title":"ES.100: Don't mix signed and unsigned arithmetic"},{"location":"cppcg/CppCoreGuidelines/#reason_256","text":"Avoid wrong results.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_238","text":"int x = -3; unsigned int y = 7; cout << x - y << '\\n'; // unsigned result, possibly 4294967286 cout << x + y << '\\n'; // unsigned result: 4 cout << x * y << '\\n'; // unsigned result, possibly 4294967275 It is harder to spot the problem in more realistic examples.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_224","text":"Unfortunately, C++ uses signed integers for array subscripts and the standard library uses unsigned integers for container subscripts. This precludes consistency. Use gsl::index for subscripts; see ES.107 .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_246","text":"Compilers already know and sometimes warn. (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is sizeof or a call to container .size() and the other is ptrdiff_t .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es101-use-unsigned-types-for-bit-manipulation","text":"","title":"ES.101: Use unsigned types for bit manipulation"},{"location":"cppcg/CppCoreGuidelines/#reason_257","text":"Unsigned types support bit manipulation without surprises from sign bits.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_239","text":"unsigned char x = 0b1010'1010; unsigned char y = ~x; // y == 0b0101'0101;","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_225","text":"Unsigned types can also be useful for modulo arithmetic. However, if you want modulo arithmetic add comments as necessary noting the reliance on wraparound behavior, as such code can be surprising for many programmers.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_247","text":"Just about impossible in general because of the use of unsigned subscripts in the standard library ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es102-use-signed-types-for-arithmetic","text":"","title":"ES.102: Use signed types for arithmetic"},{"location":"cppcg/CppCoreGuidelines/#reason_258","text":"Because most arithmetic is assumed to be signed; x - y yields a negative number when y > x except in the rare cases where you really want modulo arithmetic.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_240","text":"Unsigned arithmetic can yield surprising results if you are not expecting it. This is even more true for mixed signed and unsigned arithmetic. template<typename T, typename T2> T subtract(T x, T2 y) { return x - y; } void test() { int s = 5; unsigned int us = 5; cout << subtract(s, 7) << '\\n'; // -2 cout << subtract(us, 7u) << '\\n'; // 4294967294 cout << subtract(s, 7u) << '\\n'; // -2 cout << subtract(us, 7) << '\\n'; // 4294967294 cout << subtract(s, us + 2) << '\\n'; // -2 cout << subtract(us, s + 2) << '\\n'; // 4294967294 } Here we have been very explicit about what\u2019s happening, but if you had seen us - (s + 2) or s += 2; ...; us - s , would you reliably have suspected that the result would print as 4294967294 ?","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_44","text":"Use unsigned types if you really want modulo arithmetic - add comments as necessary noting the reliance on overflow behavior, as such code is going to be surprising for many programmers.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#example_241","text":"The standard library uses unsigned types for subscripts. The built-in array uses signed types for subscripts. This makes surprises (and bugs) inevitable. int a[10]; for (int i = 0; i < 10; ++i) a[i] = i; vector<int> v(10); // compares signed to unsigned; some compilers warn, but we should not for (gsl::index i = 0; i < v.size(); ++i) v[i] = i; int a2[-2]; // error: negative size // OK, but the number of ints (4294967294) is so large that we should get an exception vector<int> v2(-2); Use gsl::index for subscripts; see ES.107 .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_248","text":"Flag mixed signed and unsigned arithmetic Flag results of unsigned arithmetic assigned to or printed as signed. Flag negative literals (e.g. -2 ) used as container subscripts. (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is sizeof or a call to container .size() and the other is ptrdiff_t .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es103-dont-overflow","text":"","title":"ES.103: Don't overflow"},{"location":"cppcg/CppCoreGuidelines/#reason_259","text":"Overflow usually makes your numeric algorithm meaningless. Incrementing a value beyond a maximum value can lead to memory corruption and undefined behavior.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_102","text":"int a[10]; a[10] = 7; // bad int n = 0; while (n++ < 10) a[n - 1] = 9; // bad (twice)","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-bad_103","text":"int n = numeric_limits<int>::max(); int m = n + 1; // bad","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-bad_104","text":"int area(int h, int w) { return h * w; } auto a = area(10'000'000, 100'000'000); // bad","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#exception_45","text":"Use unsigned types if you really want modulo arithmetic. Alternative : For critical applications that can afford some overhead, use a range-checked integer and/or floating-point type.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_249","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es104-dont-underflow","text":"","title":"ES.104: Don't underflow"},{"location":"cppcg/CppCoreGuidelines/#reason_260","text":"Decrementing a value beyond a minimum value can lead to memory corruption and undefined behavior.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_105","text":"int a[10]; a[-2] = 7; // bad int n = 101; while (n--) a[n - 1] = 9; // bad (twice)","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#exception_46","text":"Use unsigned types if you really want modulo arithmetic.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_250","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es105-dont-divide-by-zero","text":"","title":"ES.105: Don't divide by zero"},{"location":"cppcg/CppCoreGuidelines/#reason_261","text":"The result is undefined and probably a crash.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_226","text":"This also applies to % .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad_106","text":"double divide(int a, int b) { // BAD, should be checked (e.g., in a precondition) return a / b; }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_18","text":"double divide(int a, int b) { // good, address via precondition (and replace with contracts once C++ gets them) Expects(b != 0); return a / b; } double divide(int a, int b) { // good, address via check return b ? a / b : quiet_NaN<double>(); } Alternative : For critical applications that can afford some overhead, use a range-checked integer and/or floating-point type.","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#enforcement_251","text":"Flag division by an integral value that could be zero","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es106-dont-try-to-avoid-negative-values-by-using-unsigned","text":"","title":"ES.106: Don't try to avoid negative values by using unsigned"},{"location":"cppcg/CppCoreGuidelines/#reason_262","text":"Choosing unsigned implies many changes to the usual behavior of integers, including modulo arithmetic, can suppress warnings related to overflow, and opens the door for errors related to signed/unsigned mixes. Using unsigned doesn\u2019t actually eliminate the possibility of negative values.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_242","text":"unsigned int u1 = -2; // Valid: the value of u1 is 4294967294 int i1 = -2; unsigned int u2 = i1; // Valid: the value of u2 is 4294967294 int i2 = u2; // Valid: the value of i2 is -2 These problems with such (perfectly legal) constructs are hard to spot in real code and are the source of many real-world errors. Consider: unsigned area(unsigned height, unsigned width) { return height*width; } // [see also](#Ri-expects) // ... int height; cin >> height; auto a = area(height, 2); // if the input is -2 a becomes 4294967292 Remember that -1 when assigned to an unsigned int becomes the largest unsigned int . Also, since unsigned arithmetic is modulo arithmetic the multiplication didn\u2019t overflow, it wrapped around.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_243","text":"unsigned max = 100000; // \"accidental typo\", I mean to say 10'000 unsigned short x = 100; while (x < max) x += 100; // infinite loop Had x been a signed short , we could have warned about the undefined behavior upon overflow.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#alternatives_2","text":"use signed integers and check for x >= 0 use a positive integer type use an integer subrange type Assert(-1 < x) For example struct Positive { int val; Positive(int x) :val{x} { Assert(0 < x); } operator int() { return val; } }; int f(Positive arg) { return arg; } int r1 = f(2); int r2 = f(-2); // throws","title":"Alternatives"},{"location":"cppcg/CppCoreGuidelines/#note_227","text":"???","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_252","text":"See ES.100 Enforcements.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#es107-dont-use-unsigned-for-subscripts-prefer-gslindex","text":"","title":"ES.107: Don't use unsigned for subscripts, prefer gsl::index"},{"location":"cppcg/CppCoreGuidelines/#reason_263","text":"To avoid signed/unsigned confusion. To enable better optimization. To enable better error detection. To avoid the pitfalls with auto and int .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_107","text":"vector<int> vec = /*...*/; for (int i = 0; i < vec.size(); i += 2) // may not be big enough cout << vec[i] << '\\n'; for (unsigned i = 0; i < vec.size(); i += 2) // risk wraparound cout << vec[i] << '\\n'; for (auto i = 0; i < vec.size(); i += 2) // may not be big enough cout << vec[i] << '\\n'; for (vector<int>::size_type i = 0; i < vec.size(); i += 2) // verbose cout << vec[i] << '\\n'; for (auto i = vec.size()-1; i >= 0; i -= 2) // bug cout << vec[i] << '\\n'; for (int i = vec.size()-1; i >= 0; i -= 2) // may not be big enough cout << vec[i] << '\\n';","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_19","text":"vector<int> vec = /*...*/; for (gsl::index i = 0; i < vec.size(); i += 2) // ok cout << vec[i] << '\\n'; for (gsl::index i = vec.size()-1; i >= 0; i -= 2) // ok cout << vec[i] << '\\n';","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#note_228","text":"The built-in array uses signed subscripts. The standard-library containers use unsigned subscripts. Thus, no perfect and fully compatible solution is possible (unless and until the standard-library containers change to use signed subscripts someday in the future). Given the known problems with unsigned and signed/unsigned mixtures, better stick to (signed) integers of a sufficient size, which is guaranteed by gsl::index .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_244","text":"template<typename T> struct My_container { public: // ... T& operator[](gsl::index i); // not unsigned // ... };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_245","text":"??? demonstrate improved code generation and potential for error detection ???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#alternatives_3","text":"Alternatives for users use algorithms use range-for use iterators/pointers","title":"Alternatives"},{"location":"cppcg/CppCoreGuidelines/#enforcement_253","text":"Very tricky as long as the standard-library containers get it wrong. (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is sizeof or a call to container .size() and the other is ptrdiff_t .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#per-performance","text":"??? should this section be in the main guide??? This section contains rules for people who need high performance or low-latency. That is, these are rules that relate to how to use as little time and as few resources as possible to achieve a task in a predictably short time. The rules in this section are more restrictive and intrusive than what is needed for many (most) applications. Do not blindly try to follow them in general code: achieving the goals of low latency requires extra work. Performance rule summary: Per.1: Don\u2019t optimize without reason Per.2: Don\u2019t optimize prematurely Per.3: Don\u2019t optimize something that\u2019s not performance critical Per.4: Don\u2019t assume that complicated code is necessarily faster than simple code Per.5: Don\u2019t assume that low-level code is necessarily faster than high-level code Per.6: Don\u2019t make claims about performance without measurements Per.7: Design to enable optimization Per.10: Rely on the static type system Per.11: Move computation from run time to compile time Per.12: Eliminate redundant aliases Per.13: Eliminate redundant indirections Per.14: Minimize the number of allocations and deallocations Per.15: Do not allocate on a critical branch Per.16: Use compact data structures Per.17: Declare the most used member of a time-critical struct first Per.18: Space is time Per.19: Access memory predictably Per.30: Avoid context switches on the critical path","title":"Per: Performance"},{"location":"cppcg/CppCoreGuidelines/#per1-dont-optimize-without-reason","text":"","title":"Per.1: Don't optimize without reason"},{"location":"cppcg/CppCoreGuidelines/#reason_264","text":"If there is no need for optimization, the main result of the effort will be more errors and higher maintenance costs.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_229","text":"Some people optimize out of habit or because it\u2019s fun. ???","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#per2-dont-optimize-prematurely","text":"","title":"Per.2: Don't optimize prematurely"},{"location":"cppcg/CppCoreGuidelines/#reason_265","text":"Elaborately optimized code is usually larger and harder to change than unoptimized code. ???","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#per3-dont-optimize-something-thats-not-performance-critical","text":"","title":"Per.3: Don't optimize something that's not performance critical"},{"location":"cppcg/CppCoreGuidelines/#reason_266","text":"Optimizing a non-performance-critical part of a program has no effect on system performance.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_230","text":"If your program spends most of its time waiting for the web or for a human, optimization of in-memory computation is probably useless. Put another way: If your program spends 4% of its processing time doing computation A and 40% of its time doing computation B, a 50% improvement on A is only as impactful as a 5% improvement on B. (If you don\u2019t even know how much time is spent on A or B, see Per.1 and Per.2 .)","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#per4-dont-assume-that-complicated-code-is-necessarily-faster-than-simple-code","text":"","title":"Per.4: Don't assume that complicated code is necessarily faster than simple code"},{"location":"cppcg/CppCoreGuidelines/#reason_267","text":"Simple code can be very fast. Optimizers sometimes do marvels with simple code","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-good_20","text":"// clear expression of intent, fast execution vector<uint8_t> v(100000); for (auto& c : v) c = ~c;","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#example-bad_108","text":"// intended to be faster, but is actually slower vector<uint8_t> v(100000); for (size_t i = 0; i < v.size(); i += sizeof(uint64_t)) { uint64_t& quad_word = *reinterpret_cast<uint64_t*>(&v[i]); quad_word = ~quad_word; }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_231","text":"??? ???","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#per5-dont-assume-that-low-level-code-is-necessarily-faster-than-high-level-code","text":"","title":"Per.5: Don't assume that low-level code is necessarily faster than high-level code"},{"location":"cppcg/CppCoreGuidelines/#reason_268","text":"Low-level code sometimes inhibits optimizations. Optimizers sometimes do marvels with high-level code.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_232","text":"??? ???","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#per6-dont-make-claims-about-performance-without-measurements","text":"","title":"Per.6: Don't make claims about performance without measurements"},{"location":"cppcg/CppCoreGuidelines/#reason_269","text":"The field of performance is littered with myth and bogus folklore. Modern hardware and optimizers defy naive assumptions; even experts are regularly surprised.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_233","text":"Getting good performance measurements can be hard and require specialized tools.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_234","text":"A few simple microbenchmarks using Unix time or the standard-library <chrono> can help dispel the most obvious myths. If you can\u2019t measure your complete system accurately, at least try to measure a few of your key operations and algorithms. A profiler can help tell you which parts of your system are performance critical. Often, you will be surprised. ???","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#per7-design-to-enable-optimization","text":"","title":"Per.7: Design to enable optimization"},{"location":"cppcg/CppCoreGuidelines/#reason_270","text":"Because we often need to optimize the initial design. Because a design that ignores the possibility of later improvement is hard to change.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_246","text":"From the C (and C++) standard: void qsort (void* base, size_t num, size_t size, int (*compar)(const void*, const void*)); When did you even want to sort memory? Really, we sort sequences of elements, typically stored in containers. A call to qsort throws away much useful information (e.g., the element type), forces the user to repeat information already known (e.g., the element size), and forces the user to write extra code (e.g., a function to compare double s). This implies added work for the programmer, is error-prone, and deprives the compiler of information needed for optimization. double data[100]; // ... fill a ... // 100 chunks of memory of sizeof(double) starting at // address data using the order defined by compare_doubles qsort(data, 100, sizeof(double), compare_doubles); From the point of view of interface design is that qsort throws away useful information. We can do better (in C++98) template<typename Iter> void sort(Iter b, Iter e); // sort [b:e) sort(data, data + 100); Here, we use the compiler\u2019s knowledge about the size of the array, the type of elements, and how to compare double s. With C++11 plus concepts , we can do better still // Sortable specifies that c must be a // random-access sequence of elements comparable with < void sort(Sortable& c); sort(c); The key is to pass sufficient information for a good implementation to be chosen. In this, the sort interfaces shown here still have a weakness: They implicitly rely on the element type having less-than ( < ) defined. To complete the interface, we need a second version that accepts a comparison criteria: // compare elements of c using p void sort(Sortable& c, Predicate<Value_type<Sortable>> p); The standard-library specification of sort offers those two versions, but the semantics is expressed in English rather than code using concepts.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_235","text":"Premature optimization is said to be the root of all evil , but that\u2019s not a reason to despise performance. It is never premature to consider what makes a design amenable to improvement, and improved performance is a commonly desired improvement. Aim to build a set of habits that by default results in efficient, maintainable, and optimizable code. In particular, when you write a function that is not a one-off implementation detail, consider Information passing: Prefer clean interfaces carrying sufficient information for later improvement of implementation. Note that information flows into and out of an implementation through the interfaces we provide. Compact data: By default, use compact data , such as std::vector and access it in a systematic fashion . If you think you need a linked structure, try to craft the interface so that this structure isn\u2019t seen by users. Function argument passing and return: Distinguish between mutable and non-mutable data. Don\u2019t impose a resource management burden on your users. Don\u2019t impose spurious run-time indirections on your users. Use conventional ways of passing information through an interface; unconventional and/or \u201coptimized\u201d ways of passing data can seriously complicate later reimplementation. Abstraction: Don\u2019t overgeneralize; a design that tries to cater for every possible use (and misuse) and defers every design decision for later (using compile-time or run-time indirections) is usually a complicated, bloated, hard-to-understand mess. Generalize from concrete examples, preserving performance as we generalize. Do not generalize based on mere speculation about future needs. The ideal is zero-overhead generalization. Libraries: Use libraries with good interfaces. If no library is available build one yourself and imitate the interface style from a good library. The standard library is a good first place to look for inspiration. Isolation: Isolate your code from messy and/or old-style code by providing an interface of your choosing to it. This is sometimes called \u201cproviding a wrapper\u201d for the useful/necessary but messy code. Don\u2019t let bad designs \u201cbleed into\u201d your code.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_247","text":"Consider: template <class ForwardIterator, class T> bool binary_search(ForwardIterator first, ForwardIterator last, const T& val); binary_search(begin(c), end(c), 7) will tell you whether 7 is in c or not. However, it will not tell you where that 7 is or whether there are more than one 7 . Sometimes, just passing the minimal amount of information back (here, true or false ) is sufficient, but a good interface passes needed information back to the caller. Therefore, the standard library also offers template <class ForwardIterator, class T> ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T& val); lower_bound returns an iterator to the first match if any, otherwise to the first element greater than val , or last if no such element is found. However, lower_bound still doesn\u2019t return enough information for all uses, so the standard library also offers template <class ForwardIterator, class T> pair<ForwardIterator, ForwardIterator> equal_range(ForwardIterator first, ForwardIterator last, const T& val); equal_range returns a pair of iterators specifying the first and one beyond last match. auto r = equal_range(begin(c), end(c), 7); for (auto p = r.first; p != r.second; ++p) cout << *p << '\\n'; Obviously, these three interfaces are implemented by the same basic code. They are simply three ways of presenting the basic binary search algorithm to users, ranging from the simplest (\u201cmake simple things simple!\u201d) to returning complete, but not always needed, information (\u201cdon\u2019t hide useful information\u201d). Naturally, crafting such a set of interfaces requires experience and domain knowledge.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_236","text":"Do not simply craft the interface to match the first implementation and the first use case you think of. Once your first initial implementation is complete, review it; once you deploy it, mistakes will be hard to remedy.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_237","text":"A need for efficiency does not imply a need for low-level code . High-level code does not imply slow or bloated.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_238","text":"Things have costs. Don\u2019t be paranoid about costs (modern computers really are very fast), but have a rough idea of the order of magnitude of cost of what you use. For example, have a rough idea of the cost of a memory access, a function call, a string comparison, a system call, a disk access, and a message through a network.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_239","text":"If you can only think of one implementation, you probably don\u2019t have something for which you can devise a stable interface. Maybe, it is just an implementation detail - not every piece of code needs a stable interface - but pause and consider. One question that can be useful is \u201cwhat interface would be needed if this operation should be implemented using multiple threads? be vectorized?\u201d","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_240","text":"This rule does not contradict the Don\u2019t optimize prematurely rule. It complements it encouraging developers enable later - appropriate and non-premature - optimization, if and where needed.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_254","text":"Tricky. Maybe looking for void* function arguments will find examples of interfaces that hinder later optimization.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#per10-rely-on-the-static-type-system","text":"","title":"Per.10: Rely on the static type system"},{"location":"cppcg/CppCoreGuidelines/#reason_271","text":"Type violations, weak types (e.g. void* s), and low-level code (e.g., manipulation of sequences as individual bytes) make the job of the optimizer much harder. Simple code often optimizes better than hand-crafted complex code. ???","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#per11-move-computation-from-run-time-to-compile-time","text":"","title":"Per.11: Move computation from run time to compile time"},{"location":"cppcg/CppCoreGuidelines/#reason_272","text":"To decrease code size and run time. To avoid data races by using constants. To catch errors at compile time (and thus eliminate the need for error-handling code).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_248","text":"double square(double d) { return d*d; } static double s2 = square(2); // old-style: dynamic initialization constexpr double ntimes(double d, int n) // assume 0 <= n { double m = 1; while (n--) m *= d; return m; } constexpr double s3 {ntimes(2, 3)}; // modern-style: compile-time initialization Code like the initialization of s2 isn\u2019t uncommon, especially for initialization that\u2019s a bit more complicated than square() . However, compared to the initialization of s3 there are two problems: we suffer the overhead of a function call at run time s2 just might be accessed by another thread before the initialization happens. Note: you can\u2019t have a data race on a constant.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_249","text":"Consider a popular technique for providing a handle for storing small objects in the handle itself and larger ones on the heap. constexpr int on_stack_max = 20; template<typename T> struct Scoped { // store a T in Scoped // ... T obj; }; template<typename T> struct On_heap { // store a T on the free store // ... T* objp; }; template<typename T> using Handle = typename std::conditional<(sizeof(T) <= on_stack_max), Scoped<T>, // first alternative On_heap<T> // second alternative >::type; void f() { Handle<double> v1; // the double goes on the stack Handle<std::array<double, 200>> v2; // the array goes on the free store // ... } Assume that Scoped and On_heap provide compatible user interfaces. Here we compute the optimal type to use at compile time. There are similar techniques for selecting the optimal function to call.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_241","text":"The ideal is {not} to try execute everything at compile time. Obviously, most computations depend on inputs so they can\u2019t be moved to compile time, but beyond that logical constraint is the fact that complex compile-time computation can seriously increase compile times and complicate debugging. It is even possible to slow down code by compile-time computation. This is admittedly rare, but by factoring out a general computation into separate optimal sub-calculations it is possible to render the instruction cache less effective.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_255","text":"Look for simple functions that might be constexpr (but are not). Look for functions called with all constant-expression arguments. Look for macros that could be constexpr.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#per12-eliminate-redundant-aliases","text":"???","title":"Per.12: Eliminate redundant aliases"},{"location":"cppcg/CppCoreGuidelines/#per13-eliminate-redundant-indirections","text":"???","title":"Per.13: Eliminate redundant indirections"},{"location":"cppcg/CppCoreGuidelines/#per14-minimize-the-number-of-allocations-and-deallocations","text":"???","title":"Per.14: Minimize the number of allocations and deallocations"},{"location":"cppcg/CppCoreGuidelines/#per15-do-not-allocate-on-a-critical-branch","text":"???","title":"Per.15: Do not allocate on a critical branch"},{"location":"cppcg/CppCoreGuidelines/#per16-use-compact-data-structures","text":"","title":"Per.16: Use compact data structures"},{"location":"cppcg/CppCoreGuidelines/#reason_273","text":"Performance is typically dominated by memory access times. ???","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#per17-declare-the-most-used-member-of-a-time-critical-struct-first","text":"???","title":"Per.17: Declare the most used member of a time-critical struct first"},{"location":"cppcg/CppCoreGuidelines/#per18-space-is-time","text":"","title":"Per.18: Space is time"},{"location":"cppcg/CppCoreGuidelines/#reason_274","text":"Performance is typically dominated by memory access times. ???","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#per19-access-memory-predictably","text":"","title":"Per.19: Access memory predictably"},{"location":"cppcg/CppCoreGuidelines/#reason_275","text":"Performance is very sensitive to cache performance and cache algorithms favor simple (usually linear) access to adjacent data.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_250","text":"int matrix[rows][cols]; // bad for (int c = 0; c < cols; ++c) for (int r = 0; r < rows; ++r) sum += matrix[r][c]; // good for (int r = 0; r < rows; ++r) for (int c = 0; c < cols; ++c) sum += matrix[r][c];","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#per30-avoid-context-switches-on-the-critical-path","text":"???","title":"Per.30: Avoid context switches on the critical path"},{"location":"cppcg/CppCoreGuidelines/#cp-concurrency-and-parallelism","text":"We often want our computers to do many tasks at the same time (or at least appear to do them at the same time). The reasons for doing so vary (e.g., waiting for many events using only a single processor, processing many data streams simultaneously, or utilizing many hardware facilities) and so do the basic facilities for expressing concurrency and parallelism. Here, we articulate principles and rules for using the ISO standard C++ facilities for expressing basic concurrency and parallelism. Threads are the machine-level foundation for concurrent and parallel programming. Threads allow running multiple sections of a program independently, while sharing the same memory. Concurrent programming is tricky, because protecting shared data between threads is easier said than done. Making existing single-threaded code execute concurrently can be as trivial as adding std::async or std::thread strategically, or it can necessitate a full rewrite, depending on whether the original code was written in a thread-friendly way. The concurrency/parallelism rules in this document are designed with three goals in mind: To help in writing code that is amenable to being used in a threaded environment To show clean, safe ways to use the threading primitives offered by the standard library To offer guidance on what to do when concurrency and parallelism aren\u2019t giving the performance gains needed It is also important to note that concurrency in C++ is an unfinished story. C++11 introduced many core concurrency primitives, C++14 and C++17 improved on them, and there is much interest in making the writing of concurrent programs in C++ even easier. We expect some of the library-related guidance here to change significantly over time. This section needs a lot of work (obviously). Please note that we start with rules for relative non-experts. Real experts must wait a bit; contributions are welcome, but please think about the majority of programmers who are struggling to get their concurrent programs correct and performant. Concurrency and parallelism rule summary: CP.1: Assume that your code will run as part of a multi-threaded program CP.2: Avoid data races CP.3: Minimize explicit sharing of writable data CP.4: Think in terms of tasks, rather than threads CP.8: Don\u2019t try to use volatile for synchronization CP.9: Whenever feasible use tools to validate your concurrent code See also : CP.con: Concurrency CP.par: Parallelism CP.mess: Message passing CP.vec: Vectorization CP.free: Lock-free programming CP.etc: Etc. concurrency rules","title":"CP: Concurrency and parallelism"},{"location":"cppcg/CppCoreGuidelines/#cp1-assume-that-your-code-will-run-as-part-of-a-multi-threaded-program","text":"","title":"CP.1: Assume that your code will run as part of a multi-threaded program"},{"location":"cppcg/CppCoreGuidelines/#reason_276","text":"It\u2019s hard to be certain that concurrency isn\u2019t used now or won\u2019t be used sometime in the future. Code gets reused. Libraries not using threads may be used from some other part of a program that does use threads. Note that this rule applies most urgently to library code and least urgently to stand-alone applications. However, over time, code fragments can turn up in unexpected places.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_109","text":"double cached_computation(double x) { // bad: these two statics cause data races in multi-threaded usage static double cached_x = 0.0; static double cached_result = COMPUTATION_OF_ZERO; double result; if (cached_x == x) return cached_result; result = computation(x); cached_x = x; cached_result = result; return result; } Although cached_computation works perfectly in a single-threaded environment, in a multi-threaded environment the two static variables result in data races and thus undefined behavior. There are several ways that this example could be made safe for a multi-threaded environment: Delegate concurrency concerns upwards to the caller. Mark the static variables as thread_local (which might make caching less effective). Implement concurrency control, for example, protecting the two static variables with a static lock (which might reduce performance). Have the caller provide the memory to be used for the cache, thereby delegating both memory allocation and concurrency concerns upwards to the caller. Refuse to build and/or run in a multi-threaded environment. Provide two implementations, one which is used in single-threaded environments and another which is used in multi-threaded environments.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#exception_47","text":"Code that is never run in a multi-threaded environment. Be careful: there are many examples where code that was \u201cknown\u201d to never run in a multi-threaded program was run as part of a multi-threaded program, often years later. Typically, such programs lead to a painful effort to remove data races. Therefore, code that is never intended to run in a multi-threaded environment should be clearly labeled as such and ideally come with compile or run-time enforcement mechanisms to catch those usage bugs early.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#cp2-avoid-data-races","text":"","title":"CP.2: Avoid data races"},{"location":"cppcg/CppCoreGuidelines/#reason_277","text":"Unless you do, nothing is guaranteed to work and subtle errors will persist.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_242","text":"In a nutshell, if two threads can access the same object concurrently (without synchronization), and at least one is a writer (performing a non- const operation), you have a data race. For further information of how to use synchronization well to eliminate data races, please consult a good book about concurrency.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad_110","text":"There are many examples of data races that exist, some of which are running in production software at this very moment. One very simple example: int get_id() { static int id = 1; return id++; } The increment here is an example of a data race. This can go wrong in many ways, including: Thread A loads the value of id , the OS context switches A out for some period, during which other threads create hundreds of IDs. Thread A is then allowed to run again, and id is written back to that location as A\u2019s read of id plus one. Thread A and B load id and increment it simultaneously. They both get the same ID. Local static variables are a common source of data races.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-bad_111","text":"void f(fstream& fs, regex pattern) { array<double, max> buf; int sz = read_vec(fs, buf, max); // read from fs into buf gsl::span<double> s {buf}; // ... auto h1 = async([&]{ sort(std::execution::par, s); }); // spawn a task to sort // ... auto h2 = async([&]{ return find_all(buf, sz, pattern); }); // spawn a task to find matches // ... } Here, we have a (nasty) data race on the elements of buf ( sort will both read and write). All data races are nasty. Here, we managed to get a data race on data on the stack. Not all data races are as easy to spot as this one.","title":"Example, bad:"},{"location":"cppcg/CppCoreGuidelines/#example-bad_112","text":"// code not controlled by a lock unsigned val; if (val < 5) { // ... other thread can change val here ... switch (val) { case 0: // ... case 1: // ... case 2: // ... case 3: // ... case 4: // ... } } Now, a compiler that does not know that val can change will most likely implement that switch using a jump table with five entries. Then, a val outside the [0..4] range will cause a jump to an address that could be anywhere in the program, and execution would proceed there. Really, \u201call bets are off\u201d if you get a data race. Actually, it can be worse still: by looking at the generated code you may be able to determine where the stray jump will go for a given value; this can be a security risk.","title":"Example, bad:"},{"location":"cppcg/CppCoreGuidelines/#enforcement_256","text":"Some is possible, do at least something. There are commercial and open-source tools that try to address this problem, but be aware that solutions have costs and blind spots. Static tools often have many false positives and run-time tools often have a significant cost. We hope for better tools. Using multiple tools can catch more problems than a single one. There are other ways you can mitigate the chance of data races: Avoid global data Avoid static variables More use of value types on the stack (and don\u2019t pass pointers around too much) More use of immutable data (literals, constexpr , and const )","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp3-minimize-explicit-sharing-of-writable-data","text":"","title":"CP.3: Minimize explicit sharing of writable data"},{"location":"cppcg/CppCoreGuidelines/#reason_278","text":"If you don\u2019t share writable data, you can\u2019t have a data race. The less sharing you do, the less chance you have to forget to synchronize access (and get data races). The less sharing you do, the less chance you have to wait on a lock (so performance can improve).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_251","text":"bool validate(const vector<Reading>&); Graph<Temp_node> temperature_gradiants(const vector<Reading>&); Image altitude_map(const vector<Reading>&); // ... void process_readings(const vector<Reading>& surface_readings) { auto h1 = async([&] { if (!validate(surface_readings)) throw Invalid_data{}; }); auto h2 = async([&] { return temperature_gradiants(surface_readings); }); auto h3 = async([&] { return altitude_map(surface_readings); }); // ... h1.get(); auto v2 = h2.get(); auto v3 = h3.get(); // ... } Without those const s, we would have to review every asynchronously invoked function for potential data races on surface_readings . Making surface_readings be const (with respect to this function) allow reasoning using only the function body.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_243","text":"Immutable data can be safely and efficiently shared. No locking is needed: You can\u2019t have a data race on a constant. See also CP.mess: Message Passing and CP.31: prefer pass by value .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_257","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp4-think-in-terms-of-tasks-rather-than-threads","text":"","title":"CP.4: Think in terms of tasks, rather than threads"},{"location":"cppcg/CppCoreGuidelines/#reason_279","text":"A thread is an implementation concept, a way of thinking about the machine. A task is an application notion, something you\u2019d like to do, preferably concurrently with other tasks. Application concepts are easier to reason about.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_252","text":"void some_fun() { std::string msg, msg2; std::thread publisher([&] { msg = \"Hello\"; }); // bad: less expressive // and more error-prone auto pubtask = std::async([&] { msg2 = \"Hello\"; }); // OK // ... publisher.join(); }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_244","text":"With the exception of async() , the standard-library facilities are low-level, machine-oriented, threads-and-lock level. This is a necessary foundation, but we have to try to raise the level of abstraction: for productivity, for reliability, and for performance. This is a potent argument for using higher level, more applications-oriented libraries (if possibly, built on top of standard-library facilities).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_258","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp8-dont-try-to-use-volatile-for-synchronization","text":"","title":"CP.8: Don't try to use volatile for synchronization"},{"location":"cppcg/CppCoreGuidelines/#reason_280","text":"In C++, unlike some other languages, volatile does not provide atomicity, does not synchronize between threads, and does not prevent instruction reordering (neither compiler nor hardware). It simply has nothing to do with concurrency.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_113","text":"int free_slots = max_slots; // current source of memory for objects Pool* use() { if (int n = free_slots--) return &pool[n]; } Here we have a problem: This is perfectly good code in a single-threaded program, but have two threads execute this and there is a race condition on free_slots so that two threads might get the same value and free_slots . That\u2019s (obviously) a bad data race, so people trained in other languages may try to fix it like this: volatile int free_slots = max_slots; // current source of memory for objects Pool* use() { if (int n = free_slots--) return &pool[n]; } This has no effect on synchronization: The data race is still there! The C++ mechanism for this is atomic types: atomic<int> free_slots = max_slots; // current source of memory for objects Pool* use() { if (int n = free_slots--) return &pool[n]; } Now the -- operation is atomic, rather than a read-increment-write sequence where another thread might get in-between the individual operations.","title":"Example, bad:"},{"location":"cppcg/CppCoreGuidelines/#alternative_10","text":"Use atomic types where you might have used volatile in some other language. Use a mutex for more complicated examples.","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#see-also_3","text":"(rare) proper uses of volatile","title":"See also"},{"location":"cppcg/CppCoreGuidelines/#cp9-whenever-feasible-use-tools-to-validate-your-concurrent-code","text":"Experience shows that concurrent code is exceptionally hard to get right and that compile-time checking, run-time checks, and testing are less effective at finding concurrency errors than they are at finding errors in sequential code. Subtle concurrency errors can have dramatically bad effects, including memory corruption and deadlocks.","title":"CP.9: Whenever feasible use tools to validate your concurrent code"},{"location":"cppcg/CppCoreGuidelines/#example_253","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_245","text":"Thread safety is challenging, often getting the better of experienced programmers: tooling is an important strategy to mitigate those risks. There are many tools \u201cout there\u201d, both commercial and open-source tools, both research and production tools. Unfortunately people\u2019s needs and constraints differ so dramatically that we cannot make specific recommendations, but we can mention: Static enforcement tools: both clang and some older versions of GCC have some support for static annotation of thread safety properties. Consistent use of this technique turns many classes of thread-safety errors into compile-time errors. The annotations are generally local (marking a particular member variable as guarded by a particular mutex), and are usually easy to learn. However, as with many static tools, it can often present false negatives; cases that should have been caught but were allowed. dynamic enforcement tools: Clang\u2019s Thread Sanitizer (aka TSAN) is a powerful example of dynamic tools: it changes the build and execution of your program to add bookkeeping on memory access, absolutely identifying data races in a given execution of your binary. The cost for this is both memory (5-10x in most cases) and CPU slowdown (2-20x). Dynamic tools like this are best when applied to integration tests, canary pushes, or unittests that operate on multiple threads. Workload matters: When TSAN identifies a problem, it is effectively always an actual data race, but it can only identify races seen in a given execution.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_259","text":"It is up to an application builder to choose which support tools are valuable for a particular applications.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cpcon-concurrency","text":"This section focuses on relatively ad-hoc uses of multiple threads communicating through shared data. For parallel algorithms, see parallelism For inter-task communication without explicit sharing, see messaging For vector parallel code, see vectorization For lock-free programming, see lock free Concurrency rule summary: CP.20: Use RAII, never plain lock() / unlock() CP.21: Use std::lock() or std::scoped_lock to acquire multiple mutex es CP.22: Never call unknown code while holding a lock (e.g., a callback) CP.23: Think of a joining thread as a scoped container CP.24: Think of a thread as a global container CP.25: Prefer gsl::joining_thread over std::thread CP.26: Don\u2019t detach() a thread CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer CP.32: To share ownership between unrelated thread s use shared_ptr CP.40: Minimize context switching CP.41: Minimize thread creation and destruction CP.42: Don\u2019t wait without a condition CP.43: Minimize time spent in a critical section CP.44: Remember to name your lock_guard s and unique_lock s CP.50: Define a mutex together with the data it guards. Use synchronized_value<T> where possible When ??? when to use try_lock() ??? when to prefer lock_guard over unique_lock Time ??? when/how to use new thread","title":"CP.con: Concurrency"},{"location":"cppcg/CppCoreGuidelines/#cp20-use-raii-never-plain-lockunlock","text":"","title":"CP.20: Use RAII, never plain lock()/unlock()"},{"location":"cppcg/CppCoreGuidelines/#reason_281","text":"Avoids nasty errors from unreleased locks.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_114","text":"mutex mtx; void do_stuff() { mtx.lock(); // ... do stuff ... mtx.unlock(); } Sooner or later, someone will forget the mtx.unlock() , place a return in the ... do stuff ... , throw an exception, or something. mutex mtx; void do_stuff() { unique_lock<mutex> lck {mtx}; // ... do stuff ... }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_260","text":"Flag calls of member lock() and unlock() . ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp21-use-stdlock-or-stdscoped_lock-to-acquire-multiple-mutexes","text":"","title":"CP.21: Use std::lock() or std::scoped_lock to acquire multiple mutexes"},{"location":"cppcg/CppCoreGuidelines/#reason_282","text":"To avoid deadlocks on multiple mutex es.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_254","text":"This is asking for deadlock: // thread 1 lock_guard<mutex> lck1(m1); lock_guard<mutex> lck2(m2); // thread 2 lock_guard<mutex> lck2(m2); lock_guard<mutex> lck1(m1); Instead, use lock() : // thread 1 lock(m1, m2); lock_guard<mutex> lck1(m1, adopt_lock); lock_guard<mutex> lck2(m2, adopt_lock); // thread 2 lock(m2, m1); lock_guard<mutex> lck2(m2, adopt_lock); lock_guard<mutex> lck1(m1, adopt_lock); or (better, but C++17 only): // thread 1 scoped_lock<mutex, mutex> lck1(m1, m2); // thread 2 scoped_lock<mutex, mutex> lck2(m2, m1); Here, the writers of thread1 and thread2 are still not agreeing on the order of the mutex es, but order no longer matters.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_246","text":"In real code, mutex es are rarely named to conveniently remind the programmer of an intended relation and intended order of acquisition. In real code, mutex es are not always conveniently acquired on consecutive lines. In C++17 it\u2019s possible to write plain lock_guard lck1(m1, adopt_lock); and have the mutex type deduced.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_261","text":"Detect the acquisition of multiple mutex es. This is undecidable in general, but catching common simple examples (like the one above) is easy.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp22-never-call-unknown-code-while-holding-a-lock-eg-a-callback","text":"","title":"CP.22: Never call unknown code while holding a lock (e.g., a callback)"},{"location":"cppcg/CppCoreGuidelines/#reason_283","text":"If you don\u2019t know what a piece of code does, you are risking deadlock.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_255","text":"void do_this(Foo* p) { lock_guard<mutex> lck {my_mutex}; // ... do something ... p->act(my_data); // ... } If you don\u2019t know what Foo::act does (maybe it is a virtual function invoking a derived class member of a class not yet written), it may call do_this (recursively) and cause a deadlock on my_mutex . Maybe it will lock on a different mutex and not return in a reasonable time, causing delays to any code calling do_this .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_256","text":"A common example of the \u201ccalling unknown code\u201d problem is a call to a function that tries to gain locked access to the same object. Such problem can often be solved by using a recursive_mutex . For example: recursive_mutex my_mutex; template<typename Action> void do_something(Action f) { unique_lock<recursive_mutex> lck {my_mutex}; // ... do something ... f(this); // f will do something to *this // ... } If, as it is likely, f() invokes operations on *this , we must make sure that the object\u2019s invariant holds before the call.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_262","text":"Flag calling a virtual function with a non-recursive mutex held Flag calling a callback with a non-recursive mutex held","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp23-think-of-a-joining-thread-as-a-scoped-container","text":"","title":"CP.23: Think of a joining thread as a scoped container"},{"location":"cppcg/CppCoreGuidelines/#reason_284","text":"To maintain pointer safety and avoid leaks, we need to consider what pointers are used by a thread . If a thread joins, we can safely pass pointers to objects in the scope of the thread and its enclosing scopes.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_257","text":"void f(int* p) { // ... *p = 99; // ... } int glob = 33; void some_fct(int* p) { int x = 77; joining_thread t0(f, &x); // OK joining_thread t1(f, p); // OK joining_thread t2(f, &glob); // OK auto q = make_unique<int>(99); joining_thread t3(f, q.get()); // OK // ... } A gsl::joining_thread is a std::thread with a destructor that joins and that cannot be detached() . By \u201cOK\u201d we mean that the object will be in scope (\u201clive\u201d) for as long as a thread can use the pointer to it. The fact that thread s run concurrently doesn\u2019t affect the lifetime or ownership issues here; these thread s can be seen as just a function object called from some_fct .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_263","text":"Ensure that joining_thread s don\u2019t detach() . After that, the usual lifetime and ownership (for local objects) enforcement applies.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp24-think-of-a-thread-as-a-global-container","text":"","title":"CP.24: Think of a thread as a global container"},{"location":"cppcg/CppCoreGuidelines/#reason_285","text":"To maintain pointer safety and avoid leaks, we need to consider what pointers are used by a thread . If a thread is detached, we can safely pass pointers to static and free store objects (only).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_258","text":"void f(int* p) { // ... *p = 99; // ... } int glob = 33; void some_fct(int* p) { int x = 77; std::thread t0(f, &x); // bad std::thread t1(f, p); // bad std::thread t2(f, &glob); // OK auto q = make_unique<int>(99); std::thread t3(f, q.get()); // bad // ... t0.detach(); t1.detach(); t2.detach(); t3.detach(); // ... } By \u201cOK\u201d we mean that the object will be in scope (\u201clive\u201d) for as long as a thread can use the pointers to it. By \u201cbad\u201d we mean that a thread may use a pointer after the pointed-to object is destroyed. The fact that thread s run concurrently doesn\u2019t affect the lifetime or ownership issues here; these thread s can be seen as just a function object called from some_fct .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_247","text":"Even objects with static storage duration can be problematic if used from detached threads: if the thread continues until the end of the program, it might be running concurrently with the destruction of objects with static storage duration, and thus accesses to such objects might race.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_248","text":"This rule is redundant if you don\u2019t detach() and use gsl::joining_thread . However, converting code to follow those guidelines could be difficult and even impossible for third-party libraries. In such cases, the rule becomes essential for lifetime safety and type safety. In general, it is undecidable whether a detach() is executed for a thread , but simple common cases are easily detected. If we cannot prove that a thread does not detach() , we must assume that it does and that it outlives the scope in which it was constructed; After that, the usual lifetime and ownership (for global objects) enforcement applies.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_264","text":"Flag attempts to pass local variables to a thread that might detach() .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp25-prefer-gsljoining_thread-over-stdthread","text":"","title":"CP.25: Prefer gsl::joining_thread over std::thread"},{"location":"cppcg/CppCoreGuidelines/#reason_286","text":"A joining_thread is a thread that joins at the end of its scope. Detached threads are hard to monitor. It is harder to ensure absence of errors in detached threads (and potentially detached threads)","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_115","text":"void f() { std::cout << \"Hello \"; } struct F { void operator()() { std::cout << \"parallel world \"; } }; int main() { std::thread t1{f}; // f() executes in separate thread std::thread t2{F()}; // F()() executes in separate thread } // spot the bugs","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_259","text":"void f() { std::cout << \"Hello \"; } struct F { void operator()() { std::cout << \"parallel world \"; } }; int main() { std::thread t1{f}; // f() executes in separate thread std::thread t2{F()}; // F()() executes in separate thread t1.join(); t2.join(); } // one bad bug left","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_116","text":"The code determining whether to join() or detach() may be complicated and even decided in the thread of functions called from it or functions called by the function that creates a thread: void tricky(thread* t, int n) { // ... if (is_odd(n)) t->detach(); // ... } void use(int n) { thread t { tricky, this, n }; // ... // ... should I join here? ... } This seriously complicates lifetime analysis, and in not too unlikely cases makes lifetime analysis impossible. This implies that we cannot safely refer to local objects in use() from the thread or refer to local objects in the thread from use() .","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_249","text":"Make \u201cimmortal threads\u201d globals, put them in an enclosing scope, or put them on the free store rather than detach() . don\u2019t detach .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_250","text":"Because of old code and third party libraries using std::thread this rule can be hard to introduce.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_265","text":"Flag uses of std::thread : Suggest use of gsl::joining_thread . Suggest \u201cexporting ownership\u201d to an enclosing scope if it detaches. Seriously warn if it is not obvious whether if joins of detaches.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp26-dont-detach-a-thread","text":"","title":"CP.26: Don't detach() a thread"},{"location":"cppcg/CppCoreGuidelines/#reason_287","text":"Often, the need to outlive the scope of its creation is inherent in the thread s task, but implementing that idea by detach makes it harder to monitor and communicate with the detached thread. In particular, it is harder (though not impossible) to ensure that the thread completed as expected or lives for as long as expected.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_260","text":"void heartbeat(); void use() { std::thread t(heartbeat); // don't join; heartbeat is meant to run forever t.detach(); // ... } This is a reasonable use of a thread, for which detach() is commonly used. There are problems, though. How do we monitor the detached thread to see if it is alive? Something might go wrong with the heartbeat, and losing a heartbeat can be very serious in a system for which it is needed. So, we need to communicate with the heartbeat thread (e.g., through a stream of messages or notification events using a condition_variable ). An alternative, and usually superior solution is to control its lifetime by placing it in a scope outside its point of creation (or activation). For example: void heartbeat(); gsl::joining_thread t(heartbeat); // heartbeat is meant to run \"forever\" This heartbeat will (barring error, hardware problems, etc.) run for as long as the program does. Sometimes, we need to separate the point of creation from the point of ownership: void heartbeat(); unique_ptr<gsl::joining_thread> tick_tock {nullptr}; void use() { // heartbeat is meant to run as long as tick_tock lives tick_tock = make_unique<gsl::joining_thread>(heartbeat); // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_266","text":"Flag detach() .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp31-pass-small-amounts-of-data-between-threads-by-value-rather-than-by-reference-or-pointer","text":"","title":"CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer"},{"location":"cppcg/CppCoreGuidelines/#reason_288","text":"Copying a small amount of data is cheaper to copy and access than to share it using some locking mechanism. Copying naturally gives unique ownership (simplifies code) and eliminates the possibility of data races.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_251","text":"Defining \u201csmall amount\u201d precisely is impossible.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_261","text":"string modify1(string); void modify2(string&); void fct(string& s) { auto res = async(modify1, s); async(modify2, s); } The call of modify1 involves copying two string values; the call of modify2 does not. On the other hand, the implementation of modify1 is exactly as we would have written it for single-threaded code, whereas the implementation of modify2 will need some form of locking to avoid data races. If the string is short (say 10 characters), the call of modify1 can be surprisingly fast; essentially all the cost is in the thread switch. If the string is long (say 1,000,000 characters), copying it twice is probably not a good idea. Note that this argument has nothing to do with async as such. It applies equally to considerations about whether to use message passing or shared memory.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_267","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp32-to-share-ownership-between-unrelated-threads-use-shared_ptr","text":"","title":"CP.32: To share ownership between unrelated threads use shared_ptr"},{"location":"cppcg/CppCoreGuidelines/#reason_289","text":"If threads are unrelated (that is, not known to be in the same scope or one within the lifetime of the other) and they need to share free store memory that needs to be deleted, a shared_ptr (or equivalent) is the only safe way to ensure proper deletion.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_262","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_252","text":"A static object (e.g. a global) can be shared because it is not owned in the sense that some thread is responsible for its deletion. An object on free store that is never to be deleted can be shared. An object owned by one thread can be safely shared with another as long as that second thread doesn\u2019t outlive the owner.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_268","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp40-minimize-context-switching","text":"","title":"CP.40: Minimize context switching"},{"location":"cppcg/CppCoreGuidelines/#reason_290","text":"Context switches are expensive.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_263","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_269","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp41-minimize-thread-creation-and-destruction","text":"","title":"CP.41: Minimize thread creation and destruction"},{"location":"cppcg/CppCoreGuidelines/#reason_291","text":"Thread creation is expensive.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_264","text":"void worker(Message m) { // process } void master(istream& is) { for (Message m; is >> m; ) run_list.push_back(new thread(worker, m)); } This spawns a thread per message, and the run_list is presumably managed to destroy those tasks once they are finished. Instead, we could have a set of pre-created worker threads processing the messages Sync_queue<Message> work; void master(istream& is) { for (Message m; is >> m; ) work.put(m); } void worker() { for (Message m; m = work.get(); ) { // process } } void workers() // set up worker threads (specifically 4 worker threads) { joining_thread w1 {worker}; joining_thread w2 {worker}; joining_thread w3 {worker}; joining_thread w4 {worker}; }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_253","text":"If your system has a good thread pool, use it. If your system has a good message queue, use it.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_270","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp42-dont-wait-without-a-condition","text":"","title":"CP.42: Don't wait without a condition"},{"location":"cppcg/CppCoreGuidelines/#reason_292","text":"A wait without a condition can miss a wakeup or wake up simply to find that there is no work to do.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_117","text":"std::condition_variable cv; std::mutex mx; void thread1() { while (true) { // do some work ... std::unique_lock<std::mutex> lock(mx); cv.notify_one(); // wake other thread } } void thread2() { while (true) { std::unique_lock<std::mutex> lock(mx); cv.wait(lock); // might block forever // do work ... } } Here, if some other thread consumes thread1 \u2018s notification, thread2 can wait forever.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_265","text":"template<typename T> class Sync_queue { public: void put(const T& val); void put(T&& val); void get(T& val); private: mutex mtx; condition_variable cond; // this controls access list<T> q; }; template<typename T> void Sync_queue<T>::put(const T& val) { lock_guard<mutex> lck(mtx); q.push_back(val); cond.notify_one(); } template<typename T> void Sync_queue<T>::get(T& val) { unique_lock<mutex> lck(mtx); cond.wait(lck, [this]{ return !q.empty(); }); // prevent spurious wakeup val = q.front(); q.pop_front(); } Now if the queue is empty when a thread executing get() wakes up (e.g., because another thread has gotten to get() before it), it will immediately go back to sleep, waiting.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_271","text":"Flag all wait s without conditions.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp43-minimize-time-spent-in-a-critical-section","text":"","title":"CP.43: Minimize time spent in a critical section"},{"location":"cppcg/CppCoreGuidelines/#reason_293","text":"The less time is spent with a mutex taken, the less chance that another thread has to wait, and thread suspension and resumption are expensive.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_266","text":"void do_something() // bad { unique_lock<mutex> lck(my_lock); do0(); // preparation: does not need lock do1(); // transaction: needs locking do2(); // cleanup: does not need locking } Here, we are holding the lock for longer than necessary: We should not have taken the lock before we needed it and should have released it again before starting the cleanup. We could rewrite this to void do_something() // bad { do0(); // preparation: does not need lock my_lock.lock(); do1(); // transaction: needs locking my_lock.unlock(); do2(); // cleanup: does not need locking } But that compromises safety and violates the use RAII rule. Instead, add a block for the critical section: void do_something() // OK { do0(); // preparation: does not need lock { unique_lock<mutex> lck(my_lock); do1(); // transaction: needs locking } do2(); // cleanup: does not need locking }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_272","text":"Impossible in general. Flag \u201cnaked\u201d lock() and unlock() .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp44-remember-to-name-your-lock_guards-and-unique_locks","text":"","title":"CP.44: Remember to name your lock_guards and unique_locks"},{"location":"cppcg/CppCoreGuidelines/#reason_294","text":"An unnamed local objects is a temporary that immediately goes out of scope.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_267","text":"unique_lock<mutex>(m1); lock_guard<mutex> {m2}; lock(m1, m2); This looks innocent enough, but it isn\u2019t.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_273","text":"Flag all unnamed lock_guard s and unique_lock s.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp50-define-a-mutex-together-with-the-data-it-guards-use-synchronized_valuet-where-possible","text":"","title":"CP.50: Define a mutex together with the data it guards. Use synchronized_value&lt;T&gt; where possible"},{"location":"cppcg/CppCoreGuidelines/#reason_295","text":"It should be obvious to a reader that the data is to be guarded and how. This decreases the chance of the wrong mutex being locked, or the mutex not being locked. Using a synchronized_value<T> ensures that the data has a mutex, and the right mutex is locked when the data is accessed. See the WG21 proposal to add synchronized_value to a future TS or revision of the C++ standard.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_268","text":"struct Record { std::mutex m; // take this mutex before accessing other members // ... }; class MyClass { struct DataRecord { // ... }; synchronized_value<DataRecord> data; // Protect the data with a mutex };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_274","text":"??? Possible?","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cppar-parallelism","text":"By \u201cparallelism\u201d we refer to performing a task (more or less) simultaneously (\u201cin parallel with\u201d) on many data items. Parallelism rule summary: ??? ??? Where appropriate, prefer the standard-library parallel algorithms Use algorithms that are designed for parallelism, not algorithms with unnecessary dependency on linear evaluation","title":"CP.par: Parallelism"},{"location":"cppcg/CppCoreGuidelines/#cpmess-message-passing","text":"The standard-library facilities are quite low-level, focused on the needs of close-to the hardware critical programming using thread s, mutex es, atomic types, etc. Most people shouldn\u2019t work at this level: it\u2019s error-prone and development is slow. If possible, use a higher level facility: messaging libraries, parallel algorithms, and vectorization. This section looks at passing messages so that a programmer doesn\u2019t have to do explicit synchronization. Message passing rules summary: CP.60: Use a future to return a value from a concurrent task CP.61: Use an async() to spawn a concurrent task message queues messaging libraries ???? should there be a \u201cuse X rather than std::async \u201d where X is something that would use a better specified thread pool? ??? Is std::async worth using in light of future (and even existing, as libraries) parallelism facilities? What should the guidelines recommend if someone wants to parallelize, e.g., std::accumulate (with the additional precondition of commutativity), or merge sort?","title":"CP.mess: Message passing"},{"location":"cppcg/CppCoreGuidelines/#cp60-use-a-future-to-return-a-value-from-a-concurrent-task","text":"","title":"CP.60: Use a future to return a value from a concurrent task"},{"location":"cppcg/CppCoreGuidelines/#reason_296","text":"A future preserves the usual function call return semantics for asynchronous tasks. There is no explicit locking and both correct (value) return and error (exception) return are handled simply.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_269","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_254","text":"???","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_275","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp61-use-an-async-to-spawn-a-concurrent-task","text":"","title":"CP.61: Use an async() to spawn a concurrent task"},{"location":"cppcg/CppCoreGuidelines/#reason_297","text":"A future preserves the usual function call return semantics for asynchronous tasks. There is no explicit locking and both correct (value) return and error (exception) return are handled simply.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_270","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_255","text":"Unfortunately, async() is not perfect. For example, there is no guarantee that a thread pool is used to minimize thread construction. In fact, most current async() implementations don\u2019t. However, async() is simple and logically correct so until something better comes along and unless you really need to optimize for many asynchronous tasks, stick with async() .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_276","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cpvec-vectorization","text":"Vectorization is a technique for executing a number of tasks concurrently without introducing explicit synchronization. An operation is simply applied to elements of a data structure (a vector, an array, etc.) in parallel. Vectorization has the interesting property of often requiring no non-local changes to a program. However, vectorization works best with simple data structures and with algorithms specifically crafted to enable it. Vectorization rule summary: ??? ???","title":"CP.vec: Vectorization"},{"location":"cppcg/CppCoreGuidelines/#cpfree-lock-free-programming","text":"Synchronization using mutex es and condition_variable s can be relatively expensive. Furthermore, it can lead to deadlock. For performance and to eliminate the possibility of deadlock, we sometimes have to use the tricky low-level \u201clock-free\u201d facilities that rely on briefly gaining exclusive (\u201catomic\u201d) access to memory. Lock-free programming is also used to implement higher-level concurrency mechanisms, such as thread s and mutex es. Lock-free programming rule summary: CP.100: Don\u2019t use lock-free programming unless you absolutely have to CP.101: Distrust your hardware/compiler combination CP.102: Carefully study the literature how/when to use atomics avoid starvation use a lock-free data structure rather than hand-crafting specific lock-free access CP.110: Do not write your own double-checked locking for initialization CP.111: Use a conventional pattern if you really need double-checked locking how/when to compare and swap","title":"CP.free: Lock-free programming"},{"location":"cppcg/CppCoreGuidelines/#cp100-dont-use-lock-free-programming-unless-you-absolutely-have-to","text":"","title":"CP.100: Don't use lock-free programming unless you absolutely have to"},{"location":"cppcg/CppCoreGuidelines/#reason_298","text":"It\u2019s error-prone and requires expert level knowledge of language features, machine architecture, and data structures.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_118","text":"extern atomic<Link*> head; // the shared head of a linked list Link* nh = new Link(data, nullptr); // make a link ready for insertion Link* h = head.load(); // read the shared head of the list do { if (h->data <= data) break; // if so, insert elsewhere nh->next = h; // next element is the previous head } while (!head.compare_exchange_weak(h, nh)); // write nh to head or to h Spot the bug. It would be really hard to find through testing. Read up on the ABA problem.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#exception_48","text":"Atomic variables can be used simply and safely, as long as you are using the sequentially consistent memory model (memory_order_seq_cst), which is the default.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#note_256","text":"Higher-level concurrency mechanisms, such as thread s and mutex es are implemented using lock-free programming. Alternative : Use lock-free data structures implemented by others as part of some library.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#cp101-distrust-your-hardwarecompiler-combination","text":"","title":"CP.101: Distrust your hardware/compiler combination"},{"location":"cppcg/CppCoreGuidelines/#reason_299","text":"The low-level hardware interfaces used by lock-free programming are among the hardest to implement well and among the areas where the most subtle portability problems occur. If you are doing lock-free programming for performance, you need to check for regressions.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_257","text":"Instruction reordering (static and dynamic) makes it hard for us to think effectively at this level (especially if you use relaxed memory models). Experience, (semi)formal models and model checking can be useful. Testing - often to an extreme extent - is essential. \u201cDon\u2019t fly too close to the sun.\u201d","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_277","text":"Have strong rules for re-testing in place that covers any change in hardware, operating system, compiler, and libraries.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp102-carefully-study-the-literature","text":"","title":"CP.102: Carefully study the literature"},{"location":"cppcg/CppCoreGuidelines/#reason_300","text":"With the exception of atomics and a few use standard patterns, lock-free programming is really an expert-only topic. Become an expert before shipping lock-free code for others to use.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#references","text":"Anthony Williams: C++ concurrency in action. Manning Publications. Boehm, Adve, You Don\u2019t Know Jack About Shared Variables or Memory Models , Communications of the ACM, Feb 2012. Boehm, \u201cThreads Basics\u201d, HPL TR 2009-259. Adve, Boehm, \u201cMemory Models: A Case for Rethinking Parallel Languages and Hardware\u201d, Communications of the ACM, August 2010. Boehm, Adve, \u201cFoundations of the C++ Concurrency Memory Model\u201d, PLDI 08. Mark Batty, Scott Owens, Susmit Sarkar, Peter Sewell, and Tjark Weber, \u201cMathematizing C++ Concurrency\u201d, POPL 2011. Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup: Understanding and Effectively Preventing the ABA Problem in Descriptor-based Lock-free Designs. 13 th IEEE Computer Society ISORC 2010 Symposium. May 2010. Damian Dechev and Bjarne Stroustrup: Scalable Non-blocking Concurrent Objects for Mission Critical Code. ACM OOPSLA\u201809. October 2009 Damian Dechev, Peter Pirkelbauer, Nicolas Rouquette, and Bjarne Stroustrup: Semantically Enhanced Containers for Concurrent Real-Time Systems. Proc. 16 th Annual IEEE International Conference and Workshop on the Engineering of Computer Based Systems (IEEE ECBS). April 2009.","title":"References"},{"location":"cppcg/CppCoreGuidelines/#cp110-do-not-write-your-own-double-checked-locking-for-initialization","text":"","title":"CP.110: Do not write your own double-checked locking for initialization"},{"location":"cppcg/CppCoreGuidelines/#reason_301","text":"Since C++11, static local variables are now initialized in a thread-safe way. When combined with the RAII pattern, static local variables can replace the need for writing your own double-checked locking for initialization. std::call_once can also achieve the same purpose. Use either static local variables of C++11 or std::call_once instead of writing your own double-checked locking for initialization.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_271","text":"Example with std::call_once. void f() { static std::once_flag my_once_flag; std::call_once(my_once_flag, []() { // do this only once }); // ... } Example with thread-safe static local variables of C++11. void f() { // Assuming the compiler is compliant with C++11 static My_class my_object; // Constructor called only once // ... } class My_class { public: My_class() { // do this only once } };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_278","text":"??? Is it possible to detect the idiom?","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp111-use-a-conventional-pattern-if-you-really-need-double-checked-locking","text":"","title":"CP.111: Use a conventional pattern if you really need double-checked locking"},{"location":"cppcg/CppCoreGuidelines/#reason_302","text":"Double-checked locking is easy to mess up. If you really need to write your own double-checked locking, in spite of the rules CP.110: Do not write your own double-checked locking for initialization and CP.100: Don\u2019t use lock-free programming unless you absolutely have to , then do it in a conventional pattern. The uses of the double-checked locking pattern that are not in violation of CP.110: Do not write your own double-checked locking for initialization arise when a non-thread-safe action is both hard and rare, and there exists a fast thread-safe test that can be used to guarantee that the action is not needed, but cannot be used to guarantee the converse.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_119","text":"The use of volatile does not make the first check thread-safe, see also CP.200: Use volatile only to talk to non-C++ memory mutex action_mutex; volatile bool action_needed; if (action_needed) { std::lock_guard<std::mutex> lock(action_mutex); if (action_needed) { take_action(); action_needed = false; } }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_21","text":"mutex action_mutex; atomic<bool> action_needed; if (action_needed) { std::lock_guard<std::mutex> lock(action_mutex); if (action_needed) { take_action(); action_needed = false; } } Fine-tuned memory order may be beneficial where acquire load is more efficient than sequentially-consistent load mutex action_mutex; atomic<bool> action_needed; if (action_needed.load(memory_order_acquire)) { lock_guard<std::mutex> lock(action_mutex); if (action_needed.load(memory_order_relaxed)) { take_action(); action_needed.store(false, memory_order_release); } }","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#enforcement_279","text":"??? Is it possible to detect the idiom?","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cpetc-etc-concurrency-rules","text":"These rules defy simple categorization: CP.200: Use volatile only to talk to non-C++ memory CP.201: ??? Signals","title":"CP.etc: Etc. concurrency rules"},{"location":"cppcg/CppCoreGuidelines/#cp200-use-volatile-only-to-talk-to-non-c-memory","text":"","title":"CP.200: Use volatile only to talk to non-C++ memory"},{"location":"cppcg/CppCoreGuidelines/#reason_303","text":"volatile is used to refer to objects that are shared with \u201cnon-C++\u201d code or hardware that does not follow the C++ memory model.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_272","text":"const volatile long clock; This describes a register constantly updated by a clock circuit. clock is volatile because its value will change without any action from the C++ program that uses it. For example, reading clock twice will often yield two different values, so the optimizer had better not optimize away the second read in this code: long t1 = clock; // ... no use of clock here ... long t2 = clock; clock is const because the program should not try to write to clock .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_258","text":"Unless you are writing the lowest level code manipulating hardware directly, consider volatile an esoteric feature that is best avoided.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_273","text":"Usually C++ code receives volatile memory that is owned elsewhere (hardware or another language): int volatile* vi = get_hardware_memory_location(); // note: we get a pointer to someone else's memory here // volatile says \"treat this with extra respect\" Sometimes C++ code allocates the volatile memory and shares it with \u201celsewhere\u201d (hardware or another language) by deliberately escaping a pointer: static volatile long vl; please_use_this(&vl); // escape a reference to this to \"elsewhere\" (not C++)","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_120","text":"volatile local variables are nearly always wrong \u2013 how can they be shared with other languages or hardware if they\u2019re ephemeral? The same applies almost as strongly to member variables, for the same reason. void f() { volatile int i = 0; // bad, volatile local variable // etc. } class My_type { volatile int i = 0; // suspicious, volatile member variable // etc. };","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_259","text":"In C++, unlike in some other languages, volatile has nothing to do with synchronization .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_280","text":"Flag volatile T local and member variables; almost certainly you intended to use atomic<T> instead. ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cp201-signals","text":"???UNIX signal handling???. May be worth reminding how little is async-signal-safe, and how to communicate with a signal handler (best is probably \u201cnot at all\u201d)","title":"CP.201: ??? Signals"},{"location":"cppcg/CppCoreGuidelines/#e-error-handling","text":"Error handling involves: Detecting an error Transmitting information about an error to some handler code Preserving a valid state of the program Avoiding resource leaks It is not possible to recover from all errors. If recovery from an error is not possible, it is important to quickly \u201cget out\u201d in a well-defined way. A strategy for error handling must be simple, or it becomes a source of even worse errors. Untested and rarely executed error-handling code is itself the source of many bugs. The rules are designed to help avoid several kinds of errors: Type violations (e.g., misuse of union s and casts) Resource leaks (including memory leaks) Bounds errors Lifetime errors (e.g., accessing an object after is has been delete d) Complexity errors (logical errors made likely by overly complex expression of ideas) Interface errors (e.g., an unexpected value is passed through an interface) Error-handling rule summary: E.1: Develop an error-handling strategy early in a design E.2: Throw an exception to signal that a function can\u2019t perform its assigned task E.3: Use exceptions for error handling only E.4: Design your error-handling strategy around invariants E.5: Let a constructor establish an invariant, and throw if it cannot E.6: Use RAII to prevent leaks E.7: State your preconditions E.8: State your postconditions E.12: Use noexcept when exiting a function because of a throw is impossible or unacceptable E.13: Never throw while being the direct owner of an object E.14: Use purpose-designed user-defined types as exceptions (not built-in types) E.15: Catch exceptions from a hierarchy by reference E.16: Destructors, deallocation, and swap must never fail E.17: Don\u2019t try to catch every exception in every function E.18: Minimize the use of explicit try / catch E.19: Use a final_action object to express cleanup if no suitable resource handle is available E.25: If you can\u2019t throw exceptions, simulate RAII for resource management E.26: If you can\u2019t throw exceptions, consider failing fast E.27: If you can\u2019t throw exceptions, use error codes systematically E.28: Avoid error handling based on global state (e.g. errno ) E.30: Don\u2019t use exception specifications E.31: Properly order your catch -clauses","title":"E: Error handling"},{"location":"cppcg/CppCoreGuidelines/#e1-develop-an-error-handling-strategy-early-in-a-design","text":"","title":"E.1: Develop an error-handling strategy early in a design"},{"location":"cppcg/CppCoreGuidelines/#reason_304","text":"A consistent and complete strategy for handling errors and resource leaks is hard to retrofit into a system.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#e2-throw-an-exception-to-signal-that-a-function-cant-perform-its-assigned-task","text":"","title":"E.2: Throw an exception to signal that a function can't perform its assigned task"},{"location":"cppcg/CppCoreGuidelines/#reason_305","text":"To make error handling systematic, robust, and non-repetitive.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_274","text":"struct Foo { vector<Thing> v; File_handle f; string s; }; void use() { Foo bar {{Thing{1}, Thing{2}, Thing{monkey}}, {\"my_file\", \"r\"}, \"Here we go!\"}; // ... } Here, vector and string s constructors may not be able to allocate sufficient memory for their elements, vector s constructor may not be able copy the Thing s in its initializer list, and File_handle may not be able to open the required file. In each case, they throw an exception for use() \u2018s caller to handle. If use() could handle the failure to construct bar it can take control using try / catch . In either case, Foo \u2018s constructor correctly destroys constructed members before passing control to whatever tried to create a Foo . Note that there is no return value that could contain an error code. The File_handle constructor might be defined like this: File_handle::File_handle(const string& name, const string& mode) :f{fopen(name.c_str(), mode.c_str())} { if (!f) throw runtime_error{\"File_handle: could not open \" + name + \" as \" + mode}; }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_260","text":"It is often said that exceptions are meant to signal exceptional events and failures. However, that\u2019s a bit circular because \u201cwhat is exceptional?\u201d Examples: A precondition that cannot be met A constructor that cannot construct an object (failure to establish its class\u2019s invariant ) An out-of-range error (e.g., v[v.size()] = 7 ) Inability to acquire a resource (e.g., the network is down) In contrast, termination of an ordinary loop is not exceptional. Unless the loop was meant to be infinite, termination is normal and expected.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_261","text":"Don\u2019t use a throw as simply an alternative way of returning a value from a function.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exception_49","text":"Some systems, such as hard-real-time systems require a guarantee that an action is taken in a (typically short) constant maximum time known before execution starts. Such systems can use exceptions only if there is tool support for accurately predicting the maximum time to recover from a throw . See also : RAII See also : discussion","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#note_262","text":"Before deciding that you cannot afford or don\u2019t like exception-based error handling, have a look at the alternatives ; they have their own complexities and problems. Also, as far as possible, measure before making claims about efficiency.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#e3-use-exceptions-for-error-handling-only","text":"","title":"E.3: Use exceptions for error handling only"},{"location":"cppcg/CppCoreGuidelines/#reason_306","text":"To keep error handling separated from \u201cordinary code.\u201d C++ implementations tend to be optimized based on the assumption that exceptions are rare.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-dont_3","text":"// don't: exception not used for error handling int find_index(vector<string>& vec, const string& x) { try { for (gsl::index i = 0; i < vec.size(); ++i) if (vec[i] == x) throw i; // found x } catch (int i) { return i; } return -1; // not found } This is more complicated and most likely runs much slower than the obvious alternative. There is nothing exceptional about finding a value in a vector .","title":"Example, don't"},{"location":"cppcg/CppCoreGuidelines/#enforcement_281","text":"Would need to be heuristic. Look for exception values \u201cleaked\u201d out of catch clauses.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#e4-design-your-error-handling-strategy-around-invariants","text":"","title":"E.4: Design your error-handling strategy around invariants"},{"location":"cppcg/CppCoreGuidelines/#reason_307","text":"To use an object it must be in a valid state (defined formally or informally by an invariant) and to recover from an error every object not destroyed must be in a valid state.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_263","text":"An invariant is a logical condition for the members of an object that a constructor must establish for the public member functions to assume.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_282","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#e5-let-a-constructor-establish-an-invariant-and-throw-if-it-cannot","text":"","title":"E.5: Let a constructor establish an invariant, and throw if it cannot"},{"location":"cppcg/CppCoreGuidelines/#reason_308","text":"Leaving an object without its invariant established is asking for trouble. Not all member functions can be called.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_275","text":"class Vector { // very simplified vector of doubles // if elem != nullptr then elem points to sz doubles public: Vector() : elem{nullptr}, sz{0}{} Vector(int s) : elem{new double[s]}, sz{s} { /* initialize elements */ } ~Vector() { delete [] elem; } double& operator[](int s) { return elem[s]; } // ... private: owner<double*> elem; int sz; }; The class invariant - here stated as a comment - is established by the constructors. new throws if it cannot allocate the required memory. The operators, notably the subscript operator, relies on the invariant. See also : If a constructor cannot construct a valid object, throw an exception","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_283","text":"Flag classes with private state without a constructor (public, protected, or private).","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#e6-use-raii-to-prevent-leaks","text":"","title":"E.6: Use RAII to prevent leaks"},{"location":"cppcg/CppCoreGuidelines/#reason_309","text":"Leaks are typically unacceptable. Manual resource release is error-prone. RAII (\u201cResource Acquisition Is Initialization\u201d) is the simplest, most systematic way of preventing leaks.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_276","text":"void f1(int i) // Bad: possible leak { int* p = new int[12]; // ... if (i < 17) throw Bad{\"in f()\", i}; // ... } We could carefully release the resource before the throw: void f2(int i) // Clumsy and error-prone: explicit release { int* p = new int[12]; // ... if (i < 17) { delete[] p; throw Bad{\"in f()\", i}; } // ... } This is verbose. In larger code with multiple possible throw s explicit releases become repetitive and error-prone. void f3(int i) // OK: resource management done by a handle (but see below) { auto p = make_unique<int[]>(12); // ... if (i < 17) throw Bad{\"in f()\", i}; // ... } Note that this works even when the throw is implicit because it happened in a called function: void f4(int i) // OK: resource management done by a handle (but see below) { auto p = make_unique<int[]>(12); // ... helper(i); // may throw // ... } Unless you really need pointer semantics, use a local resource object: void f5(int i) // OK: resource management done by local object { vector<int> v(12); // ... helper(i); // may throw // ... } That\u2019s even simpler and safer, and often more efficient.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_264","text":"If there is no obvious resource handle and for some reason defining a proper RAII object/handle is infeasible, as a last resort, cleanup actions can be represented by a final_action object.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_265","text":"But what do we do if we are writing a program where exceptions cannot be used? First challenge that assumption; there are many anti-exceptions myths around. We know of only a few good reasons: We are on a system so small that the exception support would eat up most of our 2K memory. We are in a hard-real-time system and we don\u2019t have tools that guarantee us that an exception is handled within the required time. We are in a system with tons of legacy code using lots of pointers in difficult-to-understand ways (in particular without a recognizable ownership strategy) so that exceptions could cause leaks. Our implementation of the C++ exception mechanisms is unreasonably poor (slow, memory consuming, failing to work correctly for dynamically linked libraries, etc.). Complain to your implementation purveyor; if no user complains, no improvement will happen. We get fired if we challenge our manager\u2019s ancient wisdom. Only the first of these reasons is fundamental, so whenever possible, use exceptions to implement RAII, or design your RAII objects to never fail. When exceptions cannot be used, simulate RAII. That is, systematically check that objects are valid after construction and still release all resources in the destructor. One strategy is to add a valid() operation to every resource handle: void f() { vector<string> vs(100); // not std::vector: valid() added if (!vs.valid()) { // handle error or exit } ifstream fs(\"foo\"); // not std::ifstream: valid() added if (!fs.valid()) { // handle error or exit } // ... } // destructors clean up as usual Obviously, this increases the size of the code, doesn\u2019t allow for implicit propagation of \u201cexceptions\u201d ( valid() checks), and valid() checks can be forgotten. Prefer to use exceptions. See also : Use of noexcept","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_284","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#e7-state-your-preconditions","text":"","title":"E.7: State your preconditions"},{"location":"cppcg/CppCoreGuidelines/#reason_310","text":"To avoid interface errors. See also : precondition rule","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#e8-state-your-postconditions","text":"","title":"E.8: State your postconditions"},{"location":"cppcg/CppCoreGuidelines/#reason_311","text":"To avoid interface errors. See also : postcondition rule","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#e12-use-noexcept-when-exiting-a-function-because-of-a-throw-is-impossible-or-unacceptable","text":"","title":"E.12: Use noexcept when exiting a function because of a throw is impossible or unacceptable"},{"location":"cppcg/CppCoreGuidelines/#reason_312","text":"To make error handling systematic, robust, and efficient.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_277","text":"double compute(double d) noexcept { return log(sqrt(d <= 0 ? 1 : d)); } Here, we know that compute will not throw because it is composed out of operations that don\u2019t throw. By declaring compute to be noexcept , we give the compiler and human readers information that can make it easier for them to understand and manipulate compute .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_266","text":"Many standard-library functions are noexcept including all the standard-library functions \u201cinherited\u201d from the C Standard Library.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_278","text":"vector<double> munge(const vector<double>& v) noexcept { vector<double> v2(v.size()); // ... do something ... } The noexcept here states that I am not willing or able to handle the situation where I cannot construct the local vector . That is, I consider memory exhaustion a serious design error (on par with hardware failures) so that I\u2019m willing to crash the program if it happens.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_267","text":"Do not use traditional exception-specifications .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#see-also_4","text":"discussion .","title":"See also"},{"location":"cppcg/CppCoreGuidelines/#e13-never-throw-while-being-the-direct-owner-of-an-object","text":"","title":"E.13: Never throw while being the direct owner of an object"},{"location":"cppcg/CppCoreGuidelines/#reason_313","text":"That would be a leak.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_279","text":"void leak(int x) // don't: may leak { auto p = new int{7}; if (x < 0) throw Get_me_out_of_here{}; // may leak *p // ... delete p; // we may never get here } One way of avoiding such problems is to use resource handles consistently: void no_leak(int x) { auto p = make_unique<int>(7); if (x < 0) throw Get_me_out_of_here{}; // will delete *p if necessary // ... // no need for delete p } Another solution (often better) would be to use a local variable to eliminate explicit use of pointers: void no_leak_simplified(int x) { vector<int> v(7); // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_268","text":"If you have local \u201cthings\u201d that requires cleanup, but is not represented by an object with a destructor, such cleanup must also be done before a throw . Sometimes, finally() can make such unsystematic cleanup a bit more manageable.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types","text":"","title":"E.14: Use purpose-designed user-defined types as exceptions (not built-in types)"},{"location":"cppcg/CppCoreGuidelines/#reason_314","text":"A user-defined type is unlikely to clash with other people\u2019s exceptions.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_280","text":"void my_code() { // ... throw Moonphase_error{}; // ... } void your_code() { try { // ... my_code(); // ... } catch(const Bufferpool_exhausted&) { // ... } }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-dont_4","text":"void my_code() // Don't { // ... throw 7; // 7 means \"moon in the 4th quarter\" // ... } void your_code() // Don't { try { // ... my_code(); // ... } catch(int i) { // i == 7 means \"input buffer too small\" // ... } }","title":"Example, don't"},{"location":"cppcg/CppCoreGuidelines/#note_269","text":"The standard-library classes derived from exception should be used only as base classes or for exceptions that require only \u201cgeneric\u201d handling. Like built-in types, their use could clash with other people\u2019s use of them.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-dont_5","text":"void my_code() // Don't { // ... throw runtime_error{\"moon in the 4th quarter\"}; // ... } void your_code() // Don't { try { // ... my_code(); // ... } catch(const runtime_error&) { // runtime_error means \"input buffer too small\" // ... } } See also : Discussion","title":"Example, don't"},{"location":"cppcg/CppCoreGuidelines/#enforcement_285","text":"Catch throw and catch of a built-in type. Maybe warn about throw and catch using a standard-library exception type. Obviously, exceptions derived from the std::exception hierarchy are fine.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#e15-catch-exceptions-from-a-hierarchy-by-reference","text":"","title":"E.15: Catch exceptions from a hierarchy by reference"},{"location":"cppcg/CppCoreGuidelines/#reason_315","text":"To prevent slicing.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_281","text":"void f() { try { // ... } catch (exception e) { // don't: may slice // ... } } Instead, use a reference: catch (exception& e) { /* ... */ } or - typically better still - a const reference: catch (const exception& e) { /* ... */ } Most handlers do not modify their exception and in general we recommend use of const .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_270","text":"To rethrow a caught exception use throw; not throw e; . Using throw e; would throw a new copy of e (sliced to the static type std::exception ) instead of rethrowing the original exception of type std::runtime_error . (But keep Don\u2019t try to catch every exception in every function and Minimize the use of explicit try / catch in mind.)","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_286","text":"Flag by-value exceptions if their types are part of a hierarchy (could require whole-program analysis to be perfect).","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#e16-destructors-deallocation-and-swap-must-never-fail","text":"","title":"E.16: Destructors, deallocation, and swap must never fail"},{"location":"cppcg/CppCoreGuidelines/#reason_316","text":"We don\u2019t know how to write reliable programs if a destructor, a swap, or a memory deallocation fails; that is, if it exits by an exception or simply doesn\u2019t perform its required action.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-dont_6","text":"class Connection { // ... public: ~Connection() // Don't: very bad destructor { if (cannot_disconnect()) throw I_give_up{information}; // ... } };","title":"Example, don't"},{"location":"cppcg/CppCoreGuidelines/#note_271","text":"Many have tried to write reliable code violating this rule for examples, such as a network connection that \u201crefuses to close\u201d. To the best of our knowledge nobody has found a general way of doing this. Occasionally, for very specific examples, you can get away with setting some state for future cleanup. For example, we might put a socket that does not want to close on a \u201cbad socket\u201d list, to be examined by a regular sweep of the system state. Every example we have seen of this is error-prone, specialized, and often buggy.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_272","text":"The standard library assumes that destructors, deallocation functions (e.g., operator delete ), and swap do not throw. If they do, basic standard-library invariants are broken.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_273","text":"Deallocation functions, including operator delete , must be noexcept . swap functions must be noexcept . Most destructors are implicitly noexcept by default. Also, make move operations noexcept .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_287","text":"Catch destructors, deallocation operations, and swap s that throw . Catch such operations that are not noexcept . See also : discussion","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#e17-dont-try-to-catch-every-exception-in-every-function","text":"","title":"E.17: Don't try to catch every exception in every function"},{"location":"cppcg/CppCoreGuidelines/#reason_317","text":"Catching an exception in a function that cannot take a meaningful recovery action leads to complexity and waste. Let an exception propagate until it reaches a function that can handle it. Let cleanup actions on the unwinding path be handled by RAII .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-dont_7","text":"void f() // bad { try { // ... } catch (...) { // no action throw; // propagate exception } }","title":"Example, don't"},{"location":"cppcg/CppCoreGuidelines/#enforcement_288","text":"Flag nested try-blocks. Flag source code files with a too high ratio of try-blocks to functions. (??? Problem: define \u201ctoo high\u201d)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#e18-minimize-the-use-of-explicit-trycatch","text":"","title":"E.18: Minimize the use of explicit try/catch"},{"location":"cppcg/CppCoreGuidelines/#reason_318","text":"try / catch is verbose and non-trivial uses are error-prone. try / catch can be a sign of unsystematic and/or low-level resource management or error handling.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_121","text":"void f(zstring s) { Gadget* p; try { p = new Gadget(s); // ... delete p; } catch (Gadget_construction_failure) { delete p; throw; } } This code is messy. There could be a leak from the naked pointer in the try block. Not all exceptions are handled. deleting an object that failed to construct is almost certainly a mistake. Better: void f2(zstring s) { Gadget g {s}; }","title":"Example, Bad"},{"location":"cppcg/CppCoreGuidelines/#alternatives_4","text":"proper resource handles and RAII finally","title":"Alternatives"},{"location":"cppcg/CppCoreGuidelines/#enforcement_289","text":"??? hard, needs a heuristic","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#e19-use-a-final_action-object-to-express-cleanup-if-no-suitable-resource-handle-is-available","text":"","title":"E.19: Use a final_action object to express cleanup if no suitable resource handle is available"},{"location":"cppcg/CppCoreGuidelines/#reason_319","text":"finally is less verbose and harder to get wrong than try / catch .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_282","text":"void f(int n) { void* p = malloc(n); auto _ = finally([p] { free(p); }); // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_274","text":"finally is not as messy as try / catch , but it is still ad-hoc. Prefer proper resource management objects . Consider finally a last resort.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_275","text":"Use of finally is a systematic and reasonably clean alternative to the old goto exit; technique for dealing with cleanup where resource management is not systematic.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_290","text":"Heuristic: Detect goto exit;","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#e25-if-you-cant-throw-exceptions-simulate-raii-for-resource-management","text":"","title":"E.25: If you can't throw exceptions, simulate RAII for resource management"},{"location":"cppcg/CppCoreGuidelines/#reason_320","text":"Even without exceptions, RAII is usually the best and most systematic way of dealing with resources.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_276","text":"Error handling using exceptions is the only complete and systematic way of handling non-local errors in C++. In particular, non-intrusively signaling failure to construct an object requires an exception. Signaling errors in a way that cannot be ignored requires exceptions. If you can\u2019t use exceptions, simulate their use as best you can. A lot of fear of exceptions is misguided. When used for exceptional circumstances in code that is not littered with pointers and complicated control structures, exception handling is almost always affordable (in time and space) and almost always leads to better code. This, of course, assumes a good implementation of the exception handling mechanisms, which is not available on all systems. There are also cases where the problems above do not apply, but exceptions cannot be used for other reasons. Some hard-real-time systems are an example: An operation has to be completed within a fixed time with an error or a correct answer. In the absence of appropriate time estimation tools, this is hard to guarantee for exceptions. Such systems (e.g. flight control software) typically also ban the use of dynamic (heap) memory. So, the primary guideline for error handling is \u201cuse exceptions and RAII .\u201d This section deals with the cases where you either do not have an efficient implementation of exceptions, or have such a rat\u2019s nest of old-style code (e.g., lots of pointers, ill-defined ownership, and lots of unsystematic error handling based on tests of error codes) that it is infeasible to introduce simple and systematic exception handling. Before condemning exceptions or complaining too much about their cost, consider examples of the use of error codes . Consider the cost and complexity of the use of error codes. If performance is your worry, measure.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_283","text":"Assume you wanted to write void func(zstring arg) { Gadget g {arg}; // ... } If the gadget isn\u2019t correctly constructed, func exits with an exception. If we cannot throw an exception, we can simulate this RAII style of resource handling by adding a valid() member function to Gadget : error_indicator func(zstring arg) { Gadget g {arg}; if (!g.valid()) return gadget_construction_error; // ... return 0; // zero indicates \"good\" } The problem is of course that the caller now has to remember to test the return value. See also : Discussion","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_291","text":"Possible (only) for specific versions of this idea: e.g., test for systematic test of valid() after resource handle construction","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#e26-if-you-cant-throw-exceptions-consider-failing-fast","text":"","title":"E.26: If you can't throw exceptions, consider failing fast"},{"location":"cppcg/CppCoreGuidelines/#reason_321","text":"If you can\u2019t do a good job at recovering, at least you can get out before too much consequential damage is done. See also : Simulating RAII","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_277","text":"If you cannot be systematic about error handling, consider \u201ccrashing\u201d as a response to any error that cannot be handled locally. That is, if you cannot recover from an error in the context of the function that detected it, call abort() , quick_exit() , or a similar function that will trigger some sort of system restart. In systems where you have lots of processes and/or lots of computers, you need to expect and handle fatal crashes anyway, say from hardware failures. In such cases, \u201ccrashing\u201d is simply leaving error handling to the next level of the system.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_284","text":"void f(int n) { // ... p = static_cast<X*>(malloc(n * sizeof(X))); if (!p) abort(); // abort if memory is exhausted // ... } Most programs cannot handle memory exhaustion gracefully anyway. This is roughly equivalent to void f(int n) { // ... p = new X[n]; // throw if memory is exhausted (by default, terminate) // ... } Typically, it is a good idea to log the reason for the \u201ccrash\u201d before exiting.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_292","text":"Awkward","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#e27-if-you-cant-throw-exceptions-use-error-codes-systematically","text":"","title":"E.27: If you can't throw exceptions, use error codes systematically"},{"location":"cppcg/CppCoreGuidelines/#reason_322","text":"Systematic use of any error-handling strategy minimizes the chance of forgetting to handle an error. See also : Simulating RAII","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_278","text":"There are several issues to be addressed: How do you transmit an error indicator from out of a function? How do you release all resources from a function before doing an error exit? What do you use as an error indicator? In general, returning an error indicator implies returning two values: The result and an error indicator. The error indicator can be part of the object, e.g. an object can have a valid() indicator or a pair of values can be returned.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_285","text":"Gadget make_gadget(int n) { // ... } void user() { Gadget g = make_gadget(17); if (!g.valid()) { // error handling } // ... } This approach fits with simulated RAII resource management . The valid() function could return an error_indicator (e.g. a member of an error_indicator enumeration).","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_286","text":"What if we cannot or do not want to modify the Gadget type? In that case, we must return a pair of values. For example: std::pair<Gadget, error_indicator> make_gadget(int n) { // ... } void user() { auto r = make_gadget(17); if (!r.second) { // error handling } Gadget& g = r.first; // ... } As shown, std::pair is a possible return type. Some people prefer a specific type. For example: Gval make_gadget(int n) { // ... } void user() { auto r = make_gadget(17); if (!r.err) { // error handling } Gadget& g = r.val; // ... } One reason to prefer a specific return type is to have names for its members, rather than the somewhat cryptic first and second and to avoid confusion with other uses of std::pair .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_287","text":"In general, you must clean up before an error exit. This can be messy: std::pair<int, error_indicator> user() { Gadget g1 = make_gadget(17); if (!g1.valid()) { return {0, g1_error}; } Gadget g2 = make_gadget(17); if (!g2.valid()) { cleanup(g1); return {0, g2_error}; } // ... if (all_foobar(g1, g2)) { cleanup(g1); cleanup(g2); return {0, foobar_error}; // ... cleanup(g1); cleanup(g2); return {res, 0}; } Simulating RAII can be non-trivial, especially in functions with multiple resources and multiple possible errors. A not uncommon technique is to gather cleanup at the end of the function to avoid repetition (note the extra scope around g2 is undesirable but necessary to make the goto version compile): std::pair<int, error_indicator> user() { error_indicator err = 0; Gadget g1 = make_gadget(17); if (!g1.valid()) { err = g1_error; goto exit; } { Gadget g2 = make_gadget(17); if (!g2.valid()) { err = g2_error; goto exit; } if (all_foobar(g1, g2)) { err = foobar_error; goto exit; } // ... } exit: if (g1.valid()) cleanup(g1); if (g2.valid()) cleanup(g2); return {res, err}; } The larger the function, the more tempting this technique becomes. finally can ease the pain a bit . Also, the larger the program becomes the harder it is to apply an error-indicator-based error-handling strategy systematically. We prefer exception-based error handling and recommend keeping functions short . See also : Discussion See also : Returning multiple values","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_293","text":"Awkward.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#e28-avoid-error-handling-based-on-global-state-eg-errno","text":"","title":"E.28: Avoid error handling based on global state (e.g. errno)"},{"location":"cppcg/CppCoreGuidelines/#reason_323","text":"Global state is hard to manage and it is easy to forget to check it. When did you last test the return value of printf() ? See also : Simulating RAII","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_122","text":"int last_err; void f(int n) { // ... p = static_cast<X*>(malloc(n * sizeof(X))); if (!p) last_err = -1; // error if memory is exhausted // ... }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_279","text":"C-style error handling is based on the global variable errno , so it is essentially impossible to avoid this style completely.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_294","text":"Awkward.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#e30-dont-use-exception-specifications","text":"","title":"E.30: Don't use exception specifications"},{"location":"cppcg/CppCoreGuidelines/#reason_324","text":"Exception specifications make error handling brittle, impose a run-time cost, and have been removed from the C++ standard.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_288","text":"int use(int arg) throw(X, Y) { // ... auto x = f(arg); // ... } If f() throws an exception different from X and Y the unexpected handler is invoked, which by default terminates. That\u2019s OK, but say that we have checked that this cannot happen and f is changed to throw a new exception Z , we now have a crash on our hands unless we change use() (and re-test everything). The snag is that f() may be in a library we do not control and the new exception is not anything that use() can do anything about or is in any way interested in. We can change use() to pass Z through, but now use() \u2018s callers probably needs to be modified. This quickly becomes unmanageable. Alternatively, we can add a try - catch to use() to map Z into an acceptable exception. This too, quickly becomes unmanageable. Note that changes to the set of exceptions often happens at the lowest level of a system (e.g., because of changes to a network library or some middleware), so changes \u201cbubble up\u201d through long call chains. In a large code base, this could mean that nobody could update to a new version of a library until the last user was modified. If use() is part of a library, it may not be possible to update it because a change could affect unknown clients. The policy of letting exceptions propagate until they reach a function that potentially can handle it has proven itself over the years.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_280","text":"No. This would not be any better had exception specifications been statically enforced. For example, see Stroustrup94 .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_281","text":"If no exception may be thrown, use noexcept or its equivalent throw() .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_295","text":"Flag every exception specification.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#e31-properly-order-your-catch-clauses","text":"","title":"E.31: Properly order your catch-clauses"},{"location":"cppcg/CppCoreGuidelines/#reason_325","text":"catch -clauses are evaluated in the order they appear and one clause can hide another.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_289","text":"void f() { // ... try { // ... } catch (Base& b) { /* ... */ } catch (Derived& d) { /* ... */ } catch (...) { /* ... */ } catch (std::exception& e){ /* ... */ } } If Derived is derived from Base the Derived -handler will never be invoked. The \u201ccatch everything\u201d handler ensured that the std::exception -handler will never be invoked.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_296","text":"Flag all \u201chiding handlers\u201d.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#con-constants-and-immutability","text":"You can\u2019t have a race condition on a constant. It is easier to reason about a program when many of the objects cannot change their values. Interfaces that promises \u201cno change\u201d of objects passed as arguments greatly increase readability. Constant rule summary: Con.1: By default, make objects immutable Con.2: By default, make member functions const Con.3: By default, pass pointers and references to const s Con.4: Use const to define objects with values that do not change after construction Con.5: Use constexpr for values that can be computed at compile time","title":"Con: Constants and immutability"},{"location":"cppcg/CppCoreGuidelines/#con1-by-default-make-objects-immutable","text":"","title":"Con.1: By default, make objects immutable"},{"location":"cppcg/CppCoreGuidelines/#reason_326","text":"Immutable objects are easier to reason about, so make objects non- const only when there is a need to change their value. Prevents accidental or hard-to-notice change of value.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_290","text":"for (const int i : c) cout << i << '\\n'; // just reading: const for (int i : c) cout << i << '\\n'; // BAD: just reading","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_50","text":"Function arguments are rarely mutated, but also rarely declared const. To avoid confusion and lots of false positives, don\u2019t enforce this rule for function arguments. void f(const char* const p); // pedantic void g(const int i); // pedantic Note that function parameter is a local variable so changes to it are local.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_297","text":"Flag non- const variables that are not modified (except for parameters to avoid many false positives)","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#con2-by-default-make-member-functions-const","text":"","title":"Con.2: By default, make member functions const"},{"location":"cppcg/CppCoreGuidelines/#reason_327","text":"A member function should be marked const unless it changes the object\u2019s observable state. This gives a more precise statement of design intent, better readability, more errors caught by the compiler, and sometimes more optimization opportunities.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_123","text":"class Point { int x, y; public: int getx() { return x; } // BAD, should be const as it doesn't modify the object's state // ... }; void f(const Point& pt) { int x = pt.getx(); // ERROR, doesn't compile because getx was not marked const }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_282","text":"It is not inherently bad to pass a pointer or reference to non- const , but that should be done only when the called function is supposed to modify the object. A reader of code must assume that a function that takes a \u201cplain\u201d T* or T& will modify the object referred to. If it doesn\u2019t now, it might do so later without forcing recompilation.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_283","text":"There are code/libraries that offer functions that declare a T* even though those function do not modify that T . This is a problem for people modernizing code. You can update the library to be const -correct; preferred long-term solution \u201ccast away const \u201d; best avoided provide a wrapper function Example: void f(int* p); // old code: f() does not modify `*p` void f(const int* p) { f(const_cast<int*>(p)); } // wrapper Note that this wrapper solution is a patch that should be used only when the declaration of f() cannot be modified, e.g. because it is in a library that you cannot modify.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_284","text":"A const member function can modify the value of an object that is mutable or accessed through a pointer member. A common use is to maintain a cache rather than repeatedly do a complicated computation. For example, here is a Date that caches (memoizes) its string representation to simplify repeated uses: class Date { public: // ... const string& string_ref() const { if (string_val == \"\") compute_string_rep(); return string_val; } // ... private: void compute_string_rep() const; // compute string representation and place it in string_val mutable string string_val; // ... }; Another way of saying this is that const ness is not transitive. It is possible for a const member function to change the value of mutable members and the value of objects accessed through non- const pointers. It is the job of the class to ensure such mutation is done only when it makes sense according to the semantics (invariants) it offers to its users. See also : Pimpl","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_298","text":"Flag a member function that is not marked const , but that does not perform a non- const operation on any member variable.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#con3-by-default-pass-pointers-and-references-to-consts","text":"","title":"Con.3: By default, pass pointers and references to consts"},{"location":"cppcg/CppCoreGuidelines/#reason_328","text":"To avoid a called function unexpectedly changing the value. It\u2019s far easier to reason about programs when called functions don\u2019t modify state.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_291","text":"void f(char* p); // does f modify *p? (assume it does) void g(const char* p); // g does not modify *p","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_285","text":"It is not inherently bad to pass a pointer or reference to non- const , but that should be done only when the called function is supposed to modify the object.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_286","text":"Do not cast away const .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_299","text":"Flag function that does not modify an object passed by pointer or reference to non- const Flag a function that (using a cast) modifies an object passed by pointer or reference to const","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#con4-use-const-to-define-objects-with-values-that-do-not-change-after-construction","text":"","title":"Con.4: Use const to define objects with values that do not change after construction"},{"location":"cppcg/CppCoreGuidelines/#reason_329","text":"Prevent surprises from unexpectedly changed object values.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_292","text":"void f() { int x = 7; const int y = 9; for (;;) { // ... } // ... } As x is not const , we must assume that it is modified somewhere in the loop.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_300","text":"Flag unmodified non- const variables.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#con5-use-constexpr-for-values-that-can-be-computed-at-compile-time","text":"","title":"Con.5: Use constexpr for values that can be computed at compile time"},{"location":"cppcg/CppCoreGuidelines/#reason_330","text":"Better performance, better compile-time checking, guaranteed compile-time evaluation, no possibility of race conditions.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_293","text":"double x = f(2); // possible run-time evaluation const double y = f(2); // possible run-time evaluation constexpr double z = f(2); // error unless f(2) can be evaluated at compile time","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_287","text":"See F.4.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_301","text":"Flag const definitions with constant expression initializers.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t-templates-and-generic-programming","text":"Generic programming is programming using types and algorithms parameterized by types, values, and algorithms. In C++, generic programming is supported by the template language mechanisms. Arguments to generic functions are characterized by sets of requirements on the argument types and values involved. In C++, these requirements are expressed by compile-time predicates called concepts. Templates can also be used for meta-programming; that is, programs that compose code at compile time. A central notion in generic programming is \u201cconcepts\u201d; that is, requirements on template arguments presented as compile-time predicates. \u201cConcepts\u201d are defined in an ISO Technical Specification: concepts . A draft of a set of standard-library concepts can be found in another ISO TS: ranges Concepts are supported in GCC 6.1 and later. Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only. If you use GCC 6.1 or later, you can uncomment them. Template use rule summary: T.1: Use templates to raise the level of abstraction of code T.2: Use templates to express algorithms that apply to many argument types T.3: Use templates to express containers and ranges T.4: Use templates to express syntax tree manipulation T.5: Combine generic and OO techniques to amplify their strengths, not their costs Concept use rule summary: T.10: Specify concepts for all template arguments T.11: Whenever possible use standard concepts T.12: Prefer concept names over auto for local variables T.13: Prefer the shorthand notation for simple, single-type argument concepts ??? Concept definition rule summary: T.20: Avoid \u201cconcepts\u201d without meaningful semantics T.21: Require a complete set of operations for a concept T.22: Specify axioms for concepts T.23: Differentiate a refined concept from its more general case by adding new use patterns T.24: Use tag classes or traits to differentiate concepts that differ only in semantics T.25: Avoid complementary constraints T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax T.30: Use concept negation ( !C<T> ) sparingly to express a minor difference T.31: Use concept disjunction ( C1<T> || C2<T> ) sparingly to express alternatives ??? Template interface rule summary: T.40: Use function objects to pass operations to algorithms T.41: Require only essential properties in a template\u2019s concepts T.42: Use template aliases to simplify notation and hide implementation details T.43: Prefer using over typedef for defining aliases T.44: Use function templates to deduce class template argument types (where feasible) T.46: Require template arguments to be at least Regular or SemiRegular T.47: Avoid highly visible unconstrained templates with common names T.48: If your compiler does not support concepts, fake them with enable_if T.49: Where possible, avoid type-erasure Template definition rule summary: T.60: Minimize a template\u2019s context dependencies T.61: Do not over-parameterize members (SCARY) T.62: Place non-dependent class template members in a non-templated base class T.64: Use specialization to provide alternative implementations of class templates T.65: Use tag dispatch to provide alternative implementations of functions T.67: Use specialization to provide alternative implementations for irregular types T.68: Use {} rather than () within templates to avoid ambiguities T.69: Inside a template, don\u2019t make an unqualified nonmember function call unless you intend it to be a customization point Template and hierarchy rule summary: T.80: Do not naively templatize a class hierarchy T.81: Do not mix hierarchies and arrays // ??? somewhere in \u201chierarchies\u201d T.82: Linearize a hierarchy when virtual functions are undesirable T.83: Do not declare a member function template virtual T.84: Use a non-template core implementation to provide an ABI-stable interface T.??: ???? Variadic template rule summary: T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types T.101: ??? How to pass arguments to a variadic template ??? T.102: ??? How to process arguments to a variadic template ??? T.103: Don\u2019t use variadic templates for homogeneous argument lists T.??: ???? Metaprogramming rule summary: T.120: Use template metaprogramming only when you really need to T.121: Use template metaprogramming primarily to emulate concepts T.122: Use templates (usually template aliases) to compute types at compile time T.123: Use constexpr functions to compute values at compile time T.124: Prefer to use standard-library TMP facilities T.125: If you need to go beyond the standard-library TMP facilities, use an existing library T.??: ???? Other template rules summary: T.140: Name all operations with potential for reuse T.141: Use an unnamed lambda if you need a simple function object in one place only T.142: Use template variables to simplify notation T.143: Don\u2019t write unintentionally nongeneric code T.144: Don\u2019t specialize function templates T.150: Check that a class matches a concept using static_assert T.??: ????","title":"T: Templates and generic programming"},{"location":"cppcg/CppCoreGuidelines/#tgp-generic-programming","text":"Generic programming is programming using types and algorithms parameterized by types, values, and algorithms.","title":"T.gp: Generic programming"},{"location":"cppcg/CppCoreGuidelines/#t1-use-templates-to-raise-the-level-of-abstraction-of-code","text":"","title":"T.1: Use templates to raise the level of abstraction of code"},{"location":"cppcg/CppCoreGuidelines/#reason_331","text":"Generality. Reuse. Efficiency. Encourages consistent definition of user types.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_124","text":"Conceptually, the following requirements are wrong because what we want of T is more than just the very low-level concepts of \u201ccan be incremented\u201d or \u201ccan be added\u201d: template<typename T> // requires Incrementable<T> T sum1(vector<T>& v, T s) { for (auto x : v) s += x; return s; } template<typename T> // requires Simple_number<T> T sum2(vector<T>& v, T s) { for (auto x : v) s = s + x; return s; } Assuming that Incrementable does not support + and Simple_number does not support += , we have overconstrained implementers of sum1 and sum2 . And, in this case, missed an opportunity for a generalization.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_294","text":"template<typename T> // requires Arithmetic<T> T sum(vector<T>& v, T s) { for (auto x : v) s += x; return s; } Assuming that Arithmetic requires both + and += , we have constrained the user of sum to provide a complete arithmetic type. That is not a minimal requirement, but it gives the implementer of algorithms much needed freedom and ensures that any Arithmetic type can be used for a wide variety of algorithms. For additional generality and reusability, we could also use a more general Container or Range concept instead of committing to only one container, vector .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_288","text":"If we define a template to require exactly the operations required for a single implementation of a single algorithm (e.g., requiring just += rather than also = and + ) and only those, we have overconstrained maintainers. We aim to minimize requirements on template arguments, but the absolutely minimal requirements of an implementation is rarely a meaningful concept.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_289","text":"Templates can be used to express essentially everything (they are Turing complete), but the aim of generic programming (as expressed using templates) is to efficiently generalize operations/algorithms over a set of types with similar semantic properties.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_290","text":"The requires in the comments are uses of concepts . \u201cConcepts\u201d are defined in an ISO Technical Specification: concepts . Concepts are supported in GCC 6.1 and later. Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only. If you use GCC 6.1 or later, you can uncomment them.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_302","text":"Flag algorithms with \u201coverly simple\u201d requirements, such as direct use of specific operators without a concept. Do not flag the definition of the \u201coverly simple\u201d concepts themselves; they may simply be building blocks for more useful concepts.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t2-use-templates-to-express-algorithms-that-apply-to-many-argument-types","text":"","title":"T.2: Use templates to express algorithms that apply to many argument types"},{"location":"cppcg/CppCoreGuidelines/#reason_332","text":"Generality. Minimizing the amount of source code. Interoperability. Reuse.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_295","text":"That\u2019s the foundation of the STL. A single find algorithm easily works with any kind of input range: template<typename Iter, typename Val> // requires Input_iterator<Iter> // && Equality_comparable<Value_type<Iter>, Val> Iter find(Iter b, Iter e, Val v) { // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_291","text":"Don\u2019t use a template unless you have a realistic need for more than one template argument type. Don\u2019t overabstract.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_303","text":"??? tough, probably needs a human","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t3-use-templates-to-express-containers-and-ranges","text":"","title":"T.3: Use templates to express containers and ranges"},{"location":"cppcg/CppCoreGuidelines/#reason_333","text":"Containers need an element type, and expressing that as a template argument is general, reusable, and type safe. It also avoids brittle or inefficient workarounds. Convention: That\u2019s the way the STL does it.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_296","text":"template<typename T> // requires Regular<T> class Vector { // ... T* elem; // points to sz Ts int sz; }; Vector<double> v(10); v[7] = 9.9;","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_125","text":"class Container { // ... void* elem; // points to size elements of some type int sz; }; Container c(10, sizeof(double)); ((double*) c.elem)[7] = 9.9; This doesn\u2019t directly express the intent of the programmer and hides the structure of the program from the type system and optimizer. Hiding the void* behind macros simply obscures the problems and introduces new opportunities for confusion. Exceptions : If you need an ABI-stable interface, you might have to provide a base implementation and express the (type-safe) template in terms of that. See Stable base .","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_304","text":"Flag uses of void* s and casts outside low-level implementation code","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t4-use-templates-to-express-syntax-tree-manipulation","text":"","title":"T.4: Use templates to express syntax tree manipulation"},{"location":"cppcg/CppCoreGuidelines/#reason_334","text":"???","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_297","text":"??? Exceptions : ???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#t5-combine-generic-and-oo-techniques-to-amplify-their-strengths-not-their-costs","text":"","title":"T.5: Combine generic and OO techniques to amplify their strengths, not their costs"},{"location":"cppcg/CppCoreGuidelines/#reason_335","text":"Generic and OO techniques are complementary.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_298","text":"Static helps dynamic: Use static polymorphism to implement dynamically polymorphic interfaces. class Command { // pure virtual functions }; // implementations template<!--*...*/--> class ConcreteCommand : public Command { // implement virtuals };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_299","text":"Dynamic helps static: Offer a generic, comfortable, statically bound interface, but internally dispatch dynamically, so you offer a uniform object layout. Examples include type erasure as with std::shared_ptr \u2018s deleter (but don\u2019t overuse type erasure ).","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_292","text":"In a class template, nonvirtual functions are only instantiated if they\u2019re used \u2013 but virtual functions are instantiated every time. This can bloat code size, and may overconstrain a generic type by instantiating functionality that is never needed. Avoid this, even though the standard-library facets made this mistake.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#see-also_5","text":"ref ??? ref ??? ref ???","title":"See also"},{"location":"cppcg/CppCoreGuidelines/#enforcement_305","text":"See the reference to more specific rules.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#tconcepts-concept-rules","text":"Concepts is a facility for specifying requirements for template arguments. It is an ISO Technical Specification , but currently supported only by GCC. Concepts are, however, crucial in the thinking about generic programming and the basis of much work on future C++ libraries (standard and other). This section assumes concept support Concept use rule summary: T.10: Specify concepts for all template arguments T.11: Whenever possible use standard concepts T.12: Prefer concept names over auto T.13: Prefer the shorthand notation for simple, single-type argument concepts ??? Concept definition rule summary: T.20: Avoid \u201cconcepts\u201d without meaningful semantics T.21: Require a complete set of operations for a concept T.22: Specify axioms for concepts T.23: Differentiate a refined concept from its more general case by adding new use patterns T.24: Use tag classes or traits to differentiate concepts that differ only in semantics T.25: Avoid complimentary constraints T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax ???","title":"T.concepts: Concept rules"},{"location":"cppcg/CppCoreGuidelines/#tcon-use-concept-use","text":"","title":"T.con-use: Concept use"},{"location":"cppcg/CppCoreGuidelines/#t10-specify-concepts-for-all-template-arguments","text":"","title":"T.10: Specify concepts for all template arguments"},{"location":"cppcg/CppCoreGuidelines/#reason_336","text":"Correctness and readability. The assumed meaning (syntax and semantics) of a template argument is fundamental to the interface of a template. A concept dramatically improves documentation and error handling for the template. Specifying concepts for template arguments is a powerful design tool.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_300","text":"template<typename Iter, typename Val> // requires Input_iterator<Iter> // && Equality_comparable<Value_type<Iter>, Val> Iter find(Iter b, Iter e, Val v) { // ... } or equivalently and more succinctly: template<Input_iterator Iter, typename Val> // requires Equality_comparable<Value_type<Iter>, Val> Iter find(Iter b, Iter e, Val v) { // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_293","text":"\u201cConcepts\u201d are defined in an ISO Technical Specification: concepts . A draft of a set of standard-library concepts can be found in another ISO TS: ranges Concepts are supported in GCC 6.1 and later. Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only. If you use GCC 6.1 or later, you can uncomment them: template<typename Iter, typename Val> requires Input_iterator<Iter> && Equality_comparable<Value_type<Iter>, Val> Iter find(Iter b, Iter e, Val v) { // ... }","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_294","text":"Plain typename (or auto ) is the least constraining concept. It should be used only rarely when nothing more than \u201cit\u2019s a type\u201d can be assumed. This is typically only needed when (as part of template metaprogramming code) we manipulate pure expression trees, postponing type checking. References : TC++PL4, Palo Alto TR, Sutton","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_306","text":"Flag template type arguments without concepts","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t11-whenever-possible-use-standard-concepts","text":"","title":"T.11: Whenever possible use standard concepts"},{"location":"cppcg/CppCoreGuidelines/#reason_337","text":"\u201cStandard\u201d concepts (as provided by the GSL and the Ranges TS , and hopefully soon the ISO standard itself) save us the work of thinking up our own concepts, are better thought out than we can manage to do in a hurry, and improve interoperability.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_295","text":"Unless you are creating a new generic library, most of the concepts you need will already be defined by the standard library.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-using-ts-concepts","text":"template<typename T> // don't define this: Sortable is in the GSL concept Ordered_container = Sequence<T> && Random_access<Iterator<T>> && Ordered<Value_type<T>>; void sort(Ordered_container& s); This Ordered_container is quite plausible, but it is very similar to the Sortable concept in the GSL (and the Range TS). Is it better? Is it right? Does it accurately reflect the standard\u2019s requirements for sort ? It is better and simpler just to use Sortable : void sort(Sortable& s); // better","title":"Example (using TS concepts)"},{"location":"cppcg/CppCoreGuidelines/#note_296","text":"The set of \u201cstandard\u201d concepts is evolving as we approach an ISO standard including concepts.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_297","text":"Designing a useful concept is challenging.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_307","text":"Hard. Look for unconstrained arguments, templates that use \u201cunusual\u201d/non-standard concepts, templates that use \u201chomebrew\u201d concepts without axioms. Develop a concept-discovery tool (e.g., see an early experiment ).","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t12-prefer-concept-names-over-auto-for-local-variables","text":"","title":"T.12: Prefer concept names over auto for local variables"},{"location":"cppcg/CppCoreGuidelines/#reason_338","text":"auto is the weakest concept. Concept names convey more meaning than just auto .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-using-ts-concepts_1","text":"vector<string> v{ \"abc\", \"xyz\" }; auto& x = v.front(); // bad String& s = v.front(); // good (String is a GSL concept)","title":"Example (using TS concepts)"},{"location":"cppcg/CppCoreGuidelines/#enforcement_308","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t13-prefer-the-shorthand-notation-for-simple-single-type-argument-concepts","text":"","title":"T.13: Prefer the shorthand notation for simple, single-type argument concepts"},{"location":"cppcg/CppCoreGuidelines/#reason_339","text":"Readability. Direct expression of an idea.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-using-ts-concepts_2","text":"To say \u201c T is Sortable \u201d: template<typename T> // Correct but verbose: \"The parameter is // requires Sortable<T> // of type T which is the name of a type void sort(T&); // that is Sortable\" template<Sortable T> // Better (assuming support for concepts): \"The parameter is of type T void sort(T&); // which is Sortable\" void sort(Sortable&); // Best (assuming support for concepts): \"The parameter is Sortable\" The shorter versions better match the way we speak. Note that many templates don\u2019t need to use the template keyword.","title":"Example (using TS concepts)"},{"location":"cppcg/CppCoreGuidelines/#note_298","text":"\u201cConcepts\u201d are defined in an ISO Technical Specification: concepts . A draft of a set of standard-library concepts can be found in another ISO TS: ranges Concepts are supported in GCC 6.1 and later. Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only. If you use a compiler that supports concepts (e.g., GCC 6.1 or later), you can remove the // .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_309","text":"Not feasible in the short term when people convert from the <typename T> and <class T > notation. Later, flag declarations that first introduce a typename and then constrain it with a simple, single-type-argument concept.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#tconceptsdef-concept-definition-rules","text":"Defining good concepts is non-trivial. Concepts are meant to represent fundamental concepts in an application domain (hence the name \u201cconcepts\u201d). Similarly throwing together a set of syntactic constraints to be used for the arguments for a single class or algorithm is not what concepts were designed for and will not give the full benefits of the mechanism. Obviously, defining concepts will be most useful for code that can use an implementation (e.g., GCC 6.1 or later), but defining concepts is in itself a useful design technique and help catch conceptual errors and clean up the concepts (sic!) of an implementation.","title":"T.concepts.def: Concept definition rules"},{"location":"cppcg/CppCoreGuidelines/#t20-avoid-concepts-without-meaningful-semantics","text":"","title":"T.20: Avoid \"concepts\" without meaningful semantics"},{"location":"cppcg/CppCoreGuidelines/#reason_340","text":"Concepts are meant to express semantic notions, such as \u201ca number\u201d, \u201ca range\u201d of elements, and \u201ctotally ordered.\u201d Simple constraints, such as \u201chas a + operator\u201d and \u201chas a > operator\u201d cannot be meaningfully specified in isolation and should be used only as building blocks for meaningful concepts, rather than in user code.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad-using-ts-concepts","text":"template<typename T> concept Addable = has_plus<T>; // bad; insufficient template<Addable N> auto algo(const N& a, const N& b) // use two numbers { // ... return a + b; } int x = 7; int y = 9; auto z = algo(x, y); // z = 16 string xx = \"7\"; string yy = \"9\"; auto zz = algo(xx, yy); // zz = \"79\" Maybe the concatenation was expected. More likely, it was an accident. Defining minus equivalently would give dramatically different sets of accepted types. This Addable violates the mathematical rule that addition is supposed to be commutative: a+b == b+a .","title":"Example, bad (using TS concepts)"},{"location":"cppcg/CppCoreGuidelines/#note_299","text":"The ability to specify a meaningful semantics is a defining characteristic of a true concept, as opposed to a syntactic constraint.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-using-ts-concepts_3","text":"template<typename T> // The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules concept Number = has_plus<T> && has_minus<T> && has_multiply<T> && has_divide<T>; template<Number N> auto algo(const N& a, const N& b) { // ... return a + b; } int x = 7; int y = 9; auto z = algo(x, y); // z = 16 string xx = \"7\"; string yy = \"9\"; auto zz = algo(xx, yy); // error: string is not a Number","title":"Example (using TS concepts)"},{"location":"cppcg/CppCoreGuidelines/#note_300","text":"Concepts with multiple operations have far lower chance of accidentally matching a type than a single-operation concept.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_310","text":"Flag single-operation concepts when used outside the definition of other concepts . Flag uses of enable_if that appears to simulate single-operation concepts .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t21-require-a-complete-set-of-operations-for-a-concept","text":"","title":"T.21: Require a complete set of operations for a concept"},{"location":"cppcg/CppCoreGuidelines/#reason_341","text":"Ease of comprehension. Improved interoperability. Helps implementers and maintainers.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_301","text":"This is a specific variant of the general rule that a concept must make semantic sense .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad-using-ts-concepts_1","text":"template<typename T> concept Subtractable = requires(T a, T, b) { a-b; }; This makes no semantic sense. You need at least + to make - meaningful and useful. Examples of complete sets are Arithmetic : + , - , * , / , += , -= , *= , /= Comparable : < , > , <= , >= , == , !=","title":"Example, bad (using TS concepts)"},{"location":"cppcg/CppCoreGuidelines/#note_302","text":"This rule applies whether we use direct language support for concepts or not. It is a general design rule that even applies to non-templates: class Minimal { // ... }; bool operator==(const Minimal&, const Minimal&); bool operator<(const Minimal&, const Minimal&); Minimal operator+(const Minimal&, const Minimal&); // no other operators void f(const Minimal& x, const Minimal& y) { if (!(x == y)) { /* ... */ } // OK if (x != y) { /* ... */ } // surprise! error while (!(x < y)) { /* ... */ } // OK while (x >= y) { /* ... */ } // surprise! error x = x + y; // OK x += y; // surprise! error } This is minimal, but surprising and constraining for users. It could even be less efficient. The rule supports the view that a concept should reflect a (mathematically) coherent set of operations.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_301","text":"class Convenient { // ... }; bool operator==(const Convenient&, const Convenient&); bool operator<(const Convenient&, const Convenient&); // ... and the other comparison operators ... Minimal operator+(const Convenient&, const Convenient&); // .. and the other arithmetic operators ... void f(const Convenient& x, const Convenient& y) { if (!(x == y)) { /* ... */ } // OK if (x != y) { /* ... */ } // OK while (!(x < y)) { /* ... */ } // OK while (x >= y) { /* ... */ } // OK x = x + y; // OK x += y; // OK } It can be a nuisance to define all operators, but not hard. Ideally, that rule should be language supported by giving you comparison operators by default.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_311","text":"Flag classes that support \u201codd\u201d subsets of a set of operators, e.g., == but not != or + but not - . Yes, std::string is \u201codd\u201d, but it\u2019s too late to change that.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t22-specify-axioms-for-concepts","text":"","title":"T.22: Specify axioms for concepts"},{"location":"cppcg/CppCoreGuidelines/#reason_342","text":"A meaningful/useful concept has a semantic meaning. Expressing these semantics in an informal, semi-formal, or formal way makes the concept comprehensible to readers and the effort to express it can catch conceptual errors. Specifying semantics is a powerful design tool.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-using-ts-concepts_4","text":"template<typename T> // The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules // axiom(T a, T b) { a + b == b + a; a - a == 0; a * (b + c) == a * b + a * c; /*...*/ } concept Number = requires(T a, T b) { {a + b} -> T; // the result of a + b is convertible to T {a - b} -> T; {a * b} -> T; {a / b} -> T; }","title":"Example (using TS concepts)"},{"location":"cppcg/CppCoreGuidelines/#note_303","text":"This is an axiom in the mathematical sense: something that may be assumed without proof. In general, axioms are not provable, and when they are the proof is often beyond the capability of a compiler. An axiom may not be general, but the template writer may assume that it holds for all inputs actually used (similar to a precondition).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_304","text":"In this context axioms are Boolean expressions. See the Palo Alto TR for examples. Currently, C++ does not support axioms (even the ISO Concepts TS), so we have to make do with comments for a longish while. Once language support is available, the // in front of the axiom can be removed","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_305","text":"The GSL concepts have well-defined semantics; see the Palo Alto TR and the Ranges TS.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exception-using-ts-concepts","text":"Early versions of a new \u201cconcept\u201d still under development will often just define simple sets of constraints without a well-specified semantics. Finding good semantics can take effort and time. An incomplete set of constraints can still be very useful: // balancer for a generic binary tree template<typename Node> concept bool Balancer = requires(Node* p) { add_fixup(p); touch(p); detach(p); } So a Balancer must supply at least thee operations on a tree Node , but we are not yet ready to specify detailed semantics because a new kind of balanced tree might require more operations and the precise general semantics for all nodes is hard to pin down in the early stages of design. A \u201cconcept\u201d that is incomplete or without a well-specified semantics can still be useful. For example, it allows for some checking during initial experimentation. However, it should not be assumed to be stable. Each new use case may require such an incomplete concept to be improved.","title":"Exception (using TS concepts)"},{"location":"cppcg/CppCoreGuidelines/#enforcement_312","text":"Look for the word \u201caxiom\u201d in concept definition comments","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t23-differentiate-a-refined-concept-from-its-more-general-case-by-adding-new-use-patterns","text":"","title":"T.23: Differentiate a refined concept from its more general case by adding new use patterns."},{"location":"cppcg/CppCoreGuidelines/#reason_343","text":"Otherwise they cannot be distinguished automatically by the compiler.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-using-ts-concepts_5","text":"template<typename I> concept bool Input_iter = requires(I iter) { ++iter; }; template<typename I> concept bool Fwd_iter = Input_iter<I> && requires(I iter) { iter++; } The compiler can determine refinement based on the sets of required operations (here, suffix ++ ). This decreases the burden on implementers of these types since they do not need any special declarations to \u201chook into the concept\u201d. If two concepts have exactly the same requirements, they are logically equivalent (there is no refinement).","title":"Example (using TS concepts)"},{"location":"cppcg/CppCoreGuidelines/#enforcement_313","text":"Flag a concept that has exactly the same requirements as another already-seen concept (neither is more refined). To disambiguate them, see T.24 .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t24-use-tag-classes-or-traits-to-differentiate-concepts-that-differ-only-in-semantics","text":"","title":"T.24: Use tag classes or traits to differentiate concepts that differ only in semantics."},{"location":"cppcg/CppCoreGuidelines/#reason_344","text":"Two concepts requiring the same syntax but having different semantics leads to ambiguity unless the programmer differentiates them.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-using-ts-concepts_6","text":"template<typename I> // iterator providing random access concept bool RA_iter = ...; template<typename I> // iterator providing random access to contiguous data concept bool Contiguous_iter = RA_iter<I> && is_contiguous<I>::value; // using is_contiguous trait The programmer (in a library) must define is_contiguous (a trait) appropriately. Wrapping a tag class into a concept leads to a simpler expression of this idea: template<typename I> concept Contiguous = is_contiguous<I>::value; template<typename I> concept bool Contiguous_iter = RA_iter<I> && Contiguous<I>; The programmer (in a library) must define is_contiguous (a trait) appropriately.","title":"Example (using TS concepts)"},{"location":"cppcg/CppCoreGuidelines/#note_306","text":"Traits can be trait classes or type traits. These can be user-defined or standard-library ones. Prefer the standard-library ones.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_314","text":"The compiler flags ambiguous use of identical concepts. Flag the definition of identical concepts.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t25-avoid-complementary-constraints","text":"","title":"T.25: Avoid complementary constraints"},{"location":"cppcg/CppCoreGuidelines/#reason_345","text":"Clarity. Maintainability. Functions with complementary requirements expressed using negation are brittle.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-using-ts-concepts_7","text":"Initially, people will try to define functions with complementary requirements: template<typename T> requires !C<T> // bad void f(); template<typename T> requires C<T> void f(); This is better: template<typename T> // general template void f(); template<typename T> // specialization by concept requires C<T> void f(); The compiler will choose the unconstrained template only when C<T> is unsatisfied. If you do not want to (or cannot) define an unconstrained version of f() , then delete it. template<typename T> void f() = delete; The compiler will select the overload and emit an appropriate error.","title":"Example (using TS concepts)"},{"location":"cppcg/CppCoreGuidelines/#note_307","text":"Complementary constraints are unfortunately common in enable_if code: template<typename T> enable_if<!--C<T-->, void> // bad f(); template<typename T> enable_if<C<T>, void> f();","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_308","text":"Complementary requirements on one requirements is sometimes (wrongly) considered manageable. However, for two or more requirements the number of definitions needs can go up exponentially (2,4,9,16,\u2026): C1<T> && C2<T> !C1<T> && C2<T> C1<T> && !C2<T> !C1<T> && !C2<T> Now the opportunities for errors multiply.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_315","text":"Flag pairs of functions with C<T> and !C<T> constraints","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t26-prefer-to-define-concepts-in-terms-of-use-patterns-rather-than-simple-syntax","text":"","title":"T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax"},{"location":"cppcg/CppCoreGuidelines/#reason_346","text":"The definition is more readable and corresponds directly to what a user has to write. Conversions are taken into account. You don\u2019t have to remember the names of all the type traits.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-using-ts-concepts_8","text":"You might be tempted to define a concept Equality like this: template<typename T> concept Equality = has_equal<T> && has_not_equal<T>; Obviously, it would be better and easier just to use the standard EqualityComparable , but - just as an example - if you had to define such a concept, prefer: template<typename T> concept Equality = requires(T a, T b) { bool == { a == b } bool == { a != b } // axiom { !(a == b) == (a != b) } // axiom { a = b; => a == b } // => means \"implies\" } as opposed to defining two meaningless concepts has_equal and has_not_equal just as helpers in the definition of Equality . By \u201cmeaningless\u201d we mean that we cannot specify the semantics of has_equal in isolation.","title":"Example (using TS concepts)"},{"location":"cppcg/CppCoreGuidelines/#enforcement_316","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#template-interfaces","text":"Over the years, programming with templates have suffered from a weak distinction between the interface of a template and its implementation. Before concepts, that distinction had no direct language support. However, the interface to a template is a critical concept - a contract between a user and an implementer - and should be carefully designed.","title":"Template interfaces"},{"location":"cppcg/CppCoreGuidelines/#t40-use-function-objects-to-pass-operations-to-algorithms","text":"","title":"T.40: Use function objects to pass operations to algorithms"},{"location":"cppcg/CppCoreGuidelines/#reason_347","text":"Function objects can carry more information through an interface than a \u201cplain\u201d pointer to function. In general, passing function objects gives better performance than passing pointers to functions.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-using-ts-concepts_9","text":"bool greater(double x, double y) { return x > y; } sort(v, greater); // pointer to function: potentially slow sort(v, [](double x, double y) { return x > y; }); // function object sort(v, std::greater<>); // function object bool greater_than_7(double x) { return x > 7; } auto x = find_if(v, greater_than_7); // pointer to function: inflexible auto y = find_if(v, [](double x) { return x > 7; }); // function object: carries the needed data auto z = find_if(v, Greater_than<double>(7)); // function object: carries the needed data You can, of course, generalize those functions using auto or (when and where available) concepts. For example: auto y1 = find_if(v, [](Ordered x) { return x > 7; }); // require an ordered type auto z1 = find_if(v, [](auto x) { return x > 7; }); // hope that the type has a >","title":"Example (using TS concepts)"},{"location":"cppcg/CppCoreGuidelines/#note_309","text":"Lambdas generate function objects.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_310","text":"The performance argument depends on compiler and optimizer technology.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_317","text":"Flag pointer to function template arguments. Flag pointers to functions passed as arguments to a template (risk of false positives).","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t41-require-only-essential-properties-in-a-templates-concepts","text":"","title":"T.41: Require only essential properties in a template's concepts"},{"location":"cppcg/CppCoreGuidelines/#reason_348","text":"Keep interfaces simple and stable.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-using-ts-concepts_10","text":"Consider, a sort instrumented with (oversimplified) simple debug support: void sort(Sortable& s) // sort sequence s { if (debug) cerr << \"enter sort( \" << s << \")\\n\"; // ... if (debug) cerr << \"exit sort( \" << s << \")\\n\"; } Should this be rewritten to: template<Sortable S> requires Streamable<S> void sort(S& s) // sort sequence s { if (debug) cerr << \"enter sort( \" << s << \")\\n\"; // ... if (debug) cerr << \"exit sort( \" << s << \")\\n\"; } After all, there is nothing in Sortable that requires iostream support. On the other hand, there is nothing in the fundamental idea of sorting that says anything about debugging.","title":"Example (using TS concepts)"},{"location":"cppcg/CppCoreGuidelines/#note_311","text":"If we require every operation used to be listed among the requirements, the interface becomes unstable: Every time we change the debug facilities, the usage data gathering, testing support, error reporting, etc., the definition of the template would need change and every use of the template would have to be recompiled. This is cumbersome, and in some environments infeasible. Conversely, if we use an operation in the implementation that is not guaranteed by concept checking, we may get a late compile-time error. By not using concept checking for properties of a template argument that is not considered essential, we delay checking until instantiation time. We consider this a worthwhile tradeoff. Note that using non-local, non-dependent names (such as debug and cerr ) also introduces context dependencies that may lead to \u201cmysterious\u201d errors.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_312","text":"It can be hard to decide which properties of a type are essential and which are not.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_318","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t42-use-template-aliases-to-simplify-notation-and-hide-implementation-details","text":"","title":"T.42: Use template aliases to simplify notation and hide implementation details"},{"location":"cppcg/CppCoreGuidelines/#reason_349","text":"Improved readability. Implementation hiding. Note that template aliases replace many uses of traits to compute a type. They can also be used to wrap a trait.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_302","text":"template<typename T, size_t N> class Matrix { // ... using Iterator = typename std::vector<T>::iterator; // ... }; This saves the user of Matrix from having to know that its elements are stored in a vector and also saves the user from repeatedly typing typename std::vector<T>:: .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_303","text":"template<typename T> void user(T& c) { // ... typename container_traits<T>::value_type x; // bad, verbose // ... } template<typename T> using Value_type = typename container_traits<T>::value_type; This saves the user of Value_type from having to know the technique used to implement value_type s. template<typename T> void user2(T& c) { // ... Value_type<T> x; // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_313","text":"A simple, common use could be expressed: \u201cWrap traits!\u201d","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_319","text":"Flag use of typename as a disambiguator outside using declarations. ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t43-prefer-using-over-typedef-for-defining-aliases","text":"","title":"T.43: Prefer using over typedef for defining aliases"},{"location":"cppcg/CppCoreGuidelines/#reason_350","text":"Improved readability: With using , the new name comes first rather than being embedded somewhere in a declaration. Generality: using can be used for template aliases, whereas typedef s can\u2019t easily be templates. Uniformity: using is syntactically similar to auto .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_304","text":"typedef int (*PFI)(int); // OK, but convoluted using PFI2 = int (*)(int); // OK, preferred template<typename T> typedef int (*PFT)(T); // error template<typename T> using PFT2 = int (*)(T); // OK","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_320","text":"Flag uses of typedef . This will give a lot of \u201chits\u201d :-(","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t44-use-function-templates-to-deduce-class-template-argument-types-where-feasible","text":"","title":"T.44: Use function templates to deduce class template argument types (where feasible)"},{"location":"cppcg/CppCoreGuidelines/#reason_351","text":"Writing the template argument types explicitly can be tedious and unnecessarily verbose.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_305","text":"tuple<int, string, double> t1 = {1, \"Hamlet\", 3.14}; // explicit type auto t2 = make_tuple(1, \"Ophelia\"s, 3.14); // better; deduced type Note the use of the s suffix to ensure that the string is a std::string , rather than a C-style string.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_314","text":"Since you can trivially write a make_T function, so could the compiler. Thus, make_T functions may become redundant in the future.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exception_51","text":"Sometimes there isn\u2019t a good way of getting the template arguments deduced and sometimes, you want to specify the arguments explicitly: vector<double> v = { 1, 2, 3, 7.9, 15.99 }; list<Record*> lst;","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#note_315","text":"Note that C++17 will make this rule redundant by allowing the template arguments to be deduced directly from constructor arguments: Template parameter deduction for constructors (Rev. 3) . For example: tuple t1 = {1, \"Hamlet\"s, 3.14}; // deduced: tuple<int, string, double>","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_321","text":"Flag uses where an explicitly specialized type exactly matches the types of the arguments used.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t46-require-template-arguments-to-be-at-least-regular-or-semiregular","text":"","title":"T.46: Require template arguments to be at least Regular or SemiRegular"},{"location":"cppcg/CppCoreGuidelines/#reason_352","text":"Readability. Preventing surprises and errors. Most uses support that anyway.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_306","text":"class X { // ... public: explicit X(int); X(const X&); // copy X operator=(const X&); X(X&&) noexcept; // move X& operator=(X&&) noexcept; ~X(); // ... no more constructors ... }; X x {1}; // fine X y = x; // fine std::vector<X> v(10); // error: no default constructor","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_316","text":"Semiregular requires default constructible.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_322","text":"Flag types that are not at least SemiRegular .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t47-avoid-highly-visible-unconstrained-templates-with-common-names","text":"","title":"T.47: Avoid highly visible unconstrained templates with common names"},{"location":"cppcg/CppCoreGuidelines/#reason_353","text":"An unconstrained template argument is a perfect match for anything so such a template can be preferred over more specific types that require minor conversions. This is particularly annoying/dangerous when ADL is used. Common names make this problem more likely.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_307","text":"namespace Bad { struct S { int m; }; template<typename T1, typename T2> bool operator==(T1, T2) { cout << \"Bad\\n\"; return true; } } namespace T0 { bool operator==(int, Bad::S) { cout << \"T0\\n\"; return true; } // compare to int void test() { Bad::S bad{ 1 }; vector<int> v(10); bool b = 1 == bad; bool b2 = v.size() == bad; } } This prints T0 and Bad . Now the == in Bad was designed to cause trouble, but would you have spotted the problem in real code? The problem is that v.size() returns an unsigned integer so that a conversion is needed to call the local == ; the == in Bad requires no conversions. Realistic types, such as the standard-library iterators can be made to exhibit similar anti-social tendencies.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_317","text":"If an unconstrained template is defined in the same namespace as a type, that unconstrained template can be found by ADL (as happened in the example). That is, it is highly visible.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_318","text":"This rule should not be necessary, but the committee cannot agree to exclude unconstrained templated from ADL. Unfortunately this will get many false positives; the standard library violates this widely, by putting many unconstrained templates and types into the single namespace std .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_323","text":"Flag templates defined in a namespace where concrete types are also defined (maybe not feasible until we have concepts).","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t48-if-your-compiler-does-not-support-concepts-fake-them-with-enable_if","text":"","title":"T.48: If your compiler does not support concepts, fake them with enable_if"},{"location":"cppcg/CppCoreGuidelines/#reason_354","text":"Because that\u2019s the best we can do without direct concept support. enable_if can be used to conditionally define functions and to select among a set of functions.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_308","text":"template <typename T> enable_if_t<is_integral_v<T>> f(T v) { // ... } // Equivalent to: template <Integral T> void f(T v) { // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_319","text":"Beware of complementary constraints . Faking concept overloading using enable_if sometimes forces us to use that error-prone design technique.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_324","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t49-where-possible-avoid-type-erasure","text":"","title":"T.49: Where possible, avoid type-erasure"},{"location":"cppcg/CppCoreGuidelines/#reason_355","text":"Type erasure incurs an extra level of indirection by hiding type information behind a separate compilation boundary.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_309","text":"??? Exceptions : Type erasure is sometimes appropriate, such as for std::function .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_325","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#note_320","text":"","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#tdef-template-definitions","text":"A template definition (class or function) can contain arbitrary code, so only a comprehensive review of C++ programming techniques would cover this topic. However, this section focuses on what is specific to template implementation. In particular, it focuses on a template definition\u2019s dependence on its context.","title":"T.def: Template definitions"},{"location":"cppcg/CppCoreGuidelines/#t60-minimize-a-templates-context-dependencies","text":"","title":"T.60: Minimize a template's context dependencies"},{"location":"cppcg/CppCoreGuidelines/#reason_356","text":"Eases understanding. Minimizes errors from unexpected dependencies. Eases tool creation.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_310","text":"template<typename C> void sort(C& c) { std::sort(begin(c), end(c)); // necessary and useful dependency } template<typename Iter> Iter algo(Iter first, Iter last) { for (; first != last; ++first) { auto x = sqrt(*first); // potentially surprising dependency: which sqrt()? helper(first, x); // potentially surprising dependency: // helper is chosen based on first and x TT var = 7; // potentially surprising dependency: which TT? } }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_321","text":"Templates typically appear in header files so their context dependencies are more vulnerable to #include order dependencies than functions in .cpp files.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_322","text":"Having a template operate only on its arguments would be one way of reducing the number of dependencies to a minimum, but that would generally be unmanageable. For example, an algorithm usually uses other algorithms and invoke operations that does not exclusively operate on arguments. And don\u2019t get us started on macros! See also : T.69","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_326","text":"Tricky","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t61-do-not-over-parameterize-members-scary","text":"","title":"T.61: Do not over-parameterize members (SCARY)"},{"location":"cppcg/CppCoreGuidelines/#reason_357","text":"A member that does not depend on a template parameter cannot be used except for a specific template argument. This limits use and typically increases code size.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_126","text":"template<typename T, typename A = std::allocator{}> // requires Regular<T> && Allocator<A> class List { public: struct Link { // does not depend on A T elem; T* pre; T* suc; }; using iterator = Link*; iterator first() const { return head; } // ... private: Link* head; }; List<int> lst1; List<int, My_allocator> lst2; This looks innocent enough, but now Link formally depends on the allocator (even though it doesn\u2019t use the allocator). This forces redundant instantiations that can be surprisingly costly in some real-world scenarios. Typically, the solution is to make what would have been a nested class non-local, with its own minimal set of template parameters. template<typename T> struct Link { T elem; T* pre; T* suc; }; template<typename T, typename A = std::allocator{}> // requires Regular<T> && Allocator<A> class List2 { public: using iterator = Link<T>*; iterator first() const { return head; } // ... private: Link* head; }; List<int> lst1; List<int, My_allocator> lst2; Some people found the idea that the Link no longer was hidden inside the list scary, so we named the technique SCARY . From that academic paper: \u201cThe acronym SCARY describes assignments and initializations that are Seemingly erroneous (appearing Constrained by conflicting generic parameters), but Actually work with the Right implementation (unconstrained bY the conflict due to minimized dependencies).\u201d","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_327","text":"Flag member types that do not depend on every template argument Flag member functions that do not depend on every template argument","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t62-place-non-dependent-class-template-members-in-a-non-templated-base-class","text":"","title":"T.62: Place non-dependent class template members in a non-templated base class"},{"location":"cppcg/CppCoreGuidelines/#reason_358","text":"Allow the base class members to be used without specifying template arguments and without template instantiation.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_311","text":"template<typename T> class Foo { public: enum { v1, v2 }; // ... }; ??? struct Foo_base { enum { v1, v2 }; // ... }; template<typename T> class Foo : public Foo_base { public: // ... };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_323","text":"A more general version of this rule would be \u201cIf a template class member depends on only N template parameters out of M, place it in a base class with only N parameters.\u201d For N == 1, we have a choice of a base class of a class in the surrounding scope as in T.61 . ??? What about constants? class statics?","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_328","text":"Flag ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t64-use-specialization-to-provide-alternative-implementations-of-class-templates","text":"","title":"T.64: Use specialization to provide alternative implementations of class templates"},{"location":"cppcg/CppCoreGuidelines/#reason_359","text":"A template defines a general interface. Specialization offers a powerful mechanism for providing alternative implementations of that interface.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_312","text":"??? string specialization (==) ??? representation specialization ?","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_324","text":"???","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_329","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t65-use-tag-dispatch-to-provide-alternative-implementations-of-a-function","text":"","title":"T.65: Use tag dispatch to provide alternative implementations of a function"},{"location":"cppcg/CppCoreGuidelines/#reason_360","text":"A template defines a general interface. Tag dispatch allows us to select implementations based on specific properties of an argument type. Performance.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_313","text":"This is a simplified version of std::copy (ignoring the possibility of non-contiguous sequences) struct pod_tag {}; struct non_pod_tag {}; template<class T> struct copy_trait { using tag = non_pod_tag; }; // T is not \"plain old data\" template<> struct copy_trait<int> { using tag = pod_tag; }; // int is \"plain old data\" template<class Iter> Out copy_helper(Iter first, Iter last, Iter out, pod_tag) { // use memmove } template<class Iter> Out copy_helper(Iter first, Iter last, Iter out, non_pod_tag) { // use loop calling copy constructors } template<class Itert> Out copy(Iter first, Iter last, Iter out) { return copy_helper(first, last, out, typename copy_trait<Iter>::tag{}) } void use(vector<int>& vi, vector<int>& vi2, vector<string>& vs, vector<string>& vs2) { copy(vi.begin(), vi.end(), vi2.begin()); // uses memmove copy(vs.begin(), vs.end(), vs2.begin()); // uses a loop calling copy constructors } This is a general and powerful technique for compile-time algorithm selection.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_325","text":"When concept s become widely available such alternatives can be distinguished directly: template<class Iter> requires Pod<Value_type<iter>> Out copy_helper(In, first, In last, Out out) { // use memmove } template<class Iter> Out copy_helper(In, first, In last, Out out) { // use loop calling copy constructors }","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_330","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t67-use-specialization-to-provide-alternative-implementations-for-irregular-types","text":"","title":"T.67: Use specialization to provide alternative implementations for irregular types"},{"location":"cppcg/CppCoreGuidelines/#reason_361","text":"???","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_314","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_331","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t68-use-rather-than-within-templates-to-avoid-ambiguities","text":"","title":"T.68: Use {} rather than () within templates to avoid ambiguities"},{"location":"cppcg/CppCoreGuidelines/#reason_362","text":"() is vulnerable to grammar ambiguities.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_315","text":"template<typename T, typename U> void f(T t, U u) { T v1(x); // is v1 a function or a variable? T v2 {x}; // variable auto x = T(u); // construction or cast? } f(1, \"asdf\"); // bad: cast from const char* to int","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_332","text":"flag () initializers flag function-style casts","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t69-inside-a-template-dont-make-an-unqualified-nonmember-function-call-unless-you-intend-it-to-be-a-customization-point","text":"","title":"T.69: Inside a template, don't make an unqualified nonmember function call unless you intend it to be a customization point"},{"location":"cppcg/CppCoreGuidelines/#reason_363","text":"Provide only intended flexibility. Avoid vulnerability to accidental environmental changes.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_316","text":"There are three major ways to let calling code customize a template. template<class T> // Call a member function void test1(T t) { t.f(); // require T to provide f() } template<class T> void test2(T t) // Call a nonmember function without qualification { f(t); // require f(/*T*/) be available in caller's scope or in T's namespace } template<class T> void test3(T t) // Invoke a \"trait\" { test_traits<T>::f(t); // require customizing test_traits<> // to get non-default functions/types } A trait is usually a type alias to compute a type, a constexpr function to compute a value, or a traditional traits template to be specialized on the user\u2019s type.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_326","text":"If you intend to call your own helper function helper(t) with a value t that depends on a template type parameter, put it in a ::detail namespace and qualify the call as detail::helper(t); . An unqualified call becomes a customization point where any function helper in the namespace of t \u2018s type can be invoked; this can cause problems like unintentionally invoking unconstrained function templates .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_333","text":"In a template, flag an unqualified call to a nonmember function that passes a variable of dependent type when there is a nonmember function of the same name in the template\u2019s namespace.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#ttemp-hier-template-and-hierarchy-rules","text":"Templates are the backbone of C++\u2019s support for generic programming and class hierarchies the backbone of its support for object-oriented programming. The two language mechanisms can be used effectively in combination, but a few design pitfalls must be avoided.","title":"T.temp-hier: Template and hierarchy rules:"},{"location":"cppcg/CppCoreGuidelines/#t80-do-not-naively-templatize-a-class-hierarchy","text":"","title":"T.80: Do not naively templatize a class hierarchy"},{"location":"cppcg/CppCoreGuidelines/#reason_364","text":"Templating a class hierarchy that has many functions, especially many virtual functions, can lead to code bloat.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_127","text":"template<typename T> struct Container { // an interface virtual T* get(int i); virtual T* first(); virtual T* next(); virtual void sort(); }; template<typename T> class Vector : public Container<T> { public: // ... }; Vector<int> vi; Vector<string> vs; It is probably a dumb idea to define a sort as a member function of a container, but it is not unheard of and it makes a good example of what not to do. Given this, the compiler cannot know if vector<int>::sort() is called, so it must generate code for it. Similar for vector<string>::sort() . Unless those two functions are called that\u2019s code bloat. Imagine what this would do to a class hierarchy with dozens of member functions and dozens of derived classes with many instantiations.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_327","text":"In many cases you can provide a stable interface by not parameterizing a base; see \u201cstable base\u201d and OO and GP","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_334","text":"Flag virtual functions that depend on a template argument. ??? False positives","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t81-do-not-mix-hierarchies-and-arrays","text":"","title":"T.81: Do not mix hierarchies and arrays"},{"location":"cppcg/CppCoreGuidelines/#reason_365","text":"An array of derived classes can implicitly \u201cdecay\u201d to a pointer to a base class with potential disastrous results.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_317","text":"Assume that Apple and Pear are two kinds of Fruit s. void maul(Fruit* p) { *p = Pear{}; // put a Pear into *p p[1] = Pear{}; // put a Pear into p[1] } Apple aa [] = { an_apple, another_apple }; // aa contains Apples (obviously!) maul(aa); Apple& a0 = &aa[0]; // a Pear? Apple& a1 = &aa[1]; // a Pear? Probably, aa[0] will be a Pear (without the use of a cast!). If sizeof(Apple) != sizeof(Pear) the access to aa[1] will not be aligned to the proper start of an object in the array. We have a type violation and possibly (probably) a memory corruption. Never write such code. Note that maul() violates the a T* points to an individual object rule . Alternative : Use a proper (templatized) container: void maul2(Fruit* p) { *p = Pear{}; // put a Pear into *p } vector<Apple> va = { an_apple, another_apple }; // va contains Apples (obviously!) maul2(va); // error: cannot convert a vector<Apple> to a Fruit* maul2(&va[0]); // you asked for it Apple& a0 = &va[0]; // a Pear? Note that the assignment in maul2() violated the no-slicing rule .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_335","text":"Detect this horror!","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t82-linearize-a-hierarchy-when-virtual-functions-are-undesirable","text":"","title":"T.82: Linearize a hierarchy when virtual functions are undesirable"},{"location":"cppcg/CppCoreGuidelines/#reason_366","text":"???","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_318","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_336","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t83-do-not-declare-a-member-function-template-virtual","text":"","title":"T.83: Do not declare a member function template virtual"},{"location":"cppcg/CppCoreGuidelines/#reason_367","text":"C++ does not support that. If it did, vtbls could not be generated until link time. And in general, implementations must deal with dynamic linking.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-dont_8","text":"class Shape { // ... template<class T> virtual bool intersect(T* p); // error: template cannot be virtual };","title":"Example, don't"},{"location":"cppcg/CppCoreGuidelines/#note_328","text":"We need a rule because people keep asking about this","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#alternative_11","text":"Double dispatch, visitors, calculate which function to call","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#enforcement_337","text":"The compiler handles that.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t84-use-a-non-template-core-implementation-to-provide-an-abi-stable-interface","text":"","title":"T.84: Use a non-template core implementation to provide an ABI-stable interface"},{"location":"cppcg/CppCoreGuidelines/#reason_368","text":"Improve stability of code. Avoid code bloat.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_319","text":"It could be a base class: struct Link_base { // stable Link_base* suc; Link_base* pre; }; template<typename T> // templated wrapper to add type safety struct Link : Link_base { T val; }; struct List_base { Link_base* first; // first element (if any) int sz; // number of elements void add_front(Link_base* p); // ... }; template<typename T> class List : List_base { public: void put_front(const T& e) { add_front(new Link<T>{e}); } // implicit cast to Link_base T& front() { static_cast<Link<T>*>(first).val; } // explicit cast back to Link<T> // ... }; List<int> li; List<string> ls; Now there is only one copy of the operations linking and unlinking elements of a List . The Link and List classes do nothing but type manipulation. Instead of using a separate \u201cbase\u201d type, another common technique is to specialize for void or void* and have the general template for T be just the safely-encapsulated casts to and from the core void implementation. Alternative : Use a Pimpl implementation.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_338","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#tvar-variadic-template-rules","text":"???","title":"T.var: Variadic template rules"},{"location":"cppcg/CppCoreGuidelines/#t100-use-variadic-templates-when-you-need-a-function-that-takes-a-variable-number-of-arguments-of-a-variety-of-types","text":"","title":"T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types"},{"location":"cppcg/CppCoreGuidelines/#reason_369","text":"Variadic templates is the most general mechanism for that, and is both efficient and type-safe. Don\u2019t use C varargs.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_320","text":"??? printf","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_339","text":"Flag uses of va_arg in user code.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t101-how-to-pass-arguments-to-a-variadic-template","text":"","title":"T.101: ??? How to pass arguments to a variadic template ???"},{"location":"cppcg/CppCoreGuidelines/#reason_370","text":"???","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_321","text":"??? beware of move-only and reference arguments","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_340","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t102-how-to-process-arguments-to-a-variadic-template","text":"","title":"T.102: How to process arguments to a variadic template"},{"location":"cppcg/CppCoreGuidelines/#reason_371","text":"???","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_322","text":"??? forwarding, type checking, references","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_341","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t103-dont-use-variadic-templates-for-homogeneous-argument-lists","text":"","title":"T.103: Don't use variadic templates for homogeneous argument lists"},{"location":"cppcg/CppCoreGuidelines/#reason_372","text":"There are more precise ways of specifying a homogeneous sequence, such as an initializer_list .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_323","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_342","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#tmeta-template-metaprogramming-tmp","text":"Templates provide a general mechanism for compile-time programming. Metaprogramming is programming where at least one input or one result is a type. Templates offer Turing-complete (modulo memory capacity) duck typing at compile time. The syntax and techniques needed are pretty horrendous.","title":"T.meta: Template metaprogramming (TMP)"},{"location":"cppcg/CppCoreGuidelines/#t120-use-template-metaprogramming-only-when-you-really-need-to","text":"","title":"T.120: Use template metaprogramming only when you really need to"},{"location":"cppcg/CppCoreGuidelines/#reason_373","text":"Template metaprogramming is hard to get right, slows down compilation, and is often very hard to maintain. However, there are real-world examples where template metaprogramming provides better performance than any alternative short of expert-level assembly code. Also, there are real-world examples where template metaprogramming expresses the fundamental ideas better than run-time code. For example, if you really need AST manipulation at compile time (e.g., for optional matrix operation folding) there may be no other way in C++.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_128","text":"???","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-bad_129","text":"enable_if Instead, use concepts. But see How to emulate concepts if you don\u2019t have language support .","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_324","text":"??? good Alternative : If the result is a value, rather than a type, use a constexpr function .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_329","text":"If you feel the need to hide your template metaprogramming in macros, you have probably gone too far.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#t121-use-template-metaprogramming-primarily-to-emulate-concepts","text":"","title":"T.121: Use template metaprogramming primarily to emulate concepts"},{"location":"cppcg/CppCoreGuidelines/#reason_374","text":"Until concepts become generally available, we need to emulate them using TMP. Use cases that require concepts (e.g. overloading based on concepts) are among the most common (and simple) uses of TMP.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_325","text":"template<typename Iter> /*requires*/ enable_if<random_access_iterator<Iter>, void> advance(Iter p, int n) { p += n; } template<typename Iter> /*requires*/ enable_if<forward_iterator<Iter>, void> advance(Iter p, int n) { assert(n >= 0); while (n--) ++p;}","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_330","text":"Such code is much simpler using concepts: void advance(RandomAccessIterator p, int n) { p += n; } void advance(ForwardIterator p, int n) { assert(n >= 0); while (n--) ++p;}","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_343","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t122-use-templates-usually-template-aliases-to-compute-types-at-compile-time","text":"","title":"T.122: Use templates (usually template aliases) to compute types at compile time"},{"location":"cppcg/CppCoreGuidelines/#reason_375","text":"Template metaprogramming is the only directly supported and half-way principled way of generating types at compile time.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_331","text":"\u201cTraits\u201d techniques are mostly replaced by template aliases to compute types and constexpr functions to compute values.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_326","text":"??? big object / small object optimization","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_344","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t123-use-constexpr-functions-to-compute-values-at-compile-time","text":"","title":"T.123: Use constexpr functions to compute values at compile time"},{"location":"cppcg/CppCoreGuidelines/#reason_376","text":"A function is the most obvious and conventional way of expressing the computation of a value. Often a constexpr function implies less compile-time overhead than alternatives.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_332","text":"\u201cTraits\u201d techniques are mostly replaced by template aliases to compute types and constexpr functions to compute values.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_327","text":"template<typename T> // requires Number<T> constexpr T pow(T v, int n) // power/exponential { T res = 1; while (n--) res *= v; return res; } constexpr auto f7 = pow(pi, 7);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_345","text":"Flag template metaprograms yielding a value. These should be replaced with constexpr functions.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t124-prefer-to-use-standard-library-tmp-facilities","text":"","title":"T.124: Prefer to use standard-library TMP facilities"},{"location":"cppcg/CppCoreGuidelines/#reason_377","text":"Facilities defined in the standard, such as conditional , enable_if , and tuple , are portable and can be assumed to be known.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_328","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_346","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t125-if-you-need-to-go-beyond-the-standard-library-tmp-facilities-use-an-existing-library","text":"","title":"T.125: If you need to go beyond the standard-library TMP facilities, use an existing library"},{"location":"cppcg/CppCoreGuidelines/#reason_378","text":"Getting advanced TMP facilities is not easy and using a library makes you part of a (hopefully supportive) community. Write your own \u201cadvanced TMP support\u201d only if you really have to.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_329","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_347","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#other-template-rules","text":"","title":"Other template rules"},{"location":"cppcg/CppCoreGuidelines/#t140-name-all-operations-with-potential-for-reuse","text":"","title":"T.140: Name all operations with potential for reuse"},{"location":"cppcg/CppCoreGuidelines/#reason_379","text":"Documentation, readability, opportunity for reuse.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_330","text":"struct Rec { string name; string addr; int id; // unique identifier }; bool same(const Rec& a, const Rec& b) { return a.id == b.id; } vector<Rec*> find_id(const string& name); // find all records for \"name\" auto x = find_if(vr.begin(), vr.end(), [&](Rec& r) { if (r.name.size() != n.size()) return false; // name to compare to is in n for (int i = 0; i < r.name.size(); ++i) if (tolower(r.name[i]) != tolower(n[i])) return false; return true; } ); There is a useful function lurking here (case insensitive string comparison), as there often is when lambda arguments get large. bool compare_insensitive(const string& a, const string& b) { if (a.size() != b.size()) return false; for (int i = 0; i < a.size(); ++i) if (tolower(a[i]) != tolower(b[i])) return false; return true; } auto x = find_if(vr.begin(), vr.end(), [&](Rec& r) { compare_insensitive(r.name, n); } ); Or maybe (if you prefer to avoid the implicit name binding to n): auto cmp_to_n = [&n](const string& a) { return compare_insensitive(a, n); }; auto x = find_if(vr.begin(), vr.end(), [](const Rec& r) { return cmp_to_n(r.name); } );","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_333","text":"whether functions, lambdas, or operators.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exception_52","text":"Lambdas logically used only locally, such as an argument to for_each and similar control flow algorithms. Lambdas as initializers","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_348","text":"(hard) flag similar lambdas ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t141-use-an-unnamed-lambda-if-you-need-a-simple-function-object-in-one-place-only","text":"","title":"T.141: Use an unnamed lambda if you need a simple function object in one place only"},{"location":"cppcg/CppCoreGuidelines/#reason_380","text":"That makes the code concise and gives better locality than alternatives.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_331","text":"auto earlyUsersEnd = std::remove_if(users.begin(), users.end(), [](const User &a) { return a.id > 100; });","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_53","text":"Naming a lambda can be useful for clarity even if it is used only once.","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_349","text":"Look for identical and near identical lambdas (to be replaced with named functions or named lambdas).","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t142-use-template-variables-to-simplify-notation","text":"","title":"T.142?: Use template variables to simplify notation"},{"location":"cppcg/CppCoreGuidelines/#reason_381","text":"Improved readability.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_332","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_350","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t143-dont-write-unintentionally-nongeneric-code","text":"","title":"T.143: Don't write unintentionally nongeneric code"},{"location":"cppcg/CppCoreGuidelines/#reason_382","text":"Generality. Reusability. Don\u2019t gratuitously commit to details; use the most general facilities available.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_333","text":"Use != instead of < to compare iterators; != works for more objects because it doesn\u2019t rely on ordering. for (auto i = first; i < last; ++i) { // less generic // ... } for (auto i = first; i != last; ++i) { // good; more generic // ... } Of course, range- for is better still where it does what you want.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_334","text":"Use the least-derived class that has the functionality you need. class Base { public: Bar f(); Bar g(); }; class Derived1 : public Base { public: Bar h(); }; class Derived2 : public Base { public: Bar j(); }; // bad, unless there is a specific reason for limiting to Derived1 objects only void my_func(Derived1& param) { use(param.f()); use(param.g()); } // good, uses only Base interface so only commit to that void my_func(Base& param) { use(param.f()); use(param.g()); }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_351","text":"Flag comparison of iterators using < instead of != . Flag x.size() == 0 when x.empty() or x.is_empty() is available. Emptiness works for more containers than size(), because some containers don\u2019t know their size or are conceptually of unbounded size. Flag functions that take a pointer or reference to a more-derived type but only use functions declared in a base type.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t144-dont-specialize-function-templates","text":"","title":"T.144: Don't specialize function templates"},{"location":"cppcg/CppCoreGuidelines/#reason_383","text":"You can\u2019t partially specialize a function template per language rules. You can fully specialize a function template but you almost certainly want to overload instead \u2013 because function template specializations don\u2019t participate in overloading, they don\u2019t act as you probably wanted. Rarely, you should actually specialize by delegating to a class template that you can specialize properly.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_335","text":"??? Exceptions : If you do have a valid reason to specialize a function template, just write a single function template that delegates to a class template, then specialize the class template (including the ability to write partial specializations).","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_352","text":"Flag all specializations of a function template. Overload instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#t150-check-that-a-class-matches-a-concept-using-static_assert","text":"","title":"T.150: Check that a class matches a concept using static_assert"},{"location":"cppcg/CppCoreGuidelines/#reason_384","text":"If you intend for a class to match a concept, verifying that early saves users pain.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_336","text":"class X { public: X() = delete; X(const X&) = default; X(X&&) = default; X& operator=(const X&) = default; // ... }; Somewhere, possibly in an implementation file, let the compiler check the desired properties of X : static_assert(Default_constructible<X>); // error: X has no default constructor static_assert(Copyable<X>); // error: we forgot to define X's move constructor","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_353","text":"Not feasible.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cpl-c-style-programming","text":"C and C++ are closely related languages. They both originate in \u201cClassic C\u201d from 1978 and have evolved in ISO committees since then. Many attempts have been made to keep them compatible, but neither is a subset of the other. C rule summary: CPL.1: Prefer C++ to C CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++ CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces","title":"CPL: C-style programming"},{"location":"cppcg/CppCoreGuidelines/#cpl1-prefer-c-to-c","text":"","title":"CPL.1: Prefer C++ to C"},{"location":"cppcg/CppCoreGuidelines/#reason_385","text":"C++ provides better type checking and more notational support. It provides better support for high-level programming and often generates faster code.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_337","text":"char ch = 7; void* pv = &ch; int* pi = pv; // not C++ *pi = 999; // overwrite sizeof(int) bytes near &ch The rules for implicit casting to and from void* in C are subtle and unenforced. In particular, this example violates a rule against converting to a type with stricter alignment.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_354","text":"Use a C++ compiler.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cpl2-if-you-must-use-c-use-the-common-subset-of-c-and-c-and-compile-the-c-code-as-c","text":"","title":"CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++"},{"location":"cppcg/CppCoreGuidelines/#reason_386","text":"That subset can be compiled with both C and C++ compilers, and when compiled as C++ is better type checked than \u201cpure C.\u201d","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_338","text":"int* p1 = malloc(10 * sizeof(int)); // not C++ int* p2 = static_cast<int*>(malloc(10 * sizeof(int))); // not C, C-style C++ int* p3 = new int[10]; // not C int* p4 = (int*) malloc(10 * sizeof(int)); // both C and C++","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_355","text":"Flag if using a build mode that compiles code as C. The C++ compiler will enforce that the code is valid C++ unless you use C extension options.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#cpl3-if-you-must-use-c-for-interfaces-use-c-in-the-calling-code-using-such-interfaces","text":"","title":"CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces"},{"location":"cppcg/CppCoreGuidelines/#reason_387","text":"C++ is more expressive than C and offers better support for many types of programming.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_339","text":"For example, to use a 3 rd party C library or C systems interface, define the low-level interface in the common subset of C and C++ for better type checking. Whenever possible encapsulate the low-level interface in an interface that follows the C++ guidelines (for better abstraction, memory safety, and resource safety) and use that C++ interface in C++ code.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_340","text":"You can call C from C++: // in C: double sqrt(double); // in C++: extern \"C\" double sqrt(double); sqrt(2);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_341","text":"You can call C++ from C: // in C: X call_f(struct Y*, int); // in C++: extern \"C\" X call_f(Y* p, int i) { return p->f(i); // possibly a virtual function call }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_356","text":"None needed","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#sf-source-files","text":"Distinguish between declarations (used as interfaces) and definitions (used as implementations). Use header files to represent interfaces and to emphasize logical structure. Source file rule summary: SF.1: Use a .cpp suffix for code files and .h for interface files if your project doesn\u2019t already follow another convention SF.2: A .h file may not contain object definitions or non-inline function definitions SF.3: Use .h files for all declarations used in multiple source files SF.4: Include .h files before other declarations in a file SF.5: A .cpp file must include the .h file(s) that defines its interface SF.6: Use using namespace directives for transition, for foundation libraries (such as std ), or within a local scope (only) SF.7: Don\u2019t write using namespace at global scope in a header file SF.8: Use #include guards for all .h files SF.9: Avoid cyclic dependencies among source files SF.10: Avoid dependencies on implicitly #include d names SF.11: Header files should be self-contained SF.20: Use namespace s to express logical structure SF.21: Don\u2019t use an unnamed (anonymous) namespace in a header SF.22: Use an unnamed (anonymous) namespace for all internal/nonexported entities","title":"SF: Source files"},{"location":"cppcg/CppCoreGuidelines/#sf1-use-a-cpp-suffix-for-code-files-and-h-for-interface-files-if-your-project-doesnt-already-follow-another-convention","text":"","title":"SF.1: Use a .cpp suffix for code files and .h for interface files if your project doesn't already follow another convention"},{"location":"cppcg/CppCoreGuidelines/#reason_388","text":"It\u2019s a longstanding convention. But consistency is more important, so if your project uses something else, follow that.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_334","text":"This convention reflects a common use pattern: Headers are more often shared with C to compile as both C++ and C, which typically uses .h , and it\u2019s easier to name all headers .h instead of having different extensions for just those headers that are intended to be shared with C. On the other hand, implementation files are rarely shared with C and so should typically be distinguished from .c files, so it\u2019s normally best to name all C++ implementation files something else (such as .cpp ). The specific names .h and .cpp are not required (just recommended as a default) and other names are in widespread use. Examples are .hh , .C , and .cxx . Use such names equivalently. In this document, we refer to .h and .cpp as a shorthand for header and implementation files, even though the actual extension may be different. Your IDE (if you use one) may have strong opinions about suffixes.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_342","text":"// foo.h: extern int a; // a declaration extern void foo(); // foo.cpp: int a; // a definition void foo() { ++a; } foo.h provides the interface to foo.cpp . Global variables are best avoided.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_130","text":"// foo.h: int a; // a definition void foo() { ++a; } #include <foo.h> twice in a program and you get a linker error for two one-definition-rule violations.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_357","text":"Flag non-conventional file names. Check that .h and .cpp (and equivalents) follow the rules below.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#sf2-a-h-file-may-not-contain-object-definitions-or-non-inline-function-definitions","text":"","title":"SF.2: A .h file may not contain object definitions or non-inline function definitions"},{"location":"cppcg/CppCoreGuidelines/#reason_389","text":"Including entities subject to the one-definition rule leads to linkage errors.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_343","text":"// file.h: namespace Foo { int x = 7; int xx() { return x+x; } } // file1.cpp: #include <file.h> // ... more ... // file2.cpp: #include <file.h> // ... more ... Linking file1.cpp and file2.cpp will give two linker errors. Alternative formulation : A .h file must contain only: #include s of other .h files (possibly with include guards) templates class definitions function declarations extern declarations inline function definitions constexpr definitions const definitions using alias definitions ???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_358","text":"Check the positive list above.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#sf3-use-h-files-for-all-declarations-used-in-multiple-source-files","text":"","title":"SF.3: Use .h files for all declarations used in multiple source files"},{"location":"cppcg/CppCoreGuidelines/#reason_390","text":"Maintainability. Readability.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_131","text":"// bar.cpp: void bar() { cout << \"bar\\n\"; } // foo.cpp: extern void bar(); void foo() { bar(); } A maintainer of bar cannot find all declarations of bar if its type needs changing. The user of bar cannot know if the interface used is complete and correct. At best, error messages come (late) from the linker.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_359","text":"Flag declarations of entities in other source files not placed in a .h .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#sf4-include-h-files-before-other-declarations-in-a-file","text":"","title":"SF.4: Include .h files before other declarations in a file"},{"location":"cppcg/CppCoreGuidelines/#reason_391","text":"Minimize context dependencies and increase readability.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_344","text":"#include <vector> #include <algorithm> #include <string> // ... my code here ...","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_132","text":"#include <vector> // ... my code here ... #include <algorithm> #include <string>","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_335","text":"This applies to both .h and .cpp files.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_336","text":"There is an argument for insulating code from declarations and macros in header files by #including headers after the code we want to protect (as in the example labeled \u201cbad\u201d). However that only works for one file (at one level): Use that technique in a header included with other headers and the vulnerability reappears. a namespace (an \u201cimplementation namespace\u201d) can protect against many context dependencies. full protection and flexibility require modules. See also : Working Draft, Extensions to C++ for Modules Modules, Componentization, and Transition","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_360","text":"Easy.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#sf5-a-cpp-file-must-include-the-h-files-that-defines-its-interface","text":"","title":"SF.5: A .cpp file must include the .h file(s) that defines its interface"},{"location":"cppcg/CppCoreGuidelines/#reason_392","text":"This enables the compiler to do an early consistency check.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_133","text":"// foo.h: void foo(int); int bar(long); int foobar(int); // foo.cpp: void foo(int) { /* ... */ } int bar(double) { /* ... */ } double foobar(int); The errors will not be caught until link time for a program calling bar or foobar .","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_345","text":"// foo.h: void foo(int); int bar(long); int foobar(int); // foo.cpp: #include <foo.h> void foo(int) { /* ... */ } int bar(double) { /* ... */ } double foobar(int); // error: wrong return type The return-type error for foobar is now caught immediately when foo.cpp is compiled. The argument-type error for bar cannot be caught until link time because of the possibility of overloading, but systematic use of .h files increases the likelihood that it is caught earlier by the programmer.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_361","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#sf6-use-using-namespace-directives-for-transition-for-foundation-libraries-such-as-std-or-within-a-local-scope-only","text":"","title":"SF.6: Use using namespace directives for transition, for foundation libraries (such as std), or within a local scope (only)"},{"location":"cppcg/CppCoreGuidelines/#reason_393","text":"using namespace can lead to name clashes, so it should be used sparingly. However, it is not always possible to qualify every name from a namespace in user code (e.g., during transition) and sometimes a namespace is so fundamental and prevalent in a code base, that consistent qualification would be verbose and distracting.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_346","text":"#include <string> #include <vector> #include <iostream> #include <memory> #include <algorithm> using namespace std; // ... Here (obviously), the standard library is used pervasively and apparently no other library is used, so requiring std:: everywhere could be distracting.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_347","text":"The use of using namespace std; leaves the programmer open to a name clash with a name from the standard library #include <cmath> using namespace std; int g(int x) { int sqrt = 7; // ... return sqrt(x); // error } However, this is not particularly likely to lead to a resolution that is not an error and people who use using namespace std are supposed to know about std and about this risk.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_337","text":"A .cpp file is a form of local scope. There is little difference in the opportunities for name clashes in an N-line .cpp containing a using namespace X , an N-line function containing a using namespace X , and M functions each containing a using namespace X with N lines of code in total.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_338","text":"Don\u2019t write using namespace in a header file .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_362","text":"Flag multiple using namespace directives for different namespaces in a single source file.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#sf7-dont-write-using-namespace-at-global-scope-in-a-header-file","text":"","title":"SF.7: Don't write using namespace at global scope in a header file"},{"location":"cppcg/CppCoreGuidelines/#reason_394","text":"Doing so takes away an #include r\u2019s ability to effectively disambiguate and to use alternatives. It also makes #include d headers order-dependent as they may have different meaning when included in different orders.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_348","text":"// bad.h #include <iostream> using namespace std; // bad // user.cpp #include \"bad.h\" bool copy(/*... some parameters ...*/); // some function that happens to be named copy int main() { copy(/*...*/); // now overloads local ::copy and std::copy, could be ambiguous }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_339","text":"An exception is using namespace std::literals; . This is necessary to use string literals in header files and given the rules - users are required to name their own UDLs operator\"\"_x - they will not collide with the standard library.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_363","text":"Flag using namespace at global scope in a header file.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#sf8-use-include-guards-for-all-h-files","text":"","title":"SF.8: Use #include guards for all .h files"},{"location":"cppcg/CppCoreGuidelines/#reason_395","text":"To avoid files being #include d several times. In order to avoid include guard collisions, do not just name the guard after the filename. Be sure to also include a key and good differentiator, such as the name of library or component the header file is part of.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_349","text":"// file foobar.h: #ifndef LIBRARY_FOOBAR_H #define LIBRARY_FOOBAR_H // ... declarations ... #endif // LIBRARY_FOOBAR_H","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_364","text":"Flag .h files without #include guards.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#note_340","text":"Some implementations offer vendor extensions like #pragma once as alternative to include guards. It is not standard and it is not portable. It injects the hosting machine\u2019s filesystem semantics into your program, in addition to locking you down to a vendor. Our recommendation is to write in ISO C++: See rule P.2 .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#sf9-avoid-cyclic-dependencies-among-source-files","text":"","title":"SF.9: Avoid cyclic dependencies among source files"},{"location":"cppcg/CppCoreGuidelines/#reason_396","text":"Cycles complicates comprehension and slows down compilation. Complicates conversion to use language-supported modules (when they become available).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_341","text":"Eliminate cycles; don\u2019t just break them with #include guards.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad_134","text":"// file1.h: #include \"file2.h\" // file2.h: #include \"file3.h\" // file3.h: #include \"file1.h\"","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_365","text":"Flag all cycles.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#sf10-avoid-dependencies-on-implicitly-included-names","text":"","title":"SF.10: Avoid dependencies on implicitly #included names"},{"location":"cppcg/CppCoreGuidelines/#reason_397","text":"Avoid surprises. Avoid having to change #include s if an #include d header changes. Avoid accidentally becoming dependent on implementation details and logically separate entities included in a header.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_350","text":"#include <iostream> using namespace std; void use() // bad { string s; cin >> s; // fine getline(cin, s); // error: getline() not defined if (s == \"surprise\") { // error == not defined // ... } } <iostream> exposes the definition of std::string (\u201cwhy?\u201d makes for a fun trivia question), but it is not required to do so by transitively including the entire <string> header, resulting in the popular beginner question \u201cwhy doesn\u2019t getline(cin,s); work?\u201d or even an occasional \u201c string s cannot be compared with == ). The solution is to explicitly #include <string> : #include <iostream> #include <string> using namespace std; void use() { string s; cin >> s; // fine getline(cin, s); // fine if (s == \"surprise\") { // fine // ... } }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_342","text":"Some headers exist exactly to collect a set of consistent declarations from a variety of headers. For example: // basic_std_lib.h: #include <string> #include <map> #include <iostream> #include <random> #include <vector> a user can now get that set of declarations with a single #include \u201c #include \"basic_std_lib.h\" This rule against implicit inclusion is not meant to prevent such deliberate aggregation.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_366","text":"Enforcement would require some knowledge about what in a header is meant to be \u201cexported\u201d to users and what is there to enable implementation. No really good solution is possible until we have modules.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#sf11-header-files-should-be-self-contained","text":"","title":"SF.11: Header files should be self-contained"},{"location":"cppcg/CppCoreGuidelines/#reason_398","text":"Usability, headers should be simple to use and work when included on their own. Headers should encapsulate the functionality they provide. Avoid clients of a header having to manage that header\u2019s dependencies.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_351","text":"#include \"helpers.h\" // helpers.h depends on std::string and includes <string>","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_343","text":"Failing to follow this results in difficult to diagnose errors for clients of a header.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_344","text":"A header should include all its dependencies. Be careful about using relative paths because C++ implementations diverge on their meaning.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_367","text":"A test should verify that the header file itself compiles or that a cpp file which only includes the header file compiles.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#sf20-use-namespaces-to-express-logical-structure","text":"","title":"SF.20: Use namespaces to express logical structure"},{"location":"cppcg/CppCoreGuidelines/#reason_399","text":"???","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_352","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_368","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#sf21-dont-use-an-unnamed-anonymous-namespace-in-a-header","text":"","title":"SF.21: Don't use an unnamed (anonymous) namespace in a header"},{"location":"cppcg/CppCoreGuidelines/#reason_400","text":"It is almost always a bug to mention an unnamed namespace in a header file.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_353","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_369","text":"Flag any use of an anonymous namespace in a header file.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#sf22-use-an-unnamed-anonymous-namespace-for-all-internalnonexported-entities","text":"","title":"SF.22: Use an unnamed (anonymous) namespace for all internal/nonexported entities"},{"location":"cppcg/CppCoreGuidelines/#reason_401","text":"Nothing external can depend on an entity in a nested unnamed namespace. Consider putting every definition in an implementation source file in an unnamed namespace unless that is defining an \u201cexternal/exported\u201d entity.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_354","text":"An API class and its members can\u2019t live in an unnamed namespace; but any \u201chelper\u201d class or function that is defined in an implementation source file should be at an unnamed namespace scope. ???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_370","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#sl-the-standard-library","text":"Using only the bare language, every task is tedious (in any language). Using a suitable library any task can be reasonably simple. The standard library has steadily grown over the years. Its description in the standard is now larger than that of the language features. So, it is likely that this library section of the guidelines will eventually grow in size to equal or exceed all the rest. << ??? We need another level of rule numbering ??? >> C++ Standard Library component summary: SL.con: Containers SL.str: String SL.io: Iostream SL.regex: Regex SL.chrono: Time SL.C: The C Standard Library Standard-library rule summary: SL.1: Use libraries wherever possible SL.2: Prefer the standard library to other libraries SL.3: Do not add non-standard entities to namespace std SL.4: Use the standard library in a type-safe manner ???","title":"SL: The Standard Library"},{"location":"cppcg/CppCoreGuidelines/#sl1-use-libraries-wherever-possible","text":"","title":"SL.1:  Use libraries wherever possible"},{"location":"cppcg/CppCoreGuidelines/#reason_402","text":"Save time. Don\u2019t re-invent the wheel. Don\u2019t replicate the work of others. Benefit from other people\u2019s work when they make improvements. Help other people when you make improvements.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#sl2-prefer-the-standard-library-to-other-libraries","text":"","title":"SL.2: Prefer the standard library to other libraries"},{"location":"cppcg/CppCoreGuidelines/#reason_403","text":"More people know the standard library. It is more likely to be stable, well-maintained, and widely available than your own code or most other libraries.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#sl3-do-not-add-non-standard-entities-to-namespace-std","text":"","title":"SL.3: Do not add non-standard entities to namespace std"},{"location":"cppcg/CppCoreGuidelines/#reason_404","text":"Adding to std may change the meaning of otherwise standards conforming code. Additions to std may clash with future versions of the standard.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_355","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_371","text":"Possible, but messy and likely to cause problems with platforms.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#sl4-use-the-standard-library-in-a-type-safe-manner","text":"","title":"SL.4: Use the standard library in a type-safe manner"},{"location":"cppcg/CppCoreGuidelines/#reason_405","text":"Because, obviously, breaking this rule can lead to undefined behavior, memory corruption, and all kinds of other bad errors.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_345","text":"This is a semi-philosophical meta-rule, which needs many supporting concrete rules. We need it as an umbrella for the more specific rules. Summary of more specific rules: SL.4: Use the standard library in a type-safe manner","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#slcon-containers","text":"??? Container rule summary: SL.con.1: Prefer using STL array or vector instead of a C array SL.con.2: Prefer using STL vector by default unless you have a reason to use a different container SL.con.3: Avoid bounds errors ???","title":"SL.con: Containers"},{"location":"cppcg/CppCoreGuidelines/#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array","text":"","title":"SL.con.1: Prefer using STL array or vector instead of a C array"},{"location":"cppcg/CppCoreGuidelines/#reason_406","text":"C arrays are less safe, and have no advantages over array and vector . For a fixed-length array, use std::array , which does not degenerate to a pointer when passed to a function and does know its size. Also, like a built-in array, a stack-allocated std::array keeps its elements on the stack. For a variable-length array, use std::vector , which additionally can change its size and handles memory allocation.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_356","text":"int v[SIZE]; // BAD std::array<int, SIZE> w; // ok","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_357","text":"int* v = new int[initial_size]; // BAD, owning raw pointer delete[] v; // BAD, manual delete std::vector<int> w(initial_size); // ok","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_346","text":"Use gsl::span for non-owning references into a container.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_347","text":"Comparing the performance of a fixed-sized array allocated on the stack against a vector with its elements on the free store is bogus. You could just as well compare a std::array on the stack against the result of a malloc() accessed through a pointer. For most code, even the difference between stack allocation and free-store allocation doesn\u2019t matter, but the convenience and safety of vector does. People working with code for which that difference matters are quite capable of choosing between array and vector .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_372","text":"Flag declaration of a C array inside a function or class that also declares an STL container (to avoid excessive noisy warnings on legacy non-STL code). To fix: At least change the C array to a std::array .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#slcon2-prefer-using-stl-vector-by-default-unless-you-have-a-reason-to-use-a-different-container","text":"","title":"SL.con.2: Prefer using STL vector by default unless you have a reason to use a different container"},{"location":"cppcg/CppCoreGuidelines/#reason_407","text":"vector and array are the only standard containers that offer the following advantages: the fastest general-purpose access (random access, including being vectorization-friendly); the fastest default access pattern (begin-to-end or end-to-begin is prefetcher-friendly); the lowest space overhead (contiguous layout has zero per-element overhead, which is cache-friendly). Usually you need to add and remove elements from the container, so use vector by default; if you don\u2019t need to modify the container\u2019s size, use array . Even when other containers seem more suited, such as map for O(log N) lookup performance or a list for efficient insertion in the middle, a vector will usually still perform better for containers up to a few KB in size.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_348","text":"string should not be used as a container of individual characters. A string is a textual string; if you want a container of characters, use vector<!--*char_type*/--> or array<!--*char_type*/--> instead.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exceptions_2","text":"If you have a good reason to use another container, use that instead. For example: If vector suits your needs but you don\u2019t need the container to be variable size, use array instead. If you want a dictionary-style lookup container that guarantees O(K) or O(log N) lookups, the container will be larger (more than a few KB) and you perform frequent inserts so that the overhead of maintaining a sorted vector is infeasible, go ahead and use an unordered_map or map instead.","title":"Exceptions"},{"location":"cppcg/CppCoreGuidelines/#note_349","text":"To initialize a vector with a number of elements, use () -initialization. To initialize a vector with a list of elements, use {} -initialization. vector<int> v1(20); // v1 has 20 elements with the value 0 (vector<int>{}) vector<int> v2 {20}; // v2 has 1 element with the value 20 Prefer the {}-initializer syntax .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_373","text":"Flag a vector whose size never changes after construction (such as because it\u2019s const or because no non- const functions are called on it). To fix: Use an array instead.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#slcon3-avoid-bounds-errors","text":"","title":"SL.con.3: Avoid bounds errors"},{"location":"cppcg/CppCoreGuidelines/#reason_408","text":"Read or write beyond an allocated range of elements typically leads to bad errors, wrong results, crashes, and security violations.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_350","text":"The standard-library functions that apply to ranges of elements all have (or could have) bounds-safe overloads that take span . Standard types such as vector can be modified to perform bounds-checks under the bounds profile (in a compatible way, such as by adding contracts), or used with at() . Ideally, the in-bounds guarantee should be statically enforced. For example: a range- for cannot loop beyond the range of the container to which it is applied a v.begin(),v.end() is easily determined to be bounds safe Such loops are as fast as any unchecked/unsafe equivalent. Often a simple pre-check can eliminate the need for checking of individual indices. For example for v.begin(),v.begin()+i the i can easily be checked against v.size() Such loops can be much faster than individually checked element accesses.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example-bad_135","text":"void f() { array<int, 10> a, b; memset(a.data(), 0, 10); // BAD, and contains a length error (length = 10 * sizeof(int)) memcmp(a.data(), b.data(), 10); // BAD, and contains a length error (length = 10 * sizeof(int)) } Also, std::array<>::fill() or std::fill() or even an empty initializer are better candidate than memset() .","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_22","text":"void f() { array<int, 10> a, b, c{}; // c is initialized to zero a.fill(0); fill(b.begin(), b.end(), 0); // std::fill() fill(b, 0); // std::fill() + Ranges TS if ( a == b ) { // ... } }","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#example_358","text":"If code is using an unmodified standard library, then there are still workarounds that enable use of std::array and std::vector in a bounds-safe manner. Code can call the .at() member function on each class, which will result in an std::out_of_range exception being thrown. Alternatively, code can call the at() free function, which will result in fail-fast (or a customized action) on a bounds violation. void f(std::vector<int>& v, std::array<int, 12> a, int i) { v[0] = a[0]; // BAD v.at(0) = a[0]; // OK (alternative 1) at(v, 0) = a[0]; // OK (alternative 2) v.at(0) = a[i]; // BAD v.at(0) = a.at(i); // OK (alternative 1) v.at(0) = at(a, i); // OK (alternative 2) }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_374","text":"Insert This rule is part of the bounds profile . TODO Notes : Impact on the standard library will require close coordination with WG21, if only to ensure compatibility even if never standardized. We are considering specifying bounds-safe overloads for stdlib (especially C stdlib) functions like memcmp and shipping them in the GSL. For existing stdlib functions and types like vector that are not fully bounds-checked, the goal is for these features to be bounds-checked when called from code with the bounds profile on, and unchecked when called from legacy code, possibly using contracts (concurrently being proposed by several WG21 members).","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#slstr-string","text":"Text manipulation is a huge topic. std::string doesn\u2019t cover all of it. This section primarily tries to clarify std::string \u2018s relation to char* , zstring , string_view , and gsl::string_span . The important issue of non-ASCII character sets and encodings (e.g., wchar_t , Unicode, and UTF-8) will be covered elsewhere. See also : regular expressions Here, we use \u201csequence of characters\u201d or \u201cstring\u201d to refer to a sequence of characters meant to be read as text (somehow, eventually). We don\u2019t consider ??? String summary: SL.str.1: Use std::string to own character sequences SL.str.2: Use std::string_view or gsl::string_span to refer to character sequences SL.str.3: Use zstring or czstring to refer to a C-style, zero-terminated, sequence of characters SL.str.4: Use char* to refer to a single character SL.str.5: Use std::byte to refer to byte values that do not necessarily represent characters SL.str.10: Use std::string when you need to perform locale-sensitive string operations SL.str.11: Use gsl::string_span rather than std::string_view when you need to mutate a string SL.str.12: Use the s suffix for string literals meant to be standard-library string s See also : F.24 span F.25 zstring","title":"SL.str: String"},{"location":"cppcg/CppCoreGuidelines/#slstr1-use-stdstring-to-own-character-sequences","text":"","title":"SL.str.1: Use std::string to own character sequences"},{"location":"cppcg/CppCoreGuidelines/#reason_409","text":"string correctly handles allocation, ownership, copying, gradual expansion, and offers a variety of useful operations.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_359","text":"vector<string> read_until(const string& terminator) { vector<string> res; for (string s; cin >> s && s != terminator; ) // read a word res.push_back(s); return res; } Note how >> and != are provided for string (as examples of useful operations) and there are no explicit allocations, deallocations, or range checks ( string takes care of those). In C++17, we might use string_view as the argument, rather than const string* to allow more flexibility to callers: vector<string> read_until(string_view terminator) // C++17 { vector<string> res; for (string s; cin >> s && s != terminator; ) // read a word res.push_back(s); return res; } The gsl::string_span is a current alternative offering most of the benefits of std::string_view for simple examples: vector<string> read_until(string_span terminator) { vector<string> res; for (string s; cin >> s && s != terminator; ) // read a word res.push_back(s); return res; }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_136","text":"Don\u2019t use C-style strings for operations that require non-trivial memory management char* cat(const char* s1, const char* s2) // beware! // return s1 + '.' + s2 { int l1 = strlen(s1); int l2 = strlen(s2); char* p = (char*) malloc(l1 + l2 + 2); strcpy(p, s1, l1); p[l1] = '.'; strcpy(p + l1 + 1, s2, l2); p[l1 + l2 + 1] = 0; return p; } Did we get that right? Will the caller remember to free() the returned pointer? Will this code pass a security review?","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_351","text":"Do not assume that string is slower than lower-level techniques without measurement and remember that not all code is performance critical. Don\u2019t optimize prematurely","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_375","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#slstr2-use-stdstring_view-or-gslstring_span-to-refer-to-character-sequences","text":"","title":"SL.str.2: Use std::string_view or gsl::string_span to refer to character sequences"},{"location":"cppcg/CppCoreGuidelines/#reason_410","text":"std::string_view or gsl::string_span provides simple and (potentially) safe access to character sequences independently of how those sequences are allocated and stored.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_360","text":"vector<string> read_until(string_span terminator); void user(zstring p, const string& s, string_span ss) { auto v1 = read_until(p); auto v2 = read_until(s); auto v3 = read_until(ss); // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_352","text":"std::string_view (C++17) is read-only.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_376","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#slstr3-use-zstring-or-czstring-to-refer-to-a-c-style-zero-terminated-sequence-of-characters","text":"","title":"SL.str.3: Use zstring or czstring to refer to a C-style, zero-terminated, sequence of characters"},{"location":"cppcg/CppCoreGuidelines/#reason_411","text":"Readability. Statement of intent. A plain char* can be a pointer to a single character, a pointer to an array of characters, a pointer to a C-style (zero-terminated) string, or even to a small integer. Distinguishing these alternatives prevents misunderstandings and bugs.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_361","text":"void f1(const char* s); // s is probably a string All we know is that it is supposed to be the nullptr or point to at least one character void f1(zstring s); // s is a C-style string or the nullptr void f1(czstring s); // s is a C-style string constant or the nullptr void f1(std::byte* s); // s is a pointer to a byte (C++17)","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_353","text":"Don\u2019t convert a C-style string to string unless there is a reason to.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_354","text":"Like any other \u201cplain pointer\u201d, a zstring should not represent ownership.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_355","text":"There are billions of lines of C++ \u201cout there\u201d, most use char* and const char* without documenting intent. They are used in a wide variety of ways, including to represent ownership and as generic pointers to memory (instead of void* ). It is hard to separate these uses, so this guideline is hard to follow. This is one of the major sources of bugs in C and C++ programs, so it is worthwhile to follow this guideline wherever feasible..","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_377","text":"Flag uses of [] on a char* Flag uses of delete on a char* Flag uses of free() on a char*","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#slstr4-use-char-to-refer-to-a-single-character","text":"","title":"SL.str.4: Use char* to refer to a single character"},{"location":"cppcg/CppCoreGuidelines/#reason_412","text":"The variety of uses of char* in current code is a major source of errors.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_137","text":"char arr[] = {'a', 'b', 'c'}; void print(const char* p) { cout << p << '\\n'; } void use() { print(arr); // run-time error; potentially very bad } The array arr is not a C-style string because it is not zero-terminated.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#alternative_12","text":"See zstring , string , and string_span .","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#enforcement_378","text":"Flag uses of [] on a char*","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#slstr5-use-stdbyte-to-refer-to-byte-values-that-do-not-necessarily-represent-characters","text":"","title":"SL.str.5: Use std::byte to refer to byte values that do not necessarily represent characters"},{"location":"cppcg/CppCoreGuidelines/#reason_413","text":"Use of char* to represent a pointer to something that is not necessarily a character causes confusion and disables valuable optimizations.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_362","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_356","text":"C++17","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_379","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#slstr10-use-stdstring-when-you-need-to-perform-locale-sensitive-string-operations","text":"","title":"SL.str.10: Use std::string when you need to perform locale-sensitive string operations"},{"location":"cppcg/CppCoreGuidelines/#reason_414","text":"std::string supports standard-library locale facilities","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_363","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_357","text":"???","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_380","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#slstr11-use-gslstring_span-rather-than-stdstring_view-when-you-need-to-mutate-a-string","text":"","title":"SL.str.11: Use gsl::string_span rather than std::string_view when you need to mutate a string"},{"location":"cppcg/CppCoreGuidelines/#reason_415","text":"std::string_view is read-only.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_364","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_358","text":"???","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_381","text":"The compiler will flag attempts to write to a string_view .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#slstr12-use-the-s-suffix-for-string-literals-meant-to-be-standard-library-strings","text":"","title":"SL.str.12: Use the s suffix for string literals meant to be standard-library strings"},{"location":"cppcg/CppCoreGuidelines/#reason_416","text":"Direct expression of an idea minimizes mistakes.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_365","text":"auto pp1 = make_pair(\"Tokyo\", 9.00); // {C-style string,double} intended? pair<string, double> pp2 = {\"Tokyo\", 9.00}; // a bit verbose auto pp3 = make_pair(\"Tokyo\"s, 9.00); // {std::string,double} // C++14 pair pp4 = {\"Tokyo\"s, 9.00}; // {std::string,double} // C++17","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_382","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#slio-iostream","text":"iostream s is a type safe, extensible, formatted and unformatted I/O library for streaming I/O. It supports multiple (and user extensible) buffering strategies and multiple locales. It can be used for conventional I/O, reading and writing to memory (string streams), and user-defines extensions, such as streaming across networks (asio: not yet standardized). Iostream rule summary: SL.io.1: Use character-level input only when you have to SL.io.2: When reading, always consider ill-formed input SL.io.3: Prefer iostreams for I/O SL.io.10: Unless you use printf -family functions call ios_base::sync_with_stdio(false) SL.io.50: Avoid endl ???","title":"SL.io: Iostream"},{"location":"cppcg/CppCoreGuidelines/#slio1-use-character-level-input-only-when-you-have-to","text":"","title":"SL.io.1: Use character-level input only when you have to"},{"location":"cppcg/CppCoreGuidelines/#reason_417","text":"Unless you genuinely just deal with individual characters, using character-level input leads to the user code performing potentially error-prone and potentially inefficient composition of tokens out of characters.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_366","text":"char c; char buf[128]; int i = 0; while (cin.get(c) && !isspace(c) && i < 128) buf[i++] = c; if (i == 128) { // ... handle too long string .... } Better (much simpler and probably faster): string s; s.reserve(128); cin >> s; and the reserve(128) is probably not worthwhile.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_383","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#slio2-when-reading-always-consider-ill-formed-input","text":"","title":"SL.io.2: When reading, always consider ill-formed input"},{"location":"cppcg/CppCoreGuidelines/#reason_418","text":"Errors are typically best handled as soon as possible. If input isn\u2019t validated, every function must be written to cope with bad data (and that is not practical).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_367","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_384","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#slio3-prefer-iostreams-for-io","text":"","title":"SL.io.3: Prefer iostreams for I/O"},{"location":"cppcg/CppCoreGuidelines/#reason_419","text":"iostream s are safe, flexible, and extensible.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_368","text":"// write a complex number: complex<double> z{ 3, 4 }; cout << z << '\\n'; complex is a user-defined type and its I/O is defined without modifying the iostream library.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_369","text":"// read a file of complex numbers: for (complex<double> z; cin >> z; ) v.push_back(z);","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_54","text":"??? performance ???","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#discussion-iostreams-vs-the-printf-family","text":"It is often (and often correctly) pointed out that the printf() family has two advantages compared to iostream s: flexibility of formatting and performance. This has to be weighed against iostream s advantages of extensibility to handle user-defined types, resilient against security violations, implicit memory management, and locale handling. If you need I/O performance, you can almost always do better than printf() . gets() , scanf() using %s , and printf() using %s are security hazards (vulnerable to buffer overflow and generally error-prone). In C11, they are replaced by gets_s() , scanf_s() , and printf_s() as safer alternatives, but they are still not type safe.","title":"Discussion: iostreams vs. the printf() family"},{"location":"cppcg/CppCoreGuidelines/#enforcement_385","text":"Optionally flag <cstdio> and <stdio.h> .","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#slio10-unless-you-use-printf-family-functions-call-ios_basesync_with_stdiofalse","text":"","title":"SL.io.10: Unless you use printf-family functions call ios_base::sync_with_stdio(false)"},{"location":"cppcg/CppCoreGuidelines/#reason_420","text":"Synchronizing iostreams with printf-style I/O can be costly. cin and cout are by default synchronized with printf .","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_370","text":"int main() { ios_base::sync_with_stdio(false); // ... use iostreams ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_386","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#slio50-avoid-endl","text":"","title":"SL.io.50: Avoid endl"},{"location":"cppcg/CppCoreGuidelines/#reason_421","text":"The endl manipulator is mostly equivalent to '\\n' and \"\\n\" ; as most commonly used it simply slows down output by doing redundant flush() s. This slowdown can be significant compared to printf -style output.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_371","text":"cout << \"Hello, World!\" << endl; // two output operations and a flush cout << \"Hello, World!\\n\"; // one output operation and no flush","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_359","text":"For cin / cout (and equivalent) interaction, there is no reason to flush; that\u2019s done automatically. For writing to a file, there is rarely a need to flush .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_360","text":"Apart from the (occasionally important) issue of performance, the choice between '\\n' and endl is almost completely aesthetic.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#slregex-regex","text":"<regex> is the standard C++ regular expression library. It supports a variety of regular expression pattern conventions.","title":"SL.regex: Regex"},{"location":"cppcg/CppCoreGuidelines/#slchrono-time","text":"<chrono> (defined in namespace std::chrono ) provides the notions of time_point and duration together with functions for outputting time in various units. It provides clocks for registering time_points .","title":"SL.chrono: Time"},{"location":"cppcg/CppCoreGuidelines/#slc-the-c-standard-library","text":"??? C Standard Library rule summary: S.C.1: Don\u2019t use setjmp/longjmp ??? ???","title":"SL.C: The C Standard Library"},{"location":"cppcg/CppCoreGuidelines/#slc1-dont-use-setjmplongjmp","text":"","title":"SL.C.1: Don't use setjmp/longjmp"},{"location":"cppcg/CppCoreGuidelines/#reason_422","text":"a longjmp ignores destructors, thus invalidating all resource-management strategies relying on RAII","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#enforcement_387","text":"Flag all occurrences of longjmp and setjmp","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#a-architectural-ideas","text":"This section contains ideas about higher-level architectural ideas and libraries. Architectural rule summary: A.1: Separate stable code from less stable code A.2: Express potentially reusable parts as a library A.4: There should be no cycles among libraries ??? ??? ??? ??? ??? ???","title":"A: Architectural ideas"},{"location":"cppcg/CppCoreGuidelines/#a1-separate-stable-code-from-less-stable-code","text":"Isolating less stable code facilitates its unit testing, interface improvement, refactoring, and eventual deprecation.","title":"A.1: Separate stable code from less stable code"},{"location":"cppcg/CppCoreGuidelines/#a2-express-potentially-reusable-parts-as-a-library","text":"","title":"A.2: Express potentially reusable parts as a library"},{"location":"cppcg/CppCoreGuidelines/#reason_423","text":"","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_361","text":"A library is a collection of declarations and definitions maintained, documented, and shipped together. A library could be a set of headers (a \u201cheader-only library\u201d) or a set of headers plus a set of object files. You can statically or dynamically link a library into a program, or you can #include a header-only library.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#a4-there-should-be-no-cycles-among-libraries","text":"","title":"A.4: There should be no cycles among libraries"},{"location":"cppcg/CppCoreGuidelines/#reason_424","text":"A cycle complicates the build process. Cycles are hard to understand and may introduce indeterminism (unspecified behavior).","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_362","text":"A library can contain cyclic references in the definition of its components. For example: ??? However, a library should not depend on another that depends on it.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#nr-non-rules-and-myths","text":"This section contains rules and guidelines that are popular somewhere, but that we deliberately don\u2019t recommend. We know full well that there have been times and places where these rules made sense, and we have used them ourselves at times. However, in the context of the styles of programming we recommend and support with the guidelines, these \u201cnon-rules\u201d would do harm. Even today, there can be contexts where the rules make sense. For example, lack of suitable tool support can make exceptions unsuitable in hard-real-time systems, but please don\u2019t blindly trust \u201ccommon wisdom\u201d (e.g., unsupported statements about \u201cefficiency\u201d); such \u201cwisdom\u201d may be based on decades-old information or experienced from languages with very different properties than C++ (e.g., C or Java). The positive arguments for alternatives to these non-rules are listed in the rules offered as \u201cAlternatives\u201d. Non-rule summary: NR.1: Don\u2019t: All declarations should be at the top of a function NR.2: Don\u2019t: Have only a single return -statement in a function NR.3: Don\u2019t: Don\u2019t use exceptions NR.4: Don\u2019t: Place each class declaration in its own source file NR.5: Don\u2019t: Don\u2019t do substantive work in a constructor; instead use two-phase initialization NR.6: Don\u2019t: Place all cleanup actions at the end of a function and goto exit NR.7: Don\u2019t: Make all data members protected ???","title":"NR: Non-Rules and myths"},{"location":"cppcg/CppCoreGuidelines/#nr1-dont-all-declarations-should-be-at-the-top-of-a-function","text":"","title":"NR.1: Don't: All declarations should be at the top of a function"},{"location":"cppcg/CppCoreGuidelines/#reason-not-to-follow-this-rule","text":"This rule is a legacy of old programming languages that didn\u2019t allow initialization of variables and constants after a statement. This leads to longer programs and more errors caused by uninitialized and wrongly initialized variables.","title":"Reason (not to follow this rule)"},{"location":"cppcg/CppCoreGuidelines/#example-bad_138","text":"int use(int x) { int i; char c; double d; // ... some stuff ... if (x < i) { // ... i = f(x, d); } if (i < x) { // ... i = g(x, c); } return i; } The larger the distance between the uninitialized variable and its use, the larger the chance of a bug. Fortunately, compilers catch many \u201cused before set\u201d errors. Unfortunately, compilers cannot catch all such errors and unfortunately, the bugs aren\u2019t always as simple to spot as in this small example.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#alternative_13","text":"Always initialize an object ES.21: Don\u2019t introduce a variable (or constant) before you need to use it","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#nr2-dont-have-only-a-single-return-statement-in-a-function","text":"","title":"NR.2: Don't: Have only a single return-statement in a function"},{"location":"cppcg/CppCoreGuidelines/#reason-not-to-follow-this-rule_1","text":"The single-return rule can lead to unnecessarily convoluted code and the introduction of extra state variables. In particular, the single-return rule makes it harder to concentrate error checking at the top of a function.","title":"Reason (not to follow this rule)"},{"location":"cppcg/CppCoreGuidelines/#example_372","text":"template<class T> // requires Number<T> string sign(T x) { if (x < 0) return \"negative\"; else if (x > 0) return \"positive\"; return \"zero\"; } to use a single return only we would have to do something like template<class T> // requires Number<T> string sign(T x) // bad { string res; if (x < 0) res = \"negative\"; else if (x > 0) res = \"positive\"; else res = \"zero\"; return res; } This is both longer and likely to be less efficient. The larger and more complicated the function is, the more painful the workarounds get. Of course many simple functions will naturally have just one return because of their simpler inherent logic.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_373","text":"int index(const char* p) { if (!p) return -1; // error indicator: alternatively \"throw nullptr_error{}\" // ... do a lookup to find the index for p return i; } If we applied the rule, we\u2019d get something like int index2(const char* p) { int i; if (!p) i = -1; // error indicator else { // ... do a lookup to find the index for p } return i; } Note that we (deliberately) violated the rule against uninitialized variables because this style commonly leads to that. Also, this style is a temptation to use the goto exit non-rule.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#alternative_14","text":"Keep functions short and simple Feel free to use multiple return statements (and to throw exceptions).","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#nr3-dont-dont-use-exceptions","text":"","title":"NR.3: Don't: Don't use exceptions"},{"location":"cppcg/CppCoreGuidelines/#reason-not-to-follow-this-rule_2","text":"There seem to be three main reasons given for this non-rule: exceptions are inefficient exceptions lead to leaks and errors exception performance is not predictable There is no way we can settle this issue to the satisfaction of everybody. After all, the discussions about exceptions have been going on for 40+ years. Some languages cannot be used without exceptions, but others do not support them. This leads to strong traditions for the use and non-use of exceptions, and to heated debates. However, we can briefly outline why we consider exceptions the best alternative for general-purpose programming and in the context of these guidelines. Simple arguments for and against are often inconclusive. There are specialized applications where exceptions indeed can be inappropriate (e.g., hard-real-time systems without support for reliable estimates of the cost of handling an exception). Consider the major objections to exceptions in turn Exceptions are inefficient: Compared to what? When comparing make sure that the same set of errors are handled and that they are handled equivalently. In particular, do not compare a program that immediately terminate on seeing an error with a program that carefully cleans up resources before logging an error. Yes, some systems have poor exception handling implementations; sometimes, such implementations force us to use other error-handling approaches, but that\u2019s not a fundamental problem with exceptions. When using an efficiency argument - in any context - be careful that you have good data that actually provides insight into the problem under discussion. Exceptions lead to leaks and errors. They do not. If your program is a rat\u2019s nest of pointers without an overall strategy for resource management, you have a problem whatever you do. If your system consists of a million lines of such code, you probably will not be able to use exceptions, but that\u2019s a problem with excessive and undisciplined pointer use, rather than with exceptions. In our opinion, you need RAII to make exception-based error handling simple and safe \u2013 simpler and safer than alternatives. Exception performance is not predictable. If you are in a hard-real-time system where you must guarantee completion of a task in a given time, you need tools to back up such guarantees. As far as we know such tools are not available (at least not to most programmers). Many, possibly most, problems with exceptions stem from historical needs to interact with messy old code. The fundamental arguments for the use of exceptions are They clearly differentiate between erroneous return and ordinary return They cannot be forgotten or ignored They can be used systematically Remember Exceptions are for reporting errors (in C++; other languages can have different uses for exceptions). Exceptions are not for errors that can be handled locally. Don\u2019t try to catch every exception in every function (that\u2019s tedious, clumsy, and leads to slow code). Exceptions are not for errors that require instant termination of a module/system after a non-recoverable error.","title":"Reason (not to follow this rule)"},{"location":"cppcg/CppCoreGuidelines/#example_374","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#alternative_15","text":"RAII Contracts/assertions: Use GSL\u2019s Expects and Ensures (until we get language support for contracts)","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#nr4-dont-place-each-class-declaration-in-its-own-source-file","text":"","title":"NR.4: Don't: Place each class declaration in its own source file"},{"location":"cppcg/CppCoreGuidelines/#reason-not-to-follow-this-rule_3","text":"The resulting number of files are hard to manage and can slow down compilation. Individual classes are rarely a good logical unit of maintenance and distribution.","title":"Reason (not to follow this rule)"},{"location":"cppcg/CppCoreGuidelines/#example_375","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#alternative_16","text":"Use namespaces containing logically cohesive sets of classes and functions.","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#nr5-dont-dont-do-substantive-work-in-a-constructor-instead-use-two-phase-initialization","text":"","title":"NR.5: Don't: Don't do substantive work in a constructor; instead use two-phase initialization"},{"location":"cppcg/CppCoreGuidelines/#reason-not-to-follow-this-rule_4","text":"Following this rule leads to weaker invariants, more complicated code (having to deal with semi-constructed objects), and errors (when we didn\u2019t deal correctly with semi-constructed objects consistently).","title":"Reason (not to follow this rule)"},{"location":"cppcg/CppCoreGuidelines/#example-bad_139","text":"class Picture { int mx; int my; char * data; public: Picture(int x, int y) { mx = x, my = y; data = nullptr; } ~Picture() { Cleanup(); } bool Init() { // invariant checks if (mx <= 0 || my <= 0) { return false; } if (data) { return false; } data = (char*) malloc(x*y*sizeof(int)); return data != nullptr; } void Cleanup() { if (data) free(data); data = nullptr; } }; Picture picture(100, 0); // not ready-to-use picture here // this will fail.. if (!picture.Init()) { puts(\"Error, invalid picture\"); } // now have a invalid picture object instance.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_23","text":"class Picture { size_t mx; size_t my; vector<char> data; static size_t check_size(size_t s) { // invariant check Expects(s > 0); return s; } public: // even more better would be a class for a 2D Size as one single parameter Picture(size_t x, size_t y) : mx(check_size(x)) , my(check_size(y)) // now we know x and y have a valid size , data(mx * my * sizeof(int)) // will throw std::bad_alloc on error { // picture is ready-to-use } // compiler generated dtor does the job. (also see C.21) }; Picture picture1(100, 100); // picture is ready-to-use here... // not a valid size for y, // default contract violation behavior will call std::terminate then Picture picture2(100, 0); // not reach here...","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#alternative_17","text":"Always establish a class invariant in a constructor. Don\u2019t define an object before it is needed.","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#nr6-dont-place-all-cleanup-actions-at-the-end-of-a-function-and-goto-exit","text":"","title":"NR.6: Don't: Place all cleanup actions at the end of a function and goto exit"},{"location":"cppcg/CppCoreGuidelines/#reason-not-to-follow-this-rule_5","text":"goto is error-prone. This technique is a pre-exception technique for RAII-like resource and error handling.","title":"Reason (not to follow this rule)"},{"location":"cppcg/CppCoreGuidelines/#example-bad_140","text":"void do_something(int n) { if (n < 100) goto exit; // ... int* p = (int*) malloc(n); // ... if (some_error) goto_exit; // ... exit: free(p); } and spot the bug.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#alternative_18","text":"Use exceptions and RAII for non-RAII resources, use finally .","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#nr7-dont-make-all-data-members-protected","text":"","title":"NR.7: Don't: Make all data members protected"},{"location":"cppcg/CppCoreGuidelines/#reason-not-to-follow-this-rule_6","text":"protected data is a source of errors. protected data can be manipulated from an unbounded amount of code in various places. protected data is the class hierarchy equivalent to global data.","title":"Reason (not to follow this rule)"},{"location":"cppcg/CppCoreGuidelines/#example_376","text":"???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#alternative_19","text":"Make member data public or (preferably) private","title":"Alternative"},{"location":"cppcg/CppCoreGuidelines/#rf-references","text":"Many coding standards, rules, and guidelines have been written for C++, and especially for specialized uses of C++. Many focus on lower-level issues, such as the spelling of identifiers are written by C++ novices see \u201cstopping programmers from doing unusual things\u201d as their primary aim aim at portability across many compilers (some 10 years old) are written to preserve decades old code bases aim at a single application domain are downright counterproductive are ignored (must be ignored by programmers to get their work done well) A bad coding standard is worse than no coding standard. However an appropriate set of guidelines are much better than no standards: \u201cForm is liberating.\u201d Why can\u2019t we just have a language that allows all we want and disallows all we don\u2019t want (\u201ca perfect language\u201d)? Fundamentally, because affordable languages (and their tool chains) also serve people with needs that differ from yours and serve more needs than you have today. Also, your needs change over time and a general-purpose language is needed to allow you to adapt. A language that is ideal for today would be overly restrictive tomorrow. Coding guidelines adapt the use of a language to specific needs. Thus, there cannot be a single coding style for everybody. We expect different organizations to provide additions, typically with more restrictions and firmer style rules. Reference sections: RF.rules: Coding rules RF.books: Books with coding guidelines RF.C++: C++ Programming (C++11/C++14/C++17) RF.web: Websites RS.video: Videos about \u201cmodern C++\u201d RF.man: Manuals RF.core: Core Guidelines materials","title":"RF: References"},{"location":"cppcg/CppCoreGuidelines/#rfrules-coding-rules","text":"Boost Library Requirements and Guidelines . ???. Bloomberg: BDE C++ Coding . Has a strong emphasis on code organization and layout. Facebook: ??? GCC Coding Conventions . C++03 and (reasonably) a bit backwards looking. Google C++ Style Guide . Geared toward C++03 and (also) older code bases. Google experts are now actively collaborating here on helping to improve these Guidelines, and hopefully to merge efforts so these can be a modern common set they could also recommend. JSF++: JOINT STRIKE FIGHTER AIR VEHICLE C++ CODING STANDARDS . Document Number 2RDU00001 Rev C. December 2005. For flight control software. For hard-real-time. This means that it is necessarily very restrictive (\u201cif the program fails somebody dies\u201d). For example, no free store allocation or deallocation may occur after the plane takes off (no memory overflow and no fragmentation allowed). No exception may be used (because there was no available tool for guaranteeing that an exception would be handled within a fixed short time). Libraries used have to have been approved for mission critical applications. Any similarities to this set of guidelines are unsurprising because Bjarne Stroustrup was an author of JSF++. Recommended, but note its very specific focus. Mozilla Portability Guide . As the name indicates, this aims for portability across many (old) compilers. As such, it is restrictive. Geosoft.no: C++ Programming Style Guidelines . ???. Possibility.com: C++ Coding Standard . ???. SEI CERT: Secure C++ Coding Standard . A very nicely done set of rules (with examples and rationales) done for security-sensitive code. Many of their rules apply generally. High Integrity C++ Coding Standard . llvm . Somewhat brief, pre-C++11, and (not unreasonably) adjusted to its domain. ???","title":"RF.rules: Coding rules"},{"location":"cppcg/CppCoreGuidelines/#rfbooks-books-with-coding-guidelines","text":"Meyers96 Scott Meyers: More Effective C++ . Addison-Wesley 1996. Meyers97 Scott Meyers: Effective C++, Second Edition . Addison-Wesley 1997. Meyers01 Scott Meyers: Effective STL . Addison-Wesley 2001. Meyers05 Scott Meyers: Effective C++, Third Edition . Addison-Wesley 2005. Meyers15 Scott Meyers: Effective Modern C++ . O\u2019Reilly 2015. SuttAlex05 Sutter and Alexandrescu: C++ Coding Standards . Addison-Wesley 2005. More a set of meta-rules than a set of rules. Pre-C++11. Stroustrup05 Bjarne Stroustrup: A rationale for semantically enhanced library languages . LCSD05. October 2005. Stroustrup14 Stroustrup: A Tour of C++ . Addison Wesley 2014. Each chapter ends with an advice section consisting of a set of recommendations. Stroustrup13 Stroustrup: The C++ Programming Language (4 th Edition) . Addison Wesley 2013. Each chapter ends with an advice section consisting of a set of recommendations. Stroustrup: Style Guide for Programming: Principles and Practice using C++ . Mostly low-level naming and layout rules. Primarily a teaching tool.","title":"RF.books: Books with coding guidelines"},{"location":"cppcg/CppCoreGuidelines/#rfc-c-programming-c11c14","text":"TC++PL4 : A thorough description of the C++ language and standard libraries for experienced programmers. Tour++ : An overview of the C++ language and standard libraries for experienced programmers. Programming: Principles and Practice using C++ : A textbook for beginners and relative novices.","title":"RF.C++: C++ Programming (C++11/C++14)"},{"location":"cppcg/CppCoreGuidelines/#rfweb-websites","text":"isocpp.org Bjarne Stroustrup\u2019s home pages WG21 Boost Adobe open source Poco libraries Sutter\u2019s Mill? ???","title":"RF.web: Websites"},{"location":"cppcg/CppCoreGuidelines/#rsvideo-videos-about-modern-c","text":"Bjarne Stroustrup: C++11 Style . 2012. Bjarne Stroustrup: The Essence of C++: With Examples in C++84, C++98, C++11, and C++14 . 2013 All the talks from CppCon \u201814 Bjarne Stroustrup: The essence of C++ at the University of Edinburgh. 2014. Bjarne Stroustrup: The Evolution of C++ Past, Present and Future . CppCon 2016 keynote. Bjarne Stroustrup: Make Simple Tasks Simple! . CppCon 2014 keynote. Bjarne Stroustrup: Writing Good C++14 . CppCon 2015 keynote about the Core Guidelines. Herb Sutter: Writing Good C++14\u2026 By Default . CppCon 2015 keynote about the Core Guidelines. CppCon 15 ??? C++ Next ??? Meting C++ ??? more ???","title":"RS.video: Videos about \"modern C++\""},{"location":"cppcg/CppCoreGuidelines/#rfman-manuals","text":"ISO C++ Standard C++11. ISO C++ Standard C++14. ISO C++ Standard C++17 . Committee Draft. Palo Alto \u201cConcepts\u201d TR . ISO C++ Concepts TS . WG21 Ranges report . Draft.","title":"RF.man: Manuals"},{"location":"cppcg/CppCoreGuidelines/#rfcore-core-guidelines-materials","text":"This section contains materials that has been useful for presenting the core guidelines and the ideas behind them: Our documents directory Stroustrup, Sutter, and Dos Reis: A brief introduction to C++\u2019s model for type- and resource-safety . A paper with lots of examples. Sergey Zubkov: a Core Guidelines talk and here are the slides . In Russian. 2017. Neil MacIntosh: The Guideline Support Library: One Year Later . CppCon 2016. Bjarne Stroustrup: Writing Good C++14 . CppCon 2015 keynote. Herb Sutter: Writing Good C++14\u2026 By Default . CppCon 2015 keynote. Peter Sommerlad: C++ Core Guidelines - Modernize your C++ Code Base . ACCU 2017. Bjarne Stroustrup: No Littering! . Bay Area ACCU 2016. It gives some idea of the ambition level for the Core Guidelines. Note that slides for CppCon presentations are available (links with the posted videos). Contributions to this list would be most welcome.","title":"RF.core: Core Guidelines materials"},{"location":"cppcg/CppCoreGuidelines/#acknowledgements","text":"Thanks to the many people who contributed rules, suggestions, supporting information, references, etc.: Peter Juhl Neil MacIntosh Axel Naumann Andrew Pardoe Gabriel Dos Reis Zhuang, Jiangang (Jeff) Sergey Zubkov and see the contributor list on the github.","title":"Acknowledgements"},{"location":"cppcg/CppCoreGuidelines/#pro-profiles","text":"Ideally, we would follow all of the guidelines. That would give the cleanest, most regular, least error-prone, and often the fastest code. Unfortunately, that is usually impossible because we have to fit our code into large code bases and use existing libraries. Often, such code has been written over decades and does not follow these guidelines. We must aim for gradual adoption . Whatever strategy for gradual adoption we adopt, we need to be able to apply sets of related guidelines to address some set of problems first and leave the rest until later. A similar idea of \u201crelated guidelines\u201d becomes important when some, but not all, guidelines are considered relevant to a code base or if a set of specialized guidelines is to be applied for a specialized application area. We call such a set of related guidelines a \u201cprofile\u201d. We aim for such a set of guidelines to be coherent so that they together help us reach a specific goal, such as \u201cabsence of range errors\u201d or \u201cstatic type safety.\u201d Each profile is designed to eliminate a class of errors. Enforcement of \u201crandom\u201d rules in isolation is more likely to be disruptive to a code base than delivering a definite improvement. A \u201cprofile\u201d is a set of deterministic and portably enforceable subset rules (i.e., restrictions) that are designed to achieve a specific guarantee. \u201cDeterministic\u201d means they require only local analysis and could be implemented in a compiler (though they don\u2019t need to be). \u201cPortably enforceable\u201d means they are like language rules, so programmers can count on different enforcement tools giving the same answer for the same code. Code written to be warning-free using such a language profile is considered to conform to the profile. Conforming code is considered to be safe by construction with regard to the safety properties targeted by that profile. Conforming code will not be the root cause of errors for that property, although such errors may be introduced into a program by other code, libraries or the external environment. A profile may also introduce additional library types to ease conformance and encourage correct code. Profiles summary: Pro.type: Type safety Pro.bounds: Bounds safety Pro.lifetime: Lifetime safety In the future, we expect to define many more profiles and add more checks to existing profiles. Candidates include: narrowing arithmetic promotions/conversions (likely part of a separate safe-arithmetic profile) arithmetic cast from negative floating point to unsigned integral type (ditto) selected undefined behavior: Start with Gabriel Dos Reis\u2019s UB list developed for the WG21 study group selected unspecified behavior: Addressing portability concerns. const violations: Mostly done by compilers already, but we can catch inappropriate casting and underuse of const . Enabling a profile is implementation defined; typically, it is set in the analysis tool used. To suppress enforcement of a profile check, place a suppress annotation on a language contract. For example: [[suppress(bounds)]] char* raw_find(char* p, int n, char x) // find x in p[0]..p[n - 1] { // ... } Now raw_find() can scramble memory to its heart\u2019s content. Obviously, suppression should be very rare.","title":"Pro: Profiles"},{"location":"cppcg/CppCoreGuidelines/#prosafety-type-safety-profile","text":"This profile makes it easier to construct code that uses types correctly and avoids inadvertent type punning. It does so by focusing on removing the primary sources of type violations, including unsafe uses of casts and unions. For the purposes of this section, type-safety is defined to be the property that a variable is not used in a way that doesn\u2019t obey the rules for the type of its definition. Memory accessed as a type T should not be valid memory that actually contains an object of an unrelated type U . Note that the safety is intended to be complete when combined also with Bounds safety and Lifetime safety . An implementation of this profile shall recognize the following patterns in source code as non-conforming and issue a diagnostic. Type safety profile summary: Type.1: Avoid casts : a. Don\u2019t use reinterpret_cast ; A strict version of Avoid casts and prefer named casts . b. Don\u2019t use static_cast for arithmetic types; A strict version of Avoid casts and prefer named casts . c. Don\u2019t cast between pointer types where the source type and the target type are the same; A strict version of Avoid casts . d. Don\u2019t cast between pointer types when the conversion could be implicit; A strict version of Avoid casts . Type.2: Don\u2019t use static_cast to downcast: Use dynamic_cast instead . Type.3: Don\u2019t use const_cast to cast away const (i.e., at all): Don\u2019t cast away const . Type.4: Don\u2019t use C-style (T)expression or functional T(expression) casts: Prefer construction or named casts . Type.5: Don\u2019t use a variable before it has been initialized: always initialize . Type.6: Always initialize a member variable: always initialize , possibly using default constructors or default member initializers . Type.7: Avoid naked union: Use variant instead . Type.8: Avoid varargs: Don\u2019t use va_arg arguments .","title":"Pro.safety: Type-safety profile"},{"location":"cppcg/CppCoreGuidelines/#impact","text":"With the type-safety profile you can trust that every operation is applied to a valid object. Exception may be thrown to indicate errors that cannot be detected statically (at compile time). Note that this type-safety can be complete only if we also have Bounds safety and Lifetime safety . Without those guarantees, a region of memory could be accessed independent of which object, objects, or parts of objects are stored in it.","title":"Impact"},{"location":"cppcg/CppCoreGuidelines/#probounds-bounds-safety-profile","text":"This profile makes it easier to construct code that operates within the bounds of allocated blocks of memory. It does so by focusing on removing the primary sources of bounds violations: pointer arithmetic and array indexing. One of the core features of this profile is to restrict pointers to only refer to single objects, not arrays. We define bounds-safety to be the property that a program does not use an object to access memory outside of the range that was allocated for it. Bounds safety is intended to be complete only when combined with Type safety and Lifetime safety , which cover other unsafe operations that allow bounds violations. Bounds safety profile summary: Bounds.1: Don\u2019t use pointer arithmetic. Use span instead: Pass pointers to single objects (only) and Keep pointer arithmetic simple . Bounds.2: Only index into arrays using constant expressions: Pass pointers to single objects (only) and Keep pointer arithmetic simple . Bounds.3: No array-to-pointer decay: Pass pointers to single objects (only) and Keep pointer arithmetic simple . Bounds.4: Don\u2019t use standard-library functions and types that are not bounds-checked: Use the standard library in a type-safe manner .","title":"Pro.bounds: Bounds safety profile"},{"location":"cppcg/CppCoreGuidelines/#impact_1","text":"Bounds safety implies that access to an object - notably arrays - does not access beyond the object\u2019s memory allocation. This eliminates a large class of insidious and hard-to-find errors, including the (in)famous \u201cbuffer overflow\u201d errors. This closes security loopholes as well as a prominent source of memory corruption (when writing out of bounds). Even if an out-of-bounds access is \u201cjust a read\u201d, it can lead to invariant violations (when the accessed isn\u2019t of the assumed type) and \u201cmysterious values.\u201d","title":"Impact"},{"location":"cppcg/CppCoreGuidelines/#prolifetime-lifetime-safety-profile","text":"Accessing through a pointer that doesn\u2019t point to anything is a major source of errors, and very hard to avoid in many traditional C or C++ styles of programming. For example, a pointer may be uninitialized, the nullptr , point beyond the range of an array, or to a deleted object. See the current design specification here. Lifetime safety profile summary: Lifetime.1: Don\u2019t dereference a possibly invalid pointer: detect or avoid .","title":"Pro.lifetime: Lifetime safety profile"},{"location":"cppcg/CppCoreGuidelines/#impact_2","text":"Once completely enforced through a combination of style rules, static analysis, and library support, this profile eliminates one of the major sources of nasty errors in C++ eliminates a major source of potential security violations improves performance by eliminating redundant \u201cparanoia\u201d checks increases confidence in correctness of code avoids undefined behavior by enforcing a key C++ language rule","title":"Impact"},{"location":"cppcg/CppCoreGuidelines/#gsl-guidelines-support-library","text":"The GSL is a small library of facilities designed to support this set of guidelines. Without these facilities, the guidelines would have to be far more restrictive on language details. The Core Guidelines support library is defined in namespace gsl and the names may be aliases for standard library or other well-known library names. Using the (compile-time) indirection through the gsl namespace allows for experimentation and for local variants of the support facilities. The GSL is header only, and can be found at GSL: Guidelines support library . The support library facilities are designed to be extremely lightweight (zero-overhead) so that they impose no overhead compared to using conventional alternatives. Where desirable, they can be \u201cinstrumented\u201d with additional functionality (e.g., checks) for tasks such as debugging. These Guidelines assume a variant type, but this is not currently in GSL. Eventually, use the one voted into C++17 . Summary of GSL components: GSL.view: Views GSL.owner GSL.assert: Assertions GSL.util: Utilities GSL.concept: Concepts We plan for a \u201cISO C++ standard style\u201d semi-formal specification of the GSL. We rely on the ISO C++ Standard Library and hope for parts of the GSL to be absorbed into the standard library.","title":"GSL: Guidelines support library"},{"location":"cppcg/CppCoreGuidelines/#gslview-views","text":"These types allow the user to distinguish between owning and non-owning pointers and between pointers to a single object and pointers to the first element of a sequence. These \u201cviews\u201d are never owners. References are never owners (see R.4 . Note: References have many opportunities to outlive the objects they refer to (returning a local variable by reference, holding a reference to an element of a vector and doing push_back , binding to std::max(x, y + 1) , etc. The Lifetime safety profile aims to address those things, but even so owner<T&> does not make sense and is discouraged. The names are mostly ISO standard-library style (lower case and underscore): T* // The T* is not an owner, may be null; assumed to be pointing to a single element. T& // The T& is not an owner and can never be a \u201cnull reference\u201d; references are always bound to objects. The \u201craw-pointer\u201d notation (e.g. int* ) is assumed to have its most common meaning; that is, a pointer points to an object, but does not own it. Owners should be converted to resource handles (e.g., unique_ptr or vector<T> ) or marked owner<T*> . owner<T*> // a T* that owns the object pointed/referred to; may be nullptr . owner is used to mark owning pointers in code that cannot be upgraded to use proper resource handles. Reasons for that include: Cost of conversion. The pointer is used with an ABI. The pointer is part of the implementation of a resource handle. An owner<T> differs from a resource handle for a T by still requiring an explicit delete . An owner<T> is assumed to refer to an object on the free store (heap). If something is not supposed to be nullptr , say so: not_null<T> // T is usually a pointer type (e.g., not_null<int*> and not_null<owner<Foo*>> ) that may not be nullptr . T can be any type for which ==nullptr is meaningful. span<T> // [p:p+n) , constructor from {p, q} and {p, n} ; T is the pointer type span_p<T> // {p, predicate} [p:q) where q is the first element for which predicate(*p) is true string_span // span<char> cstring_span // span<const char> A span<T> refers to zero or more mutable T s unless T is a const type. \u201cPointer arithmetic\u201d is best done within span s. A char* that points to more than one char but is not a C-style string (e.g., a pointer into an input buffer) should be represented by a span . zstring // a char* supposed to be a C-style string; that is, a zero-terminated sequence of char or nullptr czstring // a const char* supposed to be a C-style string; that is, a zero-terminated sequence of const char or nullptr Logically, those last two aliases are not needed, but we are not always logical, and they make the distinction between a pointer to one char and a pointer to a C-style string explicit. A sequence of characters that is not assumed to be zero-terminated should be a char* , rather than a zstring . French accent optional. Use not_null<zstring> for C-style strings that cannot be nullptr . ??? Do we need a name for not_null<zstring> ? or is its ugliness a feature?","title":"GSL.view: Views"},{"location":"cppcg/CppCoreGuidelines/#gslowner-ownership-pointers","text":"unique_ptr<T> // unique ownership: std::unique_ptr<T> shared_ptr<T> // shared ownership: std::shared_ptr<T> (a counted pointer) stack_array<T> // A stack-allocated array. The number of elements are determined at construction and fixed thereafter. The elements are mutable unless T is a const type. dyn_array<T> // ??? needed ??? A heap-allocated array. The number of elements are determined at construction and fixed thereafter. The elements are mutable unless T is a const type. Basically a span that allocates and owns its elements.","title":"GSL.owner: Ownership pointers"},{"location":"cppcg/CppCoreGuidelines/#gslassert-assertions","text":"Expects // precondition assertion. Currently placed in function bodies. Later, should be moved to declarations. // Expects(p) terminates the program unless p == true // Expect in under control of some options (enforcement, error message, alternatives to terminate) Ensures // postcondition assertion. Currently placed in function bodies. Later, should be moved to declarations. These assertions are currently macros (yuck!) and must appear in function definitions (only) pending standard committee decisions on contracts and assertion syntax. See the contract proposal ; using the attribute syntax, for example, Expects(p) will become [[expects: p]] .","title":"GSL.assert: Assertions"},{"location":"cppcg/CppCoreGuidelines/#gslutil-utilities","text":"finally // finally(f) makes a final_action{f} with a destructor that invokes f narrow_cast // narrow_cast<T>(x) is static_cast<T>(x) narrow // narrow<T>(x) is static_cast<T>(x) if static_cast<T>(x) == x or it throws narrowing_error [[implicit]] // \u201cMarker\u201d to put on single-argument constructors to explicitly make them non-explicit. move_owner // p = move_owner(q) means p = q but ??? joining_thread // a RAII style version of std::thread that joins. index // a type to use for all container and array indexing (currently an alias for ptrdiff_t )","title":"GSL.util: Utilities"},{"location":"cppcg/CppCoreGuidelines/#gslconcept-concepts","text":"These concepts (type predicates) are borrowed from Andrew Sutton\u2019s Origin library, the Range proposal, and the ISO WG21 Palo Alto TR. They are likely to be very similar to what will become part of the ISO C++ standard. The notation is that of the ISO WG21 Concepts TS . Most of the concepts below are defined in the Ranges TS . Range String // ??? Number // ??? Sortable EqualityComparable // ???Must we suffer CaMelcAse??? Convertible Common Boolean Integral SignedIntegral SemiRegular // ??? Copyable? Regular TotallyOrdered Function RegularFunction Predicate Relation \u2026","title":"GSL.concept: Concepts"},{"location":"cppcg/CppCoreGuidelines/#gslptr-smart-pointer-concepts","text":"Pointer // A type with * , -> , == , and default construction (default construction is assumed to set the singular \u201cnull\u201d value) Unique_pointer // A type that matches Pointer , is movable, and is not copyable Shared_pointer // A type that matches Pointer , and is copyable","title":"GSL.ptr: Smart pointer concepts"},{"location":"cppcg/CppCoreGuidelines/#nl-naming-and-layout-rules","text":"Consistent naming and layout are helpful. If for no other reason because it minimizes \u201cmy style is better than your style\u201d arguments. However, there are many, many, different styles around and people are passionate about them (pro and con). Also, most real-world projects includes code from many sources, so standardizing on a single style for all code is often impossible. After many requests for guidance from users, we present a set of rules that you might use if you have no better ideas, but the real aim is consistency, rather than any particular rule set. IDEs and tools can help (as well as hinder). Naming and layout rules: NL.1: Don\u2019t say in comments what can be clearly stated in code NL.2: State intent in comments NL.3: Keep comments crisp NL.4: Maintain a consistent indentation style NL.5: Avoid encoding type information in names NL.7: Make the length of a name roughly proportional to the length of its scope NL.8: Use a consistent naming style NL.9: Use ALL_CAPS for macro names only NL.10: Prefer underscore_style names NL.11: Make literals readable NL.15: Use spaces sparingly NL.16: Use a conventional class member declaration order NL.17: Use K&R-derived layout NL.18: Use C++-style declarator layout NL.19: Avoid names that are easily misread NL.20: Don\u2019t place two statements on the same line NL.21: Declare one name (only) per declaration NL.25: Don\u2019t use void as an argument type NL.26: Use conventional const notation Most of these rules are aesthetic and programmers hold strong opinions. IDEs also tend to have defaults and a range of alternatives. These rules are suggested defaults to follow unless you have reasons not to. We have had comments to the effect that naming and layout are so personal and/or arbitrary that we should not try to \u201clegislate\u201d them. We are not \u201clegislating\u201d (see the previous paragraph). However, we have had many requests for a set of naming and layout conventions to use when there are no external constraints. More specific and detailed rules are easier to enforce. These rules bear a strong resemblance to the recommendations in the PPP Style Guide written in support of Stroustrup\u2019s Programming: Principles and Practice using C++ .","title":"NL: Naming and layout rules"},{"location":"cppcg/CppCoreGuidelines/#nl1-dont-say-in-comments-what-can-be-clearly-stated-in-code","text":"","title":"NL.1: Don't say in comments what can be clearly stated in code"},{"location":"cppcg/CppCoreGuidelines/#reason_425","text":"Compilers do not read comments. Comments are less precise than code. Comments are not updated as consistently as code.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_141","text":"auto x = m * v1 + vv; // multiply m with v1 and add the result to vv","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_388","text":"Build an AI program that interprets colloquial English text and see if what is said could be better expressed in C++.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#nl2-state-intent-in-comments","text":"","title":"NL.2: State intent in comments"},{"location":"cppcg/CppCoreGuidelines/#reason_426","text":"Code says what is done, not what is supposed to be done. Often intent can be stated more clearly and concisely than the implementation.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_377","text":"void stable_sort(Sortable& c) // sort c in the order determined by <, keep equal elements (as defined by ==) in // their original relative order { // ... quite a few lines of non-trivial code ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_363","text":"If the comment and the code disagree, both are likely to be wrong.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#nl3-keep-comments-crisp","text":"","title":"NL.3: Keep comments crisp"},{"location":"cppcg/CppCoreGuidelines/#reason_427","text":"Verbosity slows down understanding and makes the code harder to read by spreading it around in the source file.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_364","text":"Use intelligible English. I may be fluent in Danish, but most programmers are not; the maintainers of my code may not be. Avoid SMS lingo and watch your grammar, punctuation, and capitalization. Aim for professionalism, not \u201ccool.\u201d","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_389","text":"not possible.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#nl4-maintain-a-consistent-indentation-style","text":"","title":"NL.4: Maintain a consistent indentation style"},{"location":"cppcg/CppCoreGuidelines/#reason_428","text":"Readability. Avoidance of \u201csilly mistakes.\u201d","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_142","text":"int i; for (i = 0; i < max; ++i); // bug waiting to happen if (i == j) return i;","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#note_365","text":"Always indenting the statement after if (...) , for (...) , and while (...) is usually a good idea: if (i < 0) error(\"negative argument\"); if (i < 0) error(\"negative argument\");","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_390","text":"Use a tool.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#nl5-avoid-encoding-type-information-in-names","text":"","title":"NL.5: Avoid encoding type information in names"},{"location":"cppcg/CppCoreGuidelines/#rationale","text":"If names reflect types rather than functionality, it becomes hard to change the types used to provide that functionality. Also, if the type of a variable is changed, code using it will have to be modified. Minimize unintentional conversions.","title":"Rationale"},{"location":"cppcg/CppCoreGuidelines/#example-bad_143","text":"void print_int(int i); void print_string(const char*); print_int(1); // repetitive, manual type matching print_string(\"xyzzy\"); // repetitive, manual type matching","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example-good_24","text":"void print(int i); void print(string_view); // also works on any string-like sequence print(1); // clear, automatic type matching print(\"xyzzy\"); // clear, automatic type matching","title":"Example, good"},{"location":"cppcg/CppCoreGuidelines/#note_366","text":"Names with types encoded are either verbose or cryptic. printS // print a std::string prints // print a C-style string printi // print an int Requiring techniques like Hungarian notation to encode a type has been used in untyped languages, but is generally unnecessary and actively harmful in a strongly statically-typed language like C++, because the annotations get out of date (the warts are just like comments and rot just like them) and they interfere with good use of the language (use the same name and overload resolution instead).","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_367","text":"Some styles use very general (not type-specific) prefixes to denote the general use of a variable. auto p = new User(); auto p = make_unique<User>(); // note: \"p\" is not being used to say \"raw pointer to type User,\" // just generally to say \"this is an indirection\" auto cntHits = calc_total_of_hits(/*...*/); // note: \"cnt\" is not being used to encode a type, // just generally to say \"this is a count of something\" This is not harmful and does not fall under this guideline because it does not encode type information.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_368","text":"Some styles distinguish members from local variable, and/or from global variable. struct S { int m_; S(int m) :m_{abs(m)} { } }; This is not harmful and does not fall under this guideline because it does not encode type information.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_369","text":"Like C++, some styles distinguish types from non-types. For example, by capitalizing type names, but not the names of functions and variables. typename<typename T> class HashTable { // maps string to T // ... }; HashTable<int> index; This is not harmful and does not fall under this guideline because it does not encode type information.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#nl7-make-the-length-of-a-name-roughly-proportional-to-the-length-of-its-scope","text":"Rationale : The larger the scope the greater the chance of confusion and of an unintended name clash.","title":"NL.7: Make the length of a name roughly proportional to the length of its scope"},{"location":"cppcg/CppCoreGuidelines/#example_378","text":"double sqrt(double x); // return the square root of x; x must be non-negative int length(const char* p); // return the number of characters in a zero-terminated C-style string int length_of_string(const char zero_terminated_array_of_char[]) // bad: verbose int g; // bad: global variable with a cryptic name int open; // bad: global variable with a short, popular name The use of p for pointer and x for a floating-point variable is conventional and non-confusing in a restricted scope.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_391","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#nl8-use-a-consistent-naming-style","text":"Rationale : Consistence in naming and naming style increases readability.","title":"NL.8: Use a consistent naming style"},{"location":"cppcg/CppCoreGuidelines/#note_370","text":"There are many styles and when you use multiple libraries, you can\u2019t follow all their different conventions. Choose a \u201chouse style\u201d, but leave \u201cimported\u201d libraries with their original style.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_379","text":"ISO Standard, use lower case only and digits, separate words with underscores: int vector my_map Avoid double underscores __ .","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_380","text":"Stroustrup : ISO Standard, but with upper case used for your own types and concepts: int vector My_map","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_381","text":"CamelCase: capitalize each word in a multi-word identifier: int vector MyMap myMap Some conventions capitalize the first letter, some don\u2019t.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_371","text":"Try to be consistent in your use of acronyms and lengths of identifiers: int mtbf {12}; int mean_time_between_failures {12}; // make up your mind","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_392","text":"Would be possible except for the use of libraries with varying conventions.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#nl9-use-all_caps-for-macro-names-only","text":"","title":"NL.9: Use ALL_CAPS for macro names only"},{"location":"cppcg/CppCoreGuidelines/#reason_429","text":"To avoid confusing macros with names that obey scope and type rules.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_382","text":"void f() { const int SIZE{1000}; // Bad, use 'size' instead int v[SIZE]; }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_372","text":"This rule applies to non-macro symbolic constants: enum bad { BAD, WORSE, HORRIBLE }; // BAD","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_393","text":"Flag macros with lower-case letters Flag ALL_CAPS non-macro names","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#nl10-prefer-underscore_style-names","text":"","title":"NL.10: Prefer underscore_style names"},{"location":"cppcg/CppCoreGuidelines/#reason_430","text":"The use of underscores to separate parts of a name is the original C and C++ style and used in the C++ Standard Library.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_373","text":"This rule is a default to use only if you have a choice. Often, you don\u2019t have a choice and must follow an established style for consistency . The need for consistency beats personal taste. This is a recommendation for when you have no constraints or better ideas . This rule was added after many requests for guidance.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_383","text":"Stroustrup : ISO Standard, but with upper case used for your own types and concepts: int vector My_map","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_394","text":"Impossible.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#nl15-use-spaces-sparingly","text":"","title":"NL.15: Use spaces sparingly"},{"location":"cppcg/CppCoreGuidelines/#reason_431","text":"Too much space makes the text larger and distracts.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example-bad_144","text":"#include < map > int main(int argc, char * argv [ ]) { // ... }","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#example_384","text":"#include <map> int main(int argc, char* argv[]) { // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_374","text":"Some IDEs have their own opinions and add distracting space. This is a recommendation for when you have no constraints or better ideas . This rule was added after many requests for guidance.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_375","text":"We value well-placed whitespace as a significant help for readability. Just don\u2019t overdo it.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#nl11-make-literals-readable","text":"","title":"NL.11: Make literals readable"},{"location":"cppcg/CppCoreGuidelines/#reason_432","text":"Readability.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_385","text":"Use digit separators to avoid long strings of digits auto c = 299'792'458; // m/s2 auto q2 = 0b0000'1111'0000'0000; auto ss_number = 123'456'7890;","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_386","text":"Use literal suffixes where clarification is needed auto hello = \"Hello!\"s; // a std::string auto world = \"world\"; // a C-style string auto interval = 100ms; // using <chrono>","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_376","text":"Literals should not be sprinkled all over the code as \u201cmagic constants\u201d , but it is still a good idea to make them readable where they are defined. It is easy to make a typo in a long string of integers.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_395","text":"Flag long digit sequences. The trouble is to define \u201clong\u201d; maybe 7.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#nl16-use-a-conventional-class-member-declaration-order","text":"","title":"NL.16: Use a conventional class member declaration order"},{"location":"cppcg/CppCoreGuidelines/#reason_433","text":"A conventional order of members improves readability. When declaring a class use the following order types: classes, enums, and aliases ( using ) constructors, assignments, destructor functions data Use the public before protected before private order. This is a recommendation for when you have no constraints or better ideas . This rule was added after many requests for guidance.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_387","text":"class X { public: // interface protected: // unchecked function for use by derived class implementations private: // implementation details };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_388","text":"Sometimes, the default order of members conflicts with a desire to separate the public interface from implementation details. In such cases, private types and functions can be placed with private data. class X { public: // interface protected: // unchecked function for use by derived class implementations private: // implementation details (types, functions, and data) };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example-bad_145","text":"Avoid multiple blocks of declarations of one access (e.g., public ) dispersed among blocks of declarations with different access (e.g. private ). class X { // bad public: void f(); public: int g(); // ... }; The use of macros to declare groups of members often leads to violation of any ordering rules. However, macros obscures what is being expressed anyway.","title":"Example, bad"},{"location":"cppcg/CppCoreGuidelines/#enforcement_396","text":"Flag departures from the suggested order. There will be a lot of old code that doesn\u2019t follow this rule.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#nl17-use-kr-derived-layout","text":"","title":"NL.17: Use K&amp;R-derived layout"},{"location":"cppcg/CppCoreGuidelines/#reason_434","text":"This is the original C and C++ layout. It preserves vertical space well. It distinguishes different language constructs (such as functions and classes) well.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_377","text":"In the context of C++, this style is often called \u201cStroustrup\u201d. This is a recommendation for when you have no constraints or better ideas . This rule was added after many requests for guidance.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_389","text":"struct Cable { int x; // ... }; double foo(int x) { if (0 < x) { // ... } switch (x) { case 0: // ... break; case amazing: // ... break; default: // ... break; } if (0 < x) ++x; if (x < 0) something(); else something_else(); return some_value; } Note the space between if and (","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_378","text":"Use separate lines for each statement, the branches of an if , and the body of a for .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_379","text":"The { for a class and a struct is not on a separate line, but the { for a function is.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_380","text":"Capitalize the names of your user-defined types to distinguish them from standards-library types.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_381","text":"Do not capitalize function names.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_397","text":"If you want enforcement, use an IDE to reformat.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#nl18-use-c-style-declarator-layout","text":"","title":"NL.18: Use C++-style declarator layout"},{"location":"cppcg/CppCoreGuidelines/#reason_435","text":"The C-style layout emphasizes use in expressions and grammar, whereas the C++-style emphasizes types. The use in expressions argument doesn\u2019t hold for references.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_390","text":"T& operator[](size_t); // OK T &operator[](size_t); // just strange T & operator[](size_t); // undecided","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_382","text":"This is a recommendation for when you have no constraints or better ideas . This rule was added after many requests for guidance.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_398","text":"Impossible in the face of history.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#nl19-avoid-names-that-are-easily-misread","text":"","title":"NL.19: Avoid names that are easily misread"},{"location":"cppcg/CppCoreGuidelines/#reason_436","text":"Readability. Not everyone has screens and printers that make it easy to distinguish all characters. We easily confuse similarly spelled and slightly misspelled words.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_391","text":"int oO01lL = 6; // bad int splunk = 7; int splonk = 8; // bad: splunk and splonk are easily confused","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_399","text":"???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#nl20-dont-place-two-statements-on-the-same-line","text":"","title":"NL.20: Don't place two statements on the same line"},{"location":"cppcg/CppCoreGuidelines/#reason_437","text":"Readability. It is really easy to overlook a statement when there is more on a line.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_392","text":"int x = 7; char* p = 29; // don't int x = 7; f(x); ++x; // don't","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_400","text":"Easy.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#nl21-declare-one-name-only-per-declaration","text":"","title":"NL.21: Declare one name (only) per declaration"},{"location":"cppcg/CppCoreGuidelines/#reason_438","text":"Readability. Minimizing confusion with the declarator syntax.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_383","text":"For details, see ES.10 .","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#nl25-dont-use-void-as-an-argument-type","text":"","title":"NL.25: Don't use void as an argument type"},{"location":"cppcg/CppCoreGuidelines/#reason_439","text":"It\u2019s verbose and only needed where C compatibility matters.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_393","text":"void f(void); // bad void g(); // better","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_384","text":"Even Dennis Ritchie deemed void f(void) an abomination. You can make an argument for that abomination in C when function prototypes were rare so that banning: int f(); f(1, 2, \"weird but valid C89\"); // hope that f() is defined int f(a, b, c) char* c; { /* ... */ } would have caused major problems, but not in the 21 st century and in C++.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#nl26-use-conventional-const-notation","text":"","title":"NL.26: Use conventional const notation"},{"location":"cppcg/CppCoreGuidelines/#reason_440","text":"Conventional notation is more familiar to more programmers. Consistency in large code bases.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_394","text":"const int x = 7; // OK int const y = 9; // bad const int *const p = nullptr; // OK, constant pointer to constant int int const *const p = nullptr; // bad, constant pointer to constant int","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_385","text":"We are well aware that you could claim the \u201cbad\u201d examples more logical than the ones marked \u201cOK\u201d, but they also confuse more people, especially novices relying on teaching material using the far more common, conventional OK style. As ever, remember that the aim of these naming and layout rules is consistency and that aesthetics vary immensely. This is a recommendation for when you have no constraints or better ideas . This rule was added after many requests for guidance.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_401","text":"Flag const used as a suffix for a type.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#faq-answers-to-frequently-asked-questions","text":"This section covers answers to frequently asked questions about these guidelines.","title":"FAQ: Answers to frequently asked questions"},{"location":"cppcg/CppCoreGuidelines/#faq1-what-do-these-guidelines-aim-to-achieve","text":"See the top of this page . This is an open-source project to maintain modern authoritative guidelines for writing C++ code using the current C++ Standard (as of this writing, C++14). The guidelines are designed to be modern, machine-enforceable wherever possible, and open to contributions and forking so that organizations can easily incorporate them into their own corporate coding guidelines.","title":"FAQ.1: What do these guidelines aim to achieve?"},{"location":"cppcg/CppCoreGuidelines/#faq2-when-and-where-was-this-work-first-announced","text":"It was announced by Bjarne Stroustrup in his CppCon 2015 opening keynote, \u201cWriting Good C++14\u201d . See also the accompanying isocpp.org blog post , and for the rationale of the type and memory safety guidelines see Herb Sutter\u2019s follow-up CppCon 2015 talk, \u201cWriting Good C++14 \u2026 By Default\u201d .","title":"FAQ.2: When and where was this work first announced?"},{"location":"cppcg/CppCoreGuidelines/#faq3-who-are-the-authors-and-maintainers-of-these-guidelines","text":"The initial primary authors and maintainers are Bjarne Stroustrup and Herb Sutter, and the guidelines so far were developed with contributions from experts at CERN, Microsoft, Morgan Stanley, and several other organizations. At the time of their release, the guidelines are in a \u201c0.6\u201d state, and contributions are welcome. As Stroustrup said in his announcement: \u201cWe need help!\u201d","title":"FAQ.3: Who are the authors and maintainers of these guidelines?"},{"location":"cppcg/CppCoreGuidelines/#faq4-how-can-i-contribute","text":"See CONTRIBUTING.md . We appreciate volunteer help!","title":"FAQ.4: How can I contribute?"},{"location":"cppcg/CppCoreGuidelines/#faq5-how-can-i-become-an-editormaintainer","text":"By contributing a lot first and having the consistent quality of your contributions recognized. See CONTRIBUTING.md . We appreciate volunteer help!","title":"FAQ.5: How can I become an editor/maintainer?"},{"location":"cppcg/CppCoreGuidelines/#faq6-have-these-guidelines-been-approved-by-the-iso-c-standards-committee-do-they-represent-the-consensus-of-the-committee","text":"No. These guidelines are outside the standard. They are intended to serve the standard, and be maintained as current guidelines about how to use the current Standard C++ effectively. We aim to keep them in sync with the standard as that is evolved by the committee.","title":"FAQ.6: Have these guidelines been approved by the ISO C++ standards committee? Do they represent the consensus of the committee?"},{"location":"cppcg/CppCoreGuidelines/#faq7-if-these-guidelines-are-not-approved-by-the-committee-why-are-they-under-githubcomisocpp","text":"Because isocpp is the Standard C++ Foundation; the committee\u2019s repositories are under github.com/ cplusplus . Some neutral organization has to own the copyright and license to make it clear this is not being dominated by any one person or vendor. The natural entity is the Foundation, which exists to promote the use and up-to-date understanding of modern Standard C++ and the work of the committee. This follows the same pattern that isocpp.org did for the C++ FAQ , which was initially the work of Bjarne Stroustrup, Marshall Cline, and Herb Sutter and contributed to the open project in the same way.","title":"FAQ.7: If these guidelines are not approved by the committee, why are they under github.com/isocpp?"},{"location":"cppcg/CppCoreGuidelines/#faq8-will-there-be-a-c98-version-of-these-guidelines-a-c11-version","text":"No. These guidelines are about how to best use Standard C++14 (and, if you have an implementation available, the Concepts Technical Specification) and write code assuming you have a modern conforming compiler.","title":"FAQ.8: Will there be a C++98 version of these Guidelines? a C++11 version?"},{"location":"cppcg/CppCoreGuidelines/#faq9-do-these-guidelines-propose-new-language-features","text":"No. These guidelines are about how to best use Standard C++14 + the Concepts Technical Specification, and they limit themselves to recommending only those features.","title":"FAQ.9: Do these guidelines propose new language features?"},{"location":"cppcg/CppCoreGuidelines/#faq10-what-version-of-markdown-do-these-guidelines-use","text":"These coding standards are written using CommonMark , and <a> HTML anchors. We are considering the following extensions from GitHub Flavored Markdown (GFM) : fenced code blocks (consistently using indented vs. fenced is under discussion) tables (none yet but we\u2019ll likely need them, and this is a GFM extension) Avoid other HTML tags and other extensions. Note: We are not yet consistent with this style.","title":"FAQ.10: What version of Markdown do these guidelines use?"},{"location":"cppcg/CppCoreGuidelines/#faq50-what-is-the-gsl-guidelines-support-library","text":"The GSL is the small set of types and aliases specified in these guidelines. As of this writing, their specification herein is too sparse; we plan to add a WG21-style interface specification to ensure that different implementations agree, and to propose as a contribution for possible standardization, subject as usual to whatever the committee decides to accept/improve/alter/reject.","title":"FAQ.50: What is the GSL (guidelines support library)?"},{"location":"cppcg/CppCoreGuidelines/#faq51-is-githubcommicrosoftgsl-the-gsl","text":"No. That is just a first implementation contributed by Microsoft. Other implementations by other vendors are encouraged, as are forks of and contributions to that implementation. As of this writing one week into the public project, at least one GPLv3 open-source implementation already exists. We plan to produce a WG21-style interface specification to ensure that different implementations agree.","title":"FAQ.51: Is github.com/Microsoft/GSL the GSL?"},{"location":"cppcg/CppCoreGuidelines/#faq52-why-not-supply-an-actual-gsl-implementation-inwith-these-guidelines","text":"We are reluctant to bless one particular implementation because we do not want to make people think there is only one, and inadvertently stifle parallel implementations. And if these guidelines included an actual implementation, then whoever contributed it could be mistakenly seen as too influential. We prefer to follow the long-standing approach of the committee, namely to specify interfaces, not implementations. But at the same time we want at least one implementation available; we hope for many.","title":"FAQ.52: Why not supply an actual GSL implementation in/with these guidelines?"},{"location":"cppcg/CppCoreGuidelines/#faq53-why-werent-the-gsl-types-proposed-through-boost","text":"Because we want to use them immediately, and because they are temporary in that we want to retire them as soon as types that fill the same needs exist in the standard library.","title":"FAQ.53: Why weren't the GSL types proposed through Boost?"},{"location":"cppcg/CppCoreGuidelines/#faq54-has-the-gsl-guidelines-support-library-been-approved-by-the-iso-c-standards-committee","text":"No. The GSL exists only to supply a few types and aliases that are not currently in the standard library. If the committee decides on standardized versions (of these or other types that fill the same need) then they can be removed from the GSL.","title":"FAQ.54: Has the GSL (guidelines support library) been approved by the ISO C++ standards committee?"},{"location":"cppcg/CppCoreGuidelines/#faq55-if-youre-using-the-standard-types-where-available-why-is-the-gsl-string_span-different-from-the-string_view-in-the-library-fundamentals-1-technical-specification-and-c17-working-paper-why-not-just-use-the-committee-approved-string_view","text":"The consensus on the taxonomy of views for the C++ Standard Library was that \u201cview\u201d means \u201cread-only\u201d, and \u201cspan\u201d means \u201cread/write\u201d. The read-only string_view was the first such component to complete the standardization process, while span and string_span are currently being considered for standardization.","title":"FAQ.55: If you're using the standard types where available, why is the GSL string_span different from the string_view in the Library Fundamentals 1 Technical Specification and C++17 Working Paper? Why not just use the committee-approved string_view?"},{"location":"cppcg/CppCoreGuidelines/#faq56-is-owner-the-same-as-the-proposed-observer_ptr","text":"No. owner owns, is an alias, and can be applied to any indirection type. The main intent of observer_ptr is to signify a non -owning pointer.","title":"FAQ.56: Is owner the same as the proposed observer_ptr?"},{"location":"cppcg/CppCoreGuidelines/#faq57-is-stack_array-the-same-as-the-standard-array","text":"No. stack_array is guaranteed to be allocated on the stack. Although a std::array contains its storage directly inside itself, the array object can be put anywhere, including the heap.","title":"FAQ.57: Is stack_array the same as the standard array?"},{"location":"cppcg/CppCoreGuidelines/#faq58-is-dyn_array-the-same-as-vector-or-the-proposed-dynarray","text":"No. dyn_array is not resizable, and is a safe way to refer to a heap-allocated fixed-size array. Unlike vector , it is intended to replace array- new[] . Unlike the dynarray that has been proposed in the committee, this does not anticipate compiler/language magic to somehow allocate it on the stack when it is a member of an object that is allocated on the stack; it simply refers to a \u201cdynamic\u201d or heap-based array.","title":"FAQ.58: Is dyn_array the same as vector or the proposed dynarray?"},{"location":"cppcg/CppCoreGuidelines/#faq59-is-expects-the-same-as-assert","text":"No. It is a placeholder for language support for contract preconditions.","title":"FAQ.59: Is Expects the same as assert?"},{"location":"cppcg/CppCoreGuidelines/#faq60-is-ensures-the-same-as-assert","text":"No. It is a placeholder for language support for contract postconditions.","title":"FAQ.60: Is Ensures the same as assert?"},{"location":"cppcg/CppCoreGuidelines/#appendix-a-libraries","text":"This section lists recommended libraries, and explicitly recommends a few. ??? Suitable for the general guide? I think not ???","title":"Appendix A: Libraries"},{"location":"cppcg/CppCoreGuidelines/#appendix-b-modernizing-code","text":"Ideally, we follow all rules in all code. Realistically, we have to deal with a lot of old code: application code written before the guidelines were formulated or known libraries written to older/different standards code written under \u201cunusual\u201d constraints code that we just haven\u2019t gotten around to modernizing If we have a million lines of new code, the idea of \u201cjust changing it all at once\u201d is typically unrealistic. Thus, we need a way of gradually modernizing a code base. Upgrading older code to modern style can be a daunting task. Often, the old code is both a mess (hard to understand) and working correctly (for the current range of uses). Typically, the original programmer is not around and the test cases incomplete. The fact that the code is a mess dramatically increases the effort needed to make any change and the risk of introducing errors. Often, messy old code runs unnecessarily slowly because it requires outdated compilers and cannot take advantage of modern hardware. In many cases, automated \u201cmodernizer\u201d-style tool support would be required for major upgrade efforts. The purpose of modernizing code is to simplify adding new functionality, to ease maintenance, and to increase performance (throughput or latency), and to better utilize modern hardware. Making code \u201clook pretty\u201d or \u201cfollow modern style\u201d are not by themselves reasons for change. There are risks implied by every change and costs (including the cost of lost opportunities) implied by having an outdated code base. The cost reductions must outweigh the risks. But how? There is no one approach to modernizing code. How best to do it depends on the code, the pressure for updates, the backgrounds of the developers, and the available tool. Here are some (very general) ideas: The ideal is \u201cjust upgrade everything.\u201d That gives the most benefits for the shortest total time. In most circumstances, it is also impossible. We could convert a code base module for module, but any rules that affects interfaces (especially ABIs), such as use span , cannot be done on a per-module basis. We could convert code \u201cbottom up\u201d starting with the rules we estimate will give the greatest benefits and/or the least trouble in a given code base. We could start by focusing on the interfaces, e.g., make sure that no resources are lost and no pointer is misused. This would be a set of changes across the whole code base, but would most likely have huge benefits. Afterwards, code hidden behind those interfaces can be gradually modernized without affecting other code. Whichever way you choose, please note that the most advantages come with the highest conformance to the guidelines. The guidelines are not a random set of unrelated rules where you can randomly pick and choose with an expectation of success. We would dearly love to hear about experience and about tools used. Modernization can be much faster, simpler, and safer when supported with analysis tools and even code transformation tools.","title":"Appendix B: Modernizing code"},{"location":"cppcg/CppCoreGuidelines/#appendix-c-discussion","text":"This section contains follow-up material on rules and sets of rules. In particular, here we present further rationale, longer examples, and discussions of alternatives.","title":"Appendix C: Discussion"},{"location":"cppcg/CppCoreGuidelines/#discussion-define-and-initialize-member-variables-in-the-order-of-member-declaration","text":"Member variables are always initialized in the order they are declared in the class definition, so write them in that order in the constructor initialization list. Writing them in a different order just makes the code confusing because it won\u2019t run in the order you see, and that can make it hard to see order-dependent bugs. class Employee { string email, first, last; public: Employee(const char* firstName, const char* lastName); // ... }; Employee::Employee(const char* firstName, const char* lastName) : first(firstName), last(lastName), // BAD: first and last not yet constructed email(first + \".\" + last + \"@acme.com\") {} In this example, email will be constructed before first and last because it is declared first. That means its constructor will attempt to use first and last too soon \u2013 not just before they are set to the desired values, but before they are constructed at all. If the class definition and the constructor body are in separate files, the long-distance influence that the order of member variable declarations has over the constructor\u2019s correctness will be even harder to spot. References : Cline99 \u00a722.03-11, Dewhurst03 \u00a752-53, Koenig97 \u00a74, Lakos96 \u00a710.3.5, Meyers97 \u00a713, Murray93 \u00a72.1.3, Sutter00 \u00a747","title":"Discussion: Define and initialize member variables in the order of member declaration"},{"location":"cppcg/CppCoreGuidelines/#discussion-use-of-and-as-initializers","text":"???","title":"Discussion: Use of =, {}, and () as initializers"},{"location":"cppcg/CppCoreGuidelines/#discussion-use-a-factory-function-if-you-need-virtual-behavior-during-initialization","text":"If your design wants virtual dispatch into a derived class from a base class constructor or destructor for functions like f and g , you need other techniques, such as a post-constructor \u2013 a separate member function the caller must invoke to complete initialization, which can safely call f and g because in member functions virtual calls behave normally. Some techniques for this are shown in the References. Here\u2019s a non-exhaustive list of options: Pass the buck: Just document that user code must call the post-initialization function right after constructing an object. Post-initialize lazily: Do it during the first call of a member function. A Boolean flag in the base class tells whether or not post-construction has taken place yet. Use virtual base class semantics: Language rules dictate that the constructor most-derived class decides which base constructor will be invoked; you can use that to your advantage. (See Taligent94 .) Use a factory function: This way, you can easily force a mandatory invocation of a post-constructor function. Here is an example of the last option: class B { public: B() { /* ... */ f(); // BAD: C.82: Don't call virtual functions in constructors and destructors /* ... */ } virtual void f() = 0; }; class B { protected: class Token {}; public: // constructor needs to be public so that make_shared can access it. // protected access level is gained by requiring a Token. explicit B(Token) { /* ... */ } // create an imperfectly initialized object virtual void f() = 0; template<class T> static shared_ptr<T> create() // interface for creating shared objects { auto p = make_shared<T>(typename T::Token{}); p->post_initialize(); return p; } protected: virtual void post_initialize() // called right after construction { /* ... */ f(); /* ... */ } // GOOD: virtual dispatch is safe } }; class D : public B { // some derived class protected: class Token {}; public: // constructor needs to be public so that make_shared can access it. // protected access level is gained by requiring a Token. explicit D(Token) : B{ B::Token{} } {} void f() override { /* ... */ }; protected: template<class T> friend shared_ptr<T> B::create(); }; shared_ptr<D> p = D::create<D>(); // creating a D object This design requires the following discipline: Derived classes such as D must not expose a publicly callable constructor. Otherwise, D \u2018s users could create D objects that don\u2019t invoke post_initialize . Allocation is limited to operator new . B can, however, override new (see Items 45 and 46 in SuttAlex05 ). D must define a constructor with the same parameters that B selected. Defining several overloads of create can assuage this problem, however; and the overloads can even be templated on the argument types. If the requirements above are met, the design guarantees that post_initialize has been called for any fully constructed B -derived object. post_initialize doesn\u2019t need to be virtual; it can, however, invoke virtual functions freely. In summary, no post-construction technique is perfect. The worst techniques dodge the whole issue by simply asking the caller to invoke the post-constructor manually. Even the best require a different syntax for constructing objects (easy to check at compile time) and/or cooperation from derived class authors (impossible to check at compile time). References : Alexandrescu01 \u00a73, Boost , Dewhurst03 \u00a775, Meyers97 \u00a746, Stroustrup00 \u00a715.4.3, Taligent94","title":"Discussion: Use a factory function if you need \"virtual behavior\" during initialization"},{"location":"cppcg/CppCoreGuidelines/#discussion-make-base-class-destructors-public-and-virtual-or-protected-and-nonvirtual","text":"Should destruction behave virtually? That is, should destruction through a pointer to a base class be allowed? If yes, then base \u2018s destructor must be public in order to be callable, and virtual otherwise calling it results in undefined behavior. Otherwise, it should be protected so that only derived classes can invoke it in their own destructors, and nonvirtual since it doesn\u2019t need to behave virtually.","title":"Discussion: Make base class destructors public and virtual, or protected and nonvirtual"},{"location":"cppcg/CppCoreGuidelines/#example_395","text":"The common case for a base class is that it\u2019s intended to have publicly derived classes, and so calling code is just about sure to use something like a shared_ptr<base> : class Base { public: ~Base(); // BAD, not virtual virtual ~Base(); // GOOD // ... }; class Derived : public Base { /* ... */ }; { unique_ptr<Base> pb = make_unique<Derived>(); // ... } // ~pb invokes correct destructor only when ~Base is virtual In rarer cases, such as policy classes, the class is used as a base class for convenience, not for polymorphic behavior. It is recommended to make those destructors protected and nonvirtual: class My_policy { public: virtual ~My_policy(); // BAD, public and virtual protected: ~My_policy(); // GOOD // ... }; template<class Policy> class customizable : Policy { /* ... */ }; // note: private inheritance","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_386","text":"This simple guideline illustrates a subtle issue and reflects modern uses of inheritance and object-oriented design principles. For a base class Base , calling code might try to destroy derived objects through pointers to Base , such as when using a unique_ptr<Base> . If Base \u2018s destructor is public and nonvirtual (the default), it can be accidentally called on a pointer that actually points to a derived object, in which case the behavior of the attempted deletion is undefined. This state of affairs has led older coding standards to impose a blanket requirement that all base class destructors must be virtual. This is overkill (even if it is the common case); instead, the rule should be to make base class destructors virtual if and only if they are public. To write a base class is to define an abstraction (see Items 35 through 37). Recall that for each member function participating in that abstraction, you need to decide: Whether it should behave virtually or not. Whether it should be publicly available to all callers using a pointer to Base or else be a hidden internal implementation detail. As described in Item 39, for a normal member function, the choice is between allowing it to be called via a pointer to Base nonvirtually (but possibly with virtual behavior if it invokes virtual functions, such as in the NVI or Template Method patterns), virtually, or not at all. The NVI pattern is a technique to avoid public virtual functions. Destruction can be viewed as just another operation, albeit with special semantics that make nonvirtual calls dangerous or wrong. For a base class destructor, therefore, the choice is between allowing it to be called via a pointer to Base virtually or not at all; \u201cnonvirtually\u201d is not an option. Hence, a base class destructor is virtual if it can be called (i.e., is public), and nonvirtual otherwise. Note that the NVI pattern cannot be applied to the destructor because constructors and destructors cannot make deep virtual calls. (See Items 39 and 55.) Corollary: When writing a base class, always write a destructor explicitly, because the implicitly generated one is public and nonvirtual. You can always =default the implementation if the default body is fine and you\u2019re just writing the function to give it the proper visibility and virtuality.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#exception_55","text":"Some component architectures (e.g., COM and CORBA) don\u2019t use a standard deletion mechanism, and foster different protocols for object disposal. Follow the local patterns and idioms, and adapt this guideline as appropriate. Consider also this rare case: B is both a base class and a concrete class that can be instantiated by itself, and so the destructor must be public for B objects to be created and destroyed. Yet B also has no virtual functions and is not meant to be used polymorphically, and so although the destructor is public it does not need to be virtual. Then, even though the destructor has to be public, there can be great pressure to not make it virtual because as the first virtual function it would incur all the run-time type overhead when the added functionality should never be needed. In this rare case, you could make the destructor public and nonvirtual but clearly document that further-derived objects must not be used polymorphically as B \u2018s. This is what was done with std::unary_function . In general, however, avoid concrete base classes (see Item 35). For example, unary_function is a bundle-of-typedefs that was never intended to be instantiated standalone. It really makes no sense to give it a public destructor; a better design would be to follow this Item\u2019s advice and give it a protected nonvirtual destructor. References : C++CS Item 50, Cargill92 pp. 77-79, 207, Cline99 \u00a721.06, 21.12-13, Henricson97 pp. 110-114, Koenig97 Chapters 4, 11, Meyers97 \u00a714, Stroustrup00 \u00a712.4.2, Sutter02 \u00a727, Sutter04 \u00a718","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#discussion-usage-of-noexcept","text":"???","title":"Discussion: Usage of noexcept"},{"location":"cppcg/CppCoreGuidelines/#discussion-destructors-deallocation-and-swap-must-never-fail","text":"Never allow an error to be reported from a destructor, a resource deallocation function (e.g., operator delete ), or a swap function using throw . It is nearly impossible to write useful code if these operations can fail, and even if something does go wrong it nearly never makes any sense to retry. Specifically, types whose destructors may throw an exception are flatly forbidden from use with the C++ Standard Library. Most destructors are now implicitly noexcept by default.","title":"Discussion: Destructors, deallocation, and swap must never fail"},{"location":"cppcg/CppCoreGuidelines/#example_396","text":"class Nefarious { public: Nefarious() { /* code that could throw */ } // ok ~Nefarious() { /* code that could throw */ } // BAD, should not throw // ... }; Nefarious objects are hard to use safely even as local variables: void test(string& s) { Nefarious n; // trouble brewing string copy = s; // copy the string } // destroy copy and then n Here, copying s could throw, and if that throws and if n \u2018s destructor then also throws, the program will exit via std::terminate because two exceptions can\u2019t be propagated simultaneously. Classes with Nefarious members or bases are also hard to use safely, because their destructors must invoke Nefarious \u2018 destructor, and are similarly poisoned by its poor behavior: class Innocent_bystander { Nefarious member; // oops, poisons the enclosing class's destructor // ... }; void test(string& s) { Innocent_bystander i; // more trouble brewing string copy2 = s; // copy the string } // destroy copy and then i Here, if constructing copy2 throws, we have the same problem because i \u2018s destructor now also can throw, and if so we\u2019ll invoke std::terminate . You can\u2019t reliably create global or static Nefarious objects either: static Nefarious n; // oops, any destructor exception can't be caught You can\u2019t reliably create arrays of Nefarious : void test() { std::array<Nefarious, 10> arr; // this line can std::terminate(!) } The behavior of arrays is undefined in the presence of destructors that throw because there is no reasonable rollback behavior that could ever be devised. Just think: What code can the compiler generate for constructing an arr where, if the fourth object\u2019s constructor throws, the code has to give up and in its cleanup mode tries to call the destructors of the already-constructed objects \u2026 and one or more of those destructors throws? There is no satisfactory answer. You can\u2019t use Nefarious objects in standard containers: std::vector<Nefarious> vec(10); // this line can std::terminate() The standard library forbids all destructors used with it from throwing. You can\u2019t store Nefarious objects in standard containers or use them with any other part of the standard library.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_387","text":"These are key functions that must not fail because they are necessary for the two key operations in transactional programming: to back out work if problems are encountered during processing, and to commit work if no problems occur. If there\u2019s no way to safely back out using no-fail operations, then no-fail rollback is impossible to implement. If there\u2019s no way to safely commit state changes using a no-fail operation (notably, but not limited to, swap ), then no-fail commit is impossible to implement. Consider the following advice and requirements found in the C++ Standard: If a destructor called during stack unwinding exits with an exception, terminate is called (15.5.1). So destructors should generally catch exceptions and not let them propagate out of the destructor. \u2013 C++03 \u00a715.2(3) No destructor operation defined in the C++ Standard Library (including the destructor of any type that is used to instantiate a standard-library template) will throw an exception. \u2013 C++03 \u00a717.4.4.8(3) Deallocation functions, including specifically overloaded operator delete and operator delete[] , fall into the same category, because they too are used during cleanup in general, and during exception handling in particular, to back out of partial work that needs to be undone. Besides destructors and deallocation functions, common error-safety techniques rely also on swap operations never failing \u2013 in this case, not because they are used to implement a guaranteed rollback, but because they are used to implement a guaranteed commit. For example, here is an idiomatic implementation of operator= for a type T that performs copy construction followed by a call to a no-fail swap : T& T::operator=(const T& other) { auto temp = other; swap(temp); return *this; } (See also Item 56. ???) Fortunately, when releasing a resource, the scope for failure is definitely smaller. If using exceptions as the error reporting mechanism, make sure such functions handle all exceptions and other errors that their internal processing might generate. (For exceptions, simply wrap everything sensitive that your destructor does in a try/catch(...) block.) This is particularly important because a destructor might be called in a crisis situation, such as failure to allocate a system resource (e.g., memory, files, locks, ports, windows, or other system objects). When using exceptions as your error handling mechanism, always document this behavior by declaring these functions noexcept . (See Item 75.) References : C++CS Item 51; C++03 \u00a715.2(3), \u00a717.4.4.8(3), Meyers96 \u00a711, Stroustrup00 \u00a714.4.7, \u00a7E.2-4, Sutter00 \u00a78, \u00a716, Sutter02 \u00a718-19","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#define-copy-move-and-destroy-consistently","text":"","title":"Define Copy, move, and destroy consistently"},{"location":"cppcg/CppCoreGuidelines/#reason_441","text":"???","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_388","text":"If you define a copy constructor, you must also define a copy assignment operator.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#note_389","text":"If you define a move constructor, you must also define a move assignment operator.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#example_397","text":"class X { // ... public: X(const X&) { /* stuff */ } // BAD: failed to also define a copy assignment operator X(x&&) noexcept { /* stuff */ } // BAD: failed to also define a move assignment operator }; X x1; X x2 = x1; // ok x2 = x1; // pitfall: either fails to compile, or does something suspicious If you define a destructor, you should not use the compiler-generated copy or move operation; you probably need to define or suppress copy and/or move. class X { HANDLE hnd; // ... public: ~X() { /* custom stuff, such as closing hnd */ } // suspicious: no mention of copying or moving -- what happens to hnd? }; X x1; X x2 = x1; // pitfall: either fails to compile, or does something suspicious x2 = x1; // pitfall: either fails to compile, or does something suspicious If you define copying, and any base or member has a type that defines a move operation, you should also define a move operation. class X { string s; // defines more efficient move operations // ... other data members ... public: X(const X&) { /* stuff */ } X& operator=(const X&) { /* stuff */ } // BAD: failed to also define a move construction and move assignment // (why wasn't the custom \"stuff\" repeated here?) }; X test() { X local; // ... return local; // pitfall: will be inefficient and/or do the wrong thing } If you define any of the copy constructor, copy assignment operator, or destructor, you probably should define the others.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_390","text":"If you need to define any of these five functions, it means you need it to do more than its default behavior \u2013 and the five are asymmetrically interrelated. Here\u2019s how: If you write/disable either of the copy constructor or the copy assignment operator, you probably need to do the same for the other: If one does \u201cspecial\u201d work, probably so should the other because the two functions should have similar effects. (See Item 53, which expands on this point in isolation.) If you explicitly write the copying functions, you probably need to write the destructor: If the \u201cspecial\u201d work in the copy constructor is to allocate or duplicate some resource (e.g., memory, file, socket), you need to deallocate it in the destructor. If you explicitly write the destructor, you probably need to explicitly write or disable copying: If you have to write a non-trivial destructor, it\u2019s often because you need to manually release a resource that the object held. If so, it is likely that those resources require careful duplication, and then you need to pay attention to the way objects are copied and assigned, or disable copying completely. In many cases, holding properly encapsulated resources using RAII \u201cowning\u201d objects can eliminate the need to write these operations yourself. (See Item 13.) Prefer compiler-generated (including =default ) special members; only these can be classified as \u201ctrivial\u201d, and at least one major standard library vendor heavily optimizes for classes having trivial special members. This is likely to become common practice. Exceptions : When any of the special functions are declared only to make them nonpublic or virtual, but without special semantics, it doesn\u2019t imply that the others are needed. In rare cases, classes that have members of strange types (such as reference members) are an exception because they have peculiar copy semantics. In a class holding a reference, you likely need to write the copy constructor and the assignment operator, but the default destructor already does the right thing. (Note that using a reference member is almost always wrong.) References : C++CS Item 52; Cline99 \u00a730.01-14, Koenig97 \u00a74, Stroustrup00 \u00a75.5, \u00a710.4, SuttHysl04b Resource management rule summary: Provide strong resource safety; that is, never leak anything that you think of as a resource Never throw while holding a resource not owned by a handle A \u201craw\u201d pointer or reference is never a resource handle Never let a pointer outlive the object it points to Use templates to express containers (and other resource handles) Return containers by value (relying on move or copy elision for efficiency) If a class is a resource handle, it needs a constructor, a destructor, and copy and/or move operations If a class is a container, give it an initializer-list constructor","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#discussion-provide-strong-resource-safety-that-is-never-leak-anything-that-you-think-of-as-a-resource","text":"","title":"Discussion: Provide strong resource safety; that is, never leak anything that you think of as a resource"},{"location":"cppcg/CppCoreGuidelines/#reason_442","text":"Prevent leaks. Leaks can lead to performance degradation, mysterious error, system crashes, and security violations. Alternative formulation : Have every resource represented as an object of some class managing its lifetime.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_398","text":"template<class T> class Vector { // ... private: T* elem; // sz elements on the free store, owned by the class object int sz; }; This class is a resource handle. It manages the lifetime of the T s. To do so, Vector must define or delete the set of special operations (constructors, a destructor, etc.).","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#example_399","text":"??? \"odd\" non-memory resource ???","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_402","text":"The basic technique for preventing leaks is to have every resource owned by a resource handle with a suitable destructor. A checker can find \u201cnaked new s\u201d. Given a list of C-style allocation functions (e.g., fopen() ), a checker can also find uses that are not managed by a resource handle. In general, \u201cnaked pointers\u201d can be viewed with suspicion, flagged, and/or analyzed. A complete list of resources cannot be generated without human input (the definition of \u201ca resource\u201d is necessarily too general), but a tool can be \u201cparameterized\u201d with a resource list.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#discussion-never-throw-while-holding-a-resource-not-owned-by-a-handle","text":"","title":"Discussion: Never throw while holding a resource not owned by a handle"},{"location":"cppcg/CppCoreGuidelines/#reason_443","text":"That would be a leak.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_400","text":"void f(int i) { FILE* f = fopen(\"a file\", \"r\"); ifstream is { \"another file\" }; // ... if (i == 0) return; // ... fclose(f); } If i == 0 the file handle for a file is leaked. On the other hand, the ifstream for another file will correctly close its file (upon destruction). If you must use an explicit pointer, rather than a resource handle with specific semantics, use a unique_ptr or a shared_ptr with a custom deleter: void f(int i) { unique_ptr<FILE, int(*)(FILE*)> f(fopen(\"a file\", \"r\"), fclose); // ... if (i == 0) return; // ... } Better: void f(int i) { ifstream input {\"a file\"}; // ... if (i == 0) return; // ... }","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_403","text":"A checker must consider all \u201cnaked pointers\u201d suspicious. A checker probably must rely on a human-provided list of resources. For starters, we know about the standard-library containers, string , and smart pointers. The use of span and string_span should help a lot (they are not resource handles).","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#discussion-a-raw-pointer-or-reference-is-never-a-resource-handle","text":"","title":"Discussion: A \"raw\" pointer or reference is never a resource handle"},{"location":"cppcg/CppCoreGuidelines/#reason_444","text":"To be able to distinguish owners from views.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#note_391","text":"This is independent of how you \u201cspell\u201d pointer: T* , T& , Ptr<T> and Range<T> are not owners.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#discussion-never-let-a-pointer-outlive-the-object-it-points-to","text":"","title":"Discussion: Never let a pointer outlive the object it points to"},{"location":"cppcg/CppCoreGuidelines/#reason_445","text":"To avoid extremely hard-to-find errors. Dereferencing such a pointer is undefined behavior and could lead to violations of the type system.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_401","text":"string* bad() // really bad { vector<string> v = { \"This\", \"will\", \"cause\", \"trouble\", \"!\" }; // leaking a pointer into a destroyed member of a destroyed object (v) return &v[0]; } void use() { string* p = bad(); vector<int> xx = {7, 8, 9}; // undefined behavior: x may not be the string \"This\" string x = *p; // undefined behavior: we don't know what (if anything) is allocated a location p *p = \"Evil!\"; } The string s of v are destroyed upon exit from bad() and so is v itself. The returned pointer points to unallocated memory on the free store. This memory (pointed into by p ) may have been reallocated by the time *p is executed. There may be no string to read and a write through p could easily corrupt objects of unrelated types.","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_404","text":"Most compilers already warn about simple cases and have the information to do more. Consider any pointer returned from a function suspect. Use containers, resource handles, and views (e.g., span known not to be resource handles) to lower the number of cases to be examined. For starters, consider every class with a destructor as resource handle.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#discussion-use-templates-to-express-containers-and-other-resource-handles","text":"","title":"Discussion: Use templates to express containers (and other resource handles)"},{"location":"cppcg/CppCoreGuidelines/#reason_446","text":"To provide statically type-safe manipulation of elements.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_402","text":"template<typename T> class Vector { // ... T* elem; // point to sz elements of type T int sz; };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#discussion-return-containers-by-value-relying-on-move-or-copy-elision-for-efficiency","text":"","title":"Discussion: Return containers by value (relying on move or copy elision for efficiency)"},{"location":"cppcg/CppCoreGuidelines/#reason_447","text":"To simplify code and eliminate a need for explicit memory management. To bring an object into a surrounding scope, thereby extending its lifetime. See also : F.20, the general item about \u201cout\u201d output values","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_403","text":"vector<int> get_large_vector() { return ...; } auto v = get_large_vector(); // return by value is ok, most modern compilers will do copy elision","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#exception_56","text":"See the Exceptions in F.20 .","title":"Exception"},{"location":"cppcg/CppCoreGuidelines/#enforcement_405","text":"Check for pointers and references returned from functions and see if they are assigned to resource handles (e.g., to a unique_ptr ).","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#discussion-if-a-class-is-a-resource-handle-it-needs-a-constructor-a-destructor-and-copy-andor-move-operations","text":"","title":"Discussion: If a class is a resource handle, it needs a constructor, a destructor, and copy and/or move operations"},{"location":"cppcg/CppCoreGuidelines/#reason_448","text":"To provide complete control of the lifetime of the resource. To provide a coherent set of operations on the resource.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_404","text":"??? Messing with pointers","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#note_392","text":"If all members are resource handles, rely on the default special operations where possible. template<typename T> struct Named { string name; T value; }; Now Named has a default constructor, a destructor, and efficient copy and move operations, provided T has.","title":"Note"},{"location":"cppcg/CppCoreGuidelines/#enforcement_406","text":"In general, a tool cannot know if a class is a resource handle. However, if a class has some of the default operations , it should have all, and if a class has a member that is a resource handle, it should be considered as resource handle.","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#discussion-if-a-class-is-a-container-give-it-an-initializer-list-constructor","text":"","title":"Discussion: If a class is a container, give it an initializer-list constructor"},{"location":"cppcg/CppCoreGuidelines/#reason_449","text":"It is common to need an initial set of elements.","title":"Reason"},{"location":"cppcg/CppCoreGuidelines/#example_405","text":"template<typename T> class Vector { public: Vector(std::initializer_list<T>); // ... }; Vector<string> vs { \"Nygaard\", \"Ritchie\" };","title":"Example"},{"location":"cppcg/CppCoreGuidelines/#enforcement_407","text":"When is a class a container? ???","title":"Enforcement"},{"location":"cppcg/CppCoreGuidelines/#appendix-d-supporting-tools","text":"This section contains a list of tools that directly support adoption of the C++ Core Guidelines. This list is not intended to be an exhaustive list of tools that are helpful in writing good C++ code. If a tool is designed specifically to support and links to the C++ Core Guidelines it is a candidate for inclusion.","title":"Appendix D: Supporting tools"},{"location":"cppcg/CppCoreGuidelines/#tools-clang-tidy","text":"Clang-tidy has a set of rules that specifically enforce the C++ Core Guidelines. These rules are named in the pattern cppcoreguidelines-* .","title":"Tools: Clang-tidy"},{"location":"cppcg/CppCoreGuidelines/#tools-cppcorecheck","text":"The Microsoft compiler\u2019s C++ code analysis contains a set of rules specifically aimed at enforcement of the C++ Core Guidelines.","title":"Tools: CppCoreCheck"},{"location":"cppcg/CppCoreGuidelines/#glossary","text":"A relatively informal definition of terms used in the guidelines (based off the glossary in Programming: Principles and Practice using C++ ) More information on many topics about C++ can be found on the Standard C++ Foundation \u2018s site. ABI : Application Binary Interface, a specification for a specific hardware platform combined with the operating system. Contrast with API. abstract class : a class that cannot be directly used to create objects; often used to define an interface to derived classes. A class is made abstract by having a pure virtual function or only protected constructors. abstraction : a description of something that selectively and deliberately ignores (hides) details (e.g., implementation details); selective ignorance. address : a value that allows us to find an object in a computer\u2019s memory. algorithm : a procedure or formula for solving a problem; a finite series of computational steps to produce a result. alias : an alternative way of referring to an object; often a name, pointer, or reference. API : Application Programming Interface, a set of functions that form the communication between various software components. Contrast with ABI. application : a program or a collection of programs that is considered an entity by its users. approximation : something (e.g., a value or a design) that is close to the perfect or ideal (value or design). Often an approximation is a result of trade-offs among ideals. argument : a value passed to a function or a template, in which it is accessed through a parameter. array : a homogeneous sequence of elements, usually numbered, e.g., [0:max) . assertion : a statement inserted into a program to state (assert) that something must always be true at this point in the program. base class : a class used as the base of a class hierarchy. Typically a base class has one or more virtual functions. bit : the basic unit of information in a computer. A bit can have the value 0 or the value 1. bug : an error in a program. byte : the basic unit of addressing in most computers. Typically, a byte holds 8 bits. class : a user-defined type that may contain data members, function members, and member types. code : a program or a part of a program; ambiguously used for both source code and object code. compiler : a program that turns source code into object code. complexity : a hard-to-precisely-define notion or measure of the difficulty of constructing a solution to a problem or of the solution itself. Sometimes complexity is used to (simply) mean an estimate of the number of operations needed to execute an algorithm. computation : the execution of some code, usually taking some input and producing some output. concept : (1) a notion, and idea; (2) a set of requirements, usually for a template argument. concrete class : class for which objects can be created using usual construction syntax (e.g., on the stack) and the resulting object behaves much like an int as it comes to copying, comparison, and such (as opposed to a base class in a hierarchy). constant : a value that cannot be changed (in a given scope); not mutable. constructor : an operation that initializes (\u201cconstructs\u201d) an object. Typically a constructor establishes an invariant and often acquires resources needed for an object to be used (which are then typically released by a destructor). container : an object that holds elements (other objects). copy : an operation that makes two object have values that compare equal. See also move. correctness : a program or a piece of a program is correct if it meets its specification. Unfortunately, a specification can be incomplete or inconsistent, or can fail to meet users\u2019 reasonable expectations. Thus, to produce acceptable code, we sometimes have to do more than just follow the formal specification. cost : the expense (e.g., in programmer time, run time, or space) of producing a program or of executing it. Ideally, cost should be a function of complexity. customization point : ??? data : values used in a computation. debugging : the act of searching for and removing errors from a program; usually far less systematic than testing. declaration : the specification of a name with its type in a program. definition : a declaration of an entity that supplies all information necessary to complete a program using the entity. Simplified definition: a declaration that allocates memory. derived class : a class derived from one or more base classes. design : an overall description of how a piece of software should operate to meet its specification. destructor : an operation that is implicitly invoked (called) when an object is destroyed (e.g., at the end of a scope). Often, it releases resources. encapsulation : protecting something meant to be private (e.g., implementation details) from unauthorized access. error : a mismatch between reasonable expectations of program behavior (often expressed as a requirement or a users\u2019 guide) and what a program actually does. executable : a program ready to be run (executed) on a computer. feature creep : a tendency to add excess functionality to a program \u201cjust in case.\u201d file : a container of permanent information in a computer. floating-point number : a computer\u2019s approximation of a real number, such as 7.93 and 10.78e-3. function : a named unit of code that can be invoked (called) from different parts of a program; a logical unit of computation. generic programming : a style of programming focused on the design and efficient implementation of algorithms. A generic algorithm will work for all argument types that meet its requirements. In C++, generic programming typically uses templates. global variable : technically, a named object in namespace scope. handle : a class that allows access to another through a member pointer or reference. See also resource, copy, move. header : a file containing declarations used to share interfaces between parts of a program. hiding : the act of preventing a piece of information from being directly seen or accessed. For example, a name from a nested (inner) scope can prevent that same name from an outer (enclosing) scope from being directly used. ideal : the perfect version of something we are striving for. Usually we have to make trade-offs and settle for an approximation. implementation : (1) the act of writing and testing code; (2) the code that implements a program. infinite loop : a loop where the termination condition never becomes true. See iteration. infinite recursion : a recursion that doesn\u2019t end until the machine runs out of memory to hold the calls. In reality, such recursion is never infinite but is terminated by some hardware error. information hiding : the act of separating interface and implementation, thus hiding implementation details not meant for the user\u2019s attention and providing an abstraction. initialize : giving an object its first (initial) value. input : values used by a computation (e.g., function arguments and characters typed on a keyboard). integer : a whole number, such as 42 and -99. interface : a declaration or a set of declarations specifying how a piece of code (such as a function or a class) can be called. invariant : something that must be always true at a given point (or points) of a program; typically used to describe the state (set of values) of an object or the state of a loop before entry into the repeated statement. iteration : the act of repeatedly executing a piece of code; see recursion. iterator : an object that identifies an element of a sequence. ISO : International Organization for Standardization. The C++ language is an ISO standard, ISO/IEC 14882. More information at iso.org . library : a collection of types, functions, classes, etc. implementing a set of facilities (abstractions) meant to be potentially used as part of more that one program. lifetime : the time from the initialization of an object until it becomes unusable (goes out of scope, is deleted, or the program terminates). linker : a program that combines object code files and libraries into an executable program. literal : a notation that directly specifies a value, such as 12 specifying the integer value \u201ctwelve.\u201d loop : a piece of code executed repeatedly; in C++, typically a for-statement or a while -statement. move : an operation that transfers a value from one object to another leaving behind a value representing \u201cempty.\u201d See also copy. mutable : changeable; the opposite of immutable, constant, and invariable. object : (1) an initialized region of memory of a known type which holds a value of that type; (2) a region of memory. object code : output from a compiler intended as input for a linker (for the linker to produce executable code). object file : a file containing object code. object-oriented programming : (OOP) a style of programming focused on the design and use of classes and class hierarchies. operation : something that can perform some action, such as a function and an operator. output : values produced by a computation (e.g., a function result or lines of characters written on a screen). overflow : producing a value that cannot be stored in its intended target. overload : defining two functions or operators with the same name but different argument (operand) types. override : defining a function in a derived class with the same name and argument types as a virtual function in the base class, thus making the function callable through the interface defined by the base class. owner : an object responsible for releasing a resource. paradigm : a somewhat pretentious term for design or programming style; often used with the (erroneous) implication that there exists a paradigm that is superior to all others. parameter : a declaration of an explicit input to a function or a template. When called, a function can access the arguments passed through the names of its parameters. pointer : (1) a value used to identify a typed object in memory; (2) a variable holding such a value. post-condition : a condition that must hold upon exit from a piece of code, such as a function or a loop. pre-condition : a condition that must hold upon entry into a piece of code, such as a function or a loop. program : code (possibly with associated data) that is sufficiently complete to be executed by a computer. programming : the art of expressing solutions to problems as code. programming language : a language for expressing programs. pseudo code : a description of a computation written in an informal notation rather than a programming language. pure virtual function : a virtual function that must be overridden in a derived class. RAII : (\u201cResource Acquisition Is Initialization\u201d) a basic technique for resource management based on scopes. range : a sequence of values that can be described by a start point and an end point. For example, [0:5) means the values 0, 1, 2, 3, and 4. recursion : the act of a function calling itself; see also iteration. reference : (1) a value describing the location of a typed value in memory; (2) a variable holding such a value. regular expression : a notation for patterns in character strings. regular : a type that behaves similarly to built-in types like int and can be compared with == . In particular, an object of a regular type can be copied and the result of a copy is a separate object that compares equal to the original. See also semiregular type . requirement : (1) a description of the desired behavior of a program or part of a program; (2) a description of the assumptions a function or template makes of its arguments. resource : something that is acquired and must later be released, such as a file handle, a lock, or memory. See also handle, owner. rounding : conversion of a value to the mathematically nearest value of a less precise type. RTTI : Run-Time Type Information. ??? scope : the region of program text (source code) in which a name can be referred to. semiregular : a type that behaves roughly like an built-in type like int , but possibly without a == operator. See also regular type . sequence : elements that can be visited in a linear order. software : a collection of pieces of code and associated data; often used interchangeably with program. source code : code as produced by a programmer and (in principle) readable by other programmers. source file : a file containing source code. specification : a description of what a piece of code should do. standard : an officially agreed upon definition of something, such as a programming language. state : a set of values. STL : the containers, iterators, and algorithms part of the standard library. string : a sequence of characters. style : a set of techniques for programming leading to a consistent use of language features; sometimes used in a very restricted sense to refer just to low-level rules for naming and appearance of code. subtype : derived type; a type that has all the properties of a type and possibly more. supertype : base type; a type that has a subset of the properties of a type. system : (1) a program or a set of programs for performing a task on a computer; (2) a shorthand for \u201coperating system\u201d, that is, the fundamental execution environment and tools for a computer. TS : Technical Specification , A Technical Specification addresses work still under technical development, or where it is believed that there will be a future, but not immediate, possibility of agreement on an International Standard. A Technical Specification is published for immediate use, but it also provides a means to obtain feedback. The aim is that it will eventually be transformed and republished as an International Standard. template : a class or a function parameterized by one or more types or (compile-time) values; the basic C++ language construct supporting generic programming. testing : a systematic search for errors in a program. trade-off : the result of balancing several design and implementation criteria. truncation : loss of information in a conversion from a type into another that cannot exactly represent the value to be converted. type : something that defines a set of possible values and a set of operations for an object. uninitialized : the (undefined) state of an object before it is initialized. unit : (1) a standard measure that gives meaning to a value (e.g., km for a distance); (2) a distinguished (e.g., named) part of a larger whole. use case : a specific (typically simple) use of a program meant to test its functionality and demonstrate its purpose. value : a set of bits in memory interpreted according to a type. variable : a named object of a given type; contains a value unless uninitialized. virtual function : a member function that can be overridden in a derived class. word : a basic unit of memory in a computer, often the unit used to hold an integer.","title":"Glossary"},{"location":"cppcg/CppCoreGuidelines/#to-do-unclassified-proto-rules","text":"This is our to-do list. Eventually, the entries will become rules or parts of rules. Alternatively, we will decide that no change is needed and delete the entry. No long-distance friendship Should physical design (what\u2019s in a file) and large-scale design (libraries, groups of libraries) be addressed? Namespaces Avoid using directives in the global scope (except for std, and other \u201cfundamental\u201d namespaces (e.g. experimental)) How granular should namespaces be? All classes/functions designed to work together and released together (as defined in Sutter/Alexandrescu) or something narrower or wider? Should there be inline namespaces (\u00e0 la std::literals::*_literals )? Avoid implicit conversions Const member functions should be thread safe \u2026 aka, but I don\u2019t really change the variable, just assign it a value the first time it\u2019s called \u2026 argh Always initialize variables, use initialization lists for member variables. Anyone writing a public interface which takes or returns void* should have their toes set on fire. That one has been a personal favorite of mine for a number of years. :) Use const -ness wherever possible: member functions, variables and (yippee) const_iterators Use auto (size) vs. {initializers} vs. {Extent{size}} Don\u2019t overabstract Never pass a pointer down the call stack falling through a function bottom Should there be guidelines to choose between polymorphisms? YES. classic (virtual functions, reference semantics) vs. Sean Parent style (value semantics, type-erased, kind of like std::function ) vs. CRTP/static? YES Perhaps even vs. tag dispatch? should virtual calls be banned from ctors/dtors in your guidelines? YES. A lot of people ban them, even though I think it\u2019s a big strength of C++ that they are ??? -preserving (D disappointed me so much when it went the Java way). WHAT WOULD BE A GOOD EXAMPLE? Speaking of lambdas, what would weigh in on the decision between lambdas and (local?) classes in algorithm calls and other callback scenarios? And speaking of std::bind , Stephen T. Lavavej criticizes it so much I\u2019m starting to wonder if it is indeed going to fade away in future. Should lambdas be recommended instead? What to do with leaks out of temporaries? : p = (s1 + s2).c_str(); pointer/iterator invalidation leading to dangling pointers: void bad() { int* p = new int[700]; int* q = &p[7]; delete p; vector<int> v(700); int* q2 = &v[7]; v.resize(900); // ... use q and q2 ... } LSP private inheritance vs/and membership avoid static class members variables (race conditions, almost-global variables) Use RAII lock guards ( lock_guard , unique_lock , shared_lock ), never call mutex.lock and mutex.unlock directly (RAII) Prefer non-recursive locks (often used to work around bad reasoning, overhead) Join your threads! (because of std::terminate in destructor if not joined or detached \u2026 is there a good reason to detach threads?) \u2013 ??? could support library provide a RAII wrapper for std::thread ? If two or more mutexes must be acquired at the same time, use std::lock (or another deadlock avoidance algorithm?) When using a condition_variable , always protect the condition by a mutex (atomic bool whose value is set outside of the mutex is wrong!), and use the same mutex for the condition variable itself. Never use atomic_compare_exchange_strong with std::atomic<user-defined-struct> (differences in padding matter, while compare_exchange_weak in a loop converges to stable padding) individual shared_future objects are not thread-safe: two threads cannot wait on the same shared_future object (they can wait on copies of a shared_future that refer to the same shared state) individual shared_ptr objects are not thread-safe: different threads can call non- const member functions on different shared_ptr s that refer to the same shared object, but one thread cannot call a non- const member function of a shared_ptr object while another thread accesses that same shared_ptr object (if you need that, consider atomic_shared_ptr instead) rules for arithmetic","title":"To-do: Unclassified proto-rules"},{"location":"cppcg/CppCoreGuidelines/#bibliography","text":"[Abrahams01]: D. Abrahams. Exception-Safety in Generic Components . [Alexandrescu01]: A. Alexandrescu. Modern C++ Design (Addison-Wesley, 2001). [C++03]: ISO/IEC 14882:2003(E), Programming Languages \u2014 C++ (updated ISO and ANSI C++ Standard including the contents of (C++98) plus errata corrections). [C++CS]: ??? [Cargill92]: T. Cargill. C++ Programming Style (Addison-Wesley, 1992). [Cline99]: M. Cline, G. Lomow, and M. Girou. C++ FAQs (2ndEdition) (Addison-Wesley, 1999). [Dewhurst03]: S. Dewhurst. C++ Gotchas (Addison-Wesley, 2003). [Henricson97]: M. Henricson and E. Nyquist. Industrial Strength C++ (Prentice Hall, 1997). [Koenig97]: A. Koenig and B. Moo. Ruminations on C++ (Addison-Wesley, 1997). [Lakos96]: J. Lakos. Large-Scale C++ Software Design (Addison-Wesley, 1996). [Meyers96]: S. Meyers. More Effective C++ (Addison-Wesley, 1996). [Meyers97]: S. Meyers. Effective C++ (2 nd Edition) (Addison-Wesley, 1997). [Meyers15]: S. Meyers. Effective Modern C++ (O\u2019Reilly, 2015). [Murray93]: R. Murray. C++ Strategies and Tactics (Addison-Wesley, 1993). [Stroustrup94]: B. Stroustrup. The Design and Evolution of C++ (Addison-Wesley, 1994). [Stroustrup00]: B. Stroustrup. The C++ Programming Language (Special 3rdEdition) (Addison-Wesley, 2000). [Stroustrup05]: B. Stroustrup. A rationale for semantically enhanced library languages . [Stroustrup13]: B. Stroustrup. The C++ Programming Language (4 th Edition) . Addison Wesley 2013. [Stroustrup14]: B. Stroustrup. A Tour of C++ . Addison Wesley 2014. [Stroustrup15]: B. Stroustrup, Herb Sutter, and G. Dos Reis: A brief introduction to C++\u2019s model for type- and resource-safety . [SuttHysl04b]: H. Sutter and J. Hyslop. \u201cCollecting Shared Objects\u201d (C/C++ Users Journal, 22(8), August 2004). [SuttAlex05]: H. Sutter and A. Alexandrescu. C++ Coding Standards. Addison-Wesley 2005. [Sutter00]: H. Sutter. Exceptional C++ (Addison-Wesley, 2000). [Sutter02]: H. Sutter. More Exceptional C++ (Addison-Wesley, 2002). [Sutter04]: H. Sutter. Exceptional C++ Style (Addison-Wesley, 2004). [Taligent94]: Taligent\u2019s Guide to Designing Programs (Addison-Wesley, 1994).","title":"Bibliography"},{"location":"cppcg/abstract/","text":"\u6458\u8981 # \u672c\u7cfb\u5217\u6587\u6863\u662f\u4e00\u7ec4\u826f\u597d\u4f7f\u7528C++\u7684\u6307\u5357\u3002 \u672c\u7cfb\u5217\u6587\u6863\u7684\u76ee\u6807\u662f\u5e2e\u52a9\u4eba\u4eec\u6709\u6548\u7387\u7684\u4f7f\u7528\u73b0\u4ee3C++\u3002 \u5bf9\u4e8e\u201c\u73b0\u4ee3C++\u201d\u800c\u8a00\uff0c\u6211\u4eec\u6307\u7684\u662fISO C++\uff08\u76ee\u524d\u662fC++ 17\uff0c\u4f46\u51e0\u4e4e\u6240\u6709\u7684\u5efa\u8bae\u5bf9C++ 14\u548cC++ 11\u90fd\u9002\u7528\uff09\u3002 \u6362\u53e5\u8bdd\u6765\u8bf4\uff0c\u5982\u679c\u4f60\u73b0\u5728\u5f00\u59cb\u5199\u7684\u8bdd\uff0c\u4f60\u4f1a\u671f\u671b\u4f60\u7684\u4ee3\u7801\u4e94\u5e74\u540e\u662f\u4ec0\u4e48\u6837\u5b50\uff1f\u5341\u5e74\u540e\u5462\uff1f \u672c\u6307\u5357\u4e3b\u8981\u5173\u6ce8\u76f8\u5bf9\u9ad8\u7ea7\u7684\u95ee\u9898\uff0c\u6bd4\u5982\u63a5\u53e3\u3001\u8d44\u6e90\u7ba1\u7406\u3001\u5185\u5b58\u7ba1\u7406\u4ee5\u53ca\u5e76\u53d1\u3002 \u8fd9\u4e9b\u89c4\u5219\u4f1a\u5f71\u54cd\u5e94\u7528\u7a0b\u5e8f\u67b6\u6784\u548c\u5e93\u8bbe\u8ba1\u3002 \u9075\u5faa\u8fd9\u4e9b\u89c4\u5219\u5c06\u5bfc\u8ba9\u4f60\u5199\u51fa\u9759\u6001\u7c7b\u578b\u5b89\u5168\u3001\u6ca1\u6709\u8d44\u6e90\u6cc4\u6f0f\u3001\u4e14\u6355\u83b7\u66f4\u591a\u5f53\u4eca\u4ee3\u7801\u4e2d\u5e38\u89c1\u7684\u903b\u8f91\u9519\u8bef\u7684\u4ee3\u7801\u3002 \u5e76\u4e14\u5b83\u4f1a\u8dd1\u5f97\u5f88\u5feb \u2013 \u4f60\u53ef\u4ee5\u627f\u53d7\u5f97\u8d77\u505a\u5bf9\u7684\u4e8b\u3002 \u6211\u4eec\u4e0d\u592a\u5173\u5fc3\u4f4e\u7ea7\u95ee\u9898\uff0c\u4f8b\u5982\u547d\u540d\u7ea6\u5b9a\u548c\u7f29\u8fdb\u6837\u5f0f\u3002 \u4f46\u662f\uff0c\u6ca1\u6709\u80fd\u5e2e\u52a9\u7a0b\u5e8f\u5458\u7684\u8bdd\u9898\u662f\u8d85\u8d8a\u8303\u7574\u7684\u3002 \u6211\u4eec\u521d\u59cb\u7684\u4e00\u7ec4\u89c4\u5219\u5f3a\u8c03\u5b89\u5168\u6027\uff08\u5404\u79cd\u5f62\u5f0f\uff09\u548c\u7b80\u5355\u6027\u3002 \u4ed6\u4eec\u53ef\u80fd\u6709\u4e9b\u592a\u8fc7\u4e25\u683c\u3002 \u6211\u4eec\u4e0d\u5f97\u4e0d\u5f15\u5165\u66f4\u591a\u4f8b\u5916\u60c5\u51b5\u4ee5\u66f4\u597d\u5730\u6ee1\u8db3\u73b0\u5b9e\u4e16\u754c\u7684\u9700\u6c42\u3002 \u6211\u4eec\u4e5f\u8fd8\u9700\u8981\u66f4\u591a\u89c4\u5219\u3002 \u60a8\u4f1a\u53d1\u73b0\u4e00\u4e9b\u4e0e\u60a8\u7684\u671f\u671b\uff0c\u751a\u81f3\u4e0e\u4f60\u7684\u7ecf\u9a8c\u76f8\u6096\u7684\u89c4\u5219\u3002 \u5982\u679c\u6211\u4eec\u6ca1\u6709\u5efa\u8bae\u4f60\u4ee5\u4efb\u4f55\u65b9\u5f0f\u6539\u53d8\u4f60\u7684\u7f16\u7801\u98ce\u683c\uff0c\u6211\u4eec\u5c31\u5931\u8d25\u4e86\uff01 \u8bf7\u5c1d\u8bd5\u9a8c\u8bc1\u6216\u53cd\u9a73\u89c4\u5219\uff01 \u7279\u522b\u662f\uff0c\u6211\u4eec\u771f\u7684\u5e0c\u671b\u901a\u8fc7\u6d4b\u8bd5\u6216\u66f4\u597d\u7684\u4f8b\u5b50\u6765\u652f\u6301\u6211\u4eec\u7684\u4e00\u4e9b\u89c4\u5219\u3002 \u4f60\u4f1a\u53d1\u73b0\u4e00\u4e9b\u660e\u663e\u751a\u81f3\u5fae\u4e0d\u8db3\u9053\u7684\u89c4\u5219\u3002 \u8bf7\u8bb0\u4f4f\uff0c\u672c\u6307\u5357\u7684\u4e00\u4e2a\u76ee\u7684\u662f\u5e2e\u52a9\u90a3\u4e9b\u7ecf\u9a8c\u4e0d\u8db3\u6216\u6765\u81ea\u4e0d\u540c\u80cc\u666f\u6216\u8bed\u8a00\u7684\u4eba\u52a0\u5feb\u901f\u5ea6\u3002 \u8bb8\u591a\u89c4\u5219\u90fd\u65e8\u5728\u7531\u5206\u6790\u5de5\u5177\u652f\u6301\u3002 \u88ab\u8fdd\u53cd\u7684\u89c4\u5219\u5c06\u4f1a\u7531\u76f8\u5173\u89c4\u5219\u7684\u5f15\u7528\uff08\u6216\u94fe\u63a5\uff09\u6240\u6807\u6ce8\u3002 \u5728\u5c1d\u8bd5\u7f16\u5199\u4ee3\u7801\u4e4b\u524d\uff0c\u6211\u4eec\u4e0d\u5e0c\u671b\u60a8\u8bb0\u4f4f\u6240\u6709\u89c4\u5219\u3002 \u601d\u8003\u8fd9\u4e9b\u6307\u5357\u7684\u4e00\u79cd\u65b9\u6cd5\u662f\u4f5c\u4e3a\u4eba\u7c7b\u53ef\u8bfb\u7684\u5de5\u5177\u7684\u89c4\u8303\u3002 \u8fd9\u4e9b\u89c4\u5219\u610f\u5728\u9010\u6b65\u88ab\u5f15\u5165\u4ee3\u7801\u5e93\u3002 \u6211\u4eec\u8ba1\u5212\u4e3a\u6b64\u5efa\u7acb\u5de5\u5177\uff0c\u5e76\u5e0c\u671b\u5176\u4ed6\u4eba\u4e5f\u8fd9\u6837\u505a\u3002 \u975e\u5e38\u6b22\u8fce\u63d0\u51fa\u6539\u8fdb\u610f\u89c1\u548c\u5efa\u8bae\u3002 \u968f\u7740\u6211\u4eec\u7684\u7406\u89e3\u52a0\u6df1\uff0c\u4ee5\u53ca\u8bed\u8a00\u548c\u53ef\u7528\u5e93\u96c6\u7684\u6539\u8fdb\uff0c\u6211\u4eec\u8ba1\u5212\u4fee\u6539\u548c\u6269\u5c55\u6b64\u6587\u6863\u3002","title":"\u6458\u8981"},{"location":"cppcg/abstract/#_1","text":"\u672c\u7cfb\u5217\u6587\u6863\u662f\u4e00\u7ec4\u826f\u597d\u4f7f\u7528C++\u7684\u6307\u5357\u3002 \u672c\u7cfb\u5217\u6587\u6863\u7684\u76ee\u6807\u662f\u5e2e\u52a9\u4eba\u4eec\u6709\u6548\u7387\u7684\u4f7f\u7528\u73b0\u4ee3C++\u3002 \u5bf9\u4e8e\u201c\u73b0\u4ee3C++\u201d\u800c\u8a00\uff0c\u6211\u4eec\u6307\u7684\u662fISO C++\uff08\u76ee\u524d\u662fC++ 17\uff0c\u4f46\u51e0\u4e4e\u6240\u6709\u7684\u5efa\u8bae\u5bf9C++ 14\u548cC++ 11\u90fd\u9002\u7528\uff09\u3002 \u6362\u53e5\u8bdd\u6765\u8bf4\uff0c\u5982\u679c\u4f60\u73b0\u5728\u5f00\u59cb\u5199\u7684\u8bdd\uff0c\u4f60\u4f1a\u671f\u671b\u4f60\u7684\u4ee3\u7801\u4e94\u5e74\u540e\u662f\u4ec0\u4e48\u6837\u5b50\uff1f\u5341\u5e74\u540e\u5462\uff1f \u672c\u6307\u5357\u4e3b\u8981\u5173\u6ce8\u76f8\u5bf9\u9ad8\u7ea7\u7684\u95ee\u9898\uff0c\u6bd4\u5982\u63a5\u53e3\u3001\u8d44\u6e90\u7ba1\u7406\u3001\u5185\u5b58\u7ba1\u7406\u4ee5\u53ca\u5e76\u53d1\u3002 \u8fd9\u4e9b\u89c4\u5219\u4f1a\u5f71\u54cd\u5e94\u7528\u7a0b\u5e8f\u67b6\u6784\u548c\u5e93\u8bbe\u8ba1\u3002 \u9075\u5faa\u8fd9\u4e9b\u89c4\u5219\u5c06\u5bfc\u8ba9\u4f60\u5199\u51fa\u9759\u6001\u7c7b\u578b\u5b89\u5168\u3001\u6ca1\u6709\u8d44\u6e90\u6cc4\u6f0f\u3001\u4e14\u6355\u83b7\u66f4\u591a\u5f53\u4eca\u4ee3\u7801\u4e2d\u5e38\u89c1\u7684\u903b\u8f91\u9519\u8bef\u7684\u4ee3\u7801\u3002 \u5e76\u4e14\u5b83\u4f1a\u8dd1\u5f97\u5f88\u5feb \u2013 \u4f60\u53ef\u4ee5\u627f\u53d7\u5f97\u8d77\u505a\u5bf9\u7684\u4e8b\u3002 \u6211\u4eec\u4e0d\u592a\u5173\u5fc3\u4f4e\u7ea7\u95ee\u9898\uff0c\u4f8b\u5982\u547d\u540d\u7ea6\u5b9a\u548c\u7f29\u8fdb\u6837\u5f0f\u3002 \u4f46\u662f\uff0c\u6ca1\u6709\u80fd\u5e2e\u52a9\u7a0b\u5e8f\u5458\u7684\u8bdd\u9898\u662f\u8d85\u8d8a\u8303\u7574\u7684\u3002 \u6211\u4eec\u521d\u59cb\u7684\u4e00\u7ec4\u89c4\u5219\u5f3a\u8c03\u5b89\u5168\u6027\uff08\u5404\u79cd\u5f62\u5f0f\uff09\u548c\u7b80\u5355\u6027\u3002 \u4ed6\u4eec\u53ef\u80fd\u6709\u4e9b\u592a\u8fc7\u4e25\u683c\u3002 \u6211\u4eec\u4e0d\u5f97\u4e0d\u5f15\u5165\u66f4\u591a\u4f8b\u5916\u60c5\u51b5\u4ee5\u66f4\u597d\u5730\u6ee1\u8db3\u73b0\u5b9e\u4e16\u754c\u7684\u9700\u6c42\u3002 \u6211\u4eec\u4e5f\u8fd8\u9700\u8981\u66f4\u591a\u89c4\u5219\u3002 \u60a8\u4f1a\u53d1\u73b0\u4e00\u4e9b\u4e0e\u60a8\u7684\u671f\u671b\uff0c\u751a\u81f3\u4e0e\u4f60\u7684\u7ecf\u9a8c\u76f8\u6096\u7684\u89c4\u5219\u3002 \u5982\u679c\u6211\u4eec\u6ca1\u6709\u5efa\u8bae\u4f60\u4ee5\u4efb\u4f55\u65b9\u5f0f\u6539\u53d8\u4f60\u7684\u7f16\u7801\u98ce\u683c\uff0c\u6211\u4eec\u5c31\u5931\u8d25\u4e86\uff01 \u8bf7\u5c1d\u8bd5\u9a8c\u8bc1\u6216\u53cd\u9a73\u89c4\u5219\uff01 \u7279\u522b\u662f\uff0c\u6211\u4eec\u771f\u7684\u5e0c\u671b\u901a\u8fc7\u6d4b\u8bd5\u6216\u66f4\u597d\u7684\u4f8b\u5b50\u6765\u652f\u6301\u6211\u4eec\u7684\u4e00\u4e9b\u89c4\u5219\u3002 \u4f60\u4f1a\u53d1\u73b0\u4e00\u4e9b\u660e\u663e\u751a\u81f3\u5fae\u4e0d\u8db3\u9053\u7684\u89c4\u5219\u3002 \u8bf7\u8bb0\u4f4f\uff0c\u672c\u6307\u5357\u7684\u4e00\u4e2a\u76ee\u7684\u662f\u5e2e\u52a9\u90a3\u4e9b\u7ecf\u9a8c\u4e0d\u8db3\u6216\u6765\u81ea\u4e0d\u540c\u80cc\u666f\u6216\u8bed\u8a00\u7684\u4eba\u52a0\u5feb\u901f\u5ea6\u3002 \u8bb8\u591a\u89c4\u5219\u90fd\u65e8\u5728\u7531\u5206\u6790\u5de5\u5177\u652f\u6301\u3002 \u88ab\u8fdd\u53cd\u7684\u89c4\u5219\u5c06\u4f1a\u7531\u76f8\u5173\u89c4\u5219\u7684\u5f15\u7528\uff08\u6216\u94fe\u63a5\uff09\u6240\u6807\u6ce8\u3002 \u5728\u5c1d\u8bd5\u7f16\u5199\u4ee3\u7801\u4e4b\u524d\uff0c\u6211\u4eec\u4e0d\u5e0c\u671b\u60a8\u8bb0\u4f4f\u6240\u6709\u89c4\u5219\u3002 \u601d\u8003\u8fd9\u4e9b\u6307\u5357\u7684\u4e00\u79cd\u65b9\u6cd5\u662f\u4f5c\u4e3a\u4eba\u7c7b\u53ef\u8bfb\u7684\u5de5\u5177\u7684\u89c4\u8303\u3002 \u8fd9\u4e9b\u89c4\u5219\u610f\u5728\u9010\u6b65\u88ab\u5f15\u5165\u4ee3\u7801\u5e93\u3002 \u6211\u4eec\u8ba1\u5212\u4e3a\u6b64\u5efa\u7acb\u5de5\u5177\uff0c\u5e76\u5e0c\u671b\u5176\u4ed6\u4eba\u4e5f\u8fd9\u6837\u505a\u3002 \u975e\u5e38\u6b22\u8fce\u63d0\u51fa\u6539\u8fdb\u610f\u89c1\u548c\u5efa\u8bae\u3002 \u968f\u7740\u6211\u4eec\u7684\u7406\u89e3\u52a0\u6df1\uff0c\u4ee5\u53ca\u8bed\u8a00\u548c\u53ef\u7528\u5e93\u96c6\u7684\u6539\u8fdb\uff0c\u6211\u4eec\u8ba1\u5212\u4fee\u6539\u548c\u6269\u5c55\u6b64\u6587\u6863\u3002","title":"\u6458\u8981"},{"location":"cv/convolution_neural_network/","text":"\u5377\u79ef\u795e\u7ecf\u7f51\u7edc <<<<<<< Updated upstream \u73b0\u4ee3\u8ba1\u7b97\u673a\u89c6\u89c9\u4efb\u52a1\u4e2d\u51e0\u4e4e\u5904\u5904\u90fd\u7528 ======= Stashed changes","title":"\u4e92\u76f8\u5173\u4e0e\u5377\u79ef"},{"location":"cv/correlation_and_convolution/","text":"\u4e92\u76f8\u5173\u4e0e\u5377\u79ef \u4e92\u76f8\u5173\u4e0e\u5377\u79ef\u662f\u6211\u4eec\u4ece\u56fe\u50cf\u5f53\u4e2d\u62bd\u53d6\u4fe1\u606f\u7684\u57fa\u672c\u64cd\u4f5c\u3002 \u4ece\u67d0\u79cd\u610f\u4e49\u4e0a\u6765\u8bf4\uff0c\u4ed6\u4eec\u4e5f\u662f\u6211\u4eec\u5bf9\u56fe\u50cf\u6240\u80fd\u8fdb\u884c\u7684\u6700\u57fa\u672c\u7684\u64cd\u4f5c\uff0c\u4f46\u4ed6\u4eec\u6781\u5176\u6709\u7528\u3002 \u66f4\u8fdb\u4e00\u6b65\u7684\uff0c\u56e0\u4e3a\u4ed6\u4eec\u5f88\u7b80\u5355\uff0c\u4ed6\u4eec\u53ef\u4ee5\u88ab\u5f88\u597d\u7684\u7406\u89e3\u548c\u5206\u6790\uff0c\u5e76\u4e14\u4ed6\u4eec\u5f88\u5bb9\u6613\u90e8\u7f72\u4e5f\u53ef\u4ee5\u88ab\u5f88\u9ad8\u6548\u7684\u8ba1\u7b97\u3002 \u672c\u6587\u7684\u4e3b\u8981\u76ee\u6807\u662f\u89e3\u91ca\u4ec0\u4e48\u662f\u4e92\u76f8\u5173\u548c\u5377\u79ef\uff0c\u4ee5\u53ca\u4ed6\u4eec\u4e3a\u4ec0\u4e48\u6709\u7528\u3002\u6211\u4eec\u4e5f\u4f1a\u63a5\u89e6\u5230\u4ed6\u4eec\u7684\u4e00\u4e9b\u6709\u8da3\u7684\u7406\u8bba\u7279\u6027\uff0c\u5c3d\u7ba1\u6211\u4eec\u6ca1\u6709\u8db3\u591f\u7684\u65f6\u95f4\u6765\u5b8c\u6574\u7684\u89e3\u91ca\u4ed6\u4eec\u3002 \u7279\u6027 \u5e73\u79fb\u4e0d\u53d8\uff08shift-invariant\uff09\uff1a\u6211\u4eec\u4f1a\u5728\u56fe\u50cf\u4e0a\u7684\u6bcf\u4e00\u4e2a\u70b9\u8fdb\u884c\u8fd9\u4e2a\u64cd\u4f5c \u7ebf\u6027\uff08linear\uff09\u7684\u3002\u6211\u4eec\u4f1a\u7528\u4e00\u4e2a\u50cf\u7d20\u548c\u4ed6\u7684\u90bb\u5c45\u4eec\u7684\u7ebf\u6027\u7ec4\u5408\u6765\u66ff\u4ee3\u8fd9\u4e2a\u50cf\u7d20 \u8fd9\u4e24\u4e2a\u7279\u6027\u4f7f\u5f97\u8fd9\u4e24\u4e2a\u64cd\u4f5c\u975e\u5e38\u7b80\u5355\uff1a\u5728\u6bcf\u4e2a\u5730\u65b9\u90fd\u8fdb\u884c\u4e00\u6837\u7684\u64cd\u4f5c\u603b\u662f\u66f4\u7b80\u5355\u7684\uff1b\u800c\u7ebf\u6027\u64cd\u4f5c\u603b\u662f\u6700\u7b80\u5355\u7684\u3002 \u6211\u4eec\u4f1a\u9996\u9009\u5173\u6ce8\u8fd9\u4e24\u4e2a\u64cd\u4f5c\u7684\u6700\u7b80\u5355\u7684\u7248\u672c\uff0c\u7136\u540e\u6cdb\u5316\u3002\u4e92\u76f8\u5173\u548c\u5377\u79ef\u51e0\u4e4e\u662f\u4e00\u6837\u7684\u64cd\u4f5c\uff0c","title":"\u4e92\u76f8\u5173\u4e0e\u5377\u79ef"},{"location":"cv/siamfc/","text":"\u4e13\u6709\u540d\u8bcd\u7ffb\u8bd1\u548c\u7f29\u5199 \u5728\u672c\u6587\u5f53\u4e2d\uff0c\u4e13\u6709\u540d\u8bcd\u88ab\u5982\u4e0b\u7ffb\u8bd1\u548c\u7f29\u5199\uff1a anchor \u951a\u6846 Convolution Neural Network CNN \u5377\u79ef\u795e\u7ecf\u7f51\u7edc Meta-Learning \u5143\u5b66\u4e60 Padding \u586b\u5145 Regional Proposal Network RPN \u533a\u57df\u5019\u9009\u7f51\u7edc Siamese \u5b6a\u751f Single Object Tracking SOT \u5355\u76ee\u6807\u8ddf\u8e2a Visual Object Tracking VOT SiamFC\u662f\u725b\u6d25\u5927\u5b66\u7684Luca Bertinetto\u7b49\u63d0\u51fa\u7684\u7528\u4e8e\u5355\u76ee\u6807\u8ddf\u8e2a\u7684\u7f51\u7edc\u3002 \u7b80\u4ecb # \u8ba1\u7b97\u673a\u89c6\u89c9\u4e2d\u7684\u5f88\u591a\u95ee\u9898\u90fd\u5df2\u7ecf\u5728\u4ece\u5927\u578b\u76d1\u7763\u6570\u636e\u96c6\u8bad\u7ec3\u800c\u6765\u7684\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u5f53\u4e2d\u5f97\u5230\u957f\u8db3\u7684\u8fdb\u6b65\uff0c\u4f46\u662f\u76d1\u7763\u6570\u636e\u7684\u7a00\u7f3a\u548c\u5b9e\u65f6\u64cd\u4f5c\u7684\u7ea6\u675f\u963b\u6b62\u4e86\u7b80\u5355\u7684\u5c06\u6df1\u5ea6\u5b66\u4e60\u5e94\u7528\u5230\u4ece\u6bcf\u4e2a\u89c6\u9891\u5f53\u4e2d\u5b66\u4e60\u5230\u4e00\u4e2a\u68c0\u6d4b\u5668\u3002\u6700\u8fd1\u6709\u4e00\u4e9b\u5de5\u4f5c\u65e8\u5728\u514b\u670d\u8fd9\u4e9b\u95ee\u9898\uff0c\u4ed6\u4eec\u8981\u4e48\u5e94\u7528\u4e00\u4e9b\u201c\u7c97\u6d45\u201d\u7684\u65b9\u6cd5\uff08\u6bd4\u5982 \u76f8\u5173\u8fc7\u6ee4\u5668\uff09\uff0c\u5c06\u7f51\u7edc\u7684\u5185\u90e8\u8868\u793a\u4f5c\u4e3a\u7279\u5f81\uff0c\u6216\u8005\u901a\u8fc7SGD\u6765\u5fae\u8c03\u7f51\u7edc\u7684\u591a\u4e2a\u5c42\u3002\u7136\u800c\uff0c\u4f7f\u7528\u7c97\u6d45\u7684\u65b9\u6cd5\u5e76\u6ca1\u6709\u5229\u7528\u5230\u7aef\u5230\u7aef\u8bad\u7ec3\u7684\u5168\u90e8\u4f18\u70b9\uff0c\u4f7f\u7528SGD\u7684\u65b9\u6cd5\u8fbe\u5230SOTA\u7ed3\u679c\u7684\u5747\u4e0d\u80fd\u505a\u5230\u5b9e\u65f6\u64cd\u4f5c\u3002\u672c\u6587\u4f5c\u8005\u63d0\u51fa\u4e86\u4e00\u4e2a\u65b0\u7684\u65b9\u6cd5\uff0c\u8bad\u7ec3\u4e00\u4e2a\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u6765\u5728\u6700\u521d\u7684\u79bb\u7ebf\u9636\u6bb5\u89e3\u51b3\u66f4\u666e\u904d\u7684\u76f8\u4f3c\u6027\u5b66\u4e60\u95ee\u9898\uff0c\u7136\u540e\u53ea\u9700\u5728\u8ddf\u8e2a\u8fc7\u7a0b\u4e2d\u5728\u7ebf\u8bc4\u4f30\u6b64\u529f\u80fd\u3002 \u672c\u6587\u7684\u6838\u5fc3\u8d21\u732e\u5728\u4e8e\u672c\u6587\u6240\u63d0\u51fa\u7684\u65b9\u6cd5\u53ef\u4ee5\u5728\u8fdc\u8d85\u6240\u9700\u5e27\u7387\u7684\u901f\u5ea6\u65f6\u8fbe\u5230\u6781\u5177\u7ade\u4e89\u529b\u7684\u6027\u80fd\u3002\u7279\u522b\u7684\uff0c\u672c\u6587\u4f5c\u8005\u8bad\u7ec3\u4e00\u4e2a\u5b6a\u751f\u7f51\u7edc\u6765\u5728\u4e00\u4e2a\u5927\u7684 \u641c\u7d22 \u56fe\u50cf\u5f53\u4e2d\u5b9a\u4f4d\u4e00\u4e2a \u6837\u672c \u56fe\u50cf\u3002\u53e6\u4e00\u4e2a\u8d21\u732e\u662f\u76f8\u5bf9\u4e8e\u641c\u7d22\u56fe\u50cf\u7684\u5168\u5377\u79ef\u5b6a\u751f\u67b6\u6784\uff1a\u901a\u8fc7\u53cc\u7ebf\u6027\u5c42\u6765\u8ba1\u7b97\u4e24\u4e2a\u8f93\u5165\u7684\u4e92\u76f8\u5173\u6027\uff0c\u4ece\u800c\u5b9e\u73b0\u4e86\u5bc6\u96c6\u800c\u6709\u6548\u7684\u6ed1\u7a97\u8bc4\u4f30\u3002 \u672c\u6587\u4f5c\u8005\u8ba4\u4e3a\u76f8\u4f3c\u6027\u5b66\u4e60\u65b9\u6cd5\u76f8\u5bf9\u800c\u8a00\u4e00\u76f4\u53d7\u5230\u5ffd\u7565\u3002\u56e0\u4e3a\u8ddf\u8e2a\u793e\u533a\u6ca1\u6709\u5927\u91cf\u7684\u76d1\u7763\u6570\u636e\u96c6\u3002\u4e8b\u5b9e\u4e0a\uff0c\u76f4\u5230\u8fd1\uff0c\u53ef\u7528\u7684\u6570\u636e\u96c6\u4ec5\u5305\u542b\u6570\u767e\u4e2a\u5e26\u6ce8\u91ca\u7684\u89c6\u9891\u3002\u4f46\u65f6\uff0c\u672c\u6587\u4f5c\u8005\u8ba4\u4e3a\uff0c\u89c6\u9891\u4e2d\u7528\u4e8e\u5bf9\u8c61\u68c0\u6d4b\u7684ILSVRC\u6570\u636e\u96c6\u7684\u51fa\u73b0\u4f7f\u5f97\u8bad\u7ec3\u8fd9\u79cd\u6a21\u578b\u6210\u4e3a\u53ef\u80fd\u3002\u6b64\u5916\uff0c\u4f7f\u7528\u6765\u81ea\u540c\u4e00\u57df\u7684\u89c6\u9891\u8fdb\u884c\u8bad\u7ec3\u548c\u6d4b\u8bd5\u7528\u4e8e\u8ddf\u8e2a\u7684\u6df1\u5ea6\u6a21\u578b\u5728\u516c\u5e73\u6027\u4e0a\u5b58\u5728\u4e89\u8bae\uff0c\u6700\u8fd1VOT\u59d4\u5458\u4f1a\u5df2\u7ecf\u7981\u6b62\u8fd9\u6837\u505a\u3002\u672c\u6587\u4f5c\u8005\u5c55\u793a\u4e86\u672c\u6587\u63d0\u51fa\u7684\u6a21\u578b\u53ef\u4ee5\u4eceILSVRC\u57df\u63a8\u5e7f\u5230ALOV\u3001OTB\u3001VOT\u57df\uff0c\u4ece\u800c\u53ef\u4ee5\u5c06\u8ddf\u8e2a\u57fa\u51c6\u7684\u89c6\u9891\u4fdd\u7559\u7528\u4e8e\u6d4b\u8bd5\u3002 \u7528\u4e8e\u8ddf\u8e2a\u7684\u6df1\u5ea6\u76f8\u4f3c\u6027\u5b66\u4e60 # \u5b66\u4e60\u53bb\u8ffd\u8e2a\u4efb\u610f\u5bf9\u8c61\u53ef\u4ee5\u4f7f\u7528\u76f8\u4f3c\u6027\u5b66\u4e60\u6765\u89e3\u51b3\u3002\u672c\u6587\u4f5c\u8005\u63d0\u51fa\u4e86\u5b66\u4e60\u4e00\u4e2a\u51fd\u6570 f(\\mathcal{x}, \\mathcal{z}) f(\\mathcal{x}, \\mathcal{z}) \uff0c\u5b83\u5c06\u6837\u672c\u56fe\u50cf \\mathcal{z} \\mathcal{z} \u4e0e\u76f8\u540c\u5927\u5c0f\u7684\u5019\u9009\u56fe\u50cf \\mathcal{x} \\mathcal{x} \u8fdb\u884c\u6bd4\u8f83\uff0c\u5e76\u5728\u4e24\u4e2a\u56fe\u50cf\u90fd\u63cf\u7ed8\u540c\u4e00\u5bf9\u8c61\u65f6\u8fd4\u56de\u9ad8\u5206\uff0c\u5728\u5176\u4ed6\u60c5\u51b5\u4e0b\u8fd4\u56de\u4f4e\u5206\u3002\u4e3a\u4e86\u627e\u5230\u76ee\u6807\u5728\u65b0\u56fe\u50cf\u4e2d\u7684\u4f4d\u7f6e\uff0c\u672c\u6587\u4f5c\u8005\u53ef\u4ee5\u8be6\u5c3d\u7684\u5728\u6bcf\u4e00\u4e2a\u53ef\u80fd\u7684\u4f4d\u7f6e\u8fdb\u884c\u6d4b\u8bd5\uff0c\u5e76\u9009\u62e9\u4e0e\u5bf9\u8c61\u8fc7\u53bb\u7684\u6837\u5b50\u76f8\u4f3c\u5ea6\u6700\u9ad8\u7684\u5019\u9009\u3002\u5728\u5b9e\u9a8c\u4e2d\uff0c\u672c\u6587\u4f5c\u8005\u4ec5\u9009\u7528\u5bf9\u8c61\u521d\u59cb\u7684\u6837\u5b50\u4f5c\u4e3a\u6837\u672c\u3002\u51fd\u6570 f f \u4f1a\u901a\u8fc7\u4e00\u4e2a\u7531\u6807\u6ce8\u5bf9\u8c61\u8f68\u8ff9\u7684\u89c6\u9891\u6784\u6210\u7684\u6570\u636e\u96c6\u8bad\u7ec3\u3002 \u7531\u4e8e\u5b83\u5728\u8ba1\u7b97\u673a\u89c6\u89c9\u5f53\u4e2d\u7684\u5de8\u5927\u6210\u529f\uff0c\u672c\u6587\u4f5c\u8005\u5c06\u4f1a\u4f7f\u7528\u4e00\u4e2a\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u4f5c\u4e3a\u51fd\u6570 f f \u3002\u4f7f\u7528\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u8fdb\u884c\u76f8\u4f3c\u6027\u5b66\u4e60\u901a\u5e38\u4f7f\u7528\u5b6a\u751f\u67b6\u6784\u3002\u5b6a\u751f\u7f51\u7edc\u5c06\u540c\u4e00\u4e2a\u53d8\u6362 \\varphi \\varphi \u5206\u522b\u5e94\u7528\u5728\u4e24\u4e2a\u8f93\u5165\u4e0a\uff0c\u7136\u540e\u5c06\u4ed6\u4eec\u7684\u8868\u73b0\u901a\u8fc7\u53e6\u4e00\u4e2a\u51fd\u6570 g g \u57fa\u4e8e f(\\mathcal{x},\\mathcal{z}) = g(\\varphi\\mathcal{x}, \\varphi\\mathcal{z}) f(\\mathcal{x},\\mathcal{z}) = g(\\varphi\\mathcal{x}, \\varphi\\mathcal{z}) \u7ec4\u5408\u8d77\u6765\u3002\u5f53 g g \u662f\u4e00\u4e2a\u7b80\u5355\u7684\u8ddd\u79bb\u6216\u8005\u76f8\u4f3c\u5ea6\u5ea6\u91cf\uff0c\u51fd\u6570 \\varphi \\varphi \u53ef\u4ee5\u88ab\u8ba4\u4e3a\u662f\u5d4c\u5165\u3002\u6df1\u5ea6\u5b6a\u751f\u5377\u79ef\u7f51\u7edc\u66fe\u88ab\u5e94\u7528\u4e8e\u4eba\u8138\u9a8c\u8bc1\u3001\u5173\u952e\u70b9\u63cf\u8ff0\u5176\u5b66\u4e60\u548c\u5355\u6837\u672c\u5b57\u7b26\u8bc6\u522b\u3002 \u5168\u5377\u79ef\u5b6a\u751f\u67b6\u6784 # \u672c\u6587\u4f5c\u8005\u63d0\u51fa\u4e86\u4e00\u4e2a\u6709\u5173\u5019\u9009\u56fe\u50cf \\mathcal{x} \\mathcal{x} \u7684\u5168\u5377\u79ef\u7684\u5b6a\u751f\u67b6\u6784\u3002\u672c\u6587\u4f5c\u8005\u5c06\u4e00\u4e2a\u6ca1\u6709\u5e73\u79fb\u7684\u65b9\u6cd5\u79f0\u4f5c\u5168\u5377\u79ef\u3002\u66f4\u51c6\u786e\u5730\u8bf4\uff0c\u5bf9\u4e8e\u5e73\u79fb\u64cd\u4f5c L_\\tau L_\\tau \uff0c (L_{\\tau} x)[u]=x[u - \\tau] (L_{\\tau} x)[u]=x[u - \\tau] \u3002\u5bf9\u4e8e\u4efb\u4f55\u5e73\u79fb \\tau \\tau \uff0c\u5982\u679c\u5982\u679c h(L_{k\\tau}x)=L_{\\tau}h(x) h(L_{k\\tau}x)=L_{\\tau}h(x) \u6210\u7acb\uff0c\u5219\u6211\u4eec\u628a\u5c06\u4fe1\u53f7\u6620\u5c04\u5230\u5176\u4ed6\u4fe1\u53f7\u7684\u51fd\u6570 h h \u79f0\u505a\u6b65\u957f\u4e3a k k \u7684\u5168\u5377\u79ef\u3002 \u4f7f\u7528\u5168\u5377\u79ef\u7f51\u7edc\u7684\u4f18\u70b9\u5728\u4e8e\uff0c\u6211\u4eec\u53ef\u4ee5\u63d0\u4f9b\u66f4\u5927\u7684\u641c\u7d22\u56fe\u50cf\u4f5c\u4e3a\u8f93\u5165\uff0c\u4e14\u4ed6\u4f1a\u5728\u4e00\u6b21\u8bc4\u4f30\u4e2d\u8ba1\u7b97\u5bc6\u96c6\u7f51\u683c\u4e0a\u6240\u6709\u5df2\u5e73\u79fb\u7684\u5b50\u7a97\u53e3\u7684\u76f8\u4f3c\u5ea6\u3002\u4e3a\u6b64\uff0c\u672c\u6587\u4f5c\u8005\u4f7f\u7528\u4e86\u5377\u79ef\u5d4c\u5165\u51fd\u6570 \\varphi \\varphi \uff0c\u5e76\u4f7f\u7528\u4e92\u76f8\u5173\u5c42\u5c06\u751f\u6210\u7684\u7279\u5f81\u56fe\u8fdb\u884c\u7ec4\u5408\u3002 f(z, x) = \\varphi(z) * \\varphi(x) + b\\mathbb{1} f(z, x) = \\varphi(z) * \\varphi(x) + b\\mathbb{1} \u5176\u4e2d\uff0c b\\mathbb{1} b\\mathbb{1} \u8868\u793a\u4ece\u4fe1\u53f7 \u635f\u5931\u51fd\u6570 #","title":"SiamRPN"},{"location":"cv/siamfc/#_1","text":"\u8ba1\u7b97\u673a\u89c6\u89c9\u4e2d\u7684\u5f88\u591a\u95ee\u9898\u90fd\u5df2\u7ecf\u5728\u4ece\u5927\u578b\u76d1\u7763\u6570\u636e\u96c6\u8bad\u7ec3\u800c\u6765\u7684\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u5f53\u4e2d\u5f97\u5230\u957f\u8db3\u7684\u8fdb\u6b65\uff0c\u4f46\u662f\u76d1\u7763\u6570\u636e\u7684\u7a00\u7f3a\u548c\u5b9e\u65f6\u64cd\u4f5c\u7684\u7ea6\u675f\u963b\u6b62\u4e86\u7b80\u5355\u7684\u5c06\u6df1\u5ea6\u5b66\u4e60\u5e94\u7528\u5230\u4ece\u6bcf\u4e2a\u89c6\u9891\u5f53\u4e2d\u5b66\u4e60\u5230\u4e00\u4e2a\u68c0\u6d4b\u5668\u3002\u6700\u8fd1\u6709\u4e00\u4e9b\u5de5\u4f5c\u65e8\u5728\u514b\u670d\u8fd9\u4e9b\u95ee\u9898\uff0c\u4ed6\u4eec\u8981\u4e48\u5e94\u7528\u4e00\u4e9b\u201c\u7c97\u6d45\u201d\u7684\u65b9\u6cd5\uff08\u6bd4\u5982 \u76f8\u5173\u8fc7\u6ee4\u5668\uff09\uff0c\u5c06\u7f51\u7edc\u7684\u5185\u90e8\u8868\u793a\u4f5c\u4e3a\u7279\u5f81\uff0c\u6216\u8005\u901a\u8fc7SGD\u6765\u5fae\u8c03\u7f51\u7edc\u7684\u591a\u4e2a\u5c42\u3002\u7136\u800c\uff0c\u4f7f\u7528\u7c97\u6d45\u7684\u65b9\u6cd5\u5e76\u6ca1\u6709\u5229\u7528\u5230\u7aef\u5230\u7aef\u8bad\u7ec3\u7684\u5168\u90e8\u4f18\u70b9\uff0c\u4f7f\u7528SGD\u7684\u65b9\u6cd5\u8fbe\u5230SOTA\u7ed3\u679c\u7684\u5747\u4e0d\u80fd\u505a\u5230\u5b9e\u65f6\u64cd\u4f5c\u3002\u672c\u6587\u4f5c\u8005\u63d0\u51fa\u4e86\u4e00\u4e2a\u65b0\u7684\u65b9\u6cd5\uff0c\u8bad\u7ec3\u4e00\u4e2a\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u6765\u5728\u6700\u521d\u7684\u79bb\u7ebf\u9636\u6bb5\u89e3\u51b3\u66f4\u666e\u904d\u7684\u76f8\u4f3c\u6027\u5b66\u4e60\u95ee\u9898\uff0c\u7136\u540e\u53ea\u9700\u5728\u8ddf\u8e2a\u8fc7\u7a0b\u4e2d\u5728\u7ebf\u8bc4\u4f30\u6b64\u529f\u80fd\u3002 \u672c\u6587\u7684\u6838\u5fc3\u8d21\u732e\u5728\u4e8e\u672c\u6587\u6240\u63d0\u51fa\u7684\u65b9\u6cd5\u53ef\u4ee5\u5728\u8fdc\u8d85\u6240\u9700\u5e27\u7387\u7684\u901f\u5ea6\u65f6\u8fbe\u5230\u6781\u5177\u7ade\u4e89\u529b\u7684\u6027\u80fd\u3002\u7279\u522b\u7684\uff0c\u672c\u6587\u4f5c\u8005\u8bad\u7ec3\u4e00\u4e2a\u5b6a\u751f\u7f51\u7edc\u6765\u5728\u4e00\u4e2a\u5927\u7684 \u641c\u7d22 \u56fe\u50cf\u5f53\u4e2d\u5b9a\u4f4d\u4e00\u4e2a \u6837\u672c \u56fe\u50cf\u3002\u53e6\u4e00\u4e2a\u8d21\u732e\u662f\u76f8\u5bf9\u4e8e\u641c\u7d22\u56fe\u50cf\u7684\u5168\u5377\u79ef\u5b6a\u751f\u67b6\u6784\uff1a\u901a\u8fc7\u53cc\u7ebf\u6027\u5c42\u6765\u8ba1\u7b97\u4e24\u4e2a\u8f93\u5165\u7684\u4e92\u76f8\u5173\u6027\uff0c\u4ece\u800c\u5b9e\u73b0\u4e86\u5bc6\u96c6\u800c\u6709\u6548\u7684\u6ed1\u7a97\u8bc4\u4f30\u3002 \u672c\u6587\u4f5c\u8005\u8ba4\u4e3a\u76f8\u4f3c\u6027\u5b66\u4e60\u65b9\u6cd5\u76f8\u5bf9\u800c\u8a00\u4e00\u76f4\u53d7\u5230\u5ffd\u7565\u3002\u56e0\u4e3a\u8ddf\u8e2a\u793e\u533a\u6ca1\u6709\u5927\u91cf\u7684\u76d1\u7763\u6570\u636e\u96c6\u3002\u4e8b\u5b9e\u4e0a\uff0c\u76f4\u5230\u8fd1\uff0c\u53ef\u7528\u7684\u6570\u636e\u96c6\u4ec5\u5305\u542b\u6570\u767e\u4e2a\u5e26\u6ce8\u91ca\u7684\u89c6\u9891\u3002\u4f46\u65f6\uff0c\u672c\u6587\u4f5c\u8005\u8ba4\u4e3a\uff0c\u89c6\u9891\u4e2d\u7528\u4e8e\u5bf9\u8c61\u68c0\u6d4b\u7684ILSVRC\u6570\u636e\u96c6\u7684\u51fa\u73b0\u4f7f\u5f97\u8bad\u7ec3\u8fd9\u79cd\u6a21\u578b\u6210\u4e3a\u53ef\u80fd\u3002\u6b64\u5916\uff0c\u4f7f\u7528\u6765\u81ea\u540c\u4e00\u57df\u7684\u89c6\u9891\u8fdb\u884c\u8bad\u7ec3\u548c\u6d4b\u8bd5\u7528\u4e8e\u8ddf\u8e2a\u7684\u6df1\u5ea6\u6a21\u578b\u5728\u516c\u5e73\u6027\u4e0a\u5b58\u5728\u4e89\u8bae\uff0c\u6700\u8fd1VOT\u59d4\u5458\u4f1a\u5df2\u7ecf\u7981\u6b62\u8fd9\u6837\u505a\u3002\u672c\u6587\u4f5c\u8005\u5c55\u793a\u4e86\u672c\u6587\u63d0\u51fa\u7684\u6a21\u578b\u53ef\u4ee5\u4eceILSVRC\u57df\u63a8\u5e7f\u5230ALOV\u3001OTB\u3001VOT\u57df\uff0c\u4ece\u800c\u53ef\u4ee5\u5c06\u8ddf\u8e2a\u57fa\u51c6\u7684\u89c6\u9891\u4fdd\u7559\u7528\u4e8e\u6d4b\u8bd5\u3002","title":"\u7b80\u4ecb"},{"location":"cv/siamfc/#_2","text":"\u5b66\u4e60\u53bb\u8ffd\u8e2a\u4efb\u610f\u5bf9\u8c61\u53ef\u4ee5\u4f7f\u7528\u76f8\u4f3c\u6027\u5b66\u4e60\u6765\u89e3\u51b3\u3002\u672c\u6587\u4f5c\u8005\u63d0\u51fa\u4e86\u5b66\u4e60\u4e00\u4e2a\u51fd\u6570 f(\\mathcal{x}, \\mathcal{z}) f(\\mathcal{x}, \\mathcal{z}) \uff0c\u5b83\u5c06\u6837\u672c\u56fe\u50cf \\mathcal{z} \\mathcal{z} \u4e0e\u76f8\u540c\u5927\u5c0f\u7684\u5019\u9009\u56fe\u50cf \\mathcal{x} \\mathcal{x} \u8fdb\u884c\u6bd4\u8f83\uff0c\u5e76\u5728\u4e24\u4e2a\u56fe\u50cf\u90fd\u63cf\u7ed8\u540c\u4e00\u5bf9\u8c61\u65f6\u8fd4\u56de\u9ad8\u5206\uff0c\u5728\u5176\u4ed6\u60c5\u51b5\u4e0b\u8fd4\u56de\u4f4e\u5206\u3002\u4e3a\u4e86\u627e\u5230\u76ee\u6807\u5728\u65b0\u56fe\u50cf\u4e2d\u7684\u4f4d\u7f6e\uff0c\u672c\u6587\u4f5c\u8005\u53ef\u4ee5\u8be6\u5c3d\u7684\u5728\u6bcf\u4e00\u4e2a\u53ef\u80fd\u7684\u4f4d\u7f6e\u8fdb\u884c\u6d4b\u8bd5\uff0c\u5e76\u9009\u62e9\u4e0e\u5bf9\u8c61\u8fc7\u53bb\u7684\u6837\u5b50\u76f8\u4f3c\u5ea6\u6700\u9ad8\u7684\u5019\u9009\u3002\u5728\u5b9e\u9a8c\u4e2d\uff0c\u672c\u6587\u4f5c\u8005\u4ec5\u9009\u7528\u5bf9\u8c61\u521d\u59cb\u7684\u6837\u5b50\u4f5c\u4e3a\u6837\u672c\u3002\u51fd\u6570 f f \u4f1a\u901a\u8fc7\u4e00\u4e2a\u7531\u6807\u6ce8\u5bf9\u8c61\u8f68\u8ff9\u7684\u89c6\u9891\u6784\u6210\u7684\u6570\u636e\u96c6\u8bad\u7ec3\u3002 \u7531\u4e8e\u5b83\u5728\u8ba1\u7b97\u673a\u89c6\u89c9\u5f53\u4e2d\u7684\u5de8\u5927\u6210\u529f\uff0c\u672c\u6587\u4f5c\u8005\u5c06\u4f1a\u4f7f\u7528\u4e00\u4e2a\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u4f5c\u4e3a\u51fd\u6570 f f \u3002\u4f7f\u7528\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u8fdb\u884c\u76f8\u4f3c\u6027\u5b66\u4e60\u901a\u5e38\u4f7f\u7528\u5b6a\u751f\u67b6\u6784\u3002\u5b6a\u751f\u7f51\u7edc\u5c06\u540c\u4e00\u4e2a\u53d8\u6362 \\varphi \\varphi \u5206\u522b\u5e94\u7528\u5728\u4e24\u4e2a\u8f93\u5165\u4e0a\uff0c\u7136\u540e\u5c06\u4ed6\u4eec\u7684\u8868\u73b0\u901a\u8fc7\u53e6\u4e00\u4e2a\u51fd\u6570 g g \u57fa\u4e8e f(\\mathcal{x},\\mathcal{z}) = g(\\varphi\\mathcal{x}, \\varphi\\mathcal{z}) f(\\mathcal{x},\\mathcal{z}) = g(\\varphi\\mathcal{x}, \\varphi\\mathcal{z}) \u7ec4\u5408\u8d77\u6765\u3002\u5f53 g g \u662f\u4e00\u4e2a\u7b80\u5355\u7684\u8ddd\u79bb\u6216\u8005\u76f8\u4f3c\u5ea6\u5ea6\u91cf\uff0c\u51fd\u6570 \\varphi \\varphi \u53ef\u4ee5\u88ab\u8ba4\u4e3a\u662f\u5d4c\u5165\u3002\u6df1\u5ea6\u5b6a\u751f\u5377\u79ef\u7f51\u7edc\u66fe\u88ab\u5e94\u7528\u4e8e\u4eba\u8138\u9a8c\u8bc1\u3001\u5173\u952e\u70b9\u63cf\u8ff0\u5176\u5b66\u4e60\u548c\u5355\u6837\u672c\u5b57\u7b26\u8bc6\u522b\u3002","title":"\u7528\u4e8e\u8ddf\u8e2a\u7684\u6df1\u5ea6\u76f8\u4f3c\u6027\u5b66\u4e60"},{"location":"cv/siamfc/#_3","text":"\u672c\u6587\u4f5c\u8005\u63d0\u51fa\u4e86\u4e00\u4e2a\u6709\u5173\u5019\u9009\u56fe\u50cf \\mathcal{x} \\mathcal{x} \u7684\u5168\u5377\u79ef\u7684\u5b6a\u751f\u67b6\u6784\u3002\u672c\u6587\u4f5c\u8005\u5c06\u4e00\u4e2a\u6ca1\u6709\u5e73\u79fb\u7684\u65b9\u6cd5\u79f0\u4f5c\u5168\u5377\u79ef\u3002\u66f4\u51c6\u786e\u5730\u8bf4\uff0c\u5bf9\u4e8e\u5e73\u79fb\u64cd\u4f5c L_\\tau L_\\tau \uff0c (L_{\\tau} x)[u]=x[u - \\tau] (L_{\\tau} x)[u]=x[u - \\tau] \u3002\u5bf9\u4e8e\u4efb\u4f55\u5e73\u79fb \\tau \\tau \uff0c\u5982\u679c\u5982\u679c h(L_{k\\tau}x)=L_{\\tau}h(x) h(L_{k\\tau}x)=L_{\\tau}h(x) \u6210\u7acb\uff0c\u5219\u6211\u4eec\u628a\u5c06\u4fe1\u53f7\u6620\u5c04\u5230\u5176\u4ed6\u4fe1\u53f7\u7684\u51fd\u6570 h h \u79f0\u505a\u6b65\u957f\u4e3a k k \u7684\u5168\u5377\u79ef\u3002 \u4f7f\u7528\u5168\u5377\u79ef\u7f51\u7edc\u7684\u4f18\u70b9\u5728\u4e8e\uff0c\u6211\u4eec\u53ef\u4ee5\u63d0\u4f9b\u66f4\u5927\u7684\u641c\u7d22\u56fe\u50cf\u4f5c\u4e3a\u8f93\u5165\uff0c\u4e14\u4ed6\u4f1a\u5728\u4e00\u6b21\u8bc4\u4f30\u4e2d\u8ba1\u7b97\u5bc6\u96c6\u7f51\u683c\u4e0a\u6240\u6709\u5df2\u5e73\u79fb\u7684\u5b50\u7a97\u53e3\u7684\u76f8\u4f3c\u5ea6\u3002\u4e3a\u6b64\uff0c\u672c\u6587\u4f5c\u8005\u4f7f\u7528\u4e86\u5377\u79ef\u5d4c\u5165\u51fd\u6570 \\varphi \\varphi \uff0c\u5e76\u4f7f\u7528\u4e92\u76f8\u5173\u5c42\u5c06\u751f\u6210\u7684\u7279\u5f81\u56fe\u8fdb\u884c\u7ec4\u5408\u3002 f(z, x) = \\varphi(z) * \\varphi(x) + b\\mathbb{1} f(z, x) = \\varphi(z) * \\varphi(x) + b\\mathbb{1} \u5176\u4e2d\uff0c b\\mathbb{1} b\\mathbb{1} \u8868\u793a\u4ece\u4fe1\u53f7","title":"\u5168\u5377\u79ef\u5b6a\u751f\u67b6\u6784"},{"location":"cv/siamfc/#_4","text":"","title":"\u635f\u5931\u51fd\u6570"},{"location":"cv/variant/","text":"\u524d\u8a00 \u6700\u8fd1\u5728\u8bfb\u8bba\u6587\u7684\u8fc7\u7a0b\u4e2d\u9605\u8bfb\u4e86\u4e0d\u5c11\u6750\u6599\uff0c\u5374\u60ca\u8bb6\u7684\u53d1\u73b0\u751a\u81f3\u6709\u4eba\u8ba4\u4e3a\u5e73\u79fb\u540c\u53d8\u662f\u5e73\u79fb\u4e0d\u53d8\u7684\u53cd\u4e49\u8bcd\u3002\u7279\u64b0\u5199\u6b64\u6587\u3002 \u53d8\u6362 # \u5e73\u79fb\uff08Translation\uff09 \u5e73\u79fb\uff08Translation\uff09\u4e4d\u770b\u4e0a\u53bb\u6216\u8bb8\u4f1a\u6709\u4e9b\u4ee4\u4eba\u56f0\u60d1\u3002\u4ed6\u6307\u7684\u5e76\u4e0d\u662f\u7ffb\u8bd1\uff08\u4f60\u4e0d\u662f\u5728\u505aNLP\uff09\u3002\u4e8b\u5b9e\u4e0a\uff0c\u5b83\u662f\u4e00\u4e2a\u4ece\u51e0\u4f55\u5b66\u5f53\u4e2d\u501f\u6765\u7684\u5355\u8bcd\uff0c\u8fd9\u91cc\u6307\u7684\u662f\u5c06\u6bcf\u4e00\u4e2a\u50cf\u7d20\u90fd\u5411\u540c\u4e00\u65b9\u5411\u79fb\u52a8\u540c\u4e00\u957f\u5ea6\uff0c\u4e5f\u5373\u5e73\u79fb\u3002 \u4e0d\u53d8\u6027\u548c\u540c\u53d8\u6027 # \u4e0d\u53d8\u6027 \u82e5\u5bf9\u4e8e\u8f93\u5165 a a \u4e0e\u8f93\u5165 a^* a^* \uff0c\u7cfb\u7edf\u4ea7\u751f\u5b8c\u5168\u4e00\u81f4\u7684\u8f93\u51fa\uff0c\u5219\u6211\u4eec\u79f0\u8fd9\u4e2a\u7cfb\u7edf\u662f\u5e73\u79fb\u4e0d\u53d8\u7684\u3002 \u540c\u53d8\u6027 \u82e5\u5bf9\u4e8e\u8f93\u5165 a a \u4e0e\u8f93\u5165 a^* a^* \uff0c\u7cfb\u7edf\u5de5\u4f5c\u7684\u4e00\u6837\u597d\uff0c\u4f46\u4ed6\u5bf9\u8f93\u5165\u7684\u53d8\u6362\u4ea7\u751f\u5bf9\u5e94\u7684\u54cd\u5e94\uff0c\u5219\u6211\u4eec\u79f0\u8fd9\u4e2a\u7cfb\u7edf\u662f\u5e73\u79fb\u540c\u53d8\u7684\u3002 \u4e0d\u53d8\u6027\u548c\u540c\u53d8\u6027 \u4e0d\u53d8\u6027\u548c\u540c\u53d8\u6027\u5e76 \u4e0d\u662f \u4e00\u5bf9\u4e92\u4e3a\u9006\u7684\u5355\u8bcd\u3002\u4e5f\u5373\uff0c\u4e00\u4e2a\u64cd\u4f5c\u53ef\u80fd\u65e2\u4e0d\u662f\u4e0d\u53d8\u7684\uff0c\u4e5f\u4e0d\u662f\u540c\u53d8\u7684\u3002 \u4e3e\u4f8b\u6765\u8bf4\uff0c\u5bf9\u4e8e\u4eba\u8138\u8bc6\u522b\u4efb\u52a1 \\mathcal{T} \\mathcal{T} \uff0c\u5e73\u79fb\u4e0d\u53d8\u7684\u795e\u7ecf\u7f51\u7edc\u5bf9\u542b\u6709\u4eba\u8138\u7684\u56fe\u7247\u90fd\u8f93\u51fa True True \uff0c\u5e73\u79fb\u540c\u53d8\u7684\u795e\u7ecf\u7f51\u7edc\u5219\u4f1a\u6839\u636e\u4eba\u8138\u7684\u4f4d\u7f6e\u8f93\u51fa (True, Position) (True, Position) \u3002 \u5f88\u5bb9\u6613\u5373\u80fd\u770b\u51fa\u540c\u53d8\u7684\u795e\u7ecf\u7f51\u7edc\u53ef\u4ee5\u8f7b\u6613\u8f6c\u6362\u4e3a\u4e0d\u53d8\u7684\u795e\u7ecf\u7f51\u7edc\u2013\u53ea\u8981\u4e22\u6389\u4f4d\u7f6e\u4fe1\u606f\u5373\u53ef\u3002\u56e0\u6b64\uff0c\u6709\u4e9b\u4eba\u5e76\u4e0d\u80fd\u533a\u5206\u4ed6\u4eec\u3002 \u4e25\u683c\u4e0d\u53d8\u6027 #","title":"\u53d8\u5316"},{"location":"cv/variant/#_1","text":"\u5e73\u79fb\uff08Translation\uff09 \u5e73\u79fb\uff08Translation\uff09\u4e4d\u770b\u4e0a\u53bb\u6216\u8bb8\u4f1a\u6709\u4e9b\u4ee4\u4eba\u56f0\u60d1\u3002\u4ed6\u6307\u7684\u5e76\u4e0d\u662f\u7ffb\u8bd1\uff08\u4f60\u4e0d\u662f\u5728\u505aNLP\uff09\u3002\u4e8b\u5b9e\u4e0a\uff0c\u5b83\u662f\u4e00\u4e2a\u4ece\u51e0\u4f55\u5b66\u5f53\u4e2d\u501f\u6765\u7684\u5355\u8bcd\uff0c\u8fd9\u91cc\u6307\u7684\u662f\u5c06\u6bcf\u4e00\u4e2a\u50cf\u7d20\u90fd\u5411\u540c\u4e00\u65b9\u5411\u79fb\u52a8\u540c\u4e00\u957f\u5ea6\uff0c\u4e5f\u5373\u5e73\u79fb\u3002","title":"\u53d8\u6362"},{"location":"cv/variant/#_2","text":"\u4e0d\u53d8\u6027 \u82e5\u5bf9\u4e8e\u8f93\u5165 a a \u4e0e\u8f93\u5165 a^* a^* \uff0c\u7cfb\u7edf\u4ea7\u751f\u5b8c\u5168\u4e00\u81f4\u7684\u8f93\u51fa\uff0c\u5219\u6211\u4eec\u79f0\u8fd9\u4e2a\u7cfb\u7edf\u662f\u5e73\u79fb\u4e0d\u53d8\u7684\u3002 \u540c\u53d8\u6027 \u82e5\u5bf9\u4e8e\u8f93\u5165 a a \u4e0e\u8f93\u5165 a^* a^* \uff0c\u7cfb\u7edf\u5de5\u4f5c\u7684\u4e00\u6837\u597d\uff0c\u4f46\u4ed6\u5bf9\u8f93\u5165\u7684\u53d8\u6362\u4ea7\u751f\u5bf9\u5e94\u7684\u54cd\u5e94\uff0c\u5219\u6211\u4eec\u79f0\u8fd9\u4e2a\u7cfb\u7edf\u662f\u5e73\u79fb\u540c\u53d8\u7684\u3002 \u4e0d\u53d8\u6027\u548c\u540c\u53d8\u6027 \u4e0d\u53d8\u6027\u548c\u540c\u53d8\u6027\u5e76 \u4e0d\u662f \u4e00\u5bf9\u4e92\u4e3a\u9006\u7684\u5355\u8bcd\u3002\u4e5f\u5373\uff0c\u4e00\u4e2a\u64cd\u4f5c\u53ef\u80fd\u65e2\u4e0d\u662f\u4e0d\u53d8\u7684\uff0c\u4e5f\u4e0d\u662f\u540c\u53d8\u7684\u3002 \u4e3e\u4f8b\u6765\u8bf4\uff0c\u5bf9\u4e8e\u4eba\u8138\u8bc6\u522b\u4efb\u52a1 \\mathcal{T} \\mathcal{T} \uff0c\u5e73\u79fb\u4e0d\u53d8\u7684\u795e\u7ecf\u7f51\u7edc\u5bf9\u542b\u6709\u4eba\u8138\u7684\u56fe\u7247\u90fd\u8f93\u51fa True True \uff0c\u5e73\u79fb\u540c\u53d8\u7684\u795e\u7ecf\u7f51\u7edc\u5219\u4f1a\u6839\u636e\u4eba\u8138\u7684\u4f4d\u7f6e\u8f93\u51fa (True, Position) (True, Position) \u3002 \u5f88\u5bb9\u6613\u5373\u80fd\u770b\u51fa\u540c\u53d8\u7684\u795e\u7ecf\u7f51\u7edc\u53ef\u4ee5\u8f7b\u6613\u8f6c\u6362\u4e3a\u4e0d\u53d8\u7684\u795e\u7ecf\u7f51\u7edc\u2013\u53ea\u8981\u4e22\u6389\u4f4d\u7f6e\u4fe1\u606f\u5373\u53ef\u3002\u56e0\u6b64\uff0c\u6709\u4e9b\u4eba\u5e76\u4e0d\u80fd\u533a\u5206\u4ed6\u4eec\u3002","title":"\u4e0d\u53d8\u6027\u548c\u540c\u53d8\u6027"},{"location":"cv/variant/#_3","text":"","title":"\u4e25\u683c\u4e0d\u53d8\u6027"},{"location":"cv/ssl/SimCLR/","text":"SimCLR\u901a\u8fc7\u4f7f\u7528\u5bf9\u6bd4\u5b66\u4e60\u5728ImageNet\u4e0a\u8fbe\u5230\u4e8669.3%\u7684\u7cbe\u5ea6\u3002 \u52a8\u673a # \u5b66\u4e60\u6709\u6548\u7684\u89c6\u89c9\u8868\u8fbe\u800c\u65e0\u9700\u4eba\u7c7b\u76d1\u7763\u662f\u4e00\u4e2a\u957f\u671f\u5b58\u5728\u7684\u95ee\u9898\u3002\u4e3b\u6d41\u65b9\u6cd5\u901a\u5e38\u53ef\u88ab\u5f52\u7c7b\u4e3a\u4e24\u79cd\uff1a\u751f\u6210\u7c7b\u548c\u5224\u522b\u7c7b\u3002 \u751f\u6210\u65b9\u6cd5\u5b66\u4e60\u5728\u8f93\u5165\u7a7a\u95f4\u4e2d\u751f\u6210\u6216\u5efa\u6a21\u50cf\u7d20\u3002\u7136\u800c\uff0c\u50cf\u7d20\u7ea7\u751f\u6210\u975e\u5e38\u7684\u8ba1\u7b97\u6602\u8d35\uff0c\u5e76\u4e14\u5bf9\u4e8e\u8868\u8fbe\u5b66\u4e60\u6765\u8bf4\u4e5f\u53ef\u80fd\u6709\u4e9b\u8fc7\u4e86\u3002 \u5224\u522b\u65b9\u6cd5\u4f7f\u7528\u7c7b\u4f3c\u4e8e\u76d1\u7763\u5b66\u4e60\u4e2d\u7684\u76ee\u6807\u51fd\u6570\u6765\u5b66\u4e60\u8868\u8fbe\uff0c\u533a\u522b\u5728\u4e8e\u4ed6\u4eec\u4f7f\u7528\u524d\u7f6e\u4efb\u52a1\u6765\u8bad\u7ec3\u7f51\u7edc\uff0c\u800c\u8f93\u5165\u548c\u6807\u7b7e\u5747\u884d\u751f\u81ea\u65e0\u6807\u7b7e\u6570\u636e\u96c6\u3002\u8bb8\u591a\u8fd9\u4e9b\u65b9\u6cd5\u90fd\u4f9d\u8d56\u542f\u53d1\u5f0f\u65b9\u6cd5\u4ee5\u8bbe\u8ba1\u524d\u7f6e\u4efb\u52a1\uff0c\u8fd9\u53ef\u80fd\u4f1a\u9650\u5236\u6240\u5b66\u8868\u8fbe\u7684\u901a\u7528\u6027\u3002 \u8fd1\u6765\uff0c\u57fa\u4e8e\u5728\u9690\u7a7a\u95f4\u8fdb\u884c\u5bf9\u6bd4\u5b66\u4e60\u7684\u5224\u522b\u65b9\u6cd5\u8868\u73b0\u51fa\u4e86\u6781\u597d\u7684\u524d\u666f\uff0c\u8fbe\u5230\u4e86SOTA\u7ed3\u679c\u3002 \u8d21\u732e # \u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u5bf9\u6bd4\u5b66\u4e60\u7684\u7b80\u5355\u7684\u6846\u67b6\u3002\u4ed6\u65e0\u9700\u7279\u6b8a\u7684\u67b6\u6784\uff0c\u4e5f\u4e0d\u9700\u8981\u5185\u5b58\u94f6\u884c\u3002 \u591a\u4e2a\u6570\u636e\u589e\u5f3a\u7684\u7ec4\u5408\u5bf9\u4e8e\u5b9a\u4e49\u4ea7\u751f\u6709\u6548\u8868\u8fbe\u7684\u9884\u6d4b\u4efb\u52a1\u6765\u8bf4\u81f3\u5173\u91cd\u8981\u3002\u4e0e\u76d1\u7763\u5b66\u4e60\u76f8\u6bd4\uff0c\u65e0\u76d1\u7763\u5b66\u4e60\u4ece\u6570\u636e\u589e\u5f3a\u4e2d\u83b7\u5f97\u7684\u6536\u76ca\u66f4\u5927\u3002 \u5728\u8868\u8fbe\u4e0e\u5bf9\u6bd4\u635f\u5931\u4e4b\u95f4\u589e\u52a0\u4e00\u4e2a\u79d1\u5b66\u7cfb\u7684\u975e\u7ebf\u6027\u53d8\u6362\u53ef\u4ee5\u5f88\u5927\u7a0b\u5ea6\u4e0a\u63d0\u9ad8\u5b66\u5230\u7684\u8868\u8fbe\u7684\u8d28\u91cf\u3002 \u4f7f\u7528\u5bf9\u6bd4\u4ea4\u53c9\u71b5\u635f\u5931\u51fd\u6570\u7684\u8868\u8fbe\u5b66\u4e60\u53ef\u4ee5\u4ece\u5f52\u4e00\u5316\u7684\u5d4c\u5165\u548c\u5bf9\u6e29\u5ea6\u53c2\u6570\u7684\u6070\u5f53\u8c03\u6574\u4e2d\u53d7\u76ca\u3002 \u76f8\u8f83\u4e8e\u76d1\u7763\u5b66\u4e60\uff0c\u5bf9\u6bd4\u5b66\u4e60\u53d7\u76ca\u4e8e\u66f4\u5927\u7684batch size\u4e0e\u66f4\u957f\u7684\u8bad\u7ec3\u3002\u4e0e\u76d1\u7763\u5b66\u4e60\u7c7b\u4f3c\uff0c\u5bf9\u6bd4\u5b66\u4e60\u53d7\u76ca\u4e8e\u66f4\u6df1\u66f4\u5bbd\u7684\u7f51\u7edc\u3002 \u65b9\u6cd5 # \u6846\u67b6 # \u672c\u6587\u4ece\u9690\u7a7a\u95f4\u7684\u5bf9\u6bd4\u635f\u5931\u6765\u6700\u5927\u5316\u540c\u4e00\u6570\u636e\u6837\u672c\u7684\u4e0d\u540c\u589e\u5f3a\u89c6\u56fe\u7684\u4e00\u81f4\u6027\u4ee5\u5b66\u4e60\u8868\u8fbe\u3002\u672c\u6846\u67b6\u7531\u56db\u4e2a\u4e3b\u8981\u90e8\u5206\u6784\u6210\u3002 \u4e00\u4e2a\u968f\u673a \u6570\u636e\u589e\u5f3a \u6a21\u5757\uff0c\u5bf9\u4efb\u4e00\u7ed9\u5b9a\u6570\u636e\u6837\u672c\u4ea7\u751f\u4e24\u4e2a\u76f8\u5173\u7684\u89c6\u56fe\uff0c\u8868\u793a\u4e3a \\tilde{x}_i \\tilde{x}_i \u548c \\tilde{x}_j \\tilde{x}_j \uff0c\u6211\u4eec\u5c06\u5176\u79f0\u4e3a\u6b63\u6837\u672c\u5bf9\u3002\u5728\u672c\u5de5\u4f5c\u4e2d\uff0c \u6211\u4eec\u987a\u5e8f\u7684\u5e94\u7528\u4e09\u4e2a\u7b80\u5355\u7684\u589e\u5f3a\uff1a\u968f\u5373\u88c1\u526a\uff08\u955c\u50cf\uff09\u5e76\u5c06\u5176\u7f29\u653e\u56de\u539f\u59cb\u5927\u5c0f\u3001\u968f\u673a\u8272\u5f69\u5931\u771f\u3001\u968f\u673a\u9ad8\u65af\u6a21\u7cca\u3002 \u5176\u4e2d\uff0c\u88c1\u526a\u548c\u989c\u8272\u5931\u771f\u7684\u7ec4\u5408\u5bf9\u6027\u80fd\u6709\u81f3\u5173\u91cd\u8981\u7684\u5f71\u54cd\u3002 \u4e00\u4e2a\u795e\u7ecf\u7f51\u7edc \u57fa\u7840\u7f16\u7801\u5668 f(\\cdot) f(\\cdot) \uff0c\u4ece\u589e\u5f3a\u540e\u7684\u6570\u636e\u6837\u672c\u4e2d\u63d0\u53d6\u51fa\u8868\u8fbe\u5411\u91cf\u3002\u672c\u6587\u7684\u6846\u67b6\u5141\u8bb8\u4f7f\u7528\u591a\u79cd\u7f51\u7edc\u7ed3\u6784\u800c\u6ca1\u6709\u9650\u5236\u3002\u672c\u6587\u51fa\u4e8e\u7b80\u5355\u7684\u8003\u91cf\u4f7f\u7528\u4e86\u5e7f\u6cdb\u4f7f\u7528\u7684ResNet\u6765\u83b7\u53d6 \\mathbf{h}_i = f(\\tilde{x}_i) = \\mathrm{ResNet}(\\tilde{x}_i) \\mathbf{h}_i = f(\\tilde{x}_i) = \\mathrm{ResNet}(\\tilde{x}_i) \uff0c\u5176\u4e2d \\mathbf{h}_i \\in \\mathbb{R}^d \\mathbf{h}_i \\in \\mathbb{R}^d \u662f\u5e73\u5747\u6c60\u5316\u5c42\u7684\u8f93\u51fa\u3002 \u4e00\u4e2a\u5c0f\u7684\u795e\u7ecf\u7f51\u7edc \u6620\u5c04\u5934 g(\\cdot) g(\\cdot) \uff0c\u5c06\u8868\u8fbe\u6620\u5c04\u5230\u5bf9\u6bd4\u635f\u5931\u88ab\u5e94\u7528\u7684\u7a7a\u95f4\u4e0a\u3002\u672c\u6587\u4f7f\u7528\u4e00\u4e2a\u5177\u6709\u4e00\u4e2a\u9690\u85cf\u5c42\u7684MLP\u6765\u83b7\u5f97 \\mathcal{z}_i = g(\\mathbf{h}_i) = W^{(2)} \\sigma (W^{(1)} h_i) \\mathcal{z}_i = g(\\mathbf{h}_i) = W^{(2)} \\sigma (W^{(1)} h_i) \uff0c\u5176\u4e2d \\sigma \\sigma \u4ee3\u8868ReLU\u975e\u7ebf\u6027\u5c42\u3002\u6211\u4eec\u53d1\u73b0\u5728 \\mathcal{z}_i \\mathcal{z}_i \u4e0a\u5b9a\u4e49\u5bf9\u6bd4\u635f\u5931\u6bd4\u5728 \\mathbf{h}_i \\mathbf{h}_i \u4e0a\u66f4\u597d\u3002 \u4e00\u4e2a \u5bf9\u6bd4\u635f\u5931\u51fd\u6570 NT-Xent \\mathcal{l}_{i, j} = -\\log \\frac{\\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_j) / \\tau)}{\\sum^{2N}_{k=1} \\mathbf{1}_{[k \\neq i]} \\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_k) / \\tau)} \\mathcal{l}_{i, j} = -\\log \\frac{\\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_j) / \\tau)}{\\sum^{2N}_{k=1} \\mathbf{1}_{[k \\neq i]} \\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_k) / \\tau)} \uff0c\u5176\u4e2d N N \u4e3abatch size\uff0c \\mathrm{sim}(u, v) = u^Tv / \\left\\Vert u \\right\\Vert \\left\\Vert v \\right\\Vert \\mathrm{sim}(u, v) = u^Tv / \\left\\Vert u \\right\\Vert \\left\\Vert v \\right\\Vert \u8868\u793a \\mathcal{l}_2 \\mathcal{l}_2 \u6b63\u5219\u540e\u7684 u u \u548c v v \u7684\u70b9\u79ef\uff08\u4e5f\u5373\u4f59\u5f26\u76f8\u4f3c\u5ea6\uff09\uff0c \\mathbf{1}_{[k \\neq i]} \\mathbf{1}_{[k \\neq i]} \u4e3a\u4e00\u4e2a\u6307\u793a\u5668\u51fd\u6570\uff0c\u5f53\u4e14\u4ec5\u5f53 k \\neq i k \\neq i \u65f6\u4e3a1\uff0c \\tau \\tau \u8868\u793a\u6e29\u5ea6\u53c2\u6570\u3002 \u635f\u5931\u5728\u6240\u6709\u6b63\u6837\u672c\u5bf9\u4e0a\u88ab\u8ba1\u7b97\uff0c\u4e5f\u5373 (i, j) (i, j) \u548c (j, i) (j, i) \u3002 \u5927batch size\u8bad\u7ec3 # \u6807\u51c6\u7684SGD/Momentum\u7ed3\u5408\u7ebf\u6027\u5b66\u4e60\u7387\u8c03\u6574\u5bf9\u4e8e\u8d85\u5927\u89c4\u6a21\u7f51\u7edc\u8bad\u7ec3\u6765\u8bf4\u53ef\u80fd\u4e0d\u592a\u7a33\u5b9a\u3002\u672c\u5de5\u4f5c\u4f7f\u7528LARS\u4f18\u5316\u5668\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 \u7531\u4e8e\u6b63\u6837\u672c\u5bf9\u901a\u5e38\u5728\u540c\u4e00\u5f20\u5361\u4e0a\uff0c\u6a21\u578b\u53ef\u80fd\u5229\u7528\u5c40\u90e8\u4fe1\u606f\u7684\u6cc4\u9732\u800c\u5728\u4e0d\u63d0\u5347\u8868\u8fbe\u7684\u60c5\u51b5\u4e0b\u63d0\u5347\u6027\u80fd\u3002\u672c\u6587\u901a\u8fc7\u805a\u5408BN\u7684\u5747\u503c\u548c\u65b9\u5dee\u6765\u5b9e\u73b0Global BN\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\u5176\u4ed6\u65b9\u6cd5\u8fd8\u5305\u62ec\u8de8\u8bbe\u5907\u968f\u673a\u6392\u5e03\u6570\u636e\u3001\u4f7f\u7528layer norm\u66ff\u4ee3BN\u3002 \u5b9e\u9a8c\u8bbe\u7f6e # \u672c\u5de5\u4f5c\u5728ImageNet ILSVRC-2012\u4e0a\u8bad\u7ec3\uff0c\u6570\u636e\u589e\u5f3a\u5305\u62ec\u968f\u673a\u526a\u88c1\u5e76\u7f29\u653e\u56de\u539f\u59cb\u5927\u5c0f\uff08\u4f34\u968f\u968f\u673a\u955c\u50cf\uff09\u3001\u8272\u5f69\u5931\u771f\u548c\u9ad8\u65af\u6a21\u7cca\u3002\u6a21\u578b\u4f7f\u7528ResNet-50\u4f5c\u4e3a\u7f16\u7801\u5668\uff0c\u548c\u4e00\u4e2a2\u5c42MLP\u6620\u5c04\u5934\u6765\u5c06\u8868\u8fbe\u6620\u5c04\u5230\u4e00\u4e2a128\u7ef4\u7684\u9690\u7a7a\u95f4\u4e0a\u3002\u672c\u5de5\u4f5c\u4f7f\u7528NT-Xent\u635f\u5931\uff0c\u901a\u8fc7LARS\u8fdb\u884c\u4f18\u5316\u3002\u5b66\u4e60\u7387\u88ab\u8bbe\u7f6e\u4e3a4.8\uff08 0.3 \\times \\text{batch size} / 256 0.3 \\times \\text{batch size} / 256 \uff09\uff0cweight decay\u8bbe\u7f6e\u4e3a1e-6\u3002Batch size\u4e3a4096\uff0c\u8bad\u7ec3100\u4e2aepochs\u3002\u6b64\u5916\uff0c\u7ebf\u6027\u9884\u70ed\u5728\u524d10\u4e2aepoch\u88ab\u5e94\u7528\uff0c\u5b66\u4e60\u7387\u6309\u7167cosine decay schedule\u8870\u51cf\uff0c\u6ca1\u6709\u91cd\u542f\u3002 \u8ba8\u8bba # \u6570\u636e\u589e\u5f3a\u7684\u6784\u6210\u5bf9\u5b66\u4e60\u597d\u7684\u8868\u8fbe\u81f3\u5173\u91cd\u8981 \u76f8\u8f83\u4e8e\u76d1\u7763\u5b66\u4e60\uff0c\u5bf9\u6bd4\u5b66\u4e60\u9700\u8981\u66f4\u5f3a\u7684\u6570\u636e\u589e\u5f3a \u5bf9\u6bd4\u5b66\u4e60\u4ece\u66f4\u5927\u7684\u6a21\u578b\u4e2d\u83b7\u76ca\uff08\u66f4\u591a\uff09 \u975e\u7ebf\u6027\u6620\u5c04\u5934\u63d0\u5347\u5728\u5176\u4e4b\u524d\u7684\u8868\u8fbe\u7684\u8d28\u91cf \u6b63\u5219\u5316\u7684\u4ea4\u53c9\u71b5\u635f\u5931\u4e0e\u53ef\u8c03\u7684\u6e29\u5ea6\u53c2\u6570\u6bd4\u5176\u4ed6\u65b9\u6cd5\u6548\u679c\u66f4\u597d \u5bf9\u6bd4\u5b66\u4e60\u4ece\u66f4\u5927\u7684batch sizes\u548c\u66f4\u957f\u7684\u8bad\u7ec3\u4e2d\u83b7\u76ca\uff08\u66f4\u591a\uff09","title":"SimCLR"},{"location":"cv/ssl/SimCLR/#_1","text":"\u5b66\u4e60\u6709\u6548\u7684\u89c6\u89c9\u8868\u8fbe\u800c\u65e0\u9700\u4eba\u7c7b\u76d1\u7763\u662f\u4e00\u4e2a\u957f\u671f\u5b58\u5728\u7684\u95ee\u9898\u3002\u4e3b\u6d41\u65b9\u6cd5\u901a\u5e38\u53ef\u88ab\u5f52\u7c7b\u4e3a\u4e24\u79cd\uff1a\u751f\u6210\u7c7b\u548c\u5224\u522b\u7c7b\u3002 \u751f\u6210\u65b9\u6cd5\u5b66\u4e60\u5728\u8f93\u5165\u7a7a\u95f4\u4e2d\u751f\u6210\u6216\u5efa\u6a21\u50cf\u7d20\u3002\u7136\u800c\uff0c\u50cf\u7d20\u7ea7\u751f\u6210\u975e\u5e38\u7684\u8ba1\u7b97\u6602\u8d35\uff0c\u5e76\u4e14\u5bf9\u4e8e\u8868\u8fbe\u5b66\u4e60\u6765\u8bf4\u4e5f\u53ef\u80fd\u6709\u4e9b\u8fc7\u4e86\u3002 \u5224\u522b\u65b9\u6cd5\u4f7f\u7528\u7c7b\u4f3c\u4e8e\u76d1\u7763\u5b66\u4e60\u4e2d\u7684\u76ee\u6807\u51fd\u6570\u6765\u5b66\u4e60\u8868\u8fbe\uff0c\u533a\u522b\u5728\u4e8e\u4ed6\u4eec\u4f7f\u7528\u524d\u7f6e\u4efb\u52a1\u6765\u8bad\u7ec3\u7f51\u7edc\uff0c\u800c\u8f93\u5165\u548c\u6807\u7b7e\u5747\u884d\u751f\u81ea\u65e0\u6807\u7b7e\u6570\u636e\u96c6\u3002\u8bb8\u591a\u8fd9\u4e9b\u65b9\u6cd5\u90fd\u4f9d\u8d56\u542f\u53d1\u5f0f\u65b9\u6cd5\u4ee5\u8bbe\u8ba1\u524d\u7f6e\u4efb\u52a1\uff0c\u8fd9\u53ef\u80fd\u4f1a\u9650\u5236\u6240\u5b66\u8868\u8fbe\u7684\u901a\u7528\u6027\u3002 \u8fd1\u6765\uff0c\u57fa\u4e8e\u5728\u9690\u7a7a\u95f4\u8fdb\u884c\u5bf9\u6bd4\u5b66\u4e60\u7684\u5224\u522b\u65b9\u6cd5\u8868\u73b0\u51fa\u4e86\u6781\u597d\u7684\u524d\u666f\uff0c\u8fbe\u5230\u4e86SOTA\u7ed3\u679c\u3002","title":"\u52a8\u673a"},{"location":"cv/ssl/SimCLR/#_2","text":"\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u5bf9\u6bd4\u5b66\u4e60\u7684\u7b80\u5355\u7684\u6846\u67b6\u3002\u4ed6\u65e0\u9700\u7279\u6b8a\u7684\u67b6\u6784\uff0c\u4e5f\u4e0d\u9700\u8981\u5185\u5b58\u94f6\u884c\u3002 \u591a\u4e2a\u6570\u636e\u589e\u5f3a\u7684\u7ec4\u5408\u5bf9\u4e8e\u5b9a\u4e49\u4ea7\u751f\u6709\u6548\u8868\u8fbe\u7684\u9884\u6d4b\u4efb\u52a1\u6765\u8bf4\u81f3\u5173\u91cd\u8981\u3002\u4e0e\u76d1\u7763\u5b66\u4e60\u76f8\u6bd4\uff0c\u65e0\u76d1\u7763\u5b66\u4e60\u4ece\u6570\u636e\u589e\u5f3a\u4e2d\u83b7\u5f97\u7684\u6536\u76ca\u66f4\u5927\u3002 \u5728\u8868\u8fbe\u4e0e\u5bf9\u6bd4\u635f\u5931\u4e4b\u95f4\u589e\u52a0\u4e00\u4e2a\u79d1\u5b66\u7cfb\u7684\u975e\u7ebf\u6027\u53d8\u6362\u53ef\u4ee5\u5f88\u5927\u7a0b\u5ea6\u4e0a\u63d0\u9ad8\u5b66\u5230\u7684\u8868\u8fbe\u7684\u8d28\u91cf\u3002 \u4f7f\u7528\u5bf9\u6bd4\u4ea4\u53c9\u71b5\u635f\u5931\u51fd\u6570\u7684\u8868\u8fbe\u5b66\u4e60\u53ef\u4ee5\u4ece\u5f52\u4e00\u5316\u7684\u5d4c\u5165\u548c\u5bf9\u6e29\u5ea6\u53c2\u6570\u7684\u6070\u5f53\u8c03\u6574\u4e2d\u53d7\u76ca\u3002 \u76f8\u8f83\u4e8e\u76d1\u7763\u5b66\u4e60\uff0c\u5bf9\u6bd4\u5b66\u4e60\u53d7\u76ca\u4e8e\u66f4\u5927\u7684batch size\u4e0e\u66f4\u957f\u7684\u8bad\u7ec3\u3002\u4e0e\u76d1\u7763\u5b66\u4e60\u7c7b\u4f3c\uff0c\u5bf9\u6bd4\u5b66\u4e60\u53d7\u76ca\u4e8e\u66f4\u6df1\u66f4\u5bbd\u7684\u7f51\u7edc\u3002","title":"\u8d21\u732e"},{"location":"cv/ssl/SimCLR/#_3","text":"","title":"\u65b9\u6cd5"},{"location":"cv/ssl/SimCLR/#_4","text":"\u672c\u6587\u4ece\u9690\u7a7a\u95f4\u7684\u5bf9\u6bd4\u635f\u5931\u6765\u6700\u5927\u5316\u540c\u4e00\u6570\u636e\u6837\u672c\u7684\u4e0d\u540c\u589e\u5f3a\u89c6\u56fe\u7684\u4e00\u81f4\u6027\u4ee5\u5b66\u4e60\u8868\u8fbe\u3002\u672c\u6846\u67b6\u7531\u56db\u4e2a\u4e3b\u8981\u90e8\u5206\u6784\u6210\u3002 \u4e00\u4e2a\u968f\u673a \u6570\u636e\u589e\u5f3a \u6a21\u5757\uff0c\u5bf9\u4efb\u4e00\u7ed9\u5b9a\u6570\u636e\u6837\u672c\u4ea7\u751f\u4e24\u4e2a\u76f8\u5173\u7684\u89c6\u56fe\uff0c\u8868\u793a\u4e3a \\tilde{x}_i \\tilde{x}_i \u548c \\tilde{x}_j \\tilde{x}_j \uff0c\u6211\u4eec\u5c06\u5176\u79f0\u4e3a\u6b63\u6837\u672c\u5bf9\u3002\u5728\u672c\u5de5\u4f5c\u4e2d\uff0c \u6211\u4eec\u987a\u5e8f\u7684\u5e94\u7528\u4e09\u4e2a\u7b80\u5355\u7684\u589e\u5f3a\uff1a\u968f\u5373\u88c1\u526a\uff08\u955c\u50cf\uff09\u5e76\u5c06\u5176\u7f29\u653e\u56de\u539f\u59cb\u5927\u5c0f\u3001\u968f\u673a\u8272\u5f69\u5931\u771f\u3001\u968f\u673a\u9ad8\u65af\u6a21\u7cca\u3002 \u5176\u4e2d\uff0c\u88c1\u526a\u548c\u989c\u8272\u5931\u771f\u7684\u7ec4\u5408\u5bf9\u6027\u80fd\u6709\u81f3\u5173\u91cd\u8981\u7684\u5f71\u54cd\u3002 \u4e00\u4e2a\u795e\u7ecf\u7f51\u7edc \u57fa\u7840\u7f16\u7801\u5668 f(\\cdot) f(\\cdot) \uff0c\u4ece\u589e\u5f3a\u540e\u7684\u6570\u636e\u6837\u672c\u4e2d\u63d0\u53d6\u51fa\u8868\u8fbe\u5411\u91cf\u3002\u672c\u6587\u7684\u6846\u67b6\u5141\u8bb8\u4f7f\u7528\u591a\u79cd\u7f51\u7edc\u7ed3\u6784\u800c\u6ca1\u6709\u9650\u5236\u3002\u672c\u6587\u51fa\u4e8e\u7b80\u5355\u7684\u8003\u91cf\u4f7f\u7528\u4e86\u5e7f\u6cdb\u4f7f\u7528\u7684ResNet\u6765\u83b7\u53d6 \\mathbf{h}_i = f(\\tilde{x}_i) = \\mathrm{ResNet}(\\tilde{x}_i) \\mathbf{h}_i = f(\\tilde{x}_i) = \\mathrm{ResNet}(\\tilde{x}_i) \uff0c\u5176\u4e2d \\mathbf{h}_i \\in \\mathbb{R}^d \\mathbf{h}_i \\in \\mathbb{R}^d \u662f\u5e73\u5747\u6c60\u5316\u5c42\u7684\u8f93\u51fa\u3002 \u4e00\u4e2a\u5c0f\u7684\u795e\u7ecf\u7f51\u7edc \u6620\u5c04\u5934 g(\\cdot) g(\\cdot) \uff0c\u5c06\u8868\u8fbe\u6620\u5c04\u5230\u5bf9\u6bd4\u635f\u5931\u88ab\u5e94\u7528\u7684\u7a7a\u95f4\u4e0a\u3002\u672c\u6587\u4f7f\u7528\u4e00\u4e2a\u5177\u6709\u4e00\u4e2a\u9690\u85cf\u5c42\u7684MLP\u6765\u83b7\u5f97 \\mathcal{z}_i = g(\\mathbf{h}_i) = W^{(2)} \\sigma (W^{(1)} h_i) \\mathcal{z}_i = g(\\mathbf{h}_i) = W^{(2)} \\sigma (W^{(1)} h_i) \uff0c\u5176\u4e2d \\sigma \\sigma \u4ee3\u8868ReLU\u975e\u7ebf\u6027\u5c42\u3002\u6211\u4eec\u53d1\u73b0\u5728 \\mathcal{z}_i \\mathcal{z}_i \u4e0a\u5b9a\u4e49\u5bf9\u6bd4\u635f\u5931\u6bd4\u5728 \\mathbf{h}_i \\mathbf{h}_i \u4e0a\u66f4\u597d\u3002 \u4e00\u4e2a \u5bf9\u6bd4\u635f\u5931\u51fd\u6570 NT-Xent \\mathcal{l}_{i, j} = -\\log \\frac{\\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_j) / \\tau)}{\\sum^{2N}_{k=1} \\mathbf{1}_{[k \\neq i]} \\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_k) / \\tau)} \\mathcal{l}_{i, j} = -\\log \\frac{\\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_j) / \\tau)}{\\sum^{2N}_{k=1} \\mathbf{1}_{[k \\neq i]} \\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_k) / \\tau)} \uff0c\u5176\u4e2d N N \u4e3abatch size\uff0c \\mathrm{sim}(u, v) = u^Tv / \\left\\Vert u \\right\\Vert \\left\\Vert v \\right\\Vert \\mathrm{sim}(u, v) = u^Tv / \\left\\Vert u \\right\\Vert \\left\\Vert v \\right\\Vert \u8868\u793a \\mathcal{l}_2 \\mathcal{l}_2 \u6b63\u5219\u540e\u7684 u u \u548c v v \u7684\u70b9\u79ef\uff08\u4e5f\u5373\u4f59\u5f26\u76f8\u4f3c\u5ea6\uff09\uff0c \\mathbf{1}_{[k \\neq i]} \\mathbf{1}_{[k \\neq i]} \u4e3a\u4e00\u4e2a\u6307\u793a\u5668\u51fd\u6570\uff0c\u5f53\u4e14\u4ec5\u5f53 k \\neq i k \\neq i \u65f6\u4e3a1\uff0c \\tau \\tau \u8868\u793a\u6e29\u5ea6\u53c2\u6570\u3002 \u635f\u5931\u5728\u6240\u6709\u6b63\u6837\u672c\u5bf9\u4e0a\u88ab\u8ba1\u7b97\uff0c\u4e5f\u5373 (i, j) (i, j) \u548c (j, i) (j, i) \u3002","title":"\u6846\u67b6"},{"location":"cv/ssl/SimCLR/#batch-size","text":"\u6807\u51c6\u7684SGD/Momentum\u7ed3\u5408\u7ebf\u6027\u5b66\u4e60\u7387\u8c03\u6574\u5bf9\u4e8e\u8d85\u5927\u89c4\u6a21\u7f51\u7edc\u8bad\u7ec3\u6765\u8bf4\u53ef\u80fd\u4e0d\u592a\u7a33\u5b9a\u3002\u672c\u5de5\u4f5c\u4f7f\u7528LARS\u4f18\u5316\u5668\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 \u7531\u4e8e\u6b63\u6837\u672c\u5bf9\u901a\u5e38\u5728\u540c\u4e00\u5f20\u5361\u4e0a\uff0c\u6a21\u578b\u53ef\u80fd\u5229\u7528\u5c40\u90e8\u4fe1\u606f\u7684\u6cc4\u9732\u800c\u5728\u4e0d\u63d0\u5347\u8868\u8fbe\u7684\u60c5\u51b5\u4e0b\u63d0\u5347\u6027\u80fd\u3002\u672c\u6587\u901a\u8fc7\u805a\u5408BN\u7684\u5747\u503c\u548c\u65b9\u5dee\u6765\u5b9e\u73b0Global BN\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\u5176\u4ed6\u65b9\u6cd5\u8fd8\u5305\u62ec\u8de8\u8bbe\u5907\u968f\u673a\u6392\u5e03\u6570\u636e\u3001\u4f7f\u7528layer norm\u66ff\u4ee3BN\u3002","title":"\u5927batch size\u8bad\u7ec3"},{"location":"cv/ssl/SimCLR/#_5","text":"\u672c\u5de5\u4f5c\u5728ImageNet ILSVRC-2012\u4e0a\u8bad\u7ec3\uff0c\u6570\u636e\u589e\u5f3a\u5305\u62ec\u968f\u673a\u526a\u88c1\u5e76\u7f29\u653e\u56de\u539f\u59cb\u5927\u5c0f\uff08\u4f34\u968f\u968f\u673a\u955c\u50cf\uff09\u3001\u8272\u5f69\u5931\u771f\u548c\u9ad8\u65af\u6a21\u7cca\u3002\u6a21\u578b\u4f7f\u7528ResNet-50\u4f5c\u4e3a\u7f16\u7801\u5668\uff0c\u548c\u4e00\u4e2a2\u5c42MLP\u6620\u5c04\u5934\u6765\u5c06\u8868\u8fbe\u6620\u5c04\u5230\u4e00\u4e2a128\u7ef4\u7684\u9690\u7a7a\u95f4\u4e0a\u3002\u672c\u5de5\u4f5c\u4f7f\u7528NT-Xent\u635f\u5931\uff0c\u901a\u8fc7LARS\u8fdb\u884c\u4f18\u5316\u3002\u5b66\u4e60\u7387\u88ab\u8bbe\u7f6e\u4e3a4.8\uff08 0.3 \\times \\text{batch size} / 256 0.3 \\times \\text{batch size} / 256 \uff09\uff0cweight decay\u8bbe\u7f6e\u4e3a1e-6\u3002Batch size\u4e3a4096\uff0c\u8bad\u7ec3100\u4e2aepochs\u3002\u6b64\u5916\uff0c\u7ebf\u6027\u9884\u70ed\u5728\u524d10\u4e2aepoch\u88ab\u5e94\u7528\uff0c\u5b66\u4e60\u7387\u6309\u7167cosine decay schedule\u8870\u51cf\uff0c\u6ca1\u6709\u91cd\u542f\u3002","title":"\u5b9e\u9a8c\u8bbe\u7f6e"},{"location":"cv/ssl/SimCLR/#_6","text":"\u6570\u636e\u589e\u5f3a\u7684\u6784\u6210\u5bf9\u5b66\u4e60\u597d\u7684\u8868\u8fbe\u81f3\u5173\u91cd\u8981 \u76f8\u8f83\u4e8e\u76d1\u7763\u5b66\u4e60\uff0c\u5bf9\u6bd4\u5b66\u4e60\u9700\u8981\u66f4\u5f3a\u7684\u6570\u636e\u589e\u5f3a \u5bf9\u6bd4\u5b66\u4e60\u4ece\u66f4\u5927\u7684\u6a21\u578b\u4e2d\u83b7\u76ca\uff08\u66f4\u591a\uff09 \u975e\u7ebf\u6027\u6620\u5c04\u5934\u63d0\u5347\u5728\u5176\u4e4b\u524d\u7684\u8868\u8fbe\u7684\u8d28\u91cf \u6b63\u5219\u5316\u7684\u4ea4\u53c9\u71b5\u635f\u5931\u4e0e\u53ef\u8c03\u7684\u6e29\u5ea6\u53c2\u6570\u6bd4\u5176\u4ed6\u65b9\u6cd5\u6548\u679c\u66f4\u597d \u5bf9\u6bd4\u5b66\u4e60\u4ece\u66f4\u5927\u7684batch sizes\u548c\u66f4\u957f\u7684\u8bad\u7ec3\u4e2d\u83b7\u76ca\uff08\u66f4\u591a\uff09","title":"\u8ba8\u8bba"},{"location":"cv/ssl/SimCLRv2/","text":"SimCLRv2\u63d0\u51fa\u4e86\u4e00\u4e2a\u4e09\u6b65\u7684\u534a\u76d1\u7763\u7b97\u6cd5\uff0c\u9996\u5148\u4f7f\u7528SimCLRv2\u65e0\u76d1\u7763\u9884\u8bad\u7ec3\u4e00\u4e2a\u5927\u6a21\u578b\uff0c\u7136\u540e\u4f7f\u7528\u4e00\u5c0f\u90e8\u5206\u6807\u6ce8\u6570\u636e\u76d1\u7763fine-tune\uff0c\u6700\u540e\u901a\u8fc7\u65e0\u6807\u7b7e\u6837\u672c\u84b8\u998f\u6765refine\u548c\u8fc1\u79fb\u4efb\u52a1\u76f8\u5173\u77e5\u8bc6\u3002\u5bf9\u4e8eImageNet\uff0c\u5728\u4f7f\u75281%\u7684\u6807\u7b7e\u65f6\uff0c\u672c\u5de5\u4f5c\u8fbe\u5230\u4e8673.9%\u7684top-1\u51c6\u786e\u7387\uff0c\u5e76\u5728\u4f7f\u752810%\u7684\u6807\u7b7e\u65f6\u8fbe\u5230\u4e8677.5%\u7684top-1\u51c6\u786e\u7387\u3002 \u52a8\u673a # \u4f7f\u7528\u65e0\u6807\u7b7e\u6570\u636e\u8fdb\u884c\u4efb\u52a1\u65e0\u5173\u7684\u9884\u8bad\u7ec3\uff0c\u7136\u540e\u4f7f\u7528\u6807\u7b7e\u6570\u636e\u8fdb\u884c\u4efb\u52a1\u76f8\u5173\u7684fine-tune\u5728\u81ea\u7136\u8bed\u8a00\u5904\u7406\u4e2d\u88ab\u5e7f\u6cdb\u5e94\u7528\uff0c\u4f46\u5728\u8ba1\u7b97\u673a\u89c6\u89c9\u4e2d\u8fd8\u975e\u4e3b\u6d41\u3002\u5728\u8ba1\u7b97\u673a\u89c6\u89c9\u5f53\u4e2d\u66f4\u5e38\u89c1\u7684\u53e6\u4e00\u4e2a\u65b9\u6cd5\u65f6\u5728\u76d1\u7763\u5b66\u4e60\u4e2d\u76f4\u63a5\u5229\u7528\u65e0\u6807\u7b7e\u6570\u636e\uff0c\u4f5c\u4e3a\u4e00\u79cd\u89c4\u5219\u5316\u65b9\u6cd5\u3002\u8fd9\u79cd\u65b9\u6cd5\u5728\u4efb\u52a1\u7279\u5b9a\u65b9\u5f0f\u4e2d\u4f7f\u7528\u65e0\u6807\u7b7e\u6570\u636e\u4ee5\u9f13\u52b1\u5728\u4e0d\u540c\u6a21\u578b\u4e4b\u95f4\u6216\u8005\u4e0d\u540c\u6570\u636e\u589e\u5f3a\u4e0b\u5bf9\u65e0\u6807\u7b7e\u6570\u636e\u8fdb\u884c\u7c7b\u6807\u7b7e\u9884\u6d4b\u7684\u4e00\u81f4\u6027\u3002 \u8d21\u732e # \u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u534a\u76d1\u7763\u5b66\u4e60\u7684\u6846\u67b6\uff0c\u8be5\u6846\u67b6\u7531\u4e09\u4e2a\u90e8\u5206\u7ec4\u6210\uff1a1. \u65e0\u76d1\u7763\u6216\u81ea\u76d1\u7763\u9884\u8bad\u7ec3\uff0c2. \u76d1\u7763 fine-tune\uff0c3. \u4f7f\u7528\u65e0\u6807\u7b7e\u6570\u636e\u84b8\u998f\u3002 \u5bf9\u4e8e\u534a\u76d1\u7763\u5b66\u4e60\uff08\u901a\u8fc7\u4efb\u52a1\u65e0\u5173\u7684\u4f7f\u7528\u65e0\u6807\u7b7e\u6570\u636e\uff09\uff0c\u6807\u7b7e\u8d8a\u5c11\uff0c\u8d8a\u6709\u53ef\u80fd\u53d7\u76ca\u4e8e\u66f4\u5927\u7684\u6a21\u578b\u3002\u66f4\u5927\u7684\u81ea\u76d1\u7763\u6a21\u578b\u62e5\u6709\u66f4\u9ad8\u7684\u6807\u7b7e\u6548\u7387\uff0c\u5728\u5f88\u5c11\u7684\u6807\u7b7e\u6837\u672c\u4e0afine-tune\u4e4b\u540e\u6709\u663e\u8457\u66f4\u597d\u7684\u8868\u73b0\uff0c\u5c3d\u7ba1\u4ed6\u4eec\u7684\u5bb9\u91cf\u66f4\u5927\u56e0\u800c\u66f4\u53ef\u80fd\u8fc7\u62df\u5408\u3002 \u5c3d\u7ba1\u5927\u6a21\u578b\u5bf9\u4e8e\u5b66\u4e60\u901a\u7528\uff08\u89c6\u89c9\uff09\u8868\u8fbe\u800c\u8a00\u5341\u5206\u91cd\u8981\uff0c\u4f46\u662f\u989d\u5916\u7684\u5bb9\u91cf\u5bf9\u4e8e\u7279\u5b9a\u76ee\u6807\u4efb\u52a1\u800c\u8a00\u53ef\u80fd\u662f\u4e0d\u5fc5\u987b\u7684\u3002\u56e0\u6b64\uff0c\u901a\u8fc7\u4f7f\u7528\u4efb\u52a1\u7279\u5b9a\u7684\u4f7f\u7528\u65e0\u6807\u7b7e\u6570\u636e\uff0c\u6a21\u578b\u7684\u9884\u6d4b\u6027\u80fd\u53ef\u4ee5\u88ab\u8fdb\u4e00\u6b65\u63d0\u5347\u5e76\u88ab\u8fc1\u79fb\u5230\u66f4\u5c0f\u7684\u7f51\u7edc\u4e2d\u3002 \u66f4\u6df1\u7684\u6620\u5c04\u5934\u4e0d\u4f46\u80fd\u63d0\u5347\u901a\u8fc7\u7ebf\u6027\u8bc4\u4f30\u6d4b\u5f97\u7684\u8868\u8fbe\u8d28\u91cf\uff0c\u800c\u4e14\u8fd8\u80fd\u63d0\u5347\u4ece\u6620\u5c04\u5934\u7684\u4e00\u4e2a \u4e2d\u95f4\u5c42 \u8fdb\u884c\u5fae\u8c03\u65f6\u7684\u534a\u76d1\u7763\u6027\u80fd\u3002 \u65b9\u6cd5 # \u6846\u67b6 # \u672c\u6587\u4ece\u9690\u7a7a\u95f4\u7684\u5bf9\u6bd4\u635f\u5931\u6765\u6700\u5927\u5316\u540c\u4e00\u6570\u636e\u6837\u672c\u7684\u4e0d\u540c\u589e\u5f3a\u89c6\u56fe\u7684\u4e00\u81f4\u6027\u4ee5\u5b66\u4e60\u8868\u8fbe\u3002\u672c\u6846\u67b6\u7531\u56db\u4e2a\u4e3b\u8981\u90e8\u5206\u6784\u6210\u3002 \u4e00\u4e2a\u968f\u673a \u6570\u636e\u589e\u5f3a \u6a21\u5757\uff0c\u5bf9\u4efb\u4e00\u7ed9\u5b9a\u6570\u636e\u6837\u672c\u4ea7\u751f\u4e24\u4e2a\u76f8\u5173\u7684\u89c6\u56fe\uff0c\u8868\u793a\u4e3a \\tilde{x}_i \\tilde{x}_i \u548c \\tilde{x}_j \\tilde{x}_j \uff0c\u6211\u4eec\u5c06\u5176\u79f0\u4e3a\u6b63\u6837\u672c\u5bf9\u3002\u5728\u672c\u5de5\u4f5c\u4e2d\uff0c \u6211\u4eec\u987a\u5e8f\u7684\u5e94\u7528\u4e09\u4e2a\u7b80\u5355\u7684\u589e\u5f3a\uff1a\u968f\u5373\u88c1\u526a\uff08\u955c\u50cf\uff09\u5e76\u5c06\u5176\u7f29\u653e\u56de\u539f\u59cb\u5927\u5c0f\u3001\u968f\u673a\u8272\u5f69\u5931\u771f\u3001\u968f\u673a\u9ad8\u65af\u6a21\u7cca\u3002 \u5176\u4e2d\uff0c\u88c1\u526a\u548c\u989c\u8272\u5931\u771f\u7684\u7ec4\u5408\u5bf9\u6027\u80fd\u6709\u81f3\u5173\u91cd\u8981\u7684\u5f71\u54cd\u3002 \u4e00\u4e2a\u795e\u7ecf\u7f51\u7edc \u57fa\u7840\u7f16\u7801\u5668 f(\\cdot) f(\\cdot) \uff0c\u4ece\u589e\u5f3a\u540e\u7684\u6570\u636e\u6837\u672c\u4e2d\u63d0\u53d6\u51fa\u8868\u8fbe\u5411\u91cf\u3002\u672c\u6587\u7684\u6846\u67b6\u5141\u8bb8\u4f7f\u7528\u591a\u79cd\u7f51\u7edc\u7ed3\u6784\u800c\u6ca1\u6709\u9650\u5236\u3002\u672c\u6587\u51fa\u4e8e\u7b80\u5355\u7684\u8003\u91cf\u4f7f\u7528\u4e86\u5e7f\u6cdb\u4f7f\u7528\u7684ResNet\u6765\u83b7\u53d6 \\mathbf{h}_i = f(\\tilde{x}_i) = \\mathrm{ResNet}(\\tilde{x}_i) \\mathbf{h}_i = f(\\tilde{x}_i) = \\mathrm{ResNet}(\\tilde{x}_i) \uff0c\u5176\u4e2d \\mathbf{h}_i \\in \\mathbb{R}^d \\mathbf{h}_i \\in \\mathbb{R}^d \u662f\u5e73\u5747\u6c60\u5316\u5c42\u7684\u8f93\u51fa\u3002 \u4e00\u4e2a\u5c0f\u7684\u795e\u7ecf\u7f51\u7edc \u9884\u6d4b\u5934 g(\\cdot) g(\\cdot) \uff0c\u5c06\u8868\u8fbe\u6620\u5c04\u5230\u5bf9\u6bd4\u635f\u5931\u88ab\u5e94\u7528\u7684\u7a7a\u95f4\u4e0a\u3002\u672c\u6587\u4f7f\u7528\u4e00\u4e2a\u5177\u6709\u4e00\u4e2a\u9690\u85cf\u5c42\u7684MLP\u6765\u83b7\u5f97 \\mathcal{z}_i = g(\\mathbf{h}_i) = W^{(2)} \\sigma (W^{(1)} h_i) \\mathcal{z}_i = g(\\mathbf{h}_i) = W^{(2)} \\sigma (W^{(1)} h_i) \uff0c\u5176\u4e2d \\sigma \\sigma \u4ee3\u8868ReLU\u975e\u7ebf\u6027\u5c42\u3002\u6211\u4eec\u53d1\u73b0\u5728 \\mathcal{z}_i \\mathcal{z}_i \u4e0a\u5b9a\u4e49\u5bf9\u6bd4\u635f\u5931\u6bd4\u5728 \\mathbf{h}_i \\mathbf{h}_i \u4e0a\u66f4\u597d\u3002 \u4e00\u4e2a \u5bf9\u6bd4\u635f\u5931\u51fd\u6570 NT-Xent \\mathcal{l}_{i, j} = -\\log \\frac{\\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_j) / \\tau)}{\\sum^{2N}_{k=1} \\mathbf{1}_{[k \\neq i]} \\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_k) / \\tau)} \\mathcal{l}_{i, j} = -\\log \\frac{\\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_j) / \\tau)}{\\sum^{2N}_{k=1} \\mathbf{1}_{[k \\neq i]} \\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_k) / \\tau)} \uff0c\u5176\u4e2d N N \u4e3abatch size\uff0c \\mathrm{sim}(u, v) = u^Tv / \\left\\Vert u \\right\\Vert \\left\\Vert v \\right\\Vert \\mathrm{sim}(u, v) = u^Tv / \\left\\Vert u \\right\\Vert \\left\\Vert v \\right\\Vert \u8868\u793a \\mathcal{l}_2 \\mathcal{l}_2 \u6b63\u5219\u540e\u7684 u u \u548c v v \u7684\u70b9\u79ef\uff08\u4e5f\u5373\u4f59\u5f26\u76f8\u4f3c\u5ea6\uff09\uff0c \\mathbf{1}_{[k \\neq i]} \\mathbf{1}_{[k \\neq i]} \u4e3a\u4e00\u4e2a\u6307\u793a\u5668\u51fd\u6570\uff0c\u5f53\u4e14\u4ec5\u5f53 k \\neq i k \\neq i \u65f6\u4e3a1\uff0c \\tau \\tau \u8868\u793a\u6e29\u5ea6\u53c2\u6570\u3002 \u635f\u5931\u5728\u6240\u6709\u6b63\u6837\u672c\u5bf9\u4e0a\u88ab\u8ba1\u7b97\uff0c\u4e5f\u5373 (i, j) (i, j) \u548c (j, i) (j, i) \u3002 \u5927batch size\u8bad\u7ec3 # \u6807\u51c6\u7684SGD/Momentum\u7ed3\u5408\u7ebf\u6027\u5b66\u4e60\u7387\u8c03\u6574\u5bf9\u4e8e\u8d85\u5927\u89c4\u6a21\u7f51\u7edc\u8bad\u7ec3\u6765\u8bf4\u53ef\u80fd\u4e0d\u592a\u7a33\u5b9a\u3002\u672c\u5de5\u4f5c\u4f7f\u7528LARS\u4f18\u5316\u5668\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 \u7531\u4e8e\u6b63\u6837\u672c\u5bf9\u901a\u5e38\u5728\u540c\u4e00\u5f20\u5361\u4e0a\uff0c\u6a21\u578b\u53ef\u80fd\u5229\u7528\u5c40\u90e8\u4fe1\u606f\u7684\u6cc4\u9732\u800c\u5728\u4e0d\u63d0\u5347\u8868\u8fbe\u7684\u60c5\u51b5\u4e0b\u63d0\u5347\u6027\u80fd\u3002\u672c\u6587\u901a\u8fc7\u805a\u5408BN\u7684\u5747\u503c\u548c\u65b9\u5dee\u6765\u5b9e\u73b0Global BN\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\u5176\u4ed6\u65b9\u6cd5\u8fd8\u5305\u62ec\u8de8\u8bbe\u5907\u968f\u673a\u6392\u5e03\u6570\u636e\u3001\u4f7f\u7528layer norm\u66ff\u4ee3BN\u3002 \u5b9e\u9a8c\u8bbe\u7f6e # \u672c\u5de5\u4f5c\u5728ImageNet ILSVRC-2012\u4e0a\u8bad\u7ec3\uff0c\u6570\u636e\u589e\u5f3a\u5305\u62ec\u968f\u673a\u526a\u88c1\u5e76\u7f29\u653e\u56de\u539f\u59cb\u5927\u5c0f\uff08\u4f34\u968f\u968f\u673a\u955c\u50cf\uff09\u3001\u8272\u5f69\u5931\u771f\u548c\u9ad8\u65af\u6a21\u7cca\u3002\u6a21\u578b\u4f7f\u7528ResNet-50\u4f5c\u4e3a\u7f16\u7801\u5668\uff0c\u548c\u4e00\u4e2a2\u5c42MLP\u6620\u5c04\u5934\u6765\u5c06\u8868\u8fbe\u6620\u5c04\u5230\u4e00\u4e2a128\u7ef4\u7684\u9690\u7a7a\u95f4\u4e0a\u3002\u672c\u5de5\u4f5c\u4f7f\u7528NT-Xent\u635f\u5931\uff0c\u901a\u8fc7LARS\u8fdb\u884c\u4f18\u5316\u3002\u5b66\u4e60\u7387\u88ab\u8bbe\u7f6e\u4e3a4.8\uff08 0.3 \\times \\text{batch size} / 256 0.3 \\times \\text{batch size} / 256 \uff09\uff0cweight decay\u8bbe\u7f6e\u4e3a1e-6\u3002Batch size\u4e3a4096\uff0c\u8bad\u7ec3100\u4e2aepochs\u3002\u6b64\u5916\uff0c\u7ebf\u6027\u9884\u70ed\u5728\u524d10\u4e2aepoch\u88ab\u5e94\u7528\uff0c\u5b66\u4e60\u7387\u6309\u7167cosine decay schedule\u8870\u51cf\uff0c\u6ca1\u6709\u91cd\u542f\u3002 \u8ba8\u8bba # \u6570\u636e\u589e\u5f3a\u7684\u6784\u6210\u5bf9\u5b66\u4e60\u597d\u7684\u8868\u8fbe\u81f3\u5173\u91cd\u8981 \u76f8\u8f83\u4e8e\u76d1\u7763\u5b66\u4e60\uff0c\u5bf9\u6bd4\u5b66\u4e60\u9700\u8981\u66f4\u5f3a\u7684\u6570\u636e\u589e\u5f3a \u5bf9\u6bd4\u5b66\u4e60\u4ece\u66f4\u5927\u7684\u6a21\u578b\u4e2d\u83b7\u76ca\uff08\u66f4\u591a\uff09 \u975e\u7ebf\u6027\u6620\u5c04\u5934\u63d0\u5347\u5728\u5176\u4e4b\u524d\u7684\u8868\u8fbe\u7684\u8d28\u91cf \u6b63\u5219\u5316\u7684\u4ea4\u53c9\u71b5\u635f\u5931\u4e0e\u53ef\u8c03\u7684\u6e29\u5ea6\u53c2\u6570\u6bd4\u5176\u4ed6\u65b9\u6cd5\u6548\u679c\u66f4\u597d \u5bf9\u6bd4\u5b66\u4e60\u4ece\u66f4\u5927\u7684batch sizes\u548c\u66f4\u957f\u7684\u8bad\u7ec3\u4e2d\u83b7\u76ca\uff08\u66f4\u591a\uff09","title":"SimCLRv2"},{"location":"cv/ssl/SimCLRv2/#_1","text":"\u4f7f\u7528\u65e0\u6807\u7b7e\u6570\u636e\u8fdb\u884c\u4efb\u52a1\u65e0\u5173\u7684\u9884\u8bad\u7ec3\uff0c\u7136\u540e\u4f7f\u7528\u6807\u7b7e\u6570\u636e\u8fdb\u884c\u4efb\u52a1\u76f8\u5173\u7684fine-tune\u5728\u81ea\u7136\u8bed\u8a00\u5904\u7406\u4e2d\u88ab\u5e7f\u6cdb\u5e94\u7528\uff0c\u4f46\u5728\u8ba1\u7b97\u673a\u89c6\u89c9\u4e2d\u8fd8\u975e\u4e3b\u6d41\u3002\u5728\u8ba1\u7b97\u673a\u89c6\u89c9\u5f53\u4e2d\u66f4\u5e38\u89c1\u7684\u53e6\u4e00\u4e2a\u65b9\u6cd5\u65f6\u5728\u76d1\u7763\u5b66\u4e60\u4e2d\u76f4\u63a5\u5229\u7528\u65e0\u6807\u7b7e\u6570\u636e\uff0c\u4f5c\u4e3a\u4e00\u79cd\u89c4\u5219\u5316\u65b9\u6cd5\u3002\u8fd9\u79cd\u65b9\u6cd5\u5728\u4efb\u52a1\u7279\u5b9a\u65b9\u5f0f\u4e2d\u4f7f\u7528\u65e0\u6807\u7b7e\u6570\u636e\u4ee5\u9f13\u52b1\u5728\u4e0d\u540c\u6a21\u578b\u4e4b\u95f4\u6216\u8005\u4e0d\u540c\u6570\u636e\u589e\u5f3a\u4e0b\u5bf9\u65e0\u6807\u7b7e\u6570\u636e\u8fdb\u884c\u7c7b\u6807\u7b7e\u9884\u6d4b\u7684\u4e00\u81f4\u6027\u3002","title":"\u52a8\u673a"},{"location":"cv/ssl/SimCLRv2/#_2","text":"\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u534a\u76d1\u7763\u5b66\u4e60\u7684\u6846\u67b6\uff0c\u8be5\u6846\u67b6\u7531\u4e09\u4e2a\u90e8\u5206\u7ec4\u6210\uff1a1. \u65e0\u76d1\u7763\u6216\u81ea\u76d1\u7763\u9884\u8bad\u7ec3\uff0c2. \u76d1\u7763 fine-tune\uff0c3. \u4f7f\u7528\u65e0\u6807\u7b7e\u6570\u636e\u84b8\u998f\u3002 \u5bf9\u4e8e\u534a\u76d1\u7763\u5b66\u4e60\uff08\u901a\u8fc7\u4efb\u52a1\u65e0\u5173\u7684\u4f7f\u7528\u65e0\u6807\u7b7e\u6570\u636e\uff09\uff0c\u6807\u7b7e\u8d8a\u5c11\uff0c\u8d8a\u6709\u53ef\u80fd\u53d7\u76ca\u4e8e\u66f4\u5927\u7684\u6a21\u578b\u3002\u66f4\u5927\u7684\u81ea\u76d1\u7763\u6a21\u578b\u62e5\u6709\u66f4\u9ad8\u7684\u6807\u7b7e\u6548\u7387\uff0c\u5728\u5f88\u5c11\u7684\u6807\u7b7e\u6837\u672c\u4e0afine-tune\u4e4b\u540e\u6709\u663e\u8457\u66f4\u597d\u7684\u8868\u73b0\uff0c\u5c3d\u7ba1\u4ed6\u4eec\u7684\u5bb9\u91cf\u66f4\u5927\u56e0\u800c\u66f4\u53ef\u80fd\u8fc7\u62df\u5408\u3002 \u5c3d\u7ba1\u5927\u6a21\u578b\u5bf9\u4e8e\u5b66\u4e60\u901a\u7528\uff08\u89c6\u89c9\uff09\u8868\u8fbe\u800c\u8a00\u5341\u5206\u91cd\u8981\uff0c\u4f46\u662f\u989d\u5916\u7684\u5bb9\u91cf\u5bf9\u4e8e\u7279\u5b9a\u76ee\u6807\u4efb\u52a1\u800c\u8a00\u53ef\u80fd\u662f\u4e0d\u5fc5\u987b\u7684\u3002\u56e0\u6b64\uff0c\u901a\u8fc7\u4f7f\u7528\u4efb\u52a1\u7279\u5b9a\u7684\u4f7f\u7528\u65e0\u6807\u7b7e\u6570\u636e\uff0c\u6a21\u578b\u7684\u9884\u6d4b\u6027\u80fd\u53ef\u4ee5\u88ab\u8fdb\u4e00\u6b65\u63d0\u5347\u5e76\u88ab\u8fc1\u79fb\u5230\u66f4\u5c0f\u7684\u7f51\u7edc\u4e2d\u3002 \u66f4\u6df1\u7684\u6620\u5c04\u5934\u4e0d\u4f46\u80fd\u63d0\u5347\u901a\u8fc7\u7ebf\u6027\u8bc4\u4f30\u6d4b\u5f97\u7684\u8868\u8fbe\u8d28\u91cf\uff0c\u800c\u4e14\u8fd8\u80fd\u63d0\u5347\u4ece\u6620\u5c04\u5934\u7684\u4e00\u4e2a \u4e2d\u95f4\u5c42 \u8fdb\u884c\u5fae\u8c03\u65f6\u7684\u534a\u76d1\u7763\u6027\u80fd\u3002","title":"\u8d21\u732e"},{"location":"cv/ssl/SimCLRv2/#_3","text":"","title":"\u65b9\u6cd5"},{"location":"cv/ssl/SimCLRv2/#_4","text":"\u672c\u6587\u4ece\u9690\u7a7a\u95f4\u7684\u5bf9\u6bd4\u635f\u5931\u6765\u6700\u5927\u5316\u540c\u4e00\u6570\u636e\u6837\u672c\u7684\u4e0d\u540c\u589e\u5f3a\u89c6\u56fe\u7684\u4e00\u81f4\u6027\u4ee5\u5b66\u4e60\u8868\u8fbe\u3002\u672c\u6846\u67b6\u7531\u56db\u4e2a\u4e3b\u8981\u90e8\u5206\u6784\u6210\u3002 \u4e00\u4e2a\u968f\u673a \u6570\u636e\u589e\u5f3a \u6a21\u5757\uff0c\u5bf9\u4efb\u4e00\u7ed9\u5b9a\u6570\u636e\u6837\u672c\u4ea7\u751f\u4e24\u4e2a\u76f8\u5173\u7684\u89c6\u56fe\uff0c\u8868\u793a\u4e3a \\tilde{x}_i \\tilde{x}_i \u548c \\tilde{x}_j \\tilde{x}_j \uff0c\u6211\u4eec\u5c06\u5176\u79f0\u4e3a\u6b63\u6837\u672c\u5bf9\u3002\u5728\u672c\u5de5\u4f5c\u4e2d\uff0c \u6211\u4eec\u987a\u5e8f\u7684\u5e94\u7528\u4e09\u4e2a\u7b80\u5355\u7684\u589e\u5f3a\uff1a\u968f\u5373\u88c1\u526a\uff08\u955c\u50cf\uff09\u5e76\u5c06\u5176\u7f29\u653e\u56de\u539f\u59cb\u5927\u5c0f\u3001\u968f\u673a\u8272\u5f69\u5931\u771f\u3001\u968f\u673a\u9ad8\u65af\u6a21\u7cca\u3002 \u5176\u4e2d\uff0c\u88c1\u526a\u548c\u989c\u8272\u5931\u771f\u7684\u7ec4\u5408\u5bf9\u6027\u80fd\u6709\u81f3\u5173\u91cd\u8981\u7684\u5f71\u54cd\u3002 \u4e00\u4e2a\u795e\u7ecf\u7f51\u7edc \u57fa\u7840\u7f16\u7801\u5668 f(\\cdot) f(\\cdot) \uff0c\u4ece\u589e\u5f3a\u540e\u7684\u6570\u636e\u6837\u672c\u4e2d\u63d0\u53d6\u51fa\u8868\u8fbe\u5411\u91cf\u3002\u672c\u6587\u7684\u6846\u67b6\u5141\u8bb8\u4f7f\u7528\u591a\u79cd\u7f51\u7edc\u7ed3\u6784\u800c\u6ca1\u6709\u9650\u5236\u3002\u672c\u6587\u51fa\u4e8e\u7b80\u5355\u7684\u8003\u91cf\u4f7f\u7528\u4e86\u5e7f\u6cdb\u4f7f\u7528\u7684ResNet\u6765\u83b7\u53d6 \\mathbf{h}_i = f(\\tilde{x}_i) = \\mathrm{ResNet}(\\tilde{x}_i) \\mathbf{h}_i = f(\\tilde{x}_i) = \\mathrm{ResNet}(\\tilde{x}_i) \uff0c\u5176\u4e2d \\mathbf{h}_i \\in \\mathbb{R}^d \\mathbf{h}_i \\in \\mathbb{R}^d \u662f\u5e73\u5747\u6c60\u5316\u5c42\u7684\u8f93\u51fa\u3002 \u4e00\u4e2a\u5c0f\u7684\u795e\u7ecf\u7f51\u7edc \u9884\u6d4b\u5934 g(\\cdot) g(\\cdot) \uff0c\u5c06\u8868\u8fbe\u6620\u5c04\u5230\u5bf9\u6bd4\u635f\u5931\u88ab\u5e94\u7528\u7684\u7a7a\u95f4\u4e0a\u3002\u672c\u6587\u4f7f\u7528\u4e00\u4e2a\u5177\u6709\u4e00\u4e2a\u9690\u85cf\u5c42\u7684MLP\u6765\u83b7\u5f97 \\mathcal{z}_i = g(\\mathbf{h}_i) = W^{(2)} \\sigma (W^{(1)} h_i) \\mathcal{z}_i = g(\\mathbf{h}_i) = W^{(2)} \\sigma (W^{(1)} h_i) \uff0c\u5176\u4e2d \\sigma \\sigma \u4ee3\u8868ReLU\u975e\u7ebf\u6027\u5c42\u3002\u6211\u4eec\u53d1\u73b0\u5728 \\mathcal{z}_i \\mathcal{z}_i \u4e0a\u5b9a\u4e49\u5bf9\u6bd4\u635f\u5931\u6bd4\u5728 \\mathbf{h}_i \\mathbf{h}_i \u4e0a\u66f4\u597d\u3002 \u4e00\u4e2a \u5bf9\u6bd4\u635f\u5931\u51fd\u6570 NT-Xent \\mathcal{l}_{i, j} = -\\log \\frac{\\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_j) / \\tau)}{\\sum^{2N}_{k=1} \\mathbf{1}_{[k \\neq i]} \\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_k) / \\tau)} \\mathcal{l}_{i, j} = -\\log \\frac{\\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_j) / \\tau)}{\\sum^{2N}_{k=1} \\mathbf{1}_{[k \\neq i]} \\exp(\\mathrm{sim}(\\mathcal{z}_i, \\mathcal{z}_k) / \\tau)} \uff0c\u5176\u4e2d N N \u4e3abatch size\uff0c \\mathrm{sim}(u, v) = u^Tv / \\left\\Vert u \\right\\Vert \\left\\Vert v \\right\\Vert \\mathrm{sim}(u, v) = u^Tv / \\left\\Vert u \\right\\Vert \\left\\Vert v \\right\\Vert \u8868\u793a \\mathcal{l}_2 \\mathcal{l}_2 \u6b63\u5219\u540e\u7684 u u \u548c v v \u7684\u70b9\u79ef\uff08\u4e5f\u5373\u4f59\u5f26\u76f8\u4f3c\u5ea6\uff09\uff0c \\mathbf{1}_{[k \\neq i]} \\mathbf{1}_{[k \\neq i]} \u4e3a\u4e00\u4e2a\u6307\u793a\u5668\u51fd\u6570\uff0c\u5f53\u4e14\u4ec5\u5f53 k \\neq i k \\neq i \u65f6\u4e3a1\uff0c \\tau \\tau \u8868\u793a\u6e29\u5ea6\u53c2\u6570\u3002 \u635f\u5931\u5728\u6240\u6709\u6b63\u6837\u672c\u5bf9\u4e0a\u88ab\u8ba1\u7b97\uff0c\u4e5f\u5373 (i, j) (i, j) \u548c (j, i) (j, i) \u3002","title":"\u6846\u67b6"},{"location":"cv/ssl/SimCLRv2/#batch-size","text":"\u6807\u51c6\u7684SGD/Momentum\u7ed3\u5408\u7ebf\u6027\u5b66\u4e60\u7387\u8c03\u6574\u5bf9\u4e8e\u8d85\u5927\u89c4\u6a21\u7f51\u7edc\u8bad\u7ec3\u6765\u8bf4\u53ef\u80fd\u4e0d\u592a\u7a33\u5b9a\u3002\u672c\u5de5\u4f5c\u4f7f\u7528LARS\u4f18\u5316\u5668\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 \u7531\u4e8e\u6b63\u6837\u672c\u5bf9\u901a\u5e38\u5728\u540c\u4e00\u5f20\u5361\u4e0a\uff0c\u6a21\u578b\u53ef\u80fd\u5229\u7528\u5c40\u90e8\u4fe1\u606f\u7684\u6cc4\u9732\u800c\u5728\u4e0d\u63d0\u5347\u8868\u8fbe\u7684\u60c5\u51b5\u4e0b\u63d0\u5347\u6027\u80fd\u3002\u672c\u6587\u901a\u8fc7\u805a\u5408BN\u7684\u5747\u503c\u548c\u65b9\u5dee\u6765\u5b9e\u73b0Global BN\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\u5176\u4ed6\u65b9\u6cd5\u8fd8\u5305\u62ec\u8de8\u8bbe\u5907\u968f\u673a\u6392\u5e03\u6570\u636e\u3001\u4f7f\u7528layer norm\u66ff\u4ee3BN\u3002","title":"\u5927batch size\u8bad\u7ec3"},{"location":"cv/ssl/SimCLRv2/#_5","text":"\u672c\u5de5\u4f5c\u5728ImageNet ILSVRC-2012\u4e0a\u8bad\u7ec3\uff0c\u6570\u636e\u589e\u5f3a\u5305\u62ec\u968f\u673a\u526a\u88c1\u5e76\u7f29\u653e\u56de\u539f\u59cb\u5927\u5c0f\uff08\u4f34\u968f\u968f\u673a\u955c\u50cf\uff09\u3001\u8272\u5f69\u5931\u771f\u548c\u9ad8\u65af\u6a21\u7cca\u3002\u6a21\u578b\u4f7f\u7528ResNet-50\u4f5c\u4e3a\u7f16\u7801\u5668\uff0c\u548c\u4e00\u4e2a2\u5c42MLP\u6620\u5c04\u5934\u6765\u5c06\u8868\u8fbe\u6620\u5c04\u5230\u4e00\u4e2a128\u7ef4\u7684\u9690\u7a7a\u95f4\u4e0a\u3002\u672c\u5de5\u4f5c\u4f7f\u7528NT-Xent\u635f\u5931\uff0c\u901a\u8fc7LARS\u8fdb\u884c\u4f18\u5316\u3002\u5b66\u4e60\u7387\u88ab\u8bbe\u7f6e\u4e3a4.8\uff08 0.3 \\times \\text{batch size} / 256 0.3 \\times \\text{batch size} / 256 \uff09\uff0cweight decay\u8bbe\u7f6e\u4e3a1e-6\u3002Batch size\u4e3a4096\uff0c\u8bad\u7ec3100\u4e2aepochs\u3002\u6b64\u5916\uff0c\u7ebf\u6027\u9884\u70ed\u5728\u524d10\u4e2aepoch\u88ab\u5e94\u7528\uff0c\u5b66\u4e60\u7387\u6309\u7167cosine decay schedule\u8870\u51cf\uff0c\u6ca1\u6709\u91cd\u542f\u3002","title":"\u5b9e\u9a8c\u8bbe\u7f6e"},{"location":"cv/ssl/SimCLRv2/#_6","text":"\u6570\u636e\u589e\u5f3a\u7684\u6784\u6210\u5bf9\u5b66\u4e60\u597d\u7684\u8868\u8fbe\u81f3\u5173\u91cd\u8981 \u76f8\u8f83\u4e8e\u76d1\u7763\u5b66\u4e60\uff0c\u5bf9\u6bd4\u5b66\u4e60\u9700\u8981\u66f4\u5f3a\u7684\u6570\u636e\u589e\u5f3a \u5bf9\u6bd4\u5b66\u4e60\u4ece\u66f4\u5927\u7684\u6a21\u578b\u4e2d\u83b7\u76ca\uff08\u66f4\u591a\uff09 \u975e\u7ebf\u6027\u6620\u5c04\u5934\u63d0\u5347\u5728\u5176\u4e4b\u524d\u7684\u8868\u8fbe\u7684\u8d28\u91cf \u6b63\u5219\u5316\u7684\u4ea4\u53c9\u71b5\u635f\u5931\u4e0e\u53ef\u8c03\u7684\u6e29\u5ea6\u53c2\u6570\u6bd4\u5176\u4ed6\u65b9\u6cd5\u6548\u679c\u66f4\u597d \u5bf9\u6bd4\u5b66\u4e60\u4ece\u66f4\u5927\u7684batch sizes\u548c\u66f4\u957f\u7684\u8bad\u7ec3\u4e2d\u83b7\u76ca\uff08\u66f4\u591a\uff09","title":"\u8ba8\u8bba"},{"location":"docker/command_line_interface/","text":"\u547d\u4ee4\u884c\u63a5\u53e3 # \u5728\u524d\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\uff0c\u6211\u4eec\u8fd0\u884c\u4e86\u6700\u7b80\u5355\u7684hello-world\u7a0b\u5e8f\u3002\u5728\u672c\u6587\u5f53\u4e2d\uff0c\u6211\u5c06\u4ecb\u7ecd\u5e38\u7528\u7684Docker\u547d\u4ee4\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e3a\u4e86\u907f\u514d\u91cd\u590d\u7684\u8ba8\u8bba\uff0c\u6211\u4eec\u5c06\u4f1a\u5728\u4e00\u4e2a\u547d\u4ee4\u5f53\u4e2d\u4f7f\u7528\u5c3d\u53ef\u80fd\u591a\u7684\u53c2\u6570\u3002\u5b9e\u9645\u751f\u4ea7\u73af\u5883\u5f53\u4e2d\uff0c\u8fd9\u4e9b\u53c2\u6570\u53ef\u80fd\u65e0\u9700\u7528\u5230\u3002 \u521b\u5efa\u5bb9\u5668 # \u9996\u5148\uff0c\u8ba9\u6211\u4eec\u518d\u521b\u5efa\u4e00\u4e2a\u5bb9\u5668\u3002 docker run -dit \\ --name=test \\ --label color=blue \\ -v <HOST-PATH>:<CONTAINER-PATH> \\ -v <VOLUME-NAME>:<CONTAINER-PATH>:ro \\ --mount type=bind,source=<HOST-PATH>,target=<CONTAINER-PATH> \\ --mount type=volume,source=<VOLUME-NAME>,target=<CONTAINER-PATH>,readonly \\ -p 127.0.0.1:81:80/tcp \\ --cpuset=\"0-1\" \\ -m 4096m \\ -e AUTHOR=\"Zhiyuan Chen\" \\ --net=\"bridge\" 10.1-cudnn7-devel-ubuntu18.04:latest \u4e0d\u8981\u62c5\u5fc3\uff0c\u6b63\u5982\u6211\u4eec\u4e4b\u524d\u8bf4\u7684\uff0c\u672c\u6587\u64b0\u5199\u8fc7\u7a0b\u5f53\u4e2d\u4f7f\u7528\u4e86\u5c3d\u53ef\u80fd\u591a\u7684\u5e38\u7528\u53c2\u6570\uff0c\u4ee5\u514d\u91cd\u590d\u8ba8\u8bba\u3002\u5b9e\u9645\u5e94\u7528\u5f53\u4e2d\u7684Docker\u547d\u4ee4\u8981\u6bd4\u8fd9\u5c0f\u8bb8\u591a\u3002\u63a5\u4e0b\u6765\uff0c\u8ba9\u6211\u4eec\u4e00\u4e2a\u4e00\u4e2a\u89e3\u91ca\u53c2\u6570\u7684\u610f\u601d\u3002 \u9996\u5148\uff0c\u4ece -dit \u5f00\u59cb\u3002 -d \u8ba9\u5bb9\u5668\u540e\u53f0\u8fd0\u884c\uff0c\u53ea\u5728\u5f00\u59cb\u8fd0\u884c\u540e\u8fd4\u56de\u4e00\u4e2a\u5bb9\u5668ID -i \u8ba9\u5bb9\u5668\u7684\u6807\u51c6\u8f93\u5165\u4fdd\u6301\u5e38\u5f00 -t \u8ba9docker\u4e3a\u5bb9\u5668\u5206\u914d\u4e00\u4e2a\u865a\u62df\u7ec8\u7aef\uff08pseudo-tty\uff09\uff0c\u5e76\u7ed1\u5b9a\u5230\u5bb9\u5668\u7684\u6807\u51c6\u8f93\u5165\u4e0a \u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u90fd\u4f1a\u4f7f\u7528 -dit \u9009\u9879\u3002\u5f53\u7136\uff0c\u5f00\u53d1\u9636\u6bb5\u5982\u679c\u9700\u8981\u5bf9\u5bb9\u5668\u8fdb\u884c\u4e00\u4e9b\u8c03\u6574\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u7701\u7565 -d \u800c\u76f4\u63a5\u4f7f\u7528 -it\u3002 \u2013name \u6307\u5b9a\u8fd9\u4e2a\u5bb9\u5668\u7684\u540d\u5b57\u3002 \u2013label \u6307\u5b9a\u8fd9\u4e2a\u5bb9\u5668\u7684\u6807\u7b7e\u3002\u6211\u4eec\u901a\u5e38\u4f1a\u6839\u636e\u5bb9\u5668\u7c7b\u578b\u6216\u8005\u5176\u4ed6\u6765\u7ed9\u5bb9\u5668\u8bbe\u7f6e\u6807\u7b7e\uff0c\u65b9\u4fbf\u65e5\u540e\u67e5\u627e\u3002\u6807\u7b7e\u770b\u4f3c\u7b80\u5355\u5b9e\u5219\u5f88\u6df1\u3002\u65e0\u8bba\u662f\u4e00\u4e2a\u5bb9\u5668\u3001\u4e00\u4e2a\u955c\u50cf\u8fd8\u662f\u4e00\u4e2a\u6570\u636e\u5377\uff0c\u751a\u81f3\u662f\u4e00\u4e2a\u5b88\u62a4\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u88ab\u6253\u4e0a\u6807\u7b7e\u3002\u60f3\u8c61\u4e00\u4e0b\uff0c\u5f53\u4f60\u6709\u6570\u4e07\u4e2a\u5bb9\u5668\u8fd0\u884c\u7684\u65f6\u5019\uff0c\u6ca1\u6709\u6b63\u786e\u7684\u5206\u7ec4\u4e00\u5b9a\u4f1a\u8ba9\u4f60\u75af\u6389\u7684\u3002\u6211\u4eec\u4f1a\u89c6\u60c5\u51b5\u5355\u5f00\u4e00\u7ae0\u8fdb\u884c\u8ba8\u8bba\u3002 -v \u548c \u2013mount \u90fd\u8868\u793a\u6302\u8f7d\u3002\u7531\u4e8e\u4e00\u4e9b\u5386\u53f2\u539f\u56e0\uff0c\u8fd9\u4e24\u4e2a\u4e1c\u897f\u4ee3\u8868\u7684\u529f\u80fd\u5b8c\u5168\u76f8\u540c\uff0c\u4f46\u8bed\u6cd5\u7565\u6709\u5dee\u5f02\u3002\u5728\u672c\u4f8b\u5f53\u4e2d\uff0c\u6211\u4eec\u5206\u522b\u901a\u8fc7 -v \u548c \u2013mount \u6302\u5728\u4e86\u4e00\u4e2a\u672c\u5730\u6587\u4ef6\u548c\u4e00\u4e2a\u6570\u636e\u5377\u5230\u5bb9\u5668\u5f53\u4e2d\uff0c\u5176\u4e2d\u6570\u636e\u5377\u5747\u88ab\u8bbe\u7f6e\u6210\u53ea\u8bfb\u3002\u53ef\u4ee5\u770b\u5230\uff0c\u76f8\u8f83\u800c\u8a00 -v \u8981\u66f4\u7b80\u6d01\u4e00\u4e9b\uff0c\u4e5f\u662f\u6211\u66f4\u63a8\u8350\u5927\u5bb6\u4f7f\u7528\u7684\u3002\u6709\u5173\u6570\u636e\u5377\u7684\u66f4\u591a\u5185\u5bb9\uff0c\u6211\u4eec\u5c06\u4f1a\u5728\u5176\u4ed6\u7ae0\u8282\u8ba8\u8bba\u3002 -p \u5c06\u5bb9\u5668\u768480\u7aef\u53e3\u7ed1\u5b9a\u5230\u4e3b\u673a127.0.0.1\u5730\u5740\u768481\u7aef\u53e3\u3002 \u2013cpuset \u6307\u5b9a\u4e86\u5bb9\u5668\u53ea\u4f7f\u7528\u524d\u4e24\u4e2a\u5904\u7406\u5668\u5185\u6838\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u548c\u5176\u4ed6\u7a0b\u5e8f\u4e00\u6837\uff0cDocker\u770b\u5230\u7684\u4e5f\u662f\u903b\u8f91\u5185\u6838\u3002 -m \u6216\u8005 \u2013memory \u8bbe\u7f6e\u4e86\u8fd9\u4e2a\u5bb9\u5668\u80fd\u4f7f\u7528\u7684\u6700\u5927\u7684\u5185\u5b58\u5927\u5c0f\uff0c\u7ed3\u5c3e\u4e00\u822c\u662fm\u6216\u8005g\u3002\u4e00\u4e2a\u5bb9\u5668\u5141\u8bb8\u8bbe\u7f6e\u7684\u6700\u5c0f\u5185\u5b58\u662f4m\u3002\u6709\u5173\u5185\u5b58\u7684\u8bbe\u7f6e\u5176\u5b9e\u6709\u4e0d\u5c11\uff0c\u6bd4\u5982 \u2013memory-swap\u3001\u2013memory-reservation \u7b49\u7b49\u3002\u6211\u4eec\u4f1a\u89c6\u60c5\u51b5\u5355\u5f00\u4e00\u7ae0\u8fdb\u884c\u8ba8\u8bba\u3002 -e \u6307\u5b9a\u73af\u5883\u53d8\u91cf\u3002 \u2013net \u6307\u5b9a\u7f51\u7edc\u7c7b\u578b\uff0c\u672c\u9009\u9879\u5728\u7edd\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u65e0\u9700\u8bbe\u7f6e\uff0c\u9ed8\u8ba4\u4e3a\u201dbridge\u201d\u3002\u6211\u4eec\u4e5f\u4f1a\u89c6\u60c5\u51b5\u5355\u5f00\u4e00\u7ae0\u8fdb\u884c\u8ba8\u8bba\u3002 \u6700\u540e\u7684\u6700\u540e\uff0c\u6211\u4eec\u8fd0\u884c\u4e86\u4e00\u4e2a\u9884\u88c5CUDA 10.1\u3001cuDNN 7\u7684ubuntu 18.04\u955c\u50cf\u3002\u5982\u679c\u4f60\u4e0d\u6253\u7b97\u5728\u4f60\u7684\u5bb9\u5668\u91cc\u8fd0\u884c\u663e\u5361\u7684\u8bdd\uff0c\u6211\u5f3a\u70c8\u5efa\u8bae\u4f60\u628a\u8fd9\u4e00\u884c\u66ff\u6362\u6210alpine:lates\u3002Ubuntu\u5b9e\u5728\u662f\u592a\u5927\u4e86\uff0c\u5982\u679c\u6ca1\u6709\u7279\u6b8a\u9700\u8981\u7684\u8bdd\uff0c\u8fd8\u662falpine\u8fd9\u79cd\u5c0f\u5bb6\u4f19\u66f4\u9002\u5408\u5bb9\u5668\u4e00\u4e9b\u3002\u6211\u4eec\u4f1a\u5728\u968f\u540e\u5355\u5f00\u4e00\u7ae0\u8fdb\u884c\u8ba8\u8bba\u3002 \u6b64\u65f6\uff0c\u7531\u4e8e\u6211\u4eec\u4e4b\u524d\u6307\u5b9a\u4e86 -d\uff0c\u4ec0\u4e48\u90fd\u4e0d\u4f1a\u53d1\u751f\uff0c\u9664\u4e86\u4e00\u4e2a\u8fd4\u56de\u7684\u5bb9\u5668ID\u3002 \u67e5\u770b\u5bb9\u5668\u5217\u8868 # docker ps -a -f since=hello-world -n 5 -a \u6216\u8005 \u2013all \u663e\u793a\u6240\u6709\u5bb9\u5668\uff0c\u9ed8\u8ba4\u53ea\u663e\u793a\u8fd0\u884c\u5f53\u4e2d\u7684\u5bb9\u5668\u3002 -f \u6216\u8005 \u2013filter \u6839\u636e\u6307\u5b9a\u6761\u4ef6\u7b5b\u9009\u5bb9\u5668\u3002\u8fd9\u4e2a\u5185\u5bb9\u6709\u70b9\u513f\u591a\uff0c\u6211\u4eec\u4f1a\u770b\u60c5\u51b5\u5355\u5f00\u4e00\u7ae0\u8fdb\u884c\u8ba8\u8bba\uff0c\u6216\u8005\u5728\u65e5\u540e\u8865\u5145\u3002 -n \u6216\u8005 \u2013lat \u53ea\u663e\u793a\u6700\u8fd1\u521b\u5efa\u7684\u4e94\u4e2a\u5bb9\u5668\u3002\u8003\u8651\u5230\u8fd9\u4e2a\u6559\u7a0b\u7684\u8fdb\u5ea6\uff0c\u4f60\u5e94\u8be5\u53ea\u80fd\u770b\u89c1\u4e00\u4e2a\uff0c\u6240\u4ee5\u52a0\u4e0e\u4e0d\u52a0\u4e5f\u6ca1\u4ec0\u4e48\u533a\u522b\u3002 \u6b64\u5916\u8fd8\u6709\u4e00\u4e9b\u5176\u4ed6\u53c2\u6570\uff0c\u6bd4\u5982 \u2013format \u4fee\u6539\u5c55\u793a\u683c\u5f0f\u3001-s \u663e\u793a\u6587\u4ef6\u5927\u5c0f\u3001-q \u53ea\u663e\u793a\u5bb9\u5668ID\u7b49\u7b49\uff0c\u6b64\u5904\u4e0d\u518d\u8d58\u8ff0\u3002 \u8fdb\u5165\u5bb9\u5668 # \u7efc\u5408\u8003\u8651\u5230\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u5bb9\u5668\u4e4b\u540e\u603b\u8981\u505a\u4e9b\u4ec0\u4e48\uff0c\u90a3\u4e48\u6211\u4eec\u9996\u5148\u9700\u8981\u8fdb\u5165\u5bb9\u5668\u3002 \u8fdb\u5165\u5bb9\u5668\u6709\u5f88\u591a\u5f88\u591a\u65b9\u6cd5\uff0c\u8003\u8651\u5230\u8981\u7d27\u8ddf\u65f6\u4ee3\u7684\u6f6e\u6d41\uff0c\u6211\u4eec\u5c06\u53ea\u8ba8\u8bba\u76ee\u524d\u8fdb\u5165\u5bb9\u5668\u7684\u65b9\u6cd5\u2013exec\u3002 docker exec -it test /bin/bash \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u4f60\u4e4b\u524d\u9009\u62e9\u4e86alpine\u7684\u8bdd\uff0c\u7531\u4e8ealpine\u5e76\u6ca1\u6709\u5185\u7f6ebash\u8fd9\u79cd\u9ad8\u7aef\u7684\u4e1c\u897f\uff08\u4ed6\u771f\u7684\u771f\u7684\u5f88\u5c0f\uff09\uff0c\u4f60\u5e94\u8be5\u628a\u6700\u540e\u4e00\u6bb5\u66ff\u6362\u6210 /bin/sh\u3002 \u6b64\u5916\uff0c\u6216\u8bb8\u4f1a\u6709\u4e9b\u4eba\u544a\u8bc9\u4f60\u6700\u540e\u4e00\u6bb5\u53ea\u9700\u8981 bash \u5c31\u597d\uff0c\u4f46\u6211\u4eec\u63d0\u5021 \u4e0d\u8981\u8fd9\u4e48\u505a \uff01\uff01\u4e0d\u8981\u5728\u65e0\u6240\u8c13\u7684\u4e1c\u897f\u4e0a\u7701\u7565\uff0c\u5c31\u8ddf\u53d8\u91cf\u540d\u957f\u70b9\u513f\u5e76\u6ca1\u6709\u4ec0\u4e48\u5173\u7cfb\uff0c\u4f46\u91cd\u70b9\u662f\u80fd\u8ba9\u4eba\u7406\u89e3\u8fd9\u4e2a\u53d8\u91cf\u91cc\u5b58\u7684\u662f\u4ec0\u4e48\u3002 \u63a5\u4e0b\u6765\uff0c\u5728\u5bb9\u5668\u91cc\u7a0d\u5fae\u73a9\u73a9\uff0c\u6bd5\u7adf\uff0c\u8fd9\u4e2a\u5bb9\u5668\u9a6c\u4e0a\u5c31\u8981\u88ab\u6740\u6389\u4e86\u3002 \u68c0\u89c6\u5bb9\u5668\u60c5\u51b5 # docker stats \u76d1\u89c6\u5bb9\u5668\u8fd0\u884c\u6d88\u8017\u4e86\u591a\u5c11\u8d44\u6e90\u3002\u8fd9\u4e2a\u6ca1\u4ec0\u4e48\u597d\u8bf4\u7684\uff0c\u5f53\u7136\u4e5f\u4e0d\u600e\u4e48\u5e38\u7528\uff0c\u4e00\u7b14\u5e26\u8fc7\u5427\u3002 \u68c0\u67e5\u70b9 # \u8fd9\u662f\u4e00\u4e2a\u5b9e\u9a8c\u6027\u529f\u80fd\uff0c\u8bf7\u4e0d\u8981\u5728\u751f\u4ea7\u73af\u5883\u5f53\u4e2d\u4f7f\u7528\uff01 \u4f7f\u7528\u672c\u547d\u4ee4\u4e4b\u524d\u9700\u5148\u6253\u5f00Docker\u7684\u5b9e\u9a8c\u6027\u529f\u80fd\uff0c\u6211\u4eec\u4f1a\u770b\u60c5\u51b5\u5355\u5f00\u4e00\u7ae0\u8fdb\u884c\u8ba8\u8bba\u3002 docker checkpoint create --checkpoint-dir <CHECKPOINT_DIR> --leave-running test CHECKPOINT \u542f\u505c\u5bb9\u5668 # docker stop test -t 10 docker start test --checkpoint-dir <CHECKPOINT_DIR> docker restart test -t 10 docker rm -f -v \u5728\u5341\u79d2\u949f\u4e4b\u540e\u5173\u95ed\u5bb9\u5668\uff0c\u52a0\u8f7d\u68c0\u67e5\u70b9\u542f\u52a8\u5bb9\u5668\uff0c\u5728\u5341\u79d2\u949f\u4e4b\u540e\u91cd\u542f\u5bb9\u5668\uff0c\u7136\u540e\u5f7b\u5e95\u5220\u6389\u5bb9\u5668\u53ca\u5176\u6240\u6302\u8f7d\u7684\u6570\u636e\u5377\uff08\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u8fd9\u4e2a\u6570\u636e\u5377\u4ecd\u6302\u8f7d\u5728\u5176\u4ed6\u5bb9\u5668\u4e0a\uff0c\u90a3\u4ed6\u5e76\u4e0d\u4f1a\u88ab\u5220\u9664\uff09\u3002 \u7ed3\u8bed \u672c\u7ae0\u6211\u4e5f\u62d6\u4e86\u5f88\u4e45\u5f88\u4e45\u3002\u5f00\u5c40\u5230\u73b0\u5728\u8fde\u7740\u6316\u4e86\u51e0\u4e2a\u5751\u90fd\u6ca1\u65f6\u95f4\u586b\uff0c\u4e8b\u60c5\u867d\u7136\u4e0d\u662f\u5f88\u591a\u4f46\u73b0\u5728\u771f\u5fc3\u6ca1\u6709\u52a8\u529b\u53bb\u505a\u3002\u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\u6211\u4eec\u4f1a\u8ba8\u8bbaDockerfile\uff0c\u5e0c\u671b\u4e0d\u4f1a\u8ba9\u4f60\u4eec\u7b49\u592a\u4e45\u3002","title":"\u547d\u4ee4\u884c\u63a5\u53e3"},{"location":"docker/command_line_interface/#_1","text":"\u5728\u524d\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\uff0c\u6211\u4eec\u8fd0\u884c\u4e86\u6700\u7b80\u5355\u7684hello-world\u7a0b\u5e8f\u3002\u5728\u672c\u6587\u5f53\u4e2d\uff0c\u6211\u5c06\u4ecb\u7ecd\u5e38\u7528\u7684Docker\u547d\u4ee4\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e3a\u4e86\u907f\u514d\u91cd\u590d\u7684\u8ba8\u8bba\uff0c\u6211\u4eec\u5c06\u4f1a\u5728\u4e00\u4e2a\u547d\u4ee4\u5f53\u4e2d\u4f7f\u7528\u5c3d\u53ef\u80fd\u591a\u7684\u53c2\u6570\u3002\u5b9e\u9645\u751f\u4ea7\u73af\u5883\u5f53\u4e2d\uff0c\u8fd9\u4e9b\u53c2\u6570\u53ef\u80fd\u65e0\u9700\u7528\u5230\u3002","title":"\u547d\u4ee4\u884c\u63a5\u53e3"},{"location":"docker/command_line_interface/#_2","text":"\u9996\u5148\uff0c\u8ba9\u6211\u4eec\u518d\u521b\u5efa\u4e00\u4e2a\u5bb9\u5668\u3002 docker run -dit \\ --name=test \\ --label color=blue \\ -v <HOST-PATH>:<CONTAINER-PATH> \\ -v <VOLUME-NAME>:<CONTAINER-PATH>:ro \\ --mount type=bind,source=<HOST-PATH>,target=<CONTAINER-PATH> \\ --mount type=volume,source=<VOLUME-NAME>,target=<CONTAINER-PATH>,readonly \\ -p 127.0.0.1:81:80/tcp \\ --cpuset=\"0-1\" \\ -m 4096m \\ -e AUTHOR=\"Zhiyuan Chen\" \\ --net=\"bridge\" 10.1-cudnn7-devel-ubuntu18.04:latest \u4e0d\u8981\u62c5\u5fc3\uff0c\u6b63\u5982\u6211\u4eec\u4e4b\u524d\u8bf4\u7684\uff0c\u672c\u6587\u64b0\u5199\u8fc7\u7a0b\u5f53\u4e2d\u4f7f\u7528\u4e86\u5c3d\u53ef\u80fd\u591a\u7684\u5e38\u7528\u53c2\u6570\uff0c\u4ee5\u514d\u91cd\u590d\u8ba8\u8bba\u3002\u5b9e\u9645\u5e94\u7528\u5f53\u4e2d\u7684Docker\u547d\u4ee4\u8981\u6bd4\u8fd9\u5c0f\u8bb8\u591a\u3002\u63a5\u4e0b\u6765\uff0c\u8ba9\u6211\u4eec\u4e00\u4e2a\u4e00\u4e2a\u89e3\u91ca\u53c2\u6570\u7684\u610f\u601d\u3002 \u9996\u5148\uff0c\u4ece -dit \u5f00\u59cb\u3002 -d \u8ba9\u5bb9\u5668\u540e\u53f0\u8fd0\u884c\uff0c\u53ea\u5728\u5f00\u59cb\u8fd0\u884c\u540e\u8fd4\u56de\u4e00\u4e2a\u5bb9\u5668ID -i \u8ba9\u5bb9\u5668\u7684\u6807\u51c6\u8f93\u5165\u4fdd\u6301\u5e38\u5f00 -t \u8ba9docker\u4e3a\u5bb9\u5668\u5206\u914d\u4e00\u4e2a\u865a\u62df\u7ec8\u7aef\uff08pseudo-tty\uff09\uff0c\u5e76\u7ed1\u5b9a\u5230\u5bb9\u5668\u7684\u6807\u51c6\u8f93\u5165\u4e0a \u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u90fd\u4f1a\u4f7f\u7528 -dit \u9009\u9879\u3002\u5f53\u7136\uff0c\u5f00\u53d1\u9636\u6bb5\u5982\u679c\u9700\u8981\u5bf9\u5bb9\u5668\u8fdb\u884c\u4e00\u4e9b\u8c03\u6574\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u7701\u7565 -d \u800c\u76f4\u63a5\u4f7f\u7528 -it\u3002 \u2013name \u6307\u5b9a\u8fd9\u4e2a\u5bb9\u5668\u7684\u540d\u5b57\u3002 \u2013label \u6307\u5b9a\u8fd9\u4e2a\u5bb9\u5668\u7684\u6807\u7b7e\u3002\u6211\u4eec\u901a\u5e38\u4f1a\u6839\u636e\u5bb9\u5668\u7c7b\u578b\u6216\u8005\u5176\u4ed6\u6765\u7ed9\u5bb9\u5668\u8bbe\u7f6e\u6807\u7b7e\uff0c\u65b9\u4fbf\u65e5\u540e\u67e5\u627e\u3002\u6807\u7b7e\u770b\u4f3c\u7b80\u5355\u5b9e\u5219\u5f88\u6df1\u3002\u65e0\u8bba\u662f\u4e00\u4e2a\u5bb9\u5668\u3001\u4e00\u4e2a\u955c\u50cf\u8fd8\u662f\u4e00\u4e2a\u6570\u636e\u5377\uff0c\u751a\u81f3\u662f\u4e00\u4e2a\u5b88\u62a4\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u88ab\u6253\u4e0a\u6807\u7b7e\u3002\u60f3\u8c61\u4e00\u4e0b\uff0c\u5f53\u4f60\u6709\u6570\u4e07\u4e2a\u5bb9\u5668\u8fd0\u884c\u7684\u65f6\u5019\uff0c\u6ca1\u6709\u6b63\u786e\u7684\u5206\u7ec4\u4e00\u5b9a\u4f1a\u8ba9\u4f60\u75af\u6389\u7684\u3002\u6211\u4eec\u4f1a\u89c6\u60c5\u51b5\u5355\u5f00\u4e00\u7ae0\u8fdb\u884c\u8ba8\u8bba\u3002 -v \u548c \u2013mount \u90fd\u8868\u793a\u6302\u8f7d\u3002\u7531\u4e8e\u4e00\u4e9b\u5386\u53f2\u539f\u56e0\uff0c\u8fd9\u4e24\u4e2a\u4e1c\u897f\u4ee3\u8868\u7684\u529f\u80fd\u5b8c\u5168\u76f8\u540c\uff0c\u4f46\u8bed\u6cd5\u7565\u6709\u5dee\u5f02\u3002\u5728\u672c\u4f8b\u5f53\u4e2d\uff0c\u6211\u4eec\u5206\u522b\u901a\u8fc7 -v \u548c \u2013mount \u6302\u5728\u4e86\u4e00\u4e2a\u672c\u5730\u6587\u4ef6\u548c\u4e00\u4e2a\u6570\u636e\u5377\u5230\u5bb9\u5668\u5f53\u4e2d\uff0c\u5176\u4e2d\u6570\u636e\u5377\u5747\u88ab\u8bbe\u7f6e\u6210\u53ea\u8bfb\u3002\u53ef\u4ee5\u770b\u5230\uff0c\u76f8\u8f83\u800c\u8a00 -v \u8981\u66f4\u7b80\u6d01\u4e00\u4e9b\uff0c\u4e5f\u662f\u6211\u66f4\u63a8\u8350\u5927\u5bb6\u4f7f\u7528\u7684\u3002\u6709\u5173\u6570\u636e\u5377\u7684\u66f4\u591a\u5185\u5bb9\uff0c\u6211\u4eec\u5c06\u4f1a\u5728\u5176\u4ed6\u7ae0\u8282\u8ba8\u8bba\u3002 -p \u5c06\u5bb9\u5668\u768480\u7aef\u53e3\u7ed1\u5b9a\u5230\u4e3b\u673a127.0.0.1\u5730\u5740\u768481\u7aef\u53e3\u3002 \u2013cpuset \u6307\u5b9a\u4e86\u5bb9\u5668\u53ea\u4f7f\u7528\u524d\u4e24\u4e2a\u5904\u7406\u5668\u5185\u6838\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u548c\u5176\u4ed6\u7a0b\u5e8f\u4e00\u6837\uff0cDocker\u770b\u5230\u7684\u4e5f\u662f\u903b\u8f91\u5185\u6838\u3002 -m \u6216\u8005 \u2013memory \u8bbe\u7f6e\u4e86\u8fd9\u4e2a\u5bb9\u5668\u80fd\u4f7f\u7528\u7684\u6700\u5927\u7684\u5185\u5b58\u5927\u5c0f\uff0c\u7ed3\u5c3e\u4e00\u822c\u662fm\u6216\u8005g\u3002\u4e00\u4e2a\u5bb9\u5668\u5141\u8bb8\u8bbe\u7f6e\u7684\u6700\u5c0f\u5185\u5b58\u662f4m\u3002\u6709\u5173\u5185\u5b58\u7684\u8bbe\u7f6e\u5176\u5b9e\u6709\u4e0d\u5c11\uff0c\u6bd4\u5982 \u2013memory-swap\u3001\u2013memory-reservation \u7b49\u7b49\u3002\u6211\u4eec\u4f1a\u89c6\u60c5\u51b5\u5355\u5f00\u4e00\u7ae0\u8fdb\u884c\u8ba8\u8bba\u3002 -e \u6307\u5b9a\u73af\u5883\u53d8\u91cf\u3002 \u2013net \u6307\u5b9a\u7f51\u7edc\u7c7b\u578b\uff0c\u672c\u9009\u9879\u5728\u7edd\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u65e0\u9700\u8bbe\u7f6e\uff0c\u9ed8\u8ba4\u4e3a\u201dbridge\u201d\u3002\u6211\u4eec\u4e5f\u4f1a\u89c6\u60c5\u51b5\u5355\u5f00\u4e00\u7ae0\u8fdb\u884c\u8ba8\u8bba\u3002 \u6700\u540e\u7684\u6700\u540e\uff0c\u6211\u4eec\u8fd0\u884c\u4e86\u4e00\u4e2a\u9884\u88c5CUDA 10.1\u3001cuDNN 7\u7684ubuntu 18.04\u955c\u50cf\u3002\u5982\u679c\u4f60\u4e0d\u6253\u7b97\u5728\u4f60\u7684\u5bb9\u5668\u91cc\u8fd0\u884c\u663e\u5361\u7684\u8bdd\uff0c\u6211\u5f3a\u70c8\u5efa\u8bae\u4f60\u628a\u8fd9\u4e00\u884c\u66ff\u6362\u6210alpine:lates\u3002Ubuntu\u5b9e\u5728\u662f\u592a\u5927\u4e86\uff0c\u5982\u679c\u6ca1\u6709\u7279\u6b8a\u9700\u8981\u7684\u8bdd\uff0c\u8fd8\u662falpine\u8fd9\u79cd\u5c0f\u5bb6\u4f19\u66f4\u9002\u5408\u5bb9\u5668\u4e00\u4e9b\u3002\u6211\u4eec\u4f1a\u5728\u968f\u540e\u5355\u5f00\u4e00\u7ae0\u8fdb\u884c\u8ba8\u8bba\u3002 \u6b64\u65f6\uff0c\u7531\u4e8e\u6211\u4eec\u4e4b\u524d\u6307\u5b9a\u4e86 -d\uff0c\u4ec0\u4e48\u90fd\u4e0d\u4f1a\u53d1\u751f\uff0c\u9664\u4e86\u4e00\u4e2a\u8fd4\u56de\u7684\u5bb9\u5668ID\u3002","title":"\u521b\u5efa\u5bb9\u5668"},{"location":"docker/command_line_interface/#_3","text":"docker ps -a -f since=hello-world -n 5 -a \u6216\u8005 \u2013all \u663e\u793a\u6240\u6709\u5bb9\u5668\uff0c\u9ed8\u8ba4\u53ea\u663e\u793a\u8fd0\u884c\u5f53\u4e2d\u7684\u5bb9\u5668\u3002 -f \u6216\u8005 \u2013filter \u6839\u636e\u6307\u5b9a\u6761\u4ef6\u7b5b\u9009\u5bb9\u5668\u3002\u8fd9\u4e2a\u5185\u5bb9\u6709\u70b9\u513f\u591a\uff0c\u6211\u4eec\u4f1a\u770b\u60c5\u51b5\u5355\u5f00\u4e00\u7ae0\u8fdb\u884c\u8ba8\u8bba\uff0c\u6216\u8005\u5728\u65e5\u540e\u8865\u5145\u3002 -n \u6216\u8005 \u2013lat \u53ea\u663e\u793a\u6700\u8fd1\u521b\u5efa\u7684\u4e94\u4e2a\u5bb9\u5668\u3002\u8003\u8651\u5230\u8fd9\u4e2a\u6559\u7a0b\u7684\u8fdb\u5ea6\uff0c\u4f60\u5e94\u8be5\u53ea\u80fd\u770b\u89c1\u4e00\u4e2a\uff0c\u6240\u4ee5\u52a0\u4e0e\u4e0d\u52a0\u4e5f\u6ca1\u4ec0\u4e48\u533a\u522b\u3002 \u6b64\u5916\u8fd8\u6709\u4e00\u4e9b\u5176\u4ed6\u53c2\u6570\uff0c\u6bd4\u5982 \u2013format \u4fee\u6539\u5c55\u793a\u683c\u5f0f\u3001-s \u663e\u793a\u6587\u4ef6\u5927\u5c0f\u3001-q \u53ea\u663e\u793a\u5bb9\u5668ID\u7b49\u7b49\uff0c\u6b64\u5904\u4e0d\u518d\u8d58\u8ff0\u3002","title":"\u67e5\u770b\u5bb9\u5668\u5217\u8868"},{"location":"docker/command_line_interface/#_4","text":"\u7efc\u5408\u8003\u8651\u5230\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u5bb9\u5668\u4e4b\u540e\u603b\u8981\u505a\u4e9b\u4ec0\u4e48\uff0c\u90a3\u4e48\u6211\u4eec\u9996\u5148\u9700\u8981\u8fdb\u5165\u5bb9\u5668\u3002 \u8fdb\u5165\u5bb9\u5668\u6709\u5f88\u591a\u5f88\u591a\u65b9\u6cd5\uff0c\u8003\u8651\u5230\u8981\u7d27\u8ddf\u65f6\u4ee3\u7684\u6f6e\u6d41\uff0c\u6211\u4eec\u5c06\u53ea\u8ba8\u8bba\u76ee\u524d\u8fdb\u5165\u5bb9\u5668\u7684\u65b9\u6cd5\u2013exec\u3002 docker exec -it test /bin/bash \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u4f60\u4e4b\u524d\u9009\u62e9\u4e86alpine\u7684\u8bdd\uff0c\u7531\u4e8ealpine\u5e76\u6ca1\u6709\u5185\u7f6ebash\u8fd9\u79cd\u9ad8\u7aef\u7684\u4e1c\u897f\uff08\u4ed6\u771f\u7684\u771f\u7684\u5f88\u5c0f\uff09\uff0c\u4f60\u5e94\u8be5\u628a\u6700\u540e\u4e00\u6bb5\u66ff\u6362\u6210 /bin/sh\u3002 \u6b64\u5916\uff0c\u6216\u8bb8\u4f1a\u6709\u4e9b\u4eba\u544a\u8bc9\u4f60\u6700\u540e\u4e00\u6bb5\u53ea\u9700\u8981 bash \u5c31\u597d\uff0c\u4f46\u6211\u4eec\u63d0\u5021 \u4e0d\u8981\u8fd9\u4e48\u505a \uff01\uff01\u4e0d\u8981\u5728\u65e0\u6240\u8c13\u7684\u4e1c\u897f\u4e0a\u7701\u7565\uff0c\u5c31\u8ddf\u53d8\u91cf\u540d\u957f\u70b9\u513f\u5e76\u6ca1\u6709\u4ec0\u4e48\u5173\u7cfb\uff0c\u4f46\u91cd\u70b9\u662f\u80fd\u8ba9\u4eba\u7406\u89e3\u8fd9\u4e2a\u53d8\u91cf\u91cc\u5b58\u7684\u662f\u4ec0\u4e48\u3002 \u63a5\u4e0b\u6765\uff0c\u5728\u5bb9\u5668\u91cc\u7a0d\u5fae\u73a9\u73a9\uff0c\u6bd5\u7adf\uff0c\u8fd9\u4e2a\u5bb9\u5668\u9a6c\u4e0a\u5c31\u8981\u88ab\u6740\u6389\u4e86\u3002","title":"\u8fdb\u5165\u5bb9\u5668"},{"location":"docker/command_line_interface/#_5","text":"docker stats \u76d1\u89c6\u5bb9\u5668\u8fd0\u884c\u6d88\u8017\u4e86\u591a\u5c11\u8d44\u6e90\u3002\u8fd9\u4e2a\u6ca1\u4ec0\u4e48\u597d\u8bf4\u7684\uff0c\u5f53\u7136\u4e5f\u4e0d\u600e\u4e48\u5e38\u7528\uff0c\u4e00\u7b14\u5e26\u8fc7\u5427\u3002","title":"\u68c0\u89c6\u5bb9\u5668\u60c5\u51b5"},{"location":"docker/command_line_interface/#_6","text":"\u8fd9\u662f\u4e00\u4e2a\u5b9e\u9a8c\u6027\u529f\u80fd\uff0c\u8bf7\u4e0d\u8981\u5728\u751f\u4ea7\u73af\u5883\u5f53\u4e2d\u4f7f\u7528\uff01 \u4f7f\u7528\u672c\u547d\u4ee4\u4e4b\u524d\u9700\u5148\u6253\u5f00Docker\u7684\u5b9e\u9a8c\u6027\u529f\u80fd\uff0c\u6211\u4eec\u4f1a\u770b\u60c5\u51b5\u5355\u5f00\u4e00\u7ae0\u8fdb\u884c\u8ba8\u8bba\u3002 docker checkpoint create --checkpoint-dir <CHECKPOINT_DIR> --leave-running test CHECKPOINT","title":"\u68c0\u67e5\u70b9"},{"location":"docker/command_line_interface/#_7","text":"docker stop test -t 10 docker start test --checkpoint-dir <CHECKPOINT_DIR> docker restart test -t 10 docker rm -f -v \u5728\u5341\u79d2\u949f\u4e4b\u540e\u5173\u95ed\u5bb9\u5668\uff0c\u52a0\u8f7d\u68c0\u67e5\u70b9\u542f\u52a8\u5bb9\u5668\uff0c\u5728\u5341\u79d2\u949f\u4e4b\u540e\u91cd\u542f\u5bb9\u5668\uff0c\u7136\u540e\u5f7b\u5e95\u5220\u6389\u5bb9\u5668\u53ca\u5176\u6240\u6302\u8f7d\u7684\u6570\u636e\u5377\uff08\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u8fd9\u4e2a\u6570\u636e\u5377\u4ecd\u6302\u8f7d\u5728\u5176\u4ed6\u5bb9\u5668\u4e0a\uff0c\u90a3\u4ed6\u5e76\u4e0d\u4f1a\u88ab\u5220\u9664\uff09\u3002 \u7ed3\u8bed \u672c\u7ae0\u6211\u4e5f\u62d6\u4e86\u5f88\u4e45\u5f88\u4e45\u3002\u5f00\u5c40\u5230\u73b0\u5728\u8fde\u7740\u6316\u4e86\u51e0\u4e2a\u5751\u90fd\u6ca1\u65f6\u95f4\u586b\uff0c\u4e8b\u60c5\u867d\u7136\u4e0d\u662f\u5f88\u591a\u4f46\u73b0\u5728\u771f\u5fc3\u6ca1\u6709\u52a8\u529b\u53bb\u505a\u3002\u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\u6211\u4eec\u4f1a\u8ba8\u8bbaDockerfile\uff0c\u5e0c\u671b\u4e0d\u4f1a\u8ba9\u4f60\u4eec\u7b49\u592a\u4e45\u3002","title":"\u542f\u505c\u5bb9\u5668"},{"location":"docker/dockerfile/","text":"Dockerfile # Dockerfile\u53ef\u4ee5\u8bf4\u662fDocker\u6700\u91cd\u8981\u7684\u4e00\u90e8\u5206\u3002Docker\u4f9d\u636eDockerfile\u7684\u63cf\u8ff0\u6784\u5efa\u51fa\u4e00\u4e2a\u53c8\u4e00\u4e2aDocker\u955c\u50cf\uff0c\u4f7f\u4e4b\u5f97\u4ee5\u8fd0\u884c\u3002\u4e5f\u662f\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u8f6f\u4ef6\u4ea4\u4ed8\u4ece\u6570\u5341GiB\u7684\u4ee3\u7801\u7f29\u51cf\u5230\u6570\u767eKiB\u3002 \u672c\u6587\u5c06\u7b80\u8981\u4ecb\u7ecdDockerfile\u7684\u5185\u5bb9\uff0c\u5e76\u5c06\u5bf9nvidia/cuda:10.1-cudnn7-devel-ubuntu18.04\u7684Dockerfile\u8fdb\u884c\u5206\u6790\u3002 \u6307\u4ee4 # \u9996\u5148\uff0c\u6211\u4eec\u4eceDockerfile\u7684\u6307\u4ee4\u5f00\u59cb\u3002Dockerfile\u6709\u5341\u51e0\u79cd\u6307\u4ee4\uff0c\u5176\u4e2d\u53ea\u6709\u516d\u79cd\u6307\u4ee4\u4f1a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5c42\u3002\u4ed6\u4eec\u662f**ADD**\u3001 CMD \u3001 COPY \u3001 ENTRYPOINT \u3001 FROM**\u548c**RUN \u3002\u8fd9\u516d\u79cd\u6307\u4ee4\u5728\u8fd0\u884c\u5f53\u4e2d\u4f1a\u521b\u5efa\u65b0\u7684\u5c42\uff0c\u5728\u5b9e\u8df5\u8fc7\u7a0b\u5f53\u4e2d\u6211\u4eec\u9700\u8981\u7279\u522b\u5173\u6ce8\u8fd9\u4e9b\u6307\u4ee4\uff0c\u9519\u8bef\u7684\u4f7f\u7528\u8fd9\u4e9b\u6307\u4ee4\u5c06\u53ef\u80fd\u9020\u6210\u5bb9\u5668\u672a\u6309\u671f\u5f85\u8fd0\u884c\u3002\u5bf9\u4e8e\u5176\u4ed6\u6240\u6709\u6307\u4ee4\uff0cDocker\u90fd\u5c06\u53ea\u4f1a\u6784\u5efa\u4e00\u4e2a\u4e2d\u95f4\u955c\u50cf\uff0c\u8fd9\u65e2\u4e0d\u4f1a\u589e\u52a0\u5bb9\u5668\u7684\u5927\u5c0f\uff0c\u4e5f\u4e0d\u4f1a\u5bf9\u5bb9\u5668\u7684\u6027\u80fd\u4ea7\u751f\u4efb\u4f55\u5f71\u54cd\u3002 FROM # FROM <image>[:<tag>] [AS <name>] FROM <image>[@<digest>] [AS <name>] \u901a\u5e38\u60c5\u51b5\u4e0b\uff0cDockerfile\u7684\u7b2c\u4e00\u884c\u662fFROM\uff0c\u4e5f\u5373\u4ee3\u8868\u5176\u5c06\u57fa\u4e8e\u4e00\u4e2a\u53e6\u4e00\u4e2aDocker\uff08\u5f53\u7136\uff0c\u6781\u5c11\u6570\u60c5\u51b5\u4e0b\u4e5f\u53ef\u80fd\u662fscratch\uff09\u6784\u5efa\u3002\u4f60\u53ef\u4ee5\u5c06\u5176\u7406\u89e3\u4e3a\u7ee7\u627f\u2013\u5b50\u7c7b\u5c06\u5b9e\u73b0\u7236\u7c7b\u7684\u5168\u90e8\u529f\u80fd\u3002\u5982\u679c\u4f60\u5e0c\u671b\u5bf9\u4f60\u7684\u5bb9\u5668\u5177\u6709\u5b8c\u5168\u7684\u638c\u63a7\u7684\u8bdd\uff0c\u4f60\u4e5f\u53ef\u4ee5\u7701\u7565\u6389FROM\u6216\u8005\u76f4\u63a5FROM scratch\u6765\u6784\u5efa\u4e00\u4e2a\u57fa\u955c\u50cf\u3002\u8fd9\u5c06\u5f88\u53ef\u80fd\u8017\u53bb\u4f60\u5927\u91cf\u7684\u7cbe\u529b\u5374\u65e0\u6cd5\u5e26\u6765\u4efb\u4f55\u6536\u76ca\uff0c\u6211\u4eec\u5f3a\u70c8\u63a8\u8350\u4f60\u4e0d\u8981\u8fd9\u4e48\u505a\uff0c\u9664\u975e\u4f60\u5f88\u786e\u5b9a\u4f60\u81ea\u5df1\u60f3\u505a\u4e9b\u4ec0\u4e48\u3002 \u5728\u4e0a\u53e4\u65f6\u4ee3\uff08Docker 17.05\u4e4b\u524d\uff09\uff0cDocker\u662f\u4e0d\u652f\u6301\u591a\u4e2aFROM\u8bed\u53e5\u7684\u3002\u5373Docker\u662f\u5355\u4e00\u7ee7\u627f\u7684\u3002\u4f46Docker 17.05\u6dfb\u52a0\u4e86\u591a\u9636\u6bb5\u6784\u5efa\uff08multi-stage builds\uff09\u3002\u5982\u679c\u4f60\u5728\u5bb9\u5668\u5f53\u4e2d\u9700\u8981\u7f16\u8bd1\u4ec0\u4e48\u4e1c\u897f\u7684\u8bdd\uff0c\u4f7f\u7528\u591a\u9636\u6bb5\u6784\u5efa\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5bb9\u5668\u8fdb\u884c\u7f16\u8bd1\u5e76\u5c06\u7ed3\u679c\u590d\u5236\u5230\u672c\u5bb9\u5668\u5f53\u4e2d\u5c06\u5bf9\u4e8e\u964d\u4f4e\u5bb9\u5668\u5927\u5c0f\u975e\u5e38\u6709\u5229\u3002\u6211\u4eec\u4f1a\u5728\u7a0d\u540e\u7684\u4f8b\u5b50\u5f53\u4e2d\u8fdb\u884c\u6f14\u793a\u3002 LABEL # LABEL <key>=<value> LABEL\u5bf9\u955c\u50cf\u8fdb\u884c\u6807\u7b7e\uff0c\u8fd9\u4e2a\u4f3c\u4e4e\u6ca1\u4ec0\u4e48\u9700\u8981\u591a\u8bf4\u7684\u3002 ARG \u548c ENV # ARG <name>[=<default value>] ENV <key> <value> ENV <key>=<value> ARG\u6307\u4ee4\u8bbe\u7f6e\u53c2\u6570\uff0c\u53c2\u6570\u53ea\u80fd\u5728\u6784\u5efa\u955c\u50cf\u65f6\u4f7f\u7528\uff0c\u955c\u50cf\u521b\u5efa\u5b8c\u6bd5\u5373\u4e22\u5931\u3002ENV\u6307\u4ee4\u8bbe\u7f6e\u7684\u5219\u662f\u73af\u5883\u53d8\u91cf\uff0c\u5728\u5bb9\u5668\u521b\u5efa\u597d\u540e\u4ecd\u7136\u5b58\u5728\u3002\u8fd9\u4e24\u4e2a\u6307\u4ee4\u90fd\u5bf9\u63a5\u4e0b\u6765\u7684ADD\u3001CMD\u3001COPY\u3001ENV\u3001EXPOSE\u3001ENTRYPOINT\u3001FROM\u3001LABEL\u3001RUN\u3001STOPSIGNAL\u3001USER\u3001VOLUME\u548cWORKDIR\u751f\u6548\u3002\u6b64\u5916\uff0c\u5bf9\u4e8eDocker 1.4\u4e4b\u540e\u7684\u7248\u672c\u6765\u8bf4\uff0c\u5982\u679cONBUILD\u4e0e\u4e0a\u8ff0\u5341\u4e2a\u6307\u4ee4\u8054\u7528\uff0c\u90a3\u4ed6\u4eec\u4e5f\u5c06\u5bf9ONBUILD\u6307\u4ee4\u751f\u6548\u3002\u5bf9\u4e8eDocker 1.13\u4e4b\u540e\u7684\u7248\u672c\u6765\u8bf4\uff0c\u5982\u679c docker build \u2013build-arg \u4f20\u9012\u7684\u53c2\u6570\u5728Dockerfile\u5f53\u4e2d\u6ca1\u6709\u4f7f\u7528\uff0cDocker\u5c06\u4f1a\u4ea7\u751f\u5982\u4e0b\u8b66\u544a\uff1a [Warning] One or more build-args [foo] were not consumed. \u8fd9\u4e24\u4e2a\u6307\u4ee4\u7684\u533a\u522b\u4e3b\u8981\u5728\u4e8e\u4f5c\u7528\u57df\u3002\u5982\u679c\u9700\u8981\u5728\u6784\u5efa\u955c\u50cf\u65f6\u521b\u5efa\u73af\u5883\u53d8\u91cf\uff0c\u4e5f\u53ef\u8fd9\u4e48\u5199\uff1a ARG ZC=\"Zhiyuan Chen\" ENV ${ZC} Docker\u6709\u5982\u4e0b\u7684\u9884\u5b9a\u4e49\u53c2\u6570\uff0c\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\uff1a HTTP_PROXY http_proxy HTTPS_PROXY https_proxy FTP_PROXY ftp_proxy NO_PROXY no_proxy \u6b64\u5916\uff0cARG\u662f\u552f\u4e00\u4e00\u4e2a\u5141\u8bb8\u5728\u7b2c\u4e00\u4e2a FROM \u6307\u4ee4\u4e4b\u524d\u51fa\u73b0\u7684\u6307\u4ee4\u3002 WORKDIR \u548c USER # WORKDIR /path/to/workdir USER <user>[:<group>] USER <UID>[:<GID>] WORKDIR\u6307\u4ee4\u8bbe\u7f6e\u5f53\u524d\u7684\u5de5\u4f5c\u76ee\u5f55\u3002\u8be5\u6307\u4ee4\u5c06\u5bf9\u63a5\u4e0b\u6765\u7684ADD\u3001CMD\u3001COPY\u3001ENTRYPOINT\u548cRUN\u6307\u4ee4\u4ea7\u751f\u5f71\u54cd\u3002 USER\u6307\u4ee4\u8bbe\u7f6e\u5f53\u524d\u7684\u64cd\u4f5c\u7528\u6237\u3002\u8be5\u6307\u4ee4\u5c06\u5bf9\u63a5\u4e0b\u6765\u7684RUN\u3001CMD\u548cENTRYPOINT\u6307\u4ee4\u4ea7\u751f\u5f71\u54cd\u3002 RUN # RUN <command> RUN [\"executable\", \"param1\", \"param2\"] RUN\u6307\u4ee4\u6709\u4e24\u79cd\u683c\u5f0f\uff0c\u7b2c\u4e00\u79cd\u662fshell\u683c\u5f0f\uff0c\u5728Linux\u7cfb\u7edf\u4e0b\u9ed8\u8ba4\u4f7f\u7528 /bin/sh -c \uff0c \u5728Windows\u7cfb\u7edf\u4e0b\u5219\u9ed8\u8ba4\u4f7f\u7528 cmd /S /C \u3002\u7b2c\u4e8c\u79cd\u5219\u662fexec\u683c\u5f0f\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5728exec\u683c\u5f0f\u4e4b\u4e0b\uff0c\u5c06\u7531shell\u6765\u5904\u7406\u73af\u5883\u53d8\u91cf\u800c\u4e0d\u662fDocker\uff0c\u6240\u4ee5\u5728Dockerfile\u5f53\u4e2d\u5b9a\u4e49\u7684\u73af\u5883\u53d8\u91cf\u901a\u5e38\u65e0\u6548\u3002\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u7b2c\u4e8c\u79cd\u683c\u5f0f\uff0c\u9664\u975e\u5fc5\u987b\u663e\u5f0f\u6307\u5b9ashell\u3002 RUN\u5e94\u8be5\u662f\u4f7f\u7528\u6700\u591a\u7684Dockerfile\u6307\u4ee4\u4e86\uff0c\u65e0\u8bba\u662f\u4e0b\u8f7d\u8fd8\u662f\u8fd0\u884c\uff0c\u4e00\u5207\u90fd\u5c11\u4e0d\u4e86RUN\u7684\u5e55\u540e\u9ed1\u624b\u3002\u8fd9\u4e5f\u5bfc\u81f4RUN\u6210\u4e86\u6700\u5bb9\u6613\u51fa\u9519\u7684\u5730\u65b9\u3002 **&&**\u5173\u952e\u5b57\u5141\u8bb8\u4f60\u5728\u4e00\u4e2aRUN\u5f53\u4e2d\u6267\u884c\u591a\u6761\u547d\u4ee4\u3002\u7531\u4e8eRUN\u6307\u4ee4\u6267\u884c\u7684\u8fc7\u7a0b\u5f53\u4e2d\u4f1a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5c42\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u6309\u7167\u9700\u6c42\u5bf9\u6307\u4ee4\u8fdb\u884c\u5408\u5e76\u6216\u8005\u62c6\u5206\u3002 \u6bd4\u5982\u8bf4\u5728\u521d\u59cb\u7684apt-get\u5f53\u4e2d\uff0c\u5982\u679c\u6211\u4eec\u9519\u8bef\u7684\u5c06\u6307\u4ee4\u62c6\u5206\u6210\uff1a RUN apt-get update # layer x RUN apt-get install -y git # layer x + 1 \u90a3\u4e48\u5728\u6267\u884c\u5b8c\u7b2c\u4e00\u4e2a\u6307\u4ee4\u4e4b\u540e\uff0cx\u5c42\u5c31\u4f1a\u88ab\u7f13\u5b58\u4e0b\u6765\uff0c\u968f\u540e\u5018\u82e5\u6211\u4eec\u5bf9\u7b2c\u4e8c\u884c\u6307\u4ee4\u8fdb\u884c\u66f4\u6539\uff0c\u90a3\u4ed6\u53ef\u80fd\u5c31\u4f1a\u83b7\u53d6\u5230\u8fc7\u65f6\u7684\u8f6f\u4ef6\u3002\u56e0\u6b64\uff0capt-get\u4e00\u5b9a\u8981\u5199\u6210\u5982\u4e0b\u5f62\u5f0f\uff1a RUN apt-get update && apt-get install -y \\ git COPY \u548c ADD # COPY [--chown=<user>:<group>] <src>... <dest> COPY <src> <dest> \u8fd9\u4e24\u4e2a\u6307\u4ee4\u7684\u529f\u80fd\u975e\u5e38\u76f8\u4f3c\uff0c\u90fd\u662f\u5c06\u6587\u4ef6\u4ece\u5bb9\u5668\u4e4b\u5916\u590d\u5236\u5230\u5bb9\u5668\u4e4b\u5185\u3002\u4f46COPY\u6307\u4ee4\u66f4\u7b80\u5355\u4e5f\u66f4\u900f\u660e\u4e00\u4e9b\uff0c\u4e5f\u66f4\u7ecf\u5e38\u88ab\u4f7f\u7528\u3002ADD\u6307\u4ee4\u589e\u52a0\u4e86\u5bf9url\u7684\u652f\u6301\u4f7f\u5f97\u5176\u53ef\u4ee5\u4ece\u7f51\u4e0a\u4e0b\u8f7d\u6587\u4ef6\uff0c\u540c\u65f6\u5b83\u4e5f\u53ef\u4ee5\u76f4\u63a5\u5c06\u6587\u4ef6\u89e3\u538b\u3002\u4f46\u662f\u7531\u4e8eADD\u6307\u4ee4\u4ece\u7f51\u4e0a\u4e0b\u8f7d\u7684\u6587\u4ef6\u4f1a\u81ea\u52a8\u8bbe\u7f6e\u6743\u9650\u4e3a600\uff0c\u800c\u8c03\u6574\u6743\u9650\u8fd8\u9700\u8981\u4e00\u4e2aRUN\u6307\u4ee4\u3002\u4e0d\u5982\u76f4\u63a5\u901a\u8fc7RUN\u4e0b\u8f7d\u6587\u4ef6\u6765\u7684\u65b9\u4fbf\u3002\u56e0\u6b64\uff0c\u8bf7\u53ea\u5728\u9700\u8981\u89e3\u538b\u6587\u4ef6\u7684\u65f6\u5019\u624d\u4f7f\u7528ADD\u6307\u4ee4\u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c \u4e3a\u6e90\u4e8eDockfile\u6240\u5728\u6587\u4ef6\u5939\u7684\u76f8\u5bf9\u8def\u5f84\uff0c \u5219\u662f\u76ee\u6807\u5bb9\u5668\u5185\u7684\u7edd\u5bf9\u8def\u5f84\u3002\u6b64\u5916\uff0c\u8fd9\u4e24\u4e2a\u6307\u4ee4\u540c\u65f6\u652f\u6301\u901a\u914d\u7b26\uff0c\u5373 COPY zc* /usr/local/docker \u5c06\u4f1a\u628a\u5f53\u524d\u76ee\u5f55\u4e0b\u6240\u6709\u4ee5zc\u5f00\u5934\u7684\u6587\u4ef6\u590d\u5236\u5230\u5bb9\u5668\u7684/usr/local/docker\u76ee\u5f55\u5f53\u4e2d\u3002 EXPOSE # EXPOSE <port> [<port>/<protocol>...] EXPOSE\u6307\u4ee4\u66b4\u9732\u5bb9\u5668\u5bf9\u5e94\u7684\u7aef\u53e3\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cEXPOSE\u6307\u4ee4\u5c06\u5047\u8bbeTCP\u534f\u8bae\uff0c\u5982\u679c\u4f7f\u7528UDP\u534f\u8bae\u9700\u8981\u663e\u5f0f\u58f0\u660e\u3002 VOLUME # VOLUME [\"/zc\"] VOLUME\u6307\u4ee4\u548c\u524d\u6587\u6240\u8ff0\u7684\u4f7f\u7528 docker run -v \u4f46\u53ea\u6307\u5b9a\u5bb9\u5668\u5185\u76ee\u5f55\u5b8c\u5168\u4e00\u6837\u3002\u4ed6\u4f1a\u7ed9\u8fd9\u4e2a\u6302\u8f7d\u968f\u673a\u4e00\u4e2a\u540d\u5b57\uff0c\u7136\u540e\u518d\u672c\u673a/var/lib/docker/volumes\u76ee\u5f55\u4e4b\u4e0b\u521b\u5efa\u4e00\u4e2a\u4e0e\u6302\u8f7d\u540d\u5b57\u76f8\u540c\u7684\u6587\u4ef6\u5939\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u867d\u7136\u5b83\u7684\u540d\u5b57\u53eb\u5377\uff0c\u4f46\u521b\u5efa\u7684\u5b9e\u9645\u4e0a\u662f\u4e00\u4e2a\u6346\u7ed1\u6302\u8f7d\u2026\u2026\u8fd9\u4e2a\u6307\u4ee4\u6211\u4ece\u6765\u6ca1\u6709\u7528\u8fc7\uff0c\u8fd8\u4e13\u95e8\u4e3a\u8fd9\u7bc7\u6587\u7ae0\u67e5\u4e86\u534a\u5929\u8d44\u6599\u987a\u5e26\u505a\u4e86\u4e24\u4e2a\u5b9e\u9a8c\u3002\u6211\u5b8c\u5168\u65e0\u6cd5\u7406\u89e3\u8fd9\u79cd\u8bbe\u8ba1\u7684\u7528\u610f\uff0c\u4e5f\u5f3a\u70c8\u5efa\u8bae\u5927\u5bb6\u90fd\u4e0d\u8981\u4f7f\u7528\u3002docker run \u547d\u4ee4\u591a\u6253\u4e24\u53e5\u80fd\u5b9e\u73b0\u7684\u8981\u6bd4\u4ed6\u4f18\u96c5\u7684\u591a\uff0c\u5efa\u8bae\u4f7f\u7528\u3002\u503c\u5f97\u4e00\u63d0\u7684\u662f\uff0c\u5982\u679c\u5728VOLUME\u91cc\u548c\u5728 docker run \u91cc\u540c\u65f6\u6302\u8f7d\u4e86\u76ee\u5f55\uff0c\u5219\u53ea\u6709 docker run \u6302\u8f7d\u7684\u76ee\u5f55\u4f1a\u751f\u6548\u3002 HEALTHCHECK \u548c STOPSIGNAL # HEALTHCHECK [OPTIONS] CMD command HEALTHCHECK NONE STOPSIGNAL signal HEALTHCHECK\u6307\u4ee4\u544a\u8bc9\u5bb9\u5668\u5982\u4f55\u8fd0\u884c\u5065\u5eb7\u68c0\u67e5\u3002\u5982\u679c\u5bb9\u5668\u7684Dockerfile\u4e2d\u6307\u5b9a\u4e86HEALTHCHECK\u65b9\u6cd5\uff0c\u5728\u8fd0\u884c docker ps \u547d\u4ee4\u65f6\uff0c\u5bb9\u5668\u7684\u72b6\u6001\u4e00\u680f\u4e2d\u4f1a\u663e\u793a\u5bb9\u5668\u5f53\u524d\u662f\u5426\u5065\u5eb7\u3002 STOPSIGNAL\u6307\u4ee4\u91cd\u5199\u5728 docker stop \u547d\u4ee4\u6267\u884c\u65f6\u53d1\u9001\u7ed9\u5bb9\u5668\u7684\u4fe1\u53f7\u3002 HEALTHCHECK\u6307\u4ee4\u6709\u5982\u4e0b\u53c2\u6570\uff1a --interval=DURATION # \u4e24\u6b21\u5065\u5eb7\u68c0\u67e5\u7684\u95f4\u9694\uff0c\u9ed8\u8ba430\u79d2\u3002 --timeout=DURATION # \u5065\u5eb7\u68c0\u67e5\u7684\u8d85\u65f6\uff0c\u9ed8\u8ba430\u79d2\u3002 --start-period=DURATION # \u5bb9\u5668\u542f\u52a8\u591a\u4e45\u4e4b\u540e\u5f00\u59cb\u5065\u5eb7\u68c0\u67e5\uff0c\u9ed8\u8ba40\u79d2\u3002 --retries=N # \u5065\u5eb7\u68c0\u67e5\u5931\u8d25\u4e4b\u540e\u663e\u793a\u5bb9\u5668\u4e0d\u5065\u5eb7\u65f6\u7ecf\u8fc7\u591a\u5c11\u6b21\u91cd\u8bd5\uff0c\u9ed8\u8ba43\u6b21\u3002 ONBUILD # ONBUILD [INSTRUCTION] ONBUILD\u6307\u4ee4\u540e\u8ddf\u5176\u4ed6\u6307\u4ee4\u3002ONBUILD\u6307\u4ee4\u7684\u5185\u5bb9\u5c06\u4e0d\u4f1a\u5728\u8fd9\u4e2aDocker\u6784\u5efa\u7684\u65f6\u5019\u6267\u884c\uff0c\u4f46\u662f\u5982\u679c\u5176\u4ed6Docker\u7ee7\u627f\u8fd9\u4e2aDocker\uff0cONBUILD\u540e\u8ddf\u7684\u6307\u4ee4\u4f1a\u5728FROM\u7ed3\u675f\u4e4b\u540e\u7acb\u5373\u6267\u884c\u3002 CMD \u548c ENTRYPOINT # CMD [\"executable\",\"param1\",\"param2\"] CMD command param1 param2 CMD [\"param1\",\"param2\"] ENTRYPOINT [\"executable\", \"param1\", \"param2\"] ENTRYPOINT command param1 param2 CMD\u6307\u4ee4\u548cENTRYPOINT\u6307\u4ee4\u51e0\u4e4e\u6ca1\u6709\u533a\u522b\uff0c\u4ed6\u4eec\u7684\u4f5c\u7528\u90fd\u662f\u5728\u5bb9\u5668\u6784\u5efa\u4e4b\u540e\u6267\u884c\u5176\u4e2d\u7684\u547d\u4ee4\u3002\u4ed6\u4eec\u4e5f\u90fd\u6709\u4e24\u79cd\u683c\u5f0f\u2013shell\u548cexec\uff0c\u6b63\u5982RUN\u6307\u4ee4\u4e00\u6837\u3002\u533a\u522b\u5728\u4e8eCMD\u6307\u4ee4\u591a\u4e00\u79cd\u53c2\u6570\u6a21\u5f0f\uff0c\u5728\u53c2\u6570\u6a21\u5f0f\u4e0b\uff0cCMD\u6307\u4ee4\u540e\u8ddf\u7684\u53c2\u6570\u5c06\u4f5c\u4e3a\u9ed8\u8ba4\u53c2\u6570\u4f20\u9012\u7ed9ENTRYPOINT\u6307\u4ee4\u6267\u884c\u3002\u5373\u4e0b\u5217\u4e24\u4e2a\u6307\u4ee4\u5728\u5b9e\u9645\u4e0a\u662f\u7b49\u4ef7\u7684\uff1a ENTRYPOINT [\"/start.sh\"] CMD [\"aptly\", \"api\", \"serve\"] ENTRYPOINT[\"/start.sh\", \"aptly\", \"api\", \"serve\"] \u4ed6\u4eec\u7684\u533a\u522b\u9664\u6b64\u4e4b\u5916\u4e3b\u8981\u5728\u4e8eCMD\u6307\u4ee4\u4f1a\u66f4\u5bb9\u6613\u7684\u5728 docker run \u547d\u4ee4\u5f53\u4e2d\u88ab\u91cd\u5199\uff0c\u800cENTRYPOINT\u9700\u8981\u663e\u5f0f\u6307\u5b9a \u2013entrypoint \u53c2\u6570\u624d\u80fd\u91cd\u5199\u3002 ENTRYPOINT\u6307\u4ee4\u548cCMD\u6307\u4ee4\u4e4b\u95f4\u7684\u5177\u4f53\u533a\u522b\u5728\u7f51\u4e0a\u4e94\u82b1\u516b\u95e8\uff0c\u5374\u5f88\u5c11\u6709\u6b63\u786e\u7684\u3002\u53ef\u4ee5\u80af\u5b9a\u7684\u662f\uff0cENTRYPOINT\u6307\u4ee4\u7684\u4f18\u5148\u7ea7\u8981\u6bd4CMD\u6307\u4ee4\u66f4\u9ad8\u3002\u8fd9\u91cc\u6309\u7167Docker\u5b98\u65b9\u7684\u8bf4\u6cd5\uff1a \u4f7f\u7528\u5bb9\u5668\u4f5c\u4e3a\u53ef\u6267\u884c\u6587\u4ef6\u65f6\uff0c\u5e94\u4f7f\u7528ENTRYPOINT\u6307\u4ee4\u3002CMD\u5e94\u5f53\u88ab\u7528\u4e8e\u4e3aENTRYPOINT\u6307\u4ee4\u63d0\u4f9b\u9ed8\u8ba4\u53c2\u6570\uff0c\u6216\u5728\u5bb9\u5668\u4e2d\u6267\u884cad-hoc\u547d\u4ee4\u3002 \u4e0b\u8868\u5217\u51fa\u4e86ENTRYPOINT\u6307\u4ee4\u548cCMD\u6307\u4ee4\u4e0d\u540c\u7ec4\u5408\u65f6\u7684\u5b9e\u9645\u6267\u884c\u60c5\u51b5\uff1a No ENTRYPOINT ENTRYPOINT exec_entry p1_entry ENTRYPOINT [\u201cexec_entry\u201d, \u201cp1_entry\u201d] No CMD error, not allowed /bin/sh -c exec_entry p1_entry exec_entry p1_entry CMD [\u201cexec_cmd\u201d, \u201cp1_cmd\u201d] exec_cmd p1_cmd /bin/sh -c exec_entry p1_entry exec_entry p1_entry exec_cmd p1_cmd CMD [\u201cp1_cmd\u201d, \u201cp2_cmd\u201d] p1_cmd p2_cmd /bin/sh -c exec_entry p1_entry exec_entry p1_entry p1_cmd p2_cmd CMD exec_cmd p1_cmd /bin/sh -c exec_cmd p1_cmd /bin/sh -c exec_entry p1_entry exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd \u6700\u540e\uff0c\u8fd8\u6709\u4e00\u70b9\u9700\u8981\u5f3a\u8c03\uff1a Dockerfile\u5e94\u81f3\u5c11\u6307\u5b9a\u4e00\u4e2aCMD\u6216ENTRYPOINT\u6307\u4ee4\uff01 \u5206\u6790 # \u4e86\u89e3\u4e86Docerfile\u7684\u7ec4\u6210\u90e8\u5206\uff0c\u8ba9\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0b\u522b\u4eba\u5bb6\u90fd\u662f\u600e\u4e48\u5199Dockerfile\u7684\u3002\u4ee5\u4e0b\u662fnvidia/cuda:10.1-cudnn7-devel-ubuntu18.04\u53ca\u5176\u7ee7\u627f\u7684Dockerfile\u3002 10.1-cudnn7-devel-ubuntu18.04 # ARG IMAGE_NAME FROM ${IMAGE_NAME}:10.1-devel-ubuntu18.04 LABEL maintainer \"NVIDIA CORPORATION <cudatools@nvidia.com>\" ENV CUDNN_VERSION 7.6.3.30 LABEL com.nvidia.cudnn.version=\"${CUDNN_VERSION}\" RUN apt-get update && apt-get install -y --no-install-recommends \\ libcudnn7=$CUDNN_VERSION-1+cuda10.1 \\ libcudnn7-dev=$CUDNN_VERSION-1+cuda10.1 \\ && \\ apt-mark hold libcudnn7 && \\ rm -rf /var/lib/apt/lists/* \u9996\u5148\uff0c\u7b2c\u4e00\u884cARG\u6307\u4ee4\u63cf\u8ff0\u4e86\u955c\u50cf\u7684\u540d\u5b57\uff0c\u5e76\u5728\u968f\u540e\u7684FROM\u6307\u4ee4\u5f53\u4e2d\u5e94\u7528\u5230\u3002 nvidia/cuda\u7684Dockerfile\u90fd\u662f\u5c42\u5c42\u7ee7\u627f\u7684\uff0c\u8fd9\u975e\u5e38\u503c\u5f97\u5b66\u4e60\u3002 10.1-devel-ubuntu18.04 # ARG IMAGE_NAME FROM ${IMAGE_NAME}:10.1-runtime-ubuntu18.04 LABEL maintainer \"NVIDIA CORPORATION <cudatools@nvidia.com>\" RUN apt-get update && apt-get install -y --no-install-recommends \\ cuda-nvml-dev-$CUDA_PKG_VERSION \\ cuda-command-line-tools-$CUDA_PKG_VERSION \\ cuda-libraries-dev-$CUDA_PKG_VERSION \\ cuda-minimal-build-$CUDA_PKG_VERSION \\ libnccl-dev=$NCCL_VERSION-1+cuda10.1 \\ && \\ rm -rf /var/lib/apt/lists/* ENV LIBRARY_PATH /usr/local/cuda/lib64/stubs 10.1-runtime-ubuntu18.04 # ARG IMAGE_NAME FROM ${IMAGE_NAME}:10.1-base-ubuntu18.04 LABEL maintainer \"NVIDIA CORPORATION <cudatools@nvidia.com>\" ENV NCCL_VERSION 2.4.8 RUN apt-get update && apt-get install -y --no-install-recommends \\ cuda-libraries-$CUDA_PKG_VERSION \\ cuda-nvtx-$CUDA_PKG_VERSION \\ libnccl2=$NCCL_VERSION-1+cuda10.1 && \\ apt-mark hold libnccl2 && \\ rm -rf /var/lib/apt/lists/* 10.1-base-ubuntu18.04 # FROM ubuntu:18.04 LABEL maintainer \"NVIDIA CORPORATION <cudatools@nvidia.com>\" RUN apt-get update && apt-get install -y --no-install-recommends \\ gnupg2 curl ca-certificates && \\ curl -fsSL https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/7fa2af80.pub | apt-key add - && \\ echo \"deb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64 /\" > /etc/apt/sources.list.d/cuda.list && \\ echo \"deb https://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1804/x86_64 /\" > /etc/apt/sources.list.d/nvidia-ml.list && \\ apt-get purge --autoremove -y curl && \\ rm -rf /var/lib/apt/lists/* ENV CUDA_VERSION 10.1.243 ENV CUDA_PKG_VERSION 10-1=$CUDA_VERSION-1 # For libraries in the cuda-compat-* package: https://docs.nvidia.com/cuda/eula/index.html#attachment-a RUN apt-get update && apt-get install -y --no-install-recommends \\ cuda-cudart-$CUDA_PKG_VERSION \\ cuda-compat-10-1 && \\ ln -s cuda-10.1 /usr/local/cuda && \\ rm -rf /var/lib/apt/lists/* # Required for nvidia-docker v1 RUN echo \"/usr/local/nvidia/lib\" >> /etc/ld.so.conf.d/nvidia.conf && \\ echo \"/usr/local/nvidia/lib64\" >> /etc/ld.so.conf.d/nvidia.conf ENV PATH /usr/local/nvidia/bin:/usr/local/cuda/bin:${PATH} ENV LD_LIBRARY_PATH /usr/local/nvidia/lib:/usr/local/nvidia/lib64 # nvidia-container-runtime ENV NVIDIA_VISIBLE_DEVICES all ENV NVIDIA_DRIVER_CAPABILITIES compute,utility ENV NVIDIA_REQUIRE_CUDA \"cuda>=10.1 brand=tesla,driver>=384,driver<385 brand=tesla,driver>=396,driver<397 brand=tesla,driver>=410,driver<411\" ubuntu:18.04 # FROM scratch ADD ubuntu-bionic-core-cloudimg-amd64-root.tar.gz / # verify that the APT lists files do not exist RUN [ -z \"$(apt-get indextargets)\" ] # (see https://bugs.launchpad.net/cloud-images/+bug/1699913) # a few minor docker-specific tweaks # see https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap RUN set -xe \\ \\ # https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L40-L48 && echo '#!/bin/sh' > /usr/sbin/policy-rc.d \\ && echo 'exit 101' >> /usr/sbin/policy-rc.d \\ && chmod +x /usr/sbin/policy-rc.d \\ \\ # https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L54-L56 && dpkg-divert --local --rename --add /sbin/initctl \\ && cp -a /usr/sbin/policy-rc.d /sbin/initctl \\ && sed -i 's/^exit.*/exit 0/' /sbin/initctl \\ \\ # https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L71-L78 && echo 'force-unsafe-io' > /etc/dpkg/dpkg.cfg.d/docker-apt-speedup \\ \\ # https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L85-L105 && echo 'DPkg::Post-Invoke { \"rm -f /var/cache/apt/archives/*.deb /var/cache/apt/archives/partial/*.deb /var/cache/apt/*.bin || true\"; };' > /etc/apt/apt.conf.d/docker-clean \\ && echo 'APT::Update::Post-Invoke { \"rm -f /var/cache/apt/archives/*.deb /var/cache/apt/archives/partial/*.deb /var/cache/apt/*.bin || true\"; };' >> /etc/apt/apt.conf.d/docker-clean \\ && echo 'Dir::Cache::pkgcache \"\"; Dir::Cache::srcpkgcache \"\";' >> /etc/apt/apt.conf.d/docker-clean \\ \\ # https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L109-L115 && echo 'Acquire::Languages \"none\";' > /etc/apt/apt.conf.d/docker-no-languages \\ \\ # https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L118-L130 && echo 'Acquire::GzipIndexes \"true\"; Acquire::CompressionTypes::Order:: \"gz\";' > /etc/apt/apt.conf.d/docker-gzip-indexes \\ \\ # https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L134-L151 && echo 'Apt::AutoRemove::SuggestsImportant \"false\";' > /etc/apt/apt.conf.d/docker-autoremove-suggests # make systemd-detect-virt return \"docker\" # See: https://github.com/systemd/systemd/blob/aa0c34279ee40bce2f9681b496922dedbadfca19/src/basic/virt.c#L434 RUN mkdir -p /run/systemd && echo 'docker' > /run/systemd/container # overwrite this with 'CMD []' in a dependent Dockerfile CMD [\"/bin/bash\"]","title":"Dockerfile"},{"location":"docker/dockerfile/#dockerfile","text":"Dockerfile\u53ef\u4ee5\u8bf4\u662fDocker\u6700\u91cd\u8981\u7684\u4e00\u90e8\u5206\u3002Docker\u4f9d\u636eDockerfile\u7684\u63cf\u8ff0\u6784\u5efa\u51fa\u4e00\u4e2a\u53c8\u4e00\u4e2aDocker\u955c\u50cf\uff0c\u4f7f\u4e4b\u5f97\u4ee5\u8fd0\u884c\u3002\u4e5f\u662f\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u8f6f\u4ef6\u4ea4\u4ed8\u4ece\u6570\u5341GiB\u7684\u4ee3\u7801\u7f29\u51cf\u5230\u6570\u767eKiB\u3002 \u672c\u6587\u5c06\u7b80\u8981\u4ecb\u7ecdDockerfile\u7684\u5185\u5bb9\uff0c\u5e76\u5c06\u5bf9nvidia/cuda:10.1-cudnn7-devel-ubuntu18.04\u7684Dockerfile\u8fdb\u884c\u5206\u6790\u3002","title":"Dockerfile"},{"location":"docker/dockerfile/#_1","text":"\u9996\u5148\uff0c\u6211\u4eec\u4eceDockerfile\u7684\u6307\u4ee4\u5f00\u59cb\u3002Dockerfile\u6709\u5341\u51e0\u79cd\u6307\u4ee4\uff0c\u5176\u4e2d\u53ea\u6709\u516d\u79cd\u6307\u4ee4\u4f1a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5c42\u3002\u4ed6\u4eec\u662f**ADD**\u3001 CMD \u3001 COPY \u3001 ENTRYPOINT \u3001 FROM**\u548c**RUN \u3002\u8fd9\u516d\u79cd\u6307\u4ee4\u5728\u8fd0\u884c\u5f53\u4e2d\u4f1a\u521b\u5efa\u65b0\u7684\u5c42\uff0c\u5728\u5b9e\u8df5\u8fc7\u7a0b\u5f53\u4e2d\u6211\u4eec\u9700\u8981\u7279\u522b\u5173\u6ce8\u8fd9\u4e9b\u6307\u4ee4\uff0c\u9519\u8bef\u7684\u4f7f\u7528\u8fd9\u4e9b\u6307\u4ee4\u5c06\u53ef\u80fd\u9020\u6210\u5bb9\u5668\u672a\u6309\u671f\u5f85\u8fd0\u884c\u3002\u5bf9\u4e8e\u5176\u4ed6\u6240\u6709\u6307\u4ee4\uff0cDocker\u90fd\u5c06\u53ea\u4f1a\u6784\u5efa\u4e00\u4e2a\u4e2d\u95f4\u955c\u50cf\uff0c\u8fd9\u65e2\u4e0d\u4f1a\u589e\u52a0\u5bb9\u5668\u7684\u5927\u5c0f\uff0c\u4e5f\u4e0d\u4f1a\u5bf9\u5bb9\u5668\u7684\u6027\u80fd\u4ea7\u751f\u4efb\u4f55\u5f71\u54cd\u3002","title":"\u6307\u4ee4"},{"location":"docker/dockerfile/#from","text":"FROM <image>[:<tag>] [AS <name>] FROM <image>[@<digest>] [AS <name>] \u901a\u5e38\u60c5\u51b5\u4e0b\uff0cDockerfile\u7684\u7b2c\u4e00\u884c\u662fFROM\uff0c\u4e5f\u5373\u4ee3\u8868\u5176\u5c06\u57fa\u4e8e\u4e00\u4e2a\u53e6\u4e00\u4e2aDocker\uff08\u5f53\u7136\uff0c\u6781\u5c11\u6570\u60c5\u51b5\u4e0b\u4e5f\u53ef\u80fd\u662fscratch\uff09\u6784\u5efa\u3002\u4f60\u53ef\u4ee5\u5c06\u5176\u7406\u89e3\u4e3a\u7ee7\u627f\u2013\u5b50\u7c7b\u5c06\u5b9e\u73b0\u7236\u7c7b\u7684\u5168\u90e8\u529f\u80fd\u3002\u5982\u679c\u4f60\u5e0c\u671b\u5bf9\u4f60\u7684\u5bb9\u5668\u5177\u6709\u5b8c\u5168\u7684\u638c\u63a7\u7684\u8bdd\uff0c\u4f60\u4e5f\u53ef\u4ee5\u7701\u7565\u6389FROM\u6216\u8005\u76f4\u63a5FROM scratch\u6765\u6784\u5efa\u4e00\u4e2a\u57fa\u955c\u50cf\u3002\u8fd9\u5c06\u5f88\u53ef\u80fd\u8017\u53bb\u4f60\u5927\u91cf\u7684\u7cbe\u529b\u5374\u65e0\u6cd5\u5e26\u6765\u4efb\u4f55\u6536\u76ca\uff0c\u6211\u4eec\u5f3a\u70c8\u63a8\u8350\u4f60\u4e0d\u8981\u8fd9\u4e48\u505a\uff0c\u9664\u975e\u4f60\u5f88\u786e\u5b9a\u4f60\u81ea\u5df1\u60f3\u505a\u4e9b\u4ec0\u4e48\u3002 \u5728\u4e0a\u53e4\u65f6\u4ee3\uff08Docker 17.05\u4e4b\u524d\uff09\uff0cDocker\u662f\u4e0d\u652f\u6301\u591a\u4e2aFROM\u8bed\u53e5\u7684\u3002\u5373Docker\u662f\u5355\u4e00\u7ee7\u627f\u7684\u3002\u4f46Docker 17.05\u6dfb\u52a0\u4e86\u591a\u9636\u6bb5\u6784\u5efa\uff08multi-stage builds\uff09\u3002\u5982\u679c\u4f60\u5728\u5bb9\u5668\u5f53\u4e2d\u9700\u8981\u7f16\u8bd1\u4ec0\u4e48\u4e1c\u897f\u7684\u8bdd\uff0c\u4f7f\u7528\u591a\u9636\u6bb5\u6784\u5efa\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5bb9\u5668\u8fdb\u884c\u7f16\u8bd1\u5e76\u5c06\u7ed3\u679c\u590d\u5236\u5230\u672c\u5bb9\u5668\u5f53\u4e2d\u5c06\u5bf9\u4e8e\u964d\u4f4e\u5bb9\u5668\u5927\u5c0f\u975e\u5e38\u6709\u5229\u3002\u6211\u4eec\u4f1a\u5728\u7a0d\u540e\u7684\u4f8b\u5b50\u5f53\u4e2d\u8fdb\u884c\u6f14\u793a\u3002","title":"FROM"},{"location":"docker/dockerfile/#label","text":"LABEL <key>=<value> LABEL\u5bf9\u955c\u50cf\u8fdb\u884c\u6807\u7b7e\uff0c\u8fd9\u4e2a\u4f3c\u4e4e\u6ca1\u4ec0\u4e48\u9700\u8981\u591a\u8bf4\u7684\u3002","title":"LABEL"},{"location":"docker/dockerfile/#arg-env","text":"ARG <name>[=<default value>] ENV <key> <value> ENV <key>=<value> ARG\u6307\u4ee4\u8bbe\u7f6e\u53c2\u6570\uff0c\u53c2\u6570\u53ea\u80fd\u5728\u6784\u5efa\u955c\u50cf\u65f6\u4f7f\u7528\uff0c\u955c\u50cf\u521b\u5efa\u5b8c\u6bd5\u5373\u4e22\u5931\u3002ENV\u6307\u4ee4\u8bbe\u7f6e\u7684\u5219\u662f\u73af\u5883\u53d8\u91cf\uff0c\u5728\u5bb9\u5668\u521b\u5efa\u597d\u540e\u4ecd\u7136\u5b58\u5728\u3002\u8fd9\u4e24\u4e2a\u6307\u4ee4\u90fd\u5bf9\u63a5\u4e0b\u6765\u7684ADD\u3001CMD\u3001COPY\u3001ENV\u3001EXPOSE\u3001ENTRYPOINT\u3001FROM\u3001LABEL\u3001RUN\u3001STOPSIGNAL\u3001USER\u3001VOLUME\u548cWORKDIR\u751f\u6548\u3002\u6b64\u5916\uff0c\u5bf9\u4e8eDocker 1.4\u4e4b\u540e\u7684\u7248\u672c\u6765\u8bf4\uff0c\u5982\u679cONBUILD\u4e0e\u4e0a\u8ff0\u5341\u4e2a\u6307\u4ee4\u8054\u7528\uff0c\u90a3\u4ed6\u4eec\u4e5f\u5c06\u5bf9ONBUILD\u6307\u4ee4\u751f\u6548\u3002\u5bf9\u4e8eDocker 1.13\u4e4b\u540e\u7684\u7248\u672c\u6765\u8bf4\uff0c\u5982\u679c docker build \u2013build-arg \u4f20\u9012\u7684\u53c2\u6570\u5728Dockerfile\u5f53\u4e2d\u6ca1\u6709\u4f7f\u7528\uff0cDocker\u5c06\u4f1a\u4ea7\u751f\u5982\u4e0b\u8b66\u544a\uff1a [Warning] One or more build-args [foo] were not consumed. \u8fd9\u4e24\u4e2a\u6307\u4ee4\u7684\u533a\u522b\u4e3b\u8981\u5728\u4e8e\u4f5c\u7528\u57df\u3002\u5982\u679c\u9700\u8981\u5728\u6784\u5efa\u955c\u50cf\u65f6\u521b\u5efa\u73af\u5883\u53d8\u91cf\uff0c\u4e5f\u53ef\u8fd9\u4e48\u5199\uff1a ARG ZC=\"Zhiyuan Chen\" ENV ${ZC} Docker\u6709\u5982\u4e0b\u7684\u9884\u5b9a\u4e49\u53c2\u6570\uff0c\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\uff1a HTTP_PROXY http_proxy HTTPS_PROXY https_proxy FTP_PROXY ftp_proxy NO_PROXY no_proxy \u6b64\u5916\uff0cARG\u662f\u552f\u4e00\u4e00\u4e2a\u5141\u8bb8\u5728\u7b2c\u4e00\u4e2a FROM \u6307\u4ee4\u4e4b\u524d\u51fa\u73b0\u7684\u6307\u4ee4\u3002","title":"ARG \u548c ENV"},{"location":"docker/dockerfile/#workdir-user","text":"WORKDIR /path/to/workdir USER <user>[:<group>] USER <UID>[:<GID>] WORKDIR\u6307\u4ee4\u8bbe\u7f6e\u5f53\u524d\u7684\u5de5\u4f5c\u76ee\u5f55\u3002\u8be5\u6307\u4ee4\u5c06\u5bf9\u63a5\u4e0b\u6765\u7684ADD\u3001CMD\u3001COPY\u3001ENTRYPOINT\u548cRUN\u6307\u4ee4\u4ea7\u751f\u5f71\u54cd\u3002 USER\u6307\u4ee4\u8bbe\u7f6e\u5f53\u524d\u7684\u64cd\u4f5c\u7528\u6237\u3002\u8be5\u6307\u4ee4\u5c06\u5bf9\u63a5\u4e0b\u6765\u7684RUN\u3001CMD\u548cENTRYPOINT\u6307\u4ee4\u4ea7\u751f\u5f71\u54cd\u3002","title":"WORKDIR \u548c USER"},{"location":"docker/dockerfile/#run","text":"RUN <command> RUN [\"executable\", \"param1\", \"param2\"] RUN\u6307\u4ee4\u6709\u4e24\u79cd\u683c\u5f0f\uff0c\u7b2c\u4e00\u79cd\u662fshell\u683c\u5f0f\uff0c\u5728Linux\u7cfb\u7edf\u4e0b\u9ed8\u8ba4\u4f7f\u7528 /bin/sh -c \uff0c \u5728Windows\u7cfb\u7edf\u4e0b\u5219\u9ed8\u8ba4\u4f7f\u7528 cmd /S /C \u3002\u7b2c\u4e8c\u79cd\u5219\u662fexec\u683c\u5f0f\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5728exec\u683c\u5f0f\u4e4b\u4e0b\uff0c\u5c06\u7531shell\u6765\u5904\u7406\u73af\u5883\u53d8\u91cf\u800c\u4e0d\u662fDocker\uff0c\u6240\u4ee5\u5728Dockerfile\u5f53\u4e2d\u5b9a\u4e49\u7684\u73af\u5883\u53d8\u91cf\u901a\u5e38\u65e0\u6548\u3002\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4e0d\u4f1a\u4f7f\u7528\u7b2c\u4e8c\u79cd\u683c\u5f0f\uff0c\u9664\u975e\u5fc5\u987b\u663e\u5f0f\u6307\u5b9ashell\u3002 RUN\u5e94\u8be5\u662f\u4f7f\u7528\u6700\u591a\u7684Dockerfile\u6307\u4ee4\u4e86\uff0c\u65e0\u8bba\u662f\u4e0b\u8f7d\u8fd8\u662f\u8fd0\u884c\uff0c\u4e00\u5207\u90fd\u5c11\u4e0d\u4e86RUN\u7684\u5e55\u540e\u9ed1\u624b\u3002\u8fd9\u4e5f\u5bfc\u81f4RUN\u6210\u4e86\u6700\u5bb9\u6613\u51fa\u9519\u7684\u5730\u65b9\u3002 **&&**\u5173\u952e\u5b57\u5141\u8bb8\u4f60\u5728\u4e00\u4e2aRUN\u5f53\u4e2d\u6267\u884c\u591a\u6761\u547d\u4ee4\u3002\u7531\u4e8eRUN\u6307\u4ee4\u6267\u884c\u7684\u8fc7\u7a0b\u5f53\u4e2d\u4f1a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5c42\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u6309\u7167\u9700\u6c42\u5bf9\u6307\u4ee4\u8fdb\u884c\u5408\u5e76\u6216\u8005\u62c6\u5206\u3002 \u6bd4\u5982\u8bf4\u5728\u521d\u59cb\u7684apt-get\u5f53\u4e2d\uff0c\u5982\u679c\u6211\u4eec\u9519\u8bef\u7684\u5c06\u6307\u4ee4\u62c6\u5206\u6210\uff1a RUN apt-get update # layer x RUN apt-get install -y git # layer x + 1 \u90a3\u4e48\u5728\u6267\u884c\u5b8c\u7b2c\u4e00\u4e2a\u6307\u4ee4\u4e4b\u540e\uff0cx\u5c42\u5c31\u4f1a\u88ab\u7f13\u5b58\u4e0b\u6765\uff0c\u968f\u540e\u5018\u82e5\u6211\u4eec\u5bf9\u7b2c\u4e8c\u884c\u6307\u4ee4\u8fdb\u884c\u66f4\u6539\uff0c\u90a3\u4ed6\u53ef\u80fd\u5c31\u4f1a\u83b7\u53d6\u5230\u8fc7\u65f6\u7684\u8f6f\u4ef6\u3002\u56e0\u6b64\uff0capt-get\u4e00\u5b9a\u8981\u5199\u6210\u5982\u4e0b\u5f62\u5f0f\uff1a RUN apt-get update && apt-get install -y \\ git","title":"RUN"},{"location":"docker/dockerfile/#copy-add","text":"COPY [--chown=<user>:<group>] <src>... <dest> COPY <src> <dest> \u8fd9\u4e24\u4e2a\u6307\u4ee4\u7684\u529f\u80fd\u975e\u5e38\u76f8\u4f3c\uff0c\u90fd\u662f\u5c06\u6587\u4ef6\u4ece\u5bb9\u5668\u4e4b\u5916\u590d\u5236\u5230\u5bb9\u5668\u4e4b\u5185\u3002\u4f46COPY\u6307\u4ee4\u66f4\u7b80\u5355\u4e5f\u66f4\u900f\u660e\u4e00\u4e9b\uff0c\u4e5f\u66f4\u7ecf\u5e38\u88ab\u4f7f\u7528\u3002ADD\u6307\u4ee4\u589e\u52a0\u4e86\u5bf9url\u7684\u652f\u6301\u4f7f\u5f97\u5176\u53ef\u4ee5\u4ece\u7f51\u4e0a\u4e0b\u8f7d\u6587\u4ef6\uff0c\u540c\u65f6\u5b83\u4e5f\u53ef\u4ee5\u76f4\u63a5\u5c06\u6587\u4ef6\u89e3\u538b\u3002\u4f46\u662f\u7531\u4e8eADD\u6307\u4ee4\u4ece\u7f51\u4e0a\u4e0b\u8f7d\u7684\u6587\u4ef6\u4f1a\u81ea\u52a8\u8bbe\u7f6e\u6743\u9650\u4e3a600\uff0c\u800c\u8c03\u6574\u6743\u9650\u8fd8\u9700\u8981\u4e00\u4e2aRUN\u6307\u4ee4\u3002\u4e0d\u5982\u76f4\u63a5\u901a\u8fc7RUN\u4e0b\u8f7d\u6587\u4ef6\u6765\u7684\u65b9\u4fbf\u3002\u56e0\u6b64\uff0c\u8bf7\u53ea\u5728\u9700\u8981\u89e3\u538b\u6587\u4ef6\u7684\u65f6\u5019\u624d\u4f7f\u7528ADD\u6307\u4ee4\u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c \u4e3a\u6e90\u4e8eDockfile\u6240\u5728\u6587\u4ef6\u5939\u7684\u76f8\u5bf9\u8def\u5f84\uff0c \u5219\u662f\u76ee\u6807\u5bb9\u5668\u5185\u7684\u7edd\u5bf9\u8def\u5f84\u3002\u6b64\u5916\uff0c\u8fd9\u4e24\u4e2a\u6307\u4ee4\u540c\u65f6\u652f\u6301\u901a\u914d\u7b26\uff0c\u5373 COPY zc* /usr/local/docker \u5c06\u4f1a\u628a\u5f53\u524d\u76ee\u5f55\u4e0b\u6240\u6709\u4ee5zc\u5f00\u5934\u7684\u6587\u4ef6\u590d\u5236\u5230\u5bb9\u5668\u7684/usr/local/docker\u76ee\u5f55\u5f53\u4e2d\u3002","title":"COPY \u548c ADD"},{"location":"docker/dockerfile/#expose","text":"EXPOSE <port> [<port>/<protocol>...] EXPOSE\u6307\u4ee4\u66b4\u9732\u5bb9\u5668\u5bf9\u5e94\u7684\u7aef\u53e3\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cEXPOSE\u6307\u4ee4\u5c06\u5047\u8bbeTCP\u534f\u8bae\uff0c\u5982\u679c\u4f7f\u7528UDP\u534f\u8bae\u9700\u8981\u663e\u5f0f\u58f0\u660e\u3002","title":"EXPOSE"},{"location":"docker/dockerfile/#volume","text":"VOLUME [\"/zc\"] VOLUME\u6307\u4ee4\u548c\u524d\u6587\u6240\u8ff0\u7684\u4f7f\u7528 docker run -v \u4f46\u53ea\u6307\u5b9a\u5bb9\u5668\u5185\u76ee\u5f55\u5b8c\u5168\u4e00\u6837\u3002\u4ed6\u4f1a\u7ed9\u8fd9\u4e2a\u6302\u8f7d\u968f\u673a\u4e00\u4e2a\u540d\u5b57\uff0c\u7136\u540e\u518d\u672c\u673a/var/lib/docker/volumes\u76ee\u5f55\u4e4b\u4e0b\u521b\u5efa\u4e00\u4e2a\u4e0e\u6302\u8f7d\u540d\u5b57\u76f8\u540c\u7684\u6587\u4ef6\u5939\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u867d\u7136\u5b83\u7684\u540d\u5b57\u53eb\u5377\uff0c\u4f46\u521b\u5efa\u7684\u5b9e\u9645\u4e0a\u662f\u4e00\u4e2a\u6346\u7ed1\u6302\u8f7d\u2026\u2026\u8fd9\u4e2a\u6307\u4ee4\u6211\u4ece\u6765\u6ca1\u6709\u7528\u8fc7\uff0c\u8fd8\u4e13\u95e8\u4e3a\u8fd9\u7bc7\u6587\u7ae0\u67e5\u4e86\u534a\u5929\u8d44\u6599\u987a\u5e26\u505a\u4e86\u4e24\u4e2a\u5b9e\u9a8c\u3002\u6211\u5b8c\u5168\u65e0\u6cd5\u7406\u89e3\u8fd9\u79cd\u8bbe\u8ba1\u7684\u7528\u610f\uff0c\u4e5f\u5f3a\u70c8\u5efa\u8bae\u5927\u5bb6\u90fd\u4e0d\u8981\u4f7f\u7528\u3002docker run \u547d\u4ee4\u591a\u6253\u4e24\u53e5\u80fd\u5b9e\u73b0\u7684\u8981\u6bd4\u4ed6\u4f18\u96c5\u7684\u591a\uff0c\u5efa\u8bae\u4f7f\u7528\u3002\u503c\u5f97\u4e00\u63d0\u7684\u662f\uff0c\u5982\u679c\u5728VOLUME\u91cc\u548c\u5728 docker run \u91cc\u540c\u65f6\u6302\u8f7d\u4e86\u76ee\u5f55\uff0c\u5219\u53ea\u6709 docker run \u6302\u8f7d\u7684\u76ee\u5f55\u4f1a\u751f\u6548\u3002","title":"VOLUME"},{"location":"docker/dockerfile/#healthcheck-stopsignal","text":"HEALTHCHECK [OPTIONS] CMD command HEALTHCHECK NONE STOPSIGNAL signal HEALTHCHECK\u6307\u4ee4\u544a\u8bc9\u5bb9\u5668\u5982\u4f55\u8fd0\u884c\u5065\u5eb7\u68c0\u67e5\u3002\u5982\u679c\u5bb9\u5668\u7684Dockerfile\u4e2d\u6307\u5b9a\u4e86HEALTHCHECK\u65b9\u6cd5\uff0c\u5728\u8fd0\u884c docker ps \u547d\u4ee4\u65f6\uff0c\u5bb9\u5668\u7684\u72b6\u6001\u4e00\u680f\u4e2d\u4f1a\u663e\u793a\u5bb9\u5668\u5f53\u524d\u662f\u5426\u5065\u5eb7\u3002 STOPSIGNAL\u6307\u4ee4\u91cd\u5199\u5728 docker stop \u547d\u4ee4\u6267\u884c\u65f6\u53d1\u9001\u7ed9\u5bb9\u5668\u7684\u4fe1\u53f7\u3002 HEALTHCHECK\u6307\u4ee4\u6709\u5982\u4e0b\u53c2\u6570\uff1a --interval=DURATION # \u4e24\u6b21\u5065\u5eb7\u68c0\u67e5\u7684\u95f4\u9694\uff0c\u9ed8\u8ba430\u79d2\u3002 --timeout=DURATION # \u5065\u5eb7\u68c0\u67e5\u7684\u8d85\u65f6\uff0c\u9ed8\u8ba430\u79d2\u3002 --start-period=DURATION # \u5bb9\u5668\u542f\u52a8\u591a\u4e45\u4e4b\u540e\u5f00\u59cb\u5065\u5eb7\u68c0\u67e5\uff0c\u9ed8\u8ba40\u79d2\u3002 --retries=N # \u5065\u5eb7\u68c0\u67e5\u5931\u8d25\u4e4b\u540e\u663e\u793a\u5bb9\u5668\u4e0d\u5065\u5eb7\u65f6\u7ecf\u8fc7\u591a\u5c11\u6b21\u91cd\u8bd5\uff0c\u9ed8\u8ba43\u6b21\u3002","title":"HEALTHCHECK \u548c STOPSIGNAL"},{"location":"docker/dockerfile/#onbuild","text":"ONBUILD [INSTRUCTION] ONBUILD\u6307\u4ee4\u540e\u8ddf\u5176\u4ed6\u6307\u4ee4\u3002ONBUILD\u6307\u4ee4\u7684\u5185\u5bb9\u5c06\u4e0d\u4f1a\u5728\u8fd9\u4e2aDocker\u6784\u5efa\u7684\u65f6\u5019\u6267\u884c\uff0c\u4f46\u662f\u5982\u679c\u5176\u4ed6Docker\u7ee7\u627f\u8fd9\u4e2aDocker\uff0cONBUILD\u540e\u8ddf\u7684\u6307\u4ee4\u4f1a\u5728FROM\u7ed3\u675f\u4e4b\u540e\u7acb\u5373\u6267\u884c\u3002","title":"ONBUILD"},{"location":"docker/dockerfile/#cmd-entrypoint","text":"CMD [\"executable\",\"param1\",\"param2\"] CMD command param1 param2 CMD [\"param1\",\"param2\"] ENTRYPOINT [\"executable\", \"param1\", \"param2\"] ENTRYPOINT command param1 param2 CMD\u6307\u4ee4\u548cENTRYPOINT\u6307\u4ee4\u51e0\u4e4e\u6ca1\u6709\u533a\u522b\uff0c\u4ed6\u4eec\u7684\u4f5c\u7528\u90fd\u662f\u5728\u5bb9\u5668\u6784\u5efa\u4e4b\u540e\u6267\u884c\u5176\u4e2d\u7684\u547d\u4ee4\u3002\u4ed6\u4eec\u4e5f\u90fd\u6709\u4e24\u79cd\u683c\u5f0f\u2013shell\u548cexec\uff0c\u6b63\u5982RUN\u6307\u4ee4\u4e00\u6837\u3002\u533a\u522b\u5728\u4e8eCMD\u6307\u4ee4\u591a\u4e00\u79cd\u53c2\u6570\u6a21\u5f0f\uff0c\u5728\u53c2\u6570\u6a21\u5f0f\u4e0b\uff0cCMD\u6307\u4ee4\u540e\u8ddf\u7684\u53c2\u6570\u5c06\u4f5c\u4e3a\u9ed8\u8ba4\u53c2\u6570\u4f20\u9012\u7ed9ENTRYPOINT\u6307\u4ee4\u6267\u884c\u3002\u5373\u4e0b\u5217\u4e24\u4e2a\u6307\u4ee4\u5728\u5b9e\u9645\u4e0a\u662f\u7b49\u4ef7\u7684\uff1a ENTRYPOINT [\"/start.sh\"] CMD [\"aptly\", \"api\", \"serve\"] ENTRYPOINT[\"/start.sh\", \"aptly\", \"api\", \"serve\"] \u4ed6\u4eec\u7684\u533a\u522b\u9664\u6b64\u4e4b\u5916\u4e3b\u8981\u5728\u4e8eCMD\u6307\u4ee4\u4f1a\u66f4\u5bb9\u6613\u7684\u5728 docker run \u547d\u4ee4\u5f53\u4e2d\u88ab\u91cd\u5199\uff0c\u800cENTRYPOINT\u9700\u8981\u663e\u5f0f\u6307\u5b9a \u2013entrypoint \u53c2\u6570\u624d\u80fd\u91cd\u5199\u3002 ENTRYPOINT\u6307\u4ee4\u548cCMD\u6307\u4ee4\u4e4b\u95f4\u7684\u5177\u4f53\u533a\u522b\u5728\u7f51\u4e0a\u4e94\u82b1\u516b\u95e8\uff0c\u5374\u5f88\u5c11\u6709\u6b63\u786e\u7684\u3002\u53ef\u4ee5\u80af\u5b9a\u7684\u662f\uff0cENTRYPOINT\u6307\u4ee4\u7684\u4f18\u5148\u7ea7\u8981\u6bd4CMD\u6307\u4ee4\u66f4\u9ad8\u3002\u8fd9\u91cc\u6309\u7167Docker\u5b98\u65b9\u7684\u8bf4\u6cd5\uff1a \u4f7f\u7528\u5bb9\u5668\u4f5c\u4e3a\u53ef\u6267\u884c\u6587\u4ef6\u65f6\uff0c\u5e94\u4f7f\u7528ENTRYPOINT\u6307\u4ee4\u3002CMD\u5e94\u5f53\u88ab\u7528\u4e8e\u4e3aENTRYPOINT\u6307\u4ee4\u63d0\u4f9b\u9ed8\u8ba4\u53c2\u6570\uff0c\u6216\u5728\u5bb9\u5668\u4e2d\u6267\u884cad-hoc\u547d\u4ee4\u3002 \u4e0b\u8868\u5217\u51fa\u4e86ENTRYPOINT\u6307\u4ee4\u548cCMD\u6307\u4ee4\u4e0d\u540c\u7ec4\u5408\u65f6\u7684\u5b9e\u9645\u6267\u884c\u60c5\u51b5\uff1a No ENTRYPOINT ENTRYPOINT exec_entry p1_entry ENTRYPOINT [\u201cexec_entry\u201d, \u201cp1_entry\u201d] No CMD error, not allowed /bin/sh -c exec_entry p1_entry exec_entry p1_entry CMD [\u201cexec_cmd\u201d, \u201cp1_cmd\u201d] exec_cmd p1_cmd /bin/sh -c exec_entry p1_entry exec_entry p1_entry exec_cmd p1_cmd CMD [\u201cp1_cmd\u201d, \u201cp2_cmd\u201d] p1_cmd p2_cmd /bin/sh -c exec_entry p1_entry exec_entry p1_entry p1_cmd p2_cmd CMD exec_cmd p1_cmd /bin/sh -c exec_cmd p1_cmd /bin/sh -c exec_entry p1_entry exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd \u6700\u540e\uff0c\u8fd8\u6709\u4e00\u70b9\u9700\u8981\u5f3a\u8c03\uff1a Dockerfile\u5e94\u81f3\u5c11\u6307\u5b9a\u4e00\u4e2aCMD\u6216ENTRYPOINT\u6307\u4ee4\uff01","title":"CMD \u548c ENTRYPOINT"},{"location":"docker/dockerfile/#_2","text":"\u4e86\u89e3\u4e86Docerfile\u7684\u7ec4\u6210\u90e8\u5206\uff0c\u8ba9\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0b\u522b\u4eba\u5bb6\u90fd\u662f\u600e\u4e48\u5199Dockerfile\u7684\u3002\u4ee5\u4e0b\u662fnvidia/cuda:10.1-cudnn7-devel-ubuntu18.04\u53ca\u5176\u7ee7\u627f\u7684Dockerfile\u3002","title":"\u5206\u6790"},{"location":"docker/dockerfile/#101-cudnn7-devel-ubuntu1804","text":"ARG IMAGE_NAME FROM ${IMAGE_NAME}:10.1-devel-ubuntu18.04 LABEL maintainer \"NVIDIA CORPORATION <cudatools@nvidia.com>\" ENV CUDNN_VERSION 7.6.3.30 LABEL com.nvidia.cudnn.version=\"${CUDNN_VERSION}\" RUN apt-get update && apt-get install -y --no-install-recommends \\ libcudnn7=$CUDNN_VERSION-1+cuda10.1 \\ libcudnn7-dev=$CUDNN_VERSION-1+cuda10.1 \\ && \\ apt-mark hold libcudnn7 && \\ rm -rf /var/lib/apt/lists/* \u9996\u5148\uff0c\u7b2c\u4e00\u884cARG\u6307\u4ee4\u63cf\u8ff0\u4e86\u955c\u50cf\u7684\u540d\u5b57\uff0c\u5e76\u5728\u968f\u540e\u7684FROM\u6307\u4ee4\u5f53\u4e2d\u5e94\u7528\u5230\u3002 nvidia/cuda\u7684Dockerfile\u90fd\u662f\u5c42\u5c42\u7ee7\u627f\u7684\uff0c\u8fd9\u975e\u5e38\u503c\u5f97\u5b66\u4e60\u3002","title":"10.1-cudnn7-devel-ubuntu18.04"},{"location":"docker/dockerfile/#101-devel-ubuntu1804","text":"ARG IMAGE_NAME FROM ${IMAGE_NAME}:10.1-runtime-ubuntu18.04 LABEL maintainer \"NVIDIA CORPORATION <cudatools@nvidia.com>\" RUN apt-get update && apt-get install -y --no-install-recommends \\ cuda-nvml-dev-$CUDA_PKG_VERSION \\ cuda-command-line-tools-$CUDA_PKG_VERSION \\ cuda-libraries-dev-$CUDA_PKG_VERSION \\ cuda-minimal-build-$CUDA_PKG_VERSION \\ libnccl-dev=$NCCL_VERSION-1+cuda10.1 \\ && \\ rm -rf /var/lib/apt/lists/* ENV LIBRARY_PATH /usr/local/cuda/lib64/stubs","title":"10.1-devel-ubuntu18.04"},{"location":"docker/dockerfile/#101-runtime-ubuntu1804","text":"ARG IMAGE_NAME FROM ${IMAGE_NAME}:10.1-base-ubuntu18.04 LABEL maintainer \"NVIDIA CORPORATION <cudatools@nvidia.com>\" ENV NCCL_VERSION 2.4.8 RUN apt-get update && apt-get install -y --no-install-recommends \\ cuda-libraries-$CUDA_PKG_VERSION \\ cuda-nvtx-$CUDA_PKG_VERSION \\ libnccl2=$NCCL_VERSION-1+cuda10.1 && \\ apt-mark hold libnccl2 && \\ rm -rf /var/lib/apt/lists/*","title":"10.1-runtime-ubuntu18.04"},{"location":"docker/dockerfile/#101-base-ubuntu1804","text":"FROM ubuntu:18.04 LABEL maintainer \"NVIDIA CORPORATION <cudatools@nvidia.com>\" RUN apt-get update && apt-get install -y --no-install-recommends \\ gnupg2 curl ca-certificates && \\ curl -fsSL https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/7fa2af80.pub | apt-key add - && \\ echo \"deb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64 /\" > /etc/apt/sources.list.d/cuda.list && \\ echo \"deb https://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1804/x86_64 /\" > /etc/apt/sources.list.d/nvidia-ml.list && \\ apt-get purge --autoremove -y curl && \\ rm -rf /var/lib/apt/lists/* ENV CUDA_VERSION 10.1.243 ENV CUDA_PKG_VERSION 10-1=$CUDA_VERSION-1 # For libraries in the cuda-compat-* package: https://docs.nvidia.com/cuda/eula/index.html#attachment-a RUN apt-get update && apt-get install -y --no-install-recommends \\ cuda-cudart-$CUDA_PKG_VERSION \\ cuda-compat-10-1 && \\ ln -s cuda-10.1 /usr/local/cuda && \\ rm -rf /var/lib/apt/lists/* # Required for nvidia-docker v1 RUN echo \"/usr/local/nvidia/lib\" >> /etc/ld.so.conf.d/nvidia.conf && \\ echo \"/usr/local/nvidia/lib64\" >> /etc/ld.so.conf.d/nvidia.conf ENV PATH /usr/local/nvidia/bin:/usr/local/cuda/bin:${PATH} ENV LD_LIBRARY_PATH /usr/local/nvidia/lib:/usr/local/nvidia/lib64 # nvidia-container-runtime ENV NVIDIA_VISIBLE_DEVICES all ENV NVIDIA_DRIVER_CAPABILITIES compute,utility ENV NVIDIA_REQUIRE_CUDA \"cuda>=10.1 brand=tesla,driver>=384,driver<385 brand=tesla,driver>=396,driver<397 brand=tesla,driver>=410,driver<411\"","title":"10.1-base-ubuntu18.04"},{"location":"docker/dockerfile/#ubuntu1804","text":"FROM scratch ADD ubuntu-bionic-core-cloudimg-amd64-root.tar.gz / # verify that the APT lists files do not exist RUN [ -z \"$(apt-get indextargets)\" ] # (see https://bugs.launchpad.net/cloud-images/+bug/1699913) # a few minor docker-specific tweaks # see https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap RUN set -xe \\ \\ # https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L40-L48 && echo '#!/bin/sh' > /usr/sbin/policy-rc.d \\ && echo 'exit 101' >> /usr/sbin/policy-rc.d \\ && chmod +x /usr/sbin/policy-rc.d \\ \\ # https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L54-L56 && dpkg-divert --local --rename --add /sbin/initctl \\ && cp -a /usr/sbin/policy-rc.d /sbin/initctl \\ && sed -i 's/^exit.*/exit 0/' /sbin/initctl \\ \\ # https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L71-L78 && echo 'force-unsafe-io' > /etc/dpkg/dpkg.cfg.d/docker-apt-speedup \\ \\ # https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L85-L105 && echo 'DPkg::Post-Invoke { \"rm -f /var/cache/apt/archives/*.deb /var/cache/apt/archives/partial/*.deb /var/cache/apt/*.bin || true\"; };' > /etc/apt/apt.conf.d/docker-clean \\ && echo 'APT::Update::Post-Invoke { \"rm -f /var/cache/apt/archives/*.deb /var/cache/apt/archives/partial/*.deb /var/cache/apt/*.bin || true\"; };' >> /etc/apt/apt.conf.d/docker-clean \\ && echo 'Dir::Cache::pkgcache \"\"; Dir::Cache::srcpkgcache \"\";' >> /etc/apt/apt.conf.d/docker-clean \\ \\ # https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L109-L115 && echo 'Acquire::Languages \"none\";' > /etc/apt/apt.conf.d/docker-no-languages \\ \\ # https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L118-L130 && echo 'Acquire::GzipIndexes \"true\"; Acquire::CompressionTypes::Order:: \"gz\";' > /etc/apt/apt.conf.d/docker-gzip-indexes \\ \\ # https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L134-L151 && echo 'Apt::AutoRemove::SuggestsImportant \"false\";' > /etc/apt/apt.conf.d/docker-autoremove-suggests # make systemd-detect-virt return \"docker\" # See: https://github.com/systemd/systemd/blob/aa0c34279ee40bce2f9681b496922dedbadfca19/src/basic/virt.c#L434 RUN mkdir -p /run/systemd && echo 'docker' > /run/systemd/container # overwrite this with 'CMD []' in a dependent Dockerfile CMD [\"/bin/bash\"]","title":"ubuntu:18.04"},{"location":"docker/installation/","text":"\u5b89\u88c5 # Docker\u7684\u5b89\u88c5\u975e\u5e38\u7b80\u5355\uff0capt-get/yum\u4e24\u5206\u949f\u5c31\u597d\uff0cWindows\u4e0a\u7684Docker\u66f4\u52a0\u7b80\u5355\uff0c\u4ed6\u8fd8\u9644\u5e26\u4e86Kubernetes\u3002\u4e3a\u8282\u7ea6\u7bc7\u5e45\uff0c\u672c\u6587\u53ea\u8ba8\u8bba\u5728ubuntu\u7cfb\u7edf\u4e0b\u7684\u5b89\u88c5\u3002\u5982\u679c\u4f60\u5728\uff08\u5176\u4ed6\u7cfb\u7edf\u4e0a\uff09\u5b89\u88c5\u65f6\u9047\u5230\u4efb\u4f55\u95ee\u9898\uff0c\u6b22\u8fce\u7559\u8a00\u3002 \u7531\u4e8e\u6211\u4eec\u4f1a\u7528\u5230nvidia-docker2\uff0c\u6240\u4ee5\u8fd9\u91cc\u540c\u65f6\u4e5f\u6709nvidia-docker2\u7684\u5b89\u88c5\u5185\u5bb9\u3002\u5982\u679c\u4f60\u4e0d\u9700\u8981\u5728\u5bb9\u5668\u5f53\u4e2d\u4f7f\u7528Nvidia GPU\uff0c\u90a3\u4e48\u53ef\u4ee5\u76f4\u63a5\u8df3\u8fc7\u76f8\u5173\u5185\u5bb9\u3002 # \u5b89\u88c5\u4f9d\u8d56 apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg2 \\ software-properties-common # \u6dfb\u52a0Docker\u4ed3\u5e93 # \u6709\u7684\u6559\u7a0b\u8bf4kubernetes\u4e0d\u652f\u6301Docker-CE\uff0c\u53ea\u652f\u6301Docker-IO\uff0c\u76f8\u4fe1\u6211\uff0c\u4ed6\u5728\u80e1\u626f\u3002 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" # \u66f4\u65b0\u4ed3\u5e93 apt-get update # \u5b89\u88c5Docker apt-get install docker-ce # \u5982\u679c\u4f60\u4e0d\u9700\u8981\u5728\u5bb9\u5668\u5f53\u4e2d\u4f7f\u7528Nvidia GPU\uff0c\u4ee5\u4e0b\u6b65\u9aa4\u65e0\u9700\u6267\u884c # \u6dfb\u52a0nvidia-docker2\u4ed3\u5e93 # \u7531\u4e8envidia-docker2\u662f\u901a\u8fc7Docker\u5b89\u88c5\u7684\uff0c\u6240\u4ee5\u9700\u8981\u5728\u5b8c\u6210Docker\u7684\u5b89\u88c5\u4e4b\u540e\u518d\u5b89\u88c5nvidia-docker2 docker volume ls -q -f driver=nvidia-docker | xargs -r -I{} -n1 docker ps -q -a -f volume={} | xargs -r docker rm -f curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \\ apt-key add - distribution=$(. /etc/os-release;echo $ID$VERSION_ID) curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \\ tee /etc/apt/sources.list.d/nvidia-docker.list # \u5b89\u88c5nvidia-docker2 apt-get install nvidia-docker2 pkill -SIGHUP dockerd \u5c06nvidia-docker2\u4fee\u6539\u4e3adocker\u7684\u9ed8\u8ba4\u8fd0\u884c\u65f6\u73af\u5883 \u5982\u679c\u4f60\u4e0d\u9700\u8981\u5728\u5bb9\u5668\u5f53\u4e2d\u4f7f\u7528Nvidia GPU\uff0c\u4ee5\u4e0b\u6b65\u9aa4\u65e0\u9700\u6267\u884c vim /etc/docker/daemon.json { \"default-runtime\": \"nvidia\", \"runtimes\": { \"nvidia\": { \"path\": \"/usr/bin/nvidia-container-runtime\", \"runtimeArgs\": [] } } } sudo service docker restart \u81f3\u6b64\uff0cDocker\u5df2\u7ecf\u6210\u529f\u5728\u60a8\u7684\u673a\u5668\u4e0a\u5b89\u88c5\uff0c\u8fd0\u884c docker run hello-world \u6d4b\u8bd5\u7ed3\u679c\u3002 Docker\u53ef\u80fd\u4f1a\u63d0\u793a\u6ca1\u6709\u627e\u5230\u8fd9\u4e2a\u955c\u50cf\u3002\u8fd9\u6ca1\u6709\u5173\u7cfb\uff0c\u4ed6\u5f88\u5feb\u5c31\u4f1a\u81ea\u52a8\u62c9\u53d6\u3002\u51e0\u5341\u79d2\u540e\uff0c\u4f60\u5c06\u770b\u5230\u5982\u4e0b\u5185\u5bb9\uff1a Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ $ docker images hello-world REPOSITORY TAG IMAGE ID SIZE hello-world latest fce289e99eb9 1.84kB \u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u8ba8\u8bbaDocker\u7684\u547d\u4ee4\u884c\u63a5\u53e3\uff08Command Line Interface\uff09","title":"\u5b89\u88c5"},{"location":"docker/installation/#_1","text":"Docker\u7684\u5b89\u88c5\u975e\u5e38\u7b80\u5355\uff0capt-get/yum\u4e24\u5206\u949f\u5c31\u597d\uff0cWindows\u4e0a\u7684Docker\u66f4\u52a0\u7b80\u5355\uff0c\u4ed6\u8fd8\u9644\u5e26\u4e86Kubernetes\u3002\u4e3a\u8282\u7ea6\u7bc7\u5e45\uff0c\u672c\u6587\u53ea\u8ba8\u8bba\u5728ubuntu\u7cfb\u7edf\u4e0b\u7684\u5b89\u88c5\u3002\u5982\u679c\u4f60\u5728\uff08\u5176\u4ed6\u7cfb\u7edf\u4e0a\uff09\u5b89\u88c5\u65f6\u9047\u5230\u4efb\u4f55\u95ee\u9898\uff0c\u6b22\u8fce\u7559\u8a00\u3002 \u7531\u4e8e\u6211\u4eec\u4f1a\u7528\u5230nvidia-docker2\uff0c\u6240\u4ee5\u8fd9\u91cc\u540c\u65f6\u4e5f\u6709nvidia-docker2\u7684\u5b89\u88c5\u5185\u5bb9\u3002\u5982\u679c\u4f60\u4e0d\u9700\u8981\u5728\u5bb9\u5668\u5f53\u4e2d\u4f7f\u7528Nvidia GPU\uff0c\u90a3\u4e48\u53ef\u4ee5\u76f4\u63a5\u8df3\u8fc7\u76f8\u5173\u5185\u5bb9\u3002 # \u5b89\u88c5\u4f9d\u8d56 apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg2 \\ software-properties-common # \u6dfb\u52a0Docker\u4ed3\u5e93 # \u6709\u7684\u6559\u7a0b\u8bf4kubernetes\u4e0d\u652f\u6301Docker-CE\uff0c\u53ea\u652f\u6301Docker-IO\uff0c\u76f8\u4fe1\u6211\uff0c\u4ed6\u5728\u80e1\u626f\u3002 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" # \u66f4\u65b0\u4ed3\u5e93 apt-get update # \u5b89\u88c5Docker apt-get install docker-ce # \u5982\u679c\u4f60\u4e0d\u9700\u8981\u5728\u5bb9\u5668\u5f53\u4e2d\u4f7f\u7528Nvidia GPU\uff0c\u4ee5\u4e0b\u6b65\u9aa4\u65e0\u9700\u6267\u884c # \u6dfb\u52a0nvidia-docker2\u4ed3\u5e93 # \u7531\u4e8envidia-docker2\u662f\u901a\u8fc7Docker\u5b89\u88c5\u7684\uff0c\u6240\u4ee5\u9700\u8981\u5728\u5b8c\u6210Docker\u7684\u5b89\u88c5\u4e4b\u540e\u518d\u5b89\u88c5nvidia-docker2 docker volume ls -q -f driver=nvidia-docker | xargs -r -I{} -n1 docker ps -q -a -f volume={} | xargs -r docker rm -f curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \\ apt-key add - distribution=$(. /etc/os-release;echo $ID$VERSION_ID) curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \\ tee /etc/apt/sources.list.d/nvidia-docker.list # \u5b89\u88c5nvidia-docker2 apt-get install nvidia-docker2 pkill -SIGHUP dockerd \u5c06nvidia-docker2\u4fee\u6539\u4e3adocker\u7684\u9ed8\u8ba4\u8fd0\u884c\u65f6\u73af\u5883 \u5982\u679c\u4f60\u4e0d\u9700\u8981\u5728\u5bb9\u5668\u5f53\u4e2d\u4f7f\u7528Nvidia GPU\uff0c\u4ee5\u4e0b\u6b65\u9aa4\u65e0\u9700\u6267\u884c vim /etc/docker/daemon.json { \"default-runtime\": \"nvidia\", \"runtimes\": { \"nvidia\": { \"path\": \"/usr/bin/nvidia-container-runtime\", \"runtimeArgs\": [] } } } sudo service docker restart \u81f3\u6b64\uff0cDocker\u5df2\u7ecf\u6210\u529f\u5728\u60a8\u7684\u673a\u5668\u4e0a\u5b89\u88c5\uff0c\u8fd0\u884c docker run hello-world \u6d4b\u8bd5\u7ed3\u679c\u3002 Docker\u53ef\u80fd\u4f1a\u63d0\u793a\u6ca1\u6709\u627e\u5230\u8fd9\u4e2a\u955c\u50cf\u3002\u8fd9\u6ca1\u6709\u5173\u7cfb\uff0c\u4ed6\u5f88\u5feb\u5c31\u4f1a\u81ea\u52a8\u62c9\u53d6\u3002\u51e0\u5341\u79d2\u540e\uff0c\u4f60\u5c06\u770b\u5230\u5982\u4e0b\u5185\u5bb9\uff1a Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ $ docker images hello-world REPOSITORY TAG IMAGE ID SIZE hello-world latest fce289e99eb9 1.84kB \u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u8ba8\u8bbaDocker\u7684\u547d\u4ee4\u884c\u63a5\u53e3\uff08Command Line Interface\uff09","title":"\u5b89\u88c5"},{"location":"docker/introduction/","text":"Docker # Docker\uff0c\u4f5c\u4e3a\u76ee\u524d\u6700\u6d41\u884c\u7684\u5e94\u7528\u5bb9\u5668\u5f15\u64ce\uff0c\u5df2\u7ecf\u5728\u5168\u4e16\u754c\u5f53\u4e2d\u88ab\u5e7f\u6cdb\u4f7f\u7528\u3002 \u901a\u8fc7\u79fb\u9664\u8bbf\u5ba2\u7cfb\u7edf\uff08Guest OS\uff09\u4e0e\u786c\u4ef6\u865a\u62df\u5316\u5c42\uff0cDocker\u5f97\u4ee5\u5728\u6027\u80fd\u4e0a\u8fdc\u8d85\u4f20\u7edf\u7684\u865a\u62df\u673a\u3002\u4e0e\u6b64\u540c\u65f6\uff0c\u4ed6\u8fd8\u63d0\u4f9b\u4e86\u66f4\u597d\u7684\u786c\u4ef6\u517c\u5bb9\u6027\uff08\u5c24\u5176\u5bf9\u4e8eGPU\u6765\u8bf4\uff09\u3002\u800cDocker Swarm\u548c\u4ee5Kubernetes\u4e3a\u9996\u7684\u5bb9\u5668\u7f16\u6392\u5de5\u5177\u66f4\u7ed9\u5bb9\u5668\u5e26\u6765\u4e86\u5728\u8c03\u5ea6\u3001\u7f51\u7edc\u7b49\u8bf8\u591a\u65b9\u9762\u65e0\u53ef\u6bd4\u62df\u7684\u4f18\u52bf\u3002\u66f4\u4e3a\u91cd\u8981\u7684\u662f\uff0c\u5bb9\u5668\u955c\u50cf\u91cd\u65b0\u5b9a\u4e49\u4e86\u8f6f\u4ef6\u7684\u4ea4\u4ed8\u6d41\u7a0b\uff0c\u4ece\u6839\u672c\u89e3\u51b3\u4e86\u8f6f\u4ef6\u590d\u6742\u7684\u5b89\u88c5\u4e0e\u7ef4\u62a4\u95ee\u9898\u3002\u4e00\u5207\u7684\u4e00\u5207\u90fd\u80fd\u544a\u8bc9\u6211\u4eec\u2013\u5bb9\u5668\u5316\uff0c\u8ba9\u751f\u6d3b\u66f4\u7f8e\u597d\u3002 \u6240\u4ee5\uff0c\u4f60\u8fd8\u5728\u7b49\u4e9b\u4ec0\u4e48\u5462\uff1f","title":"\u5bfc\u8bba"},{"location":"docker/introduction/#docker","text":"Docker\uff0c\u4f5c\u4e3a\u76ee\u524d\u6700\u6d41\u884c\u7684\u5e94\u7528\u5bb9\u5668\u5f15\u64ce\uff0c\u5df2\u7ecf\u5728\u5168\u4e16\u754c\u5f53\u4e2d\u88ab\u5e7f\u6cdb\u4f7f\u7528\u3002 \u901a\u8fc7\u79fb\u9664\u8bbf\u5ba2\u7cfb\u7edf\uff08Guest OS\uff09\u4e0e\u786c\u4ef6\u865a\u62df\u5316\u5c42\uff0cDocker\u5f97\u4ee5\u5728\u6027\u80fd\u4e0a\u8fdc\u8d85\u4f20\u7edf\u7684\u865a\u62df\u673a\u3002\u4e0e\u6b64\u540c\u65f6\uff0c\u4ed6\u8fd8\u63d0\u4f9b\u4e86\u66f4\u597d\u7684\u786c\u4ef6\u517c\u5bb9\u6027\uff08\u5c24\u5176\u5bf9\u4e8eGPU\u6765\u8bf4\uff09\u3002\u800cDocker Swarm\u548c\u4ee5Kubernetes\u4e3a\u9996\u7684\u5bb9\u5668\u7f16\u6392\u5de5\u5177\u66f4\u7ed9\u5bb9\u5668\u5e26\u6765\u4e86\u5728\u8c03\u5ea6\u3001\u7f51\u7edc\u7b49\u8bf8\u591a\u65b9\u9762\u65e0\u53ef\u6bd4\u62df\u7684\u4f18\u52bf\u3002\u66f4\u4e3a\u91cd\u8981\u7684\u662f\uff0c\u5bb9\u5668\u955c\u50cf\u91cd\u65b0\u5b9a\u4e49\u4e86\u8f6f\u4ef6\u7684\u4ea4\u4ed8\u6d41\u7a0b\uff0c\u4ece\u6839\u672c\u89e3\u51b3\u4e86\u8f6f\u4ef6\u590d\u6742\u7684\u5b89\u88c5\u4e0e\u7ef4\u62a4\u95ee\u9898\u3002\u4e00\u5207\u7684\u4e00\u5207\u90fd\u80fd\u544a\u8bc9\u6211\u4eec\u2013\u5bb9\u5668\u5316\uff0c\u8ba9\u751f\u6d3b\u66f4\u7f8e\u597d\u3002 \u6240\u4ee5\uff0c\u4f60\u8fd8\u5728\u7b49\u4e9b\u4ec0\u4e48\u5462\uff1f","title":"Docker"},{"location":"document/design_pattern%20copy/","text":"\u672c\u6587\u65e8\u5728\u8bb0\u5f55COMP2100\u8bfe\u7a0b\u590d\u4e60\u7684\u7b14\u8bb0\uff0c\u6d89\u53ca\u7b56\u7565\u6a21\u5f0f\uff08Strategy Pattern\uff09\u3001\u89c2\u5bdf\u8005\u6a21\u5f0f\uff08Ovserver Pattern\uff09\u3001\u5916\u89c2\u6a21\u5f0f\uff08Facade Pattern\uff09\u548c\u5355\u4f8b\u6a21\u5f0f\uff08Sigleton Pattern\uff09\u3002 \u6211\u4eec\u9884\u8ba1\u5728\u4e4b\u540e\u4f1a\u5b8c\u5584\u672c\u6587\u3002 \u672c\u6587\u4e0e\u4e4b\u524d\u4e00\u6837\u5c06\u4f7f\u7528Python\u6765\u5b9e\u73b0\u6240\u7528\u7528\u4f8b\u3002\u4f46\u5728\u5b9e\u9645\u60c5\u51b5\u5f53\u4e2d\uff0c\u6211\u4eec\u5e76\u4e0d\u63a8\u8350\u4f7f\u7528Python\u521b\u5efa\u63a5\u53e3\u548c\u62bd\u8c61\u57fa\u7c7b\u3002Python\u662f\u4e00\u95e8\u52a8\u6001\u8bed\u8a00\uff0c\u5f3a\u5236\u7c7b\u578b\u68c0\u67e5\u65e0\u5f02\u4e8e\u5357\u8f95\u5317\u8f99\u3002 \u7b56\u7565\u6a21\u5f0f\uff08Strategy Pattern, Policy Pattern\uff09 # \u7b56\u7565\u6a21\u5f0f \u7b56\u7565\u6a21\u5f0f\u5728\u8fd0\u884c\u65f6\u9009\u62e9\u7b97\u6cd5\u3002\u4ee3\u7801\u5e76\u4e0d\u76f4\u63a5\u5b9e\u73b0\u5355\u4e2a\u7b97\u6cd5\uff0c\u800c\u662f\u63a5\u6536\u8fd0\u884c\u65f6\u6307\u4ee4\uff0c\u4ee5\u6307\u793a\u5728\u4e00\u7cfb\u5217\u7b97\u6cd5\u4e2d\u8981\u4f7f\u7528\u54ea\u4e2a\u3002 \u7b56\u7565\u6a21\u5f0f\u5f53\u4e2d\u7684\u63a5\u53e3\u662f\u56fa\u5b9a\u7684\uff0c\u56e0\u6b64\u8c03\u7528\u65f6\u4e0d\u8bb8\u66f4\u6539\u65b9\u6cd5\u3002 \u7ed3\u6784 \u7b56\u7565\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u4e0a\u4e0b\u6587\uff08Context\uff09\uff1a\u5f15\u7528\u7b56\u7565\u7684\u5bf9\u8c61 \u7b56\u7565\uff08Strategy\uff09\uff1a\u7b56\u7565\u7684\u516c\u5171\u63a5\u53e3\uff0c\u5177\u4f53\u7b56\u7565\u90fd\u5c06\u5b9e\u73b0\u8fd9\u4e2a\u63a5\u53e3 \u5177\u4f53\u7b56\u7565\uff08Concrete Strategy\uff09\uff1a\u7b56\u7565\u7684\u5177\u4f53\u5b9e\u73b0\uff0c\u5305\u542b\u4e86\u5177\u4f53\u7684\u7b97\u6cd5\u4ee3\u7801 \u7b56\u7565\u6a21\u5f0f from abc import ABC , abstractmethod class ChickenCooker ( ABC ): # \u7b56\u7565 @abstractmethod def cook ( self ): pass class FriedChickenCooker ( ChickenCooker ): # \u5177\u4f53\u7b56\u75651 def cook ( self ): print ( \"Cooking fried chicken!\" ) class GrilledChickenCooker ( ChickenCooker ): # \u5177\u4f53\u7b56\u75652 def cook ( self ): print ( \"Cooking grilled chicken!\" ) class Kitchen ( object ): # \u4e0a\u4e0b\u6587 def __init__ ( self ): self . _strategy = None @property def strategy ( self ): return self . _strategy @strategy . setter def strategy ( self , strategy ): self . _strategy = strategy def cook ( self ): self . _strategy . cook () \u4f18\u70b9 \u901a\u8fc7\u628a\u7b97\u6cd5\u7684\u8c03\u7528\u653e\u5230\u4e0a\u4e0b\u6587\u5f53\u4e2d\uff0c\u628a\u5b9e\u73b0\u653e\u5230\u4e86\u7b56\u7565\u5f53\u4e2d\u800c\u5b9e\u73b0\u4e86\u4e24\u8005\u7684\u5206\u79bb \u63d0\u4f9b\u76f8\u540c\u884c\u4e3a\u7684\u4e0d\u540c\u5b9e\u73b0\uff1a\u540c\u6837\u662f\u505a\u9e21\uff0c\u6709\u5f88\u591a\u79cd\u4e0d\u540c\u7684\u505a\u6cd5 \u53ef\u4ee5\u7b80\u5355\u7684\u6dfb\u52a0\u65b0\u7684\u7b56\u7565\uff1a\u4ec5\u9700\u521b\u5efa\u4e00\u4e2a\u65b0\u7684Beggar Chicken\u5c31\u53ef\u4ee5\u5b9e\u73b0\u53eb\u82b1\u9e21 \u53ef\u4ee5\u5c06\u90e8\u5206\u4ee3\u7801\u653e\u5230\u7b56\u7565\u5f53\u4e2d\u800c\u907f\u514d\u91cd\u590d\u4ee3\u7801\uff1a\u65e0\u8bba\u662f\u70b8\u9e21\u8fd8\u662f\u70e4\u9e21\uff0c\u4f60\u90fd\u5148\u8981\u5207\u9e21 \u7f3a\u70b9 \u4e0a\u4e0b\u6587\u9700\u8981\u5bf9\u5b9e\u73b0\u6709\u8db3\u591f\u7684\u4e86\u89e3\u6765\u9009\u62e9\u6070\u5f53\u7684\u65b9\u6cd5\uff1a\u4f60\u8981\u77e5\u9053\u505a\u51fa\u6765\u662f\u4ec0\u4e48\u9e21 \u4f1a\u9020\u6210\u5f88\u591a\u7684\u5177\u4f53\u7b56\u7565\u7c7b\uff1a\u8fd9\u5bf9Python\u53ef\u80fd\u4e0d\u662f\u4ec0\u4e48\u95ee\u9898\uff0c\u4f46\u5bf9\u4e8eJava\u8fd9\u6837\u6bcf\u4e00\u4e2a\u7c7b\u90fd\u9700\u8981\u4e00\u4e2a\u6587\u4ef6\u7684\u8bed\u8a00\u6765\u8bf4\u2026\u2026 \u89c2\u5bdf\u8005\u6a21\u5f0f\uff08Observer Pattern\uff09 # \u89c2\u5bdf\u8005\u6a21\u5f0f \u89c2\u5bdf\u8005\u6a21\u5f0f\u4e2d\u4e00\u4e2a\u5bf9\u8c61\uff08\u4e3b\u4f53\uff08Subject\uff09\u6216\u53ef\u89c2\u5bdf\uff08Observable\uff09\uff09\u7ef4\u62a4\u4e00\u4e2a\u5217\u8868\u7684\u5bf9\u8c61\uff08\u89c2\u5bdf\u8005\uff08Observer\uff09\uff09\uff0c\u5e76\u5728\u81ea\u8eab\u7684\u72b6\u6001\u53d1\u751f\u6539\u53d8\u65f6\u901a\u77e5\u89c2\u5bdf\u8005\u3002 \u89c2\u5bdf\u8005\u6a21\u5f0f\u5bb9\u6613\u548c\u53d1\u5e03/\u8ba2\u9605\u6a21\u5f0f\uff08Publish/Subscribe Pattern\uff09\u6df7\u6dc6\uff0c\u4e24\u8005\u7684\u533a\u522b\u4e3b\u8981\u5728\u4e8e\u53d1\u5e03/\u8ba2\u9605\u6a21\u5f0f\u6709\u4e00\u4e2a\u4e2d\u95f4\u4ef6\u8d1f\u8d23\u6d88\u606f\u7684\u8f6c\u53d1\uff0c\u56e0\u6b64\u53d1\u5e03\u8005\u548c\u8ba2\u9605\u8005\u4e0d\u9700\u8981\u5bf9\u5f7c\u6b64\u6709\u4efb\u4f55\u4e86\u89e3\u3002\u4f46\u5728\u89c2\u5bdf\u8005\u6a21\u5f0f\u4e2d\uff0c\u4e3b\u4f53\u9700\u8981\u5bf9\u89c2\u5bdf\u8005\u7684\u901a\u77e5\u65b9\u6cd5\u6709\u6240\u4e86\u89e3\u3002 \u7ed3\u6784 \u89c2\u5bdf\u8005\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e24\u79cd\u89d2\u8272\u6784\u6210\uff1a \u4e3b\u4f53\uff08Subject\uff09\u6216\u53ef\u89c2\u5bdf\uff08Observable\uff09 \u89c2\u5bdf\u8005\uff08Observer\uff09 \u89c2\u5bdf\u8005\u6a21\u5f0f from enum import Enum class Kitchen ( object ): # \u4e3b\u4f53 def __init__ ( self ): self . _waiters = [ Waiter ( i ) for _ in range ( 10 )] def collect_order ( self ): [ waiter . collect_order () for waiter in self . _waiters ] class Waiter ( object ): # \u89c2\u5bdf\u8005 def __init__ ( self , i : int ): self . id = i self . status = WaiterStatus . Free def collect_order ( self ): print ( 'Coming' ) if self . status != WaiterStatus . Busy else print ( 'Busy' ) class WaiterStatus ( Enum ): Free = 0 Busy = 1 \u4f18\u70b9 \u964d\u4f4e\u4e86\u4e3b\u4f53\u548c\u89c2\u5bdf\u8005\u4e4b\u95f4\u7684\u8026\u5408 \u7f3a\u70b9 \u4e3b\u4f53\u548c\u89c2\u5bdf\u8005\u4e4b\u95f4\u4ecd\u5b58\u5728\u8026\u5408 \u89c2\u5bdf\u8005\u8f83\u591a\u65f6\u901a\u77e5\u53d1\u5e03\u4f1a\u5f71\u54cd\u6027\u80fd \u5916\u89c2\u6a21\u5f0f\uff08Facade Pattern\uff09 # \u5916\u89c2\u6a21\u5f0f \u7c7b\u4f3c\u4e8e\u5efa\u7b51\u4e2d\u7684\u5916\u5899\uff0c\u4e00\u4e2a\u5916\u89c2\u662f\u63a9\u76d6\u4e86\u66f4\u590d\u6742\u7684\u57fa\u7840\u6216\u7ed3\u6784\u4ee3\u7801\u800c\u5145\u5f53\u5bf9\u5916\u63a5\u53e3\u7684\u5bf9\u8c61\u3002 \u4e00\u4e2a\u5927\u578b\u53a8\u623f\u7531\u5f88\u591a\u5b50\u90e8\u5206\u6784\u6210\u2013\u6253\u8377\u3001\u51b7\u83dc\u3001\u84b8\u83dc\u3001\u9762\u6848\u3001\u6c34\u53f0\u3001\u7827\u677f\u3001\u70ed\u7076\uff0c\u800c\u5bf9\u4e8e\u8d1f\u8d23\u4e0b\u5355\u7684\u670d\u52a1\u5458\u6765\u8bf4\uff0c\u5b83\u5e76\u4e0d\u9700\u8981\u4e86\u89e3\u8fd9\u8bb8\u591a\u3002 \u7ed3\u6784 \u5916\u89c2\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u5ba2\u6237\uff08Client\uff09\uff1a\u8bbf\u95ee\u5916\u89c2\u7684\u5bf9\u8c61 \u5916\u89c2\uff08Facade\uff09\uff1a\u5c06\u5b50\u7cfb\u7edf\u5305\u88c5\u7684\u516c\u5171\u63a5\u53e3 \u5b50\u7cfb\u7edf\uff08Subsystem\uff09\uff1a\u5b50\u7cfb\u7edf\u7684\u5177\u4f53\u5b9e\u73b0 \u5916\u89c2\u6a21\u5f0f class Kitchen ( object ): # \u5916\u89c2 def __init__ ( self ): self . prepare = Prepare () self . cold = Cold () self . steam = Steam () self . noodles = Noodles () self . wash = Wash () self . chop = Chop () self . stove = Stove () def add_order ( self ): self . prepare . prepare () self . cold . cook () self . steam . cook () self . noodles . cook () self . wash . wash () self . chop . chop () self . stove . cook () self . collect_order () \u4f18\u70b9 \u5bf9\u5ba2\u6237\u5c4f\u853d\u4e86\u5b50\u7cfb\u7edf\uff0c\u964d\u4f4e\u4e86\u8026\u5408 \u7f3a\u70b9 \u96be\u4ee5\u5bf9\u5ba2\u6237\u5b9a\u5236\u9700\u6c42 \u65b0\u589e\u5b50\u7cfb\u7edf\u53ef\u80fd\u4f1a\u9700\u8981\u5916\u89c2\u548c\u5ba2\u6237\u4f5c\u51fa\u4fee\u6539 \u5355\u4f8b\u6a21\u5f0f\uff08Singleton Pattern\uff09 # \u5355\u4f8b\u6a21\u5f0f \u5c06\u7c7b\u7684\u5b9e\u4f8b\u5316\u9650\u5236\u4e3a\u552f\u4e00\u7684\u5355\u4e2a\u5b9e\u4f8b\u3002 \u4e00\u4e2a\u5927\u578b\u9152\u5e97\u53ef\u80fd\u62e5\u6709\u5f88\u591a\u5458\u5de5\u751a\u81f3\u591a\u4e2a\u53a8\u623f\uff0c\u4f46\u4ed6\u6c38\u8fdc\u53ea\u6709\u4e00\u4e2a\u603b\u53a8\u5e08\u957f\u3002 \u7ed3\u6784 \u5355\u4f8b\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u5ba2\u6237\uff08Client\uff09\uff1a\u8bbf\u95ee\u5355\u4f8b\u7684\u5bf9\u8c61 \u5355\u4f8b\uff08Singleton\uff09\uff1a\u5305\u542b\u4e00\u4e2a\u5b9e\u4f8b\u4e14\u4f1a\u81ea\u52a8\u521b\u5efa\u8be5\u5b9e\u4f8b\u7684\u7c7b \u5355\u4f8b\u6a21\u5f0f class ChiefHeadChef ( object ): __chief_head_chef = None def __new__ ( cls ): if not cls . __chief_head_chef : cls . __chief_head_chef = object . __new__ ( cls ) return cls . __chief_head_chef \u4f18\u70b9 \u5355\u4f8b\u548c\u5ba2\u6237\u9ad8\u5ea6\u8026\u5408\uff0c\u6bcf\u4e2a\u5ba2\u6237\u5bf9\u5355\u4f8b\u505a\u51fa\u7684\u4fee\u6539\u90fd\u5c06\u5f71\u54cd\u5176\u4ed6\u5ba2\u6237 \u7f3a\u70b9 \u5355\u4f8b\u548c\u5ba2\u6237\u9ad8\u5ea6\u8026\u5408\uff0c\u6bcf\u4e2a\u5ba2\u6237\u5bf9\u5355\u4f8b\u505a\u51fa\u7684\u4fee\u6539\u90fd\u5c06\u5f71\u54cd\u5176\u4ed6\u5ba2\u6237","title":"\u8bbe\u8ba1\u6a21\u5f0f\uff08Design Pattern\uff09"},{"location":"document/design_pattern%20copy/#strategy-pattern-policy-pattern","text":"\u7b56\u7565\u6a21\u5f0f \u7b56\u7565\u6a21\u5f0f\u5728\u8fd0\u884c\u65f6\u9009\u62e9\u7b97\u6cd5\u3002\u4ee3\u7801\u5e76\u4e0d\u76f4\u63a5\u5b9e\u73b0\u5355\u4e2a\u7b97\u6cd5\uff0c\u800c\u662f\u63a5\u6536\u8fd0\u884c\u65f6\u6307\u4ee4\uff0c\u4ee5\u6307\u793a\u5728\u4e00\u7cfb\u5217\u7b97\u6cd5\u4e2d\u8981\u4f7f\u7528\u54ea\u4e2a\u3002 \u7b56\u7565\u6a21\u5f0f\u5f53\u4e2d\u7684\u63a5\u53e3\u662f\u56fa\u5b9a\u7684\uff0c\u56e0\u6b64\u8c03\u7528\u65f6\u4e0d\u8bb8\u66f4\u6539\u65b9\u6cd5\u3002 \u7ed3\u6784 \u7b56\u7565\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u4e0a\u4e0b\u6587\uff08Context\uff09\uff1a\u5f15\u7528\u7b56\u7565\u7684\u5bf9\u8c61 \u7b56\u7565\uff08Strategy\uff09\uff1a\u7b56\u7565\u7684\u516c\u5171\u63a5\u53e3\uff0c\u5177\u4f53\u7b56\u7565\u90fd\u5c06\u5b9e\u73b0\u8fd9\u4e2a\u63a5\u53e3 \u5177\u4f53\u7b56\u7565\uff08Concrete Strategy\uff09\uff1a\u7b56\u7565\u7684\u5177\u4f53\u5b9e\u73b0\uff0c\u5305\u542b\u4e86\u5177\u4f53\u7684\u7b97\u6cd5\u4ee3\u7801 \u7b56\u7565\u6a21\u5f0f from abc import ABC , abstractmethod class ChickenCooker ( ABC ): # \u7b56\u7565 @abstractmethod def cook ( self ): pass class FriedChickenCooker ( ChickenCooker ): # \u5177\u4f53\u7b56\u75651 def cook ( self ): print ( \"Cooking fried chicken!\" ) class GrilledChickenCooker ( ChickenCooker ): # \u5177\u4f53\u7b56\u75652 def cook ( self ): print ( \"Cooking grilled chicken!\" ) class Kitchen ( object ): # \u4e0a\u4e0b\u6587 def __init__ ( self ): self . _strategy = None @property def strategy ( self ): return self . _strategy @strategy . setter def strategy ( self , strategy ): self . _strategy = strategy def cook ( self ): self . _strategy . cook () \u4f18\u70b9 \u901a\u8fc7\u628a\u7b97\u6cd5\u7684\u8c03\u7528\u653e\u5230\u4e0a\u4e0b\u6587\u5f53\u4e2d\uff0c\u628a\u5b9e\u73b0\u653e\u5230\u4e86\u7b56\u7565\u5f53\u4e2d\u800c\u5b9e\u73b0\u4e86\u4e24\u8005\u7684\u5206\u79bb \u63d0\u4f9b\u76f8\u540c\u884c\u4e3a\u7684\u4e0d\u540c\u5b9e\u73b0\uff1a\u540c\u6837\u662f\u505a\u9e21\uff0c\u6709\u5f88\u591a\u79cd\u4e0d\u540c\u7684\u505a\u6cd5 \u53ef\u4ee5\u7b80\u5355\u7684\u6dfb\u52a0\u65b0\u7684\u7b56\u7565\uff1a\u4ec5\u9700\u521b\u5efa\u4e00\u4e2a\u65b0\u7684Beggar Chicken\u5c31\u53ef\u4ee5\u5b9e\u73b0\u53eb\u82b1\u9e21 \u53ef\u4ee5\u5c06\u90e8\u5206\u4ee3\u7801\u653e\u5230\u7b56\u7565\u5f53\u4e2d\u800c\u907f\u514d\u91cd\u590d\u4ee3\u7801\uff1a\u65e0\u8bba\u662f\u70b8\u9e21\u8fd8\u662f\u70e4\u9e21\uff0c\u4f60\u90fd\u5148\u8981\u5207\u9e21 \u7f3a\u70b9 \u4e0a\u4e0b\u6587\u9700\u8981\u5bf9\u5b9e\u73b0\u6709\u8db3\u591f\u7684\u4e86\u89e3\u6765\u9009\u62e9\u6070\u5f53\u7684\u65b9\u6cd5\uff1a\u4f60\u8981\u77e5\u9053\u505a\u51fa\u6765\u662f\u4ec0\u4e48\u9e21 \u4f1a\u9020\u6210\u5f88\u591a\u7684\u5177\u4f53\u7b56\u7565\u7c7b\uff1a\u8fd9\u5bf9Python\u53ef\u80fd\u4e0d\u662f\u4ec0\u4e48\u95ee\u9898\uff0c\u4f46\u5bf9\u4e8eJava\u8fd9\u6837\u6bcf\u4e00\u4e2a\u7c7b\u90fd\u9700\u8981\u4e00\u4e2a\u6587\u4ef6\u7684\u8bed\u8a00\u6765\u8bf4\u2026\u2026","title":"\u7b56\u7565\u6a21\u5f0f\uff08Strategy Pattern, Policy Pattern\uff09"},{"location":"document/design_pattern%20copy/#observer-pattern","text":"\u89c2\u5bdf\u8005\u6a21\u5f0f \u89c2\u5bdf\u8005\u6a21\u5f0f\u4e2d\u4e00\u4e2a\u5bf9\u8c61\uff08\u4e3b\u4f53\uff08Subject\uff09\u6216\u53ef\u89c2\u5bdf\uff08Observable\uff09\uff09\u7ef4\u62a4\u4e00\u4e2a\u5217\u8868\u7684\u5bf9\u8c61\uff08\u89c2\u5bdf\u8005\uff08Observer\uff09\uff09\uff0c\u5e76\u5728\u81ea\u8eab\u7684\u72b6\u6001\u53d1\u751f\u6539\u53d8\u65f6\u901a\u77e5\u89c2\u5bdf\u8005\u3002 \u89c2\u5bdf\u8005\u6a21\u5f0f\u5bb9\u6613\u548c\u53d1\u5e03/\u8ba2\u9605\u6a21\u5f0f\uff08Publish/Subscribe Pattern\uff09\u6df7\u6dc6\uff0c\u4e24\u8005\u7684\u533a\u522b\u4e3b\u8981\u5728\u4e8e\u53d1\u5e03/\u8ba2\u9605\u6a21\u5f0f\u6709\u4e00\u4e2a\u4e2d\u95f4\u4ef6\u8d1f\u8d23\u6d88\u606f\u7684\u8f6c\u53d1\uff0c\u56e0\u6b64\u53d1\u5e03\u8005\u548c\u8ba2\u9605\u8005\u4e0d\u9700\u8981\u5bf9\u5f7c\u6b64\u6709\u4efb\u4f55\u4e86\u89e3\u3002\u4f46\u5728\u89c2\u5bdf\u8005\u6a21\u5f0f\u4e2d\uff0c\u4e3b\u4f53\u9700\u8981\u5bf9\u89c2\u5bdf\u8005\u7684\u901a\u77e5\u65b9\u6cd5\u6709\u6240\u4e86\u89e3\u3002 \u7ed3\u6784 \u89c2\u5bdf\u8005\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e24\u79cd\u89d2\u8272\u6784\u6210\uff1a \u4e3b\u4f53\uff08Subject\uff09\u6216\u53ef\u89c2\u5bdf\uff08Observable\uff09 \u89c2\u5bdf\u8005\uff08Observer\uff09 \u89c2\u5bdf\u8005\u6a21\u5f0f from enum import Enum class Kitchen ( object ): # \u4e3b\u4f53 def __init__ ( self ): self . _waiters = [ Waiter ( i ) for _ in range ( 10 )] def collect_order ( self ): [ waiter . collect_order () for waiter in self . _waiters ] class Waiter ( object ): # \u89c2\u5bdf\u8005 def __init__ ( self , i : int ): self . id = i self . status = WaiterStatus . Free def collect_order ( self ): print ( 'Coming' ) if self . status != WaiterStatus . Busy else print ( 'Busy' ) class WaiterStatus ( Enum ): Free = 0 Busy = 1 \u4f18\u70b9 \u964d\u4f4e\u4e86\u4e3b\u4f53\u548c\u89c2\u5bdf\u8005\u4e4b\u95f4\u7684\u8026\u5408 \u7f3a\u70b9 \u4e3b\u4f53\u548c\u89c2\u5bdf\u8005\u4e4b\u95f4\u4ecd\u5b58\u5728\u8026\u5408 \u89c2\u5bdf\u8005\u8f83\u591a\u65f6\u901a\u77e5\u53d1\u5e03\u4f1a\u5f71\u54cd\u6027\u80fd","title":"\u89c2\u5bdf\u8005\u6a21\u5f0f\uff08Observer Pattern\uff09"},{"location":"document/design_pattern%20copy/#facade-pattern","text":"\u5916\u89c2\u6a21\u5f0f \u7c7b\u4f3c\u4e8e\u5efa\u7b51\u4e2d\u7684\u5916\u5899\uff0c\u4e00\u4e2a\u5916\u89c2\u662f\u63a9\u76d6\u4e86\u66f4\u590d\u6742\u7684\u57fa\u7840\u6216\u7ed3\u6784\u4ee3\u7801\u800c\u5145\u5f53\u5bf9\u5916\u63a5\u53e3\u7684\u5bf9\u8c61\u3002 \u4e00\u4e2a\u5927\u578b\u53a8\u623f\u7531\u5f88\u591a\u5b50\u90e8\u5206\u6784\u6210\u2013\u6253\u8377\u3001\u51b7\u83dc\u3001\u84b8\u83dc\u3001\u9762\u6848\u3001\u6c34\u53f0\u3001\u7827\u677f\u3001\u70ed\u7076\uff0c\u800c\u5bf9\u4e8e\u8d1f\u8d23\u4e0b\u5355\u7684\u670d\u52a1\u5458\u6765\u8bf4\uff0c\u5b83\u5e76\u4e0d\u9700\u8981\u4e86\u89e3\u8fd9\u8bb8\u591a\u3002 \u7ed3\u6784 \u5916\u89c2\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u5ba2\u6237\uff08Client\uff09\uff1a\u8bbf\u95ee\u5916\u89c2\u7684\u5bf9\u8c61 \u5916\u89c2\uff08Facade\uff09\uff1a\u5c06\u5b50\u7cfb\u7edf\u5305\u88c5\u7684\u516c\u5171\u63a5\u53e3 \u5b50\u7cfb\u7edf\uff08Subsystem\uff09\uff1a\u5b50\u7cfb\u7edf\u7684\u5177\u4f53\u5b9e\u73b0 \u5916\u89c2\u6a21\u5f0f class Kitchen ( object ): # \u5916\u89c2 def __init__ ( self ): self . prepare = Prepare () self . cold = Cold () self . steam = Steam () self . noodles = Noodles () self . wash = Wash () self . chop = Chop () self . stove = Stove () def add_order ( self ): self . prepare . prepare () self . cold . cook () self . steam . cook () self . noodles . cook () self . wash . wash () self . chop . chop () self . stove . cook () self . collect_order () \u4f18\u70b9 \u5bf9\u5ba2\u6237\u5c4f\u853d\u4e86\u5b50\u7cfb\u7edf\uff0c\u964d\u4f4e\u4e86\u8026\u5408 \u7f3a\u70b9 \u96be\u4ee5\u5bf9\u5ba2\u6237\u5b9a\u5236\u9700\u6c42 \u65b0\u589e\u5b50\u7cfb\u7edf\u53ef\u80fd\u4f1a\u9700\u8981\u5916\u89c2\u548c\u5ba2\u6237\u4f5c\u51fa\u4fee\u6539","title":"\u5916\u89c2\u6a21\u5f0f\uff08Facade Pattern\uff09"},{"location":"document/design_pattern%20copy/#singleton-pattern","text":"\u5355\u4f8b\u6a21\u5f0f \u5c06\u7c7b\u7684\u5b9e\u4f8b\u5316\u9650\u5236\u4e3a\u552f\u4e00\u7684\u5355\u4e2a\u5b9e\u4f8b\u3002 \u4e00\u4e2a\u5927\u578b\u9152\u5e97\u53ef\u80fd\u62e5\u6709\u5f88\u591a\u5458\u5de5\u751a\u81f3\u591a\u4e2a\u53a8\u623f\uff0c\u4f46\u4ed6\u6c38\u8fdc\u53ea\u6709\u4e00\u4e2a\u603b\u53a8\u5e08\u957f\u3002 \u7ed3\u6784 \u5355\u4f8b\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u5ba2\u6237\uff08Client\uff09\uff1a\u8bbf\u95ee\u5355\u4f8b\u7684\u5bf9\u8c61 \u5355\u4f8b\uff08Singleton\uff09\uff1a\u5305\u542b\u4e00\u4e2a\u5b9e\u4f8b\u4e14\u4f1a\u81ea\u52a8\u521b\u5efa\u8be5\u5b9e\u4f8b\u7684\u7c7b \u5355\u4f8b\u6a21\u5f0f class ChiefHeadChef ( object ): __chief_head_chef = None def __new__ ( cls ): if not cls . __chief_head_chef : cls . __chief_head_chef = object . __new__ ( cls ) return cls . __chief_head_chef \u4f18\u70b9 \u5355\u4f8b\u548c\u5ba2\u6237\u9ad8\u5ea6\u8026\u5408\uff0c\u6bcf\u4e2a\u5ba2\u6237\u5bf9\u5355\u4f8b\u505a\u51fa\u7684\u4fee\u6539\u90fd\u5c06\u5f71\u54cd\u5176\u4ed6\u5ba2\u6237 \u7f3a\u70b9 \u5355\u4f8b\u548c\u5ba2\u6237\u9ad8\u5ea6\u8026\u5408\uff0c\u6bcf\u4e2a\u5ba2\u6237\u5bf9\u5355\u4f8b\u505a\u51fa\u7684\u4fee\u6539\u90fd\u5c06\u5f71\u54cd\u5176\u4ed6\u5ba2\u6237","title":"\u5355\u4f8b\u6a21\u5f0f\uff08Singleton Pattern\uff09"},{"location":"document/design_pattern/","text":"\u672c\u6587\u65e8\u5728\u8bb0\u5f55COMP2100\u8bfe\u7a0b\u590d\u4e60\u7684\u7b14\u8bb0\uff0c\u6d89\u53ca\u7b56\u7565\u6a21\u5f0f\uff08Strategy Pattern\uff09\u3001\u89c2\u5bdf\u8005\u6a21\u5f0f\uff08Ovserver Pattern\uff09\u3001\u5916\u89c2\u6a21\u5f0f\uff08Facade Pattern\uff09\u548c\u5355\u4f8b\u6a21\u5f0f\uff08Sigleton Pattern\uff09\u3002 \u6211\u4eec\u9884\u8ba1\u5728\u4e4b\u540e\u4f1a\u5b8c\u5584\u672c\u6587\u3002 \u672c\u6587\u4e0e\u4e4b\u524d\u4e00\u6837\u5c06\u4f7f\u7528Python\u6765\u5b9e\u73b0\u6240\u7528\u7528\u4f8b\u3002\u4f46\u5728\u5b9e\u9645\u60c5\u51b5\u5f53\u4e2d\uff0c\u6211\u4eec\u5e76\u4e0d\u63a8\u8350\u4f7f\u7528Python\u521b\u5efa\u63a5\u53e3\u548c\u62bd\u8c61\u57fa\u7c7b\u3002Python\u662f\u4e00\u95e8\u52a8\u6001\u8bed\u8a00\uff0c\u5f3a\u5236\u7c7b\u578b\u68c0\u67e5\u65e0\u5f02\u4e8e\u5357\u8f95\u5317\u8f99\u3002 \u7b56\u7565\u6a21\u5f0f\uff08Strategy Pattern, Policy Pattern\uff09 # \u7b56\u7565\u6a21\u5f0f \u7b56\u7565\u6a21\u5f0f\u5728\u8fd0\u884c\u65f6\u9009\u62e9\u7b97\u6cd5\u3002\u4ee3\u7801\u5e76\u4e0d\u76f4\u63a5\u5b9e\u73b0\u5355\u4e2a\u7b97\u6cd5\uff0c\u800c\u662f\u63a5\u6536\u8fd0\u884c\u65f6\u6307\u4ee4\uff0c\u4ee5\u6307\u793a\u5728\u4e00\u7cfb\u5217\u7b97\u6cd5\u4e2d\u8981\u4f7f\u7528\u54ea\u4e2a\u3002 \u7b56\u7565\u6a21\u5f0f\u5f53\u4e2d\u7684\u63a5\u53e3\u662f\u56fa\u5b9a\u7684\uff0c\u56e0\u6b64\u8c03\u7528\u65f6\u4e0d\u8bb8\u66f4\u6539\u65b9\u6cd5\u3002 \u7ed3\u6784 \u7b56\u7565\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u4e0a\u4e0b\u6587\uff08Context\uff09\uff1a\u5f15\u7528\u7b56\u7565\u7684\u5bf9\u8c61 \u7b56\u7565\uff08Strategy\uff09\uff1a\u7b56\u7565\u7684\u516c\u5171\u63a5\u53e3\uff0c\u5177\u4f53\u7b56\u7565\u90fd\u5c06\u5b9e\u73b0\u8fd9\u4e2a\u63a5\u53e3 \u5177\u4f53\u7b56\u7565\uff08Concrete Strategy\uff09\uff1a\u7b56\u7565\u7684\u5177\u4f53\u5b9e\u73b0\uff0c\u5305\u542b\u4e86\u5177\u4f53\u7684\u7b97\u6cd5\u4ee3\u7801 \u7b56\u7565\u6a21\u5f0f from abc import ABC , abstractmethod class ChickenCooker ( ABC ): # \u7b56\u7565 @abstractmethod def cook ( self ): pass class FriedChickenCooker ( ChickenCooker ): # \u5177\u4f53\u7b56\u75651 def cook ( self ): print ( \"Cooking fried chicken!\" ) class GrilledChickenCooker ( ChickenCooker ): # \u5177\u4f53\u7b56\u75652 def cook ( self ): print ( \"Cooking grilled chicken!\" ) class Kitchen ( object ): # \u4e0a\u4e0b\u6587 def __init__ ( self ): self . _strategy = None @property def strategy ( self ): return self . _strategy @strategy . setter def strategy ( self , strategy ): self . _strategy = strategy def cook ( self ): self . _strategy . cook () \u4f18\u70b9 \u901a\u8fc7\u628a\u7b97\u6cd5\u7684\u8c03\u7528\u653e\u5230\u4e0a\u4e0b\u6587\u5f53\u4e2d\uff0c\u628a\u5b9e\u73b0\u653e\u5230\u4e86\u7b56\u7565\u5f53\u4e2d\u800c\u5b9e\u73b0\u4e86\u4e24\u8005\u7684\u5206\u79bb \u63d0\u4f9b\u76f8\u540c\u884c\u4e3a\u7684\u4e0d\u540c\u5b9e\u73b0\uff1a\u540c\u6837\u662f\u505a\u9e21\uff0c\u6709\u5f88\u591a\u79cd\u4e0d\u540c\u7684\u505a\u6cd5 \u53ef\u4ee5\u7b80\u5355\u7684\u6dfb\u52a0\u65b0\u7684\u7b56\u7565\uff1a\u4ec5\u9700\u521b\u5efa\u4e00\u4e2a\u65b0\u7684Beggar Chicken\u5c31\u53ef\u4ee5\u5b9e\u73b0\u53eb\u82b1\u9e21 \u53ef\u4ee5\u5c06\u90e8\u5206\u4ee3\u7801\u653e\u5230\u7b56\u7565\u5f53\u4e2d\u800c\u907f\u514d\u91cd\u590d\u4ee3\u7801\uff1a\u65e0\u8bba\u662f\u70b8\u9e21\u8fd8\u662f\u70e4\u9e21\uff0c\u4f60\u90fd\u5148\u8981\u5207\u9e21 \u7f3a\u70b9 \u4e0a\u4e0b\u6587\u9700\u8981\u5bf9\u5b9e\u73b0\u6709\u8db3\u591f\u7684\u4e86\u89e3\u6765\u9009\u62e9\u6070\u5f53\u7684\u65b9\u6cd5\uff1a\u4f60\u8981\u77e5\u9053\u505a\u51fa\u6765\u662f\u4ec0\u4e48\u9e21 \u4f1a\u9020\u6210\u5f88\u591a\u7684\u5177\u4f53\u7b56\u7565\u7c7b\uff1a\u8fd9\u5bf9Python\u53ef\u80fd\u4e0d\u662f\u4ec0\u4e48\u95ee\u9898\uff0c\u4f46\u5bf9\u4e8eJava\u8fd9\u6837\u6bcf\u4e00\u4e2a\u7c7b\u90fd\u9700\u8981\u4e00\u4e2a\u6587\u4ef6\u7684\u8bed\u8a00\u6765\u8bf4\u2026\u2026 \u89c2\u5bdf\u8005\u6a21\u5f0f\uff08Observer Pattern\uff09 # \u89c2\u5bdf\u8005\u6a21\u5f0f \u89c2\u5bdf\u8005\u6a21\u5f0f\u4e2d\u4e00\u4e2a\u5bf9\u8c61\uff08\u4e3b\u4f53\uff08Subject\uff09\u6216\u53ef\u89c2\u5bdf\uff08Observable\uff09\uff09\u7ef4\u62a4\u4e00\u4e2a\u5217\u8868\u7684\u5bf9\u8c61\uff08\u89c2\u5bdf\u8005\uff08Observer\uff09\uff09\uff0c\u5e76\u5728\u81ea\u8eab\u7684\u72b6\u6001\u53d1\u751f\u6539\u53d8\u65f6\u901a\u77e5\u89c2\u5bdf\u8005\u3002 \u89c2\u5bdf\u8005\u6a21\u5f0f\u5bb9\u6613\u548c\u53d1\u5e03/\u8ba2\u9605\u6a21\u5f0f\uff08Publish/Subscribe Pattern\uff09\u6df7\u6dc6\uff0c\u4e24\u8005\u7684\u533a\u522b\u4e3b\u8981\u5728\u4e8e\u53d1\u5e03/\u8ba2\u9605\u6a21\u5f0f\u6709\u4e00\u4e2a\u4e2d\u95f4\u4ef6\u8d1f\u8d23\u6d88\u606f\u7684\u8f6c\u53d1\uff0c\u56e0\u6b64\u53d1\u5e03\u8005\u548c\u8ba2\u9605\u8005\u4e0d\u9700\u8981\u5bf9\u5f7c\u6b64\u6709\u4efb\u4f55\u4e86\u89e3\u3002\u4f46\u5728\u89c2\u5bdf\u8005\u6a21\u5f0f\u4e2d\uff0c\u4e3b\u4f53\u9700\u8981\u5bf9\u89c2\u5bdf\u8005\u7684\u901a\u77e5\u65b9\u6cd5\u6709\u6240\u4e86\u89e3\u3002 \u7ed3\u6784 \u89c2\u5bdf\u8005\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e24\u79cd\u89d2\u8272\u6784\u6210\uff1a \u4e3b\u4f53\uff08Subject\uff09\u6216\u53ef\u89c2\u5bdf\uff08Observable\uff09 \u89c2\u5bdf\u8005\uff08Observer\uff09 \u89c2\u5bdf\u8005\u6a21\u5f0f from enum import Enum class Kitchen ( object ): # \u4e3b\u4f53 def __init__ ( self ): self . _waiters = [ Waiter ( i ) for _ in range ( 10 )] def collect_order ( self ): [ waiter . collect_order () for waiter in self . _waiters ] class Waiter ( object ): # \u89c2\u5bdf\u8005 def __init__ ( self , i : int ): self . id = i self . status = WaiterStatus . Free def collect_order ( self ): print ( 'Coming' ) if self . status != WaiterStatus . Busy else print ( 'Busy' ) class WaiterStatus ( Enum ): Free = 0 Busy = 1 \u4f18\u70b9 \u964d\u4f4e\u4e86\u4e3b\u4f53\u548c\u89c2\u5bdf\u8005\u4e4b\u95f4\u7684\u8026\u5408 \u7f3a\u70b9 \u4e3b\u4f53\u548c\u89c2\u5bdf\u8005\u4e4b\u95f4\u4ecd\u5b58\u5728\u8026\u5408 \u89c2\u5bdf\u8005\u8f83\u591a\u65f6\u901a\u77e5\u53d1\u5e03\u4f1a\u5f71\u54cd\u6027\u80fd \u5916\u89c2\u6a21\u5f0f\uff08Facade Pattern\uff09 # \u5916\u89c2\u6a21\u5f0f \u7c7b\u4f3c\u4e8e\u5efa\u7b51\u4e2d\u7684\u5916\u5899\uff0c\u4e00\u4e2a\u5916\u89c2\u662f\u63a9\u76d6\u4e86\u66f4\u590d\u6742\u7684\u57fa\u7840\u6216\u7ed3\u6784\u4ee3\u7801\u800c\u5145\u5f53\u5bf9\u5916\u63a5\u53e3\u7684\u5bf9\u8c61\u3002 \u4e00\u4e2a\u5927\u578b\u53a8\u623f\u7531\u5f88\u591a\u5b50\u90e8\u5206\u6784\u6210\u2013\u6253\u8377\u3001\u51b7\u83dc\u3001\u84b8\u83dc\u3001\u9762\u6848\u3001\u6c34\u53f0\u3001\u7827\u677f\u3001\u70ed\u7076\uff0c\u800c\u5bf9\u4e8e\u8d1f\u8d23\u4e0b\u5355\u7684\u670d\u52a1\u5458\u6765\u8bf4\uff0c\u5b83\u5e76\u4e0d\u9700\u8981\u4e86\u89e3\u8fd9\u8bb8\u591a\u3002 \u7ed3\u6784 \u5916\u89c2\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u5ba2\u6237\uff08Client\uff09\uff1a\u8bbf\u95ee\u5916\u89c2\u7684\u5bf9\u8c61 \u5916\u89c2\uff08Facade\uff09\uff1a\u5c06\u5b50\u7cfb\u7edf\u5305\u88c5\u7684\u516c\u5171\u63a5\u53e3 \u5b50\u7cfb\u7edf\uff08Subsystem\uff09\uff1a\u5b50\u7cfb\u7edf\u7684\u5177\u4f53\u5b9e\u73b0 \u5916\u89c2\u6a21\u5f0f class Kitchen ( object ): # \u5916\u89c2 def __init__ ( self ): self . prepare = Prepare () self . cold = Cold () self . steam = Steam () self . noodles = Noodles () self . wash = Wash () self . chop = Chop () self . stove = Stove () def add_order ( self ): self . prepare . prepare () self . cold . cook () self . steam . cook () self . noodles . cook () self . wash . wash () self . chop . chop () self . stove . cook () self . collect_order () \u4f18\u70b9 \u5bf9\u5ba2\u6237\u5c4f\u853d\u4e86\u5b50\u7cfb\u7edf\uff0c\u964d\u4f4e\u4e86\u8026\u5408 \u7f3a\u70b9 \u96be\u4ee5\u5bf9\u5ba2\u6237\u5b9a\u5236\u9700\u6c42 \u65b0\u589e\u5b50\u7cfb\u7edf\u53ef\u80fd\u4f1a\u9700\u8981\u5916\u89c2\u548c\u5ba2\u6237\u4f5c\u51fa\u4fee\u6539 \u5355\u4f8b\u6a21\u5f0f\uff08Singleton Pattern\uff09 # \u5355\u4f8b\u6a21\u5f0f \u5c06\u7c7b\u7684\u5b9e\u4f8b\u5316\u9650\u5236\u4e3a\u552f\u4e00\u7684\u5355\u4e2a\u5b9e\u4f8b\u3002 \u4e00\u4e2a\u5927\u578b\u9152\u5e97\u53ef\u80fd\u62e5\u6709\u5f88\u591a\u5458\u5de5\u751a\u81f3\u591a\u4e2a\u53a8\u623f\uff0c\u4f46\u4ed6\u6c38\u8fdc\u53ea\u6709\u4e00\u4e2a\u603b\u53a8\u5e08\u957f\u3002 \u7ed3\u6784 \u5355\u4f8b\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u5ba2\u6237\uff08Client\uff09\uff1a\u8bbf\u95ee\u5355\u4f8b\u7684\u5bf9\u8c61 \u5355\u4f8b\uff08Singleton\uff09\uff1a\u5305\u542b\u4e00\u4e2a\u5b9e\u4f8b\u4e14\u4f1a\u81ea\u52a8\u521b\u5efa\u8be5\u5b9e\u4f8b\u7684\u7c7b \u5355\u4f8b\u6a21\u5f0f class ChiefHeadChef ( object ): __chief_head_chef = None def __new__ ( cls ): if not cls . __chief_head_chef : cls . __chief_head_chef = object . __new__ ( cls ) return cls . __chief_head_chef \u4f18\u70b9 \u5355\u4f8b\u548c\u5ba2\u6237\u9ad8\u5ea6\u8026\u5408\uff0c\u6bcf\u4e2a\u5ba2\u6237\u5bf9\u5355\u4f8b\u505a\u51fa\u7684\u4fee\u6539\u90fd\u5c06\u5f71\u54cd\u5176\u4ed6\u5ba2\u6237 \u7f3a\u70b9 \u5355\u4f8b\u548c\u5ba2\u6237\u9ad8\u5ea6\u8026\u5408\uff0c\u6bcf\u4e2a\u5ba2\u6237\u5bf9\u5355\u4f8b\u505a\u51fa\u7684\u4fee\u6539\u90fd\u5c06\u5f71\u54cd\u5176\u4ed6\u5ba2\u6237","title":"\u8bbe\u8ba1\u6a21\u5f0f"},{"location":"document/design_pattern/#strategy-pattern-policy-pattern","text":"\u7b56\u7565\u6a21\u5f0f \u7b56\u7565\u6a21\u5f0f\u5728\u8fd0\u884c\u65f6\u9009\u62e9\u7b97\u6cd5\u3002\u4ee3\u7801\u5e76\u4e0d\u76f4\u63a5\u5b9e\u73b0\u5355\u4e2a\u7b97\u6cd5\uff0c\u800c\u662f\u63a5\u6536\u8fd0\u884c\u65f6\u6307\u4ee4\uff0c\u4ee5\u6307\u793a\u5728\u4e00\u7cfb\u5217\u7b97\u6cd5\u4e2d\u8981\u4f7f\u7528\u54ea\u4e2a\u3002 \u7b56\u7565\u6a21\u5f0f\u5f53\u4e2d\u7684\u63a5\u53e3\u662f\u56fa\u5b9a\u7684\uff0c\u56e0\u6b64\u8c03\u7528\u65f6\u4e0d\u8bb8\u66f4\u6539\u65b9\u6cd5\u3002 \u7ed3\u6784 \u7b56\u7565\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u4e0a\u4e0b\u6587\uff08Context\uff09\uff1a\u5f15\u7528\u7b56\u7565\u7684\u5bf9\u8c61 \u7b56\u7565\uff08Strategy\uff09\uff1a\u7b56\u7565\u7684\u516c\u5171\u63a5\u53e3\uff0c\u5177\u4f53\u7b56\u7565\u90fd\u5c06\u5b9e\u73b0\u8fd9\u4e2a\u63a5\u53e3 \u5177\u4f53\u7b56\u7565\uff08Concrete Strategy\uff09\uff1a\u7b56\u7565\u7684\u5177\u4f53\u5b9e\u73b0\uff0c\u5305\u542b\u4e86\u5177\u4f53\u7684\u7b97\u6cd5\u4ee3\u7801 \u7b56\u7565\u6a21\u5f0f from abc import ABC , abstractmethod class ChickenCooker ( ABC ): # \u7b56\u7565 @abstractmethod def cook ( self ): pass class FriedChickenCooker ( ChickenCooker ): # \u5177\u4f53\u7b56\u75651 def cook ( self ): print ( \"Cooking fried chicken!\" ) class GrilledChickenCooker ( ChickenCooker ): # \u5177\u4f53\u7b56\u75652 def cook ( self ): print ( \"Cooking grilled chicken!\" ) class Kitchen ( object ): # \u4e0a\u4e0b\u6587 def __init__ ( self ): self . _strategy = None @property def strategy ( self ): return self . _strategy @strategy . setter def strategy ( self , strategy ): self . _strategy = strategy def cook ( self ): self . _strategy . cook () \u4f18\u70b9 \u901a\u8fc7\u628a\u7b97\u6cd5\u7684\u8c03\u7528\u653e\u5230\u4e0a\u4e0b\u6587\u5f53\u4e2d\uff0c\u628a\u5b9e\u73b0\u653e\u5230\u4e86\u7b56\u7565\u5f53\u4e2d\u800c\u5b9e\u73b0\u4e86\u4e24\u8005\u7684\u5206\u79bb \u63d0\u4f9b\u76f8\u540c\u884c\u4e3a\u7684\u4e0d\u540c\u5b9e\u73b0\uff1a\u540c\u6837\u662f\u505a\u9e21\uff0c\u6709\u5f88\u591a\u79cd\u4e0d\u540c\u7684\u505a\u6cd5 \u53ef\u4ee5\u7b80\u5355\u7684\u6dfb\u52a0\u65b0\u7684\u7b56\u7565\uff1a\u4ec5\u9700\u521b\u5efa\u4e00\u4e2a\u65b0\u7684Beggar Chicken\u5c31\u53ef\u4ee5\u5b9e\u73b0\u53eb\u82b1\u9e21 \u53ef\u4ee5\u5c06\u90e8\u5206\u4ee3\u7801\u653e\u5230\u7b56\u7565\u5f53\u4e2d\u800c\u907f\u514d\u91cd\u590d\u4ee3\u7801\uff1a\u65e0\u8bba\u662f\u70b8\u9e21\u8fd8\u662f\u70e4\u9e21\uff0c\u4f60\u90fd\u5148\u8981\u5207\u9e21 \u7f3a\u70b9 \u4e0a\u4e0b\u6587\u9700\u8981\u5bf9\u5b9e\u73b0\u6709\u8db3\u591f\u7684\u4e86\u89e3\u6765\u9009\u62e9\u6070\u5f53\u7684\u65b9\u6cd5\uff1a\u4f60\u8981\u77e5\u9053\u505a\u51fa\u6765\u662f\u4ec0\u4e48\u9e21 \u4f1a\u9020\u6210\u5f88\u591a\u7684\u5177\u4f53\u7b56\u7565\u7c7b\uff1a\u8fd9\u5bf9Python\u53ef\u80fd\u4e0d\u662f\u4ec0\u4e48\u95ee\u9898\uff0c\u4f46\u5bf9\u4e8eJava\u8fd9\u6837\u6bcf\u4e00\u4e2a\u7c7b\u90fd\u9700\u8981\u4e00\u4e2a\u6587\u4ef6\u7684\u8bed\u8a00\u6765\u8bf4\u2026\u2026","title":"\u7b56\u7565\u6a21\u5f0f\uff08Strategy Pattern, Policy Pattern\uff09"},{"location":"document/design_pattern/#observer-pattern","text":"\u89c2\u5bdf\u8005\u6a21\u5f0f \u89c2\u5bdf\u8005\u6a21\u5f0f\u4e2d\u4e00\u4e2a\u5bf9\u8c61\uff08\u4e3b\u4f53\uff08Subject\uff09\u6216\u53ef\u89c2\u5bdf\uff08Observable\uff09\uff09\u7ef4\u62a4\u4e00\u4e2a\u5217\u8868\u7684\u5bf9\u8c61\uff08\u89c2\u5bdf\u8005\uff08Observer\uff09\uff09\uff0c\u5e76\u5728\u81ea\u8eab\u7684\u72b6\u6001\u53d1\u751f\u6539\u53d8\u65f6\u901a\u77e5\u89c2\u5bdf\u8005\u3002 \u89c2\u5bdf\u8005\u6a21\u5f0f\u5bb9\u6613\u548c\u53d1\u5e03/\u8ba2\u9605\u6a21\u5f0f\uff08Publish/Subscribe Pattern\uff09\u6df7\u6dc6\uff0c\u4e24\u8005\u7684\u533a\u522b\u4e3b\u8981\u5728\u4e8e\u53d1\u5e03/\u8ba2\u9605\u6a21\u5f0f\u6709\u4e00\u4e2a\u4e2d\u95f4\u4ef6\u8d1f\u8d23\u6d88\u606f\u7684\u8f6c\u53d1\uff0c\u56e0\u6b64\u53d1\u5e03\u8005\u548c\u8ba2\u9605\u8005\u4e0d\u9700\u8981\u5bf9\u5f7c\u6b64\u6709\u4efb\u4f55\u4e86\u89e3\u3002\u4f46\u5728\u89c2\u5bdf\u8005\u6a21\u5f0f\u4e2d\uff0c\u4e3b\u4f53\u9700\u8981\u5bf9\u89c2\u5bdf\u8005\u7684\u901a\u77e5\u65b9\u6cd5\u6709\u6240\u4e86\u89e3\u3002 \u7ed3\u6784 \u89c2\u5bdf\u8005\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e24\u79cd\u89d2\u8272\u6784\u6210\uff1a \u4e3b\u4f53\uff08Subject\uff09\u6216\u53ef\u89c2\u5bdf\uff08Observable\uff09 \u89c2\u5bdf\u8005\uff08Observer\uff09 \u89c2\u5bdf\u8005\u6a21\u5f0f from enum import Enum class Kitchen ( object ): # \u4e3b\u4f53 def __init__ ( self ): self . _waiters = [ Waiter ( i ) for _ in range ( 10 )] def collect_order ( self ): [ waiter . collect_order () for waiter in self . _waiters ] class Waiter ( object ): # \u89c2\u5bdf\u8005 def __init__ ( self , i : int ): self . id = i self . status = WaiterStatus . Free def collect_order ( self ): print ( 'Coming' ) if self . status != WaiterStatus . Busy else print ( 'Busy' ) class WaiterStatus ( Enum ): Free = 0 Busy = 1 \u4f18\u70b9 \u964d\u4f4e\u4e86\u4e3b\u4f53\u548c\u89c2\u5bdf\u8005\u4e4b\u95f4\u7684\u8026\u5408 \u7f3a\u70b9 \u4e3b\u4f53\u548c\u89c2\u5bdf\u8005\u4e4b\u95f4\u4ecd\u5b58\u5728\u8026\u5408 \u89c2\u5bdf\u8005\u8f83\u591a\u65f6\u901a\u77e5\u53d1\u5e03\u4f1a\u5f71\u54cd\u6027\u80fd","title":"\u89c2\u5bdf\u8005\u6a21\u5f0f\uff08Observer Pattern\uff09"},{"location":"document/design_pattern/#facade-pattern","text":"\u5916\u89c2\u6a21\u5f0f \u7c7b\u4f3c\u4e8e\u5efa\u7b51\u4e2d\u7684\u5916\u5899\uff0c\u4e00\u4e2a\u5916\u89c2\u662f\u63a9\u76d6\u4e86\u66f4\u590d\u6742\u7684\u57fa\u7840\u6216\u7ed3\u6784\u4ee3\u7801\u800c\u5145\u5f53\u5bf9\u5916\u63a5\u53e3\u7684\u5bf9\u8c61\u3002 \u4e00\u4e2a\u5927\u578b\u53a8\u623f\u7531\u5f88\u591a\u5b50\u90e8\u5206\u6784\u6210\u2013\u6253\u8377\u3001\u51b7\u83dc\u3001\u84b8\u83dc\u3001\u9762\u6848\u3001\u6c34\u53f0\u3001\u7827\u677f\u3001\u70ed\u7076\uff0c\u800c\u5bf9\u4e8e\u8d1f\u8d23\u4e0b\u5355\u7684\u670d\u52a1\u5458\u6765\u8bf4\uff0c\u5b83\u5e76\u4e0d\u9700\u8981\u4e86\u89e3\u8fd9\u8bb8\u591a\u3002 \u7ed3\u6784 \u5916\u89c2\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u5ba2\u6237\uff08Client\uff09\uff1a\u8bbf\u95ee\u5916\u89c2\u7684\u5bf9\u8c61 \u5916\u89c2\uff08Facade\uff09\uff1a\u5c06\u5b50\u7cfb\u7edf\u5305\u88c5\u7684\u516c\u5171\u63a5\u53e3 \u5b50\u7cfb\u7edf\uff08Subsystem\uff09\uff1a\u5b50\u7cfb\u7edf\u7684\u5177\u4f53\u5b9e\u73b0 \u5916\u89c2\u6a21\u5f0f class Kitchen ( object ): # \u5916\u89c2 def __init__ ( self ): self . prepare = Prepare () self . cold = Cold () self . steam = Steam () self . noodles = Noodles () self . wash = Wash () self . chop = Chop () self . stove = Stove () def add_order ( self ): self . prepare . prepare () self . cold . cook () self . steam . cook () self . noodles . cook () self . wash . wash () self . chop . chop () self . stove . cook () self . collect_order () \u4f18\u70b9 \u5bf9\u5ba2\u6237\u5c4f\u853d\u4e86\u5b50\u7cfb\u7edf\uff0c\u964d\u4f4e\u4e86\u8026\u5408 \u7f3a\u70b9 \u96be\u4ee5\u5bf9\u5ba2\u6237\u5b9a\u5236\u9700\u6c42 \u65b0\u589e\u5b50\u7cfb\u7edf\u53ef\u80fd\u4f1a\u9700\u8981\u5916\u89c2\u548c\u5ba2\u6237\u4f5c\u51fa\u4fee\u6539","title":"\u5916\u89c2\u6a21\u5f0f\uff08Facade Pattern\uff09"},{"location":"document/design_pattern/#singleton-pattern","text":"\u5355\u4f8b\u6a21\u5f0f \u5c06\u7c7b\u7684\u5b9e\u4f8b\u5316\u9650\u5236\u4e3a\u552f\u4e00\u7684\u5355\u4e2a\u5b9e\u4f8b\u3002 \u4e00\u4e2a\u5927\u578b\u9152\u5e97\u53ef\u80fd\u62e5\u6709\u5f88\u591a\u5458\u5de5\u751a\u81f3\u591a\u4e2a\u53a8\u623f\uff0c\u4f46\u4ed6\u6c38\u8fdc\u53ea\u6709\u4e00\u4e2a\u603b\u53a8\u5e08\u957f\u3002 \u7ed3\u6784 \u5355\u4f8b\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u5ba2\u6237\uff08Client\uff09\uff1a\u8bbf\u95ee\u5355\u4f8b\u7684\u5bf9\u8c61 \u5355\u4f8b\uff08Singleton\uff09\uff1a\u5305\u542b\u4e00\u4e2a\u5b9e\u4f8b\u4e14\u4f1a\u81ea\u52a8\u521b\u5efa\u8be5\u5b9e\u4f8b\u7684\u7c7b \u5355\u4f8b\u6a21\u5f0f class ChiefHeadChef ( object ): __chief_head_chef = None def __new__ ( cls ): if not cls . __chief_head_chef : cls . __chief_head_chef = object . __new__ ( cls ) return cls . __chief_head_chef \u4f18\u70b9 \u5355\u4f8b\u548c\u5ba2\u6237\u9ad8\u5ea6\u8026\u5408\uff0c\u6bcf\u4e2a\u5ba2\u6237\u5bf9\u5355\u4f8b\u505a\u51fa\u7684\u4fee\u6539\u90fd\u5c06\u5f71\u54cd\u5176\u4ed6\u5ba2\u6237 \u7f3a\u70b9 \u5355\u4f8b\u548c\u5ba2\u6237\u9ad8\u5ea6\u8026\u5408\uff0c\u6bcf\u4e2a\u5ba2\u6237\u5bf9\u5355\u4f8b\u505a\u51fa\u7684\u4fee\u6539\u90fd\u5c06\u5f71\u54cd\u5176\u4ed6\u5ba2\u6237","title":"\u5355\u4f8b\u6a21\u5f0f\uff08Singleton Pattern\uff09"},{"location":"document/git/","text":"\u524d\u8a00 \u6700\u8fd1\u9047\u5230\u4e86\u597d\u591a\u540c\u5b66\u95ee\u6211\u57fa\u672c\u7684Git\u95ee\u9898\uff0c\u5bfc\u81f4\u6211\u7ecf\u5e38\u5904\u4e8e\u5b95\u673a\u72b6\u6001\u2013\u8981\u8be6\u7ec6\u7684\u53bb\u8bb2\u8ff0\u6574\u4e2a\u7cfb\u7edf\u4ee5\u53ca\u4e3a\u4ec0\u4e48\u4f1a\u51fa\u73b0\u8fd9\u4e2a\u9519\u8bef\u660e\u663e\u662f\u6d6a\u8d39\u65f6\u95f4\uff0c\u800c\u5355\u7eaf\u7684\u7ed9\u4e00\u4e2a\u547d\u4ee4\u8fd9\u6837\u6388\u4eba\u4ee5\u9c7c\u53c8\u660e\u663e\u4e0d\u662f\u6211\u7684\u4f5c\u98ce\u3002\u601d\u524d\u60f3\u540e\u4e0d\u5982\u7d22\u6027\u6765\u4e00\u4e2a\u7b80\u660eGit\u83dc\u8c31\u3002 \u672c\u6587\u4e3b\u8981\u5305\u542b\u4e09\u4e2a\u90e8\u5206\uff0c\u5206\u522b\u662f\u8fdc\u7a0b\u4ed3\u5e93\u3001\u672c\u5730\u4ed3\u5e93\u4ee5\u53ca\u8fdc\u7a0b-\u672c\u5730\u4ea4\u4e92\u3002\u4e3a \u8fdc\u7a0b\u4ed3\u5e93 # \u521d\u5b66\u8005\u4e0a\u624b\u65f6\u6700\u5148\u63a5\u89e6\u5230\u7684\u5f80\u5f80\u90fd\u662f\u4e00\u4e2a\u8fdc\u7a0b\u4ed3\u5e93\uff08\u7f51\u9875\uff09\uff0c\u6bd4\u5982 \u672c\u7f51\u7ad9\u7684\u4ed3\u5e93 \u3002\u9875\u9762\u7684\u4e3b\u4f53\u9996\u5148\u662f\u4e00\u4e2a\u5f53\u524d\u76ee\u5f55\u7684\u6587\u4ef6\u5217\u8868\uff0c\u4e0b\u9762\u5219\u5f80\u5f80\u662f\u5f53\u524d\u76ee\u5f55\u4e0b readme \u6587\u4ef6\u7684\u5185\u5bb9\uff08\u5982\u679c\u6709\uff09\u3002","title":"Git\u83dc\u8c31"},{"location":"document/git/#_1","text":"\u521d\u5b66\u8005\u4e0a\u624b\u65f6\u6700\u5148\u63a5\u89e6\u5230\u7684\u5f80\u5f80\u90fd\u662f\u4e00\u4e2a\u8fdc\u7a0b\u4ed3\u5e93\uff08\u7f51\u9875\uff09\uff0c\u6bd4\u5982 \u672c\u7f51\u7ad9\u7684\u4ed3\u5e93 \u3002\u9875\u9762\u7684\u4e3b\u4f53\u9996\u5148\u662f\u4e00\u4e2a\u5f53\u524d\u76ee\u5f55\u7684\u6587\u4ef6\u5217\u8868\uff0c\u4e0b\u9762\u5219\u5f80\u5f80\u662f\u5f53\u524d\u76ee\u5f55\u4e0b readme \u6587\u4ef6\u7684\u5185\u5bb9\uff08\u5982\u679c\u6709\uff09\u3002","title":"\u8fdc\u7a0b\u4ed3\u5e93"},{"location":"document/jetbrains/","text":"JetBrains\u4f7f\u7528\u6307\u5357 # \u4eca\u5929\u7fa4\u91cc\u6709\u540c\u5b66\u8bf4\u6211IDEA\u754c\u9762\u5341\u5206\u5947\u7279\uff0c\u8ba8\u8bba\u4e4b\u540e\u53d1\u73b0\u5f88\u591a\u540c\u5b66\u90fd\u5bf9IDE\u7684\u63d2\u4ef6\u4e0d\u592a\u719f\u6089\uff0c\u8fd9\u91cc\u7b80\u5355\u8ba8\u8bba\u4e00\u4e0b\u5982\u4f55\u6f02\u4eae\u7684\u4f7f\u7528JetBrains\u5168\u5bb6\u6876\u3002 \u9996\u5148\uff0c\u6765\u4e00\u5f20\u6211\u7684PyCharm\u754c\u9762\u622a\u56fe\u3002 \u63d2\u4ef6 # \u6211\u4eec\u8fd8\u662f\u4ece\u63d2\u4ef6\u5f00\u59cb\u5427\uff08\u7531\u4e8ePython\u6211\u5199\u7684\u76f8\u5bf9\u8f83\u5c11\u4e00\u4e9b\uff0c\u5e76\u4e14\u66f4\u5e38\u7528\u5b87\u5b99\u6700\u5f3aIDE\uff0c\u6240\u4ee5\u63d2\u4ef6\u6bd4\u8f83\u5c11\u4e00\u4e9b\uff09\uff0c\u6211\u4e3b\u8981\u7528\u5230\u7684\u63d2\u4ef6\u5217\u8868\u5982\u4e0b\uff1a \u8fd9\u91cc\u5f3a\u70c8\u63a8\u8350Material Theme UI\u8fd9\u4e2a\u63d2\u4ef6\uff08\u867d\u7136\u6211\u66f4\u559c\u6b22Fluent Design\uff0c\u4f46\u8fd9\u4e2a\u4f3c\u4e4e\u6ca1\u4eba\u505a\u5c31\u53ea\u80fd\u5c06\u5c31\u4e00\u4e0b\u4e86\uff09\uff0c\u5b83\u80fd\u8ba9\u4f60\u7684\u6574\u4e2a\u5fc3\u60c5\u90fd\u597d\u8d77\u6765\u3002\u5176\u6b21Power Mode II\u80fd\u8ba9\u4f60\u6572\u4ee3\u7801\u65f6\u51fa\u73b0Kira-Kira\u7684\u6548\u679c\uff08\u4f46\u6211\u5f3a\u70c8\u5efa\u8bae\u4f60\u540c\u65f6\u5728\u9009\u9879\u4e2d\u53bb\u6389\u55b7\u706b\uff0c\u5b8c\u5168\u662f\u753b\u86c7\u6dfb\u8db3\u597d\u561b\uff1f\uff01\uff09\u3002CodeGlance\u80fd\u8ba9\u4f60\u5927\u81f4\u7684\u770b\u5230\u4ee3\u7801\u7684\u60c5\u51b5\uff08\u5728\u5c4f\u5e55\u6700\u53f3\u4fa7\uff09\u3002\u6700\u91cd\u8981\u7684\u83ab\u8fc7\u4e8eRainbow Brackets\uff0c\u5c24\u5176\u662f\u5728\u4f60\u8ffd\u6c42\u4e00\u884c\u4ee3\u7801\u65f6\uff0c\u8ba9\u4f60\u80fd\u5bf9\u62ec\u53f7\u7684\u4f7f\u7528\u60c5\u51b5\u4e00\u76ee\u4e86\u7136\u3002\u6b64\u5916LiveEdit\u80fd\u5141\u8bb8\u4f60\u548c\u522b\u4eba\u540c\u65f6\u5de5\u4f5c\uff0c\u5e26\u59b9\u5199\u4ee3\u7801\u4ec0\u4e48\u7684\u6ca1\u6709\u4ec0\u4e48\u6bd4\u8fd9\u4e2a\u66f4\u597d\u4e86\uff08\u5f53\u7136\u8ba9\u5979\u505a\u6000\u91cc\u5e2e\u5979\u5199\u9664\u5916\uff09\u3002\u5982\u679c\u4f60\u662f\u4e00\u4e2aVIM\u7231\u597d\u8005\u7684\u8bdd\uff0cIdeaVim\u80fd\u5f88\u6709\u9650\u7684\u5b9e\u73b0\u4e00\u4e9b\u529f\u80fd\uff1b\u5982\u679c\u4f60\u4e0d\u662f\u4e00\u4e2aVIM\u7231\u597d\u8005\u7684\u8bdd\uff0c\u7528VIM\u5c31\u80fd\u5e2e\u52a9\u4f60\u628a\u53f3\u624b\u4ece\u607c\u4eba\u7684\u9f20\u6807\u64cd\u4f5c\u5f53\u4e2d\u89e3\u653e\u51fa\u6765\uff0c\u771f\u7684\u4e0d\u8003\u8651\u6210\u4e3a\u4e00\u4e0b\u5417\uff1f\u54e6\u5bf9\u4e86\uff0cGitToolBox\u548cGitLab Projects\u4e5f\u5f88\u6709\u7528\uff0c\u80fd\u5728\u4ee3\u7801\u5f53\u4e2d\u663e\u793a\u8fd9\u884c\u5783\u573e\u662f\u8c01\u5728\u4ec0\u4e48\u65f6\u5019\u6700\u540e\u7f16\u8f91\u7684\uff0c\u7529\u9505\u795e\u5668\uff08\u6240\u4ee5\u4ee3\u7801\u662f\u4ec0\u4e48\u5783\u573e\uff1f\uff09\u3002\u6700\u540e\uff0c\u8fd8\u6709\u4f20\u8bf4\u4e2d\u811a\u8e22IntelliSense\u7684TabNine\uff0c\u8fd9\u4e2a\u7edd\u5bf9\u597d\u7528\uff0c\u4fe1\u6211\u3002 \u7f8e\u5316 # \u8bf4\u5230\u754c\u9762\uff0c\u5f88\u591a\u4eba\u90fd\u95ee\u6211\u80cc\u666f\u56fe\u7247\u662f\u600e\u4e48\u505a\u5230\u7684\u3002\u8fd9\u4e2a\u4e1c\u897f\uff0c\u5bf9\u4e8eVS\u6765\u8bf4\u662f\u9700\u8981\u4e13\u95e8\u88c5\u4e00\u4e2a\u63d2\u4ef6\uff0c\u4f46\u4f18\u79c0\u7684JetBrains\u5df2\u7ecf\u673a\u667a\u7684\u5185\u7f6e\u4e86\u8fd9\u79cd\u529f\u80fd\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u5b57\u4f53\u5b57\u53f7\u7b49\u7b49\u7b49\u7b49\uff0c\u4e00\u5207\u7684\u4e00\u5207\u5c3d\u5728Appearance\u5f53\u4e2d\u3002 \u5982\u56fe\u8bbe\u7f6e\u597d\u56fe\u7247\uff0c\u6211\u4eec\u5c31\u80fd\u5feb\u4e50\u7684\u65e5\u5728\u6821\u56ed\u4e86\uff08\u8bef\uff09\u3002 \u4ee3\u7801 # \u63a5\u4e0b\u6765\u8bf4\u4e00\u4e2a\u6b63\u7ecf\u7684\u4ee3\u7801\u6280\u5de7\u3002 \u6253\u65ad\u70b9\uff08\u6211\u6ca1\u60f3\u5230\u5c45\u7136\u8fd9\u4e48\u591a\u4eba\u4e0d\u4f1a\u8fd9\u4e2a\uff0c\u8f9b\u82e6\u4e86\uff09\u3002 \u6240\u8c13\u65ad\u70b9\uff0c\u5c31\u662f\u7a0b\u5e8f\u8fd0\u884c\u5230\u8fd9\u91cc\u904d\u6682\u505c\u7684\u70b9\u3002\u4ece\u6b64\u5904\u5f00\u59cb\uff0c\u4f60\u5c06\u624b\u52a8\u4e00\u884c\u4e00\u884c\u7684\u6267\u884c\u4ee3\u7801\uff0c\u89c2\u5bdf\u5404\u4e2a\u53d8\u91cf\u770b\u770b\u662f\u5426\u6709\u975e\u671f\u5f85\u7684\u7ed3\u679c\u3002\u4ee5\u4e0b\u591a\u56fe\u6740\u732b\u9884\u8b66\u3002 \u9996\u5148\uff0c\u6211\u4eec\u5728\u6000\u7591\u51fa\u95ee\u9898\u4ee3\u7801\u4e4b\u524d\u7684\u884c\u53f7\u53f3\u4fa7\u6309\u4e00\u4e0b\uff0c\u4f1a\u51fa\u73b0\u8fd9\u6837\u7684\u4e00\u4e2a\u5c0f\u7ea2\u70b9\uff0c\u5373\u8868\u793a\u4f60\u5728\u8fd9\u91cc\u6253\u4e86\u4e00\u4e2a\u65ad\u70b9\u3002\u4e0e\u4ee5\u5f80\u4e0d\u540c\u7684\u662f\uff0c\u8c03\u8bd5\u7684\u65f6\u5019\u6211\u4eec\u4f1a\u6309\u8fd9\u4e2a\u7ea2\u8272\u7684\u5c0f\u866b\u5b50\uff0c\u5feb\u6377\u952e\u4e3aAlt F5\u3002 \u968f\u540e\uff0c\u4ee3\u7801\u4f1a\u6267\u884c\u5230\u4ee3\u7801\u4e4b\u524d\u4e00\u884c\u505c\u6b62\u3002 \u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0c\u4e0b\u9762\u7684\u8c03\u8bd5\u9762\u677f\u4e2d\u663e\u793a\u51fa\u4e86\u76ee\u524d\u7684\u53d8\u91cf\u53ca\u5176\u503c\u3002 \u6211\u4eec\u53ef\u4ee5\u5728\u8fd9\u91cc\u9009\u62e9\u6267\u884c\u4e0b\u4e00\u884c\u4ee3\u7801\u3002\u4ed6\u5de6\u8fb9\u9ec4\u8272\u5411\u4e0b\u7bad\u5934\u4e5f\u662f\u6267\u884c\u4e0b\u4e00\u884c\u4ee3\u7801\uff0c\u4f46\u4ed6\u6267\u884c\u7684\u662f\u4efb\u4f55\u4e0b\u4e00\u884c\u4ee3\u7801\u3002\u5982\u679c\u4f60\u7528\u5e93\u7684\u8bdd\uff0c\u90a3\u53ef\u80fd\u4f1a\u5728\u8fd9\u91cc\u8df3\u5f88\u591a\u6b21\u3002\u800c\u8fd9\u4e2a\u84dd\u8272\u7684\u5411\u4e0b\u7bad\u5934\u5219\u4f1a\u5ffd\u7565\u5e93\u7684\u4ee3\u7801\u3002\u66f4\u5de6\u8fb9\u7d2b\u8272\u7bad\u5934\u5219\u662f\u53ea\u6267\u884c\u672c\u6587\u4ef6\u5185\u7684\u4ee3\u7801\uff0c\u8fd9\u4e2a\u5b9e\u9645\u4e0a\u662f\u6700\u5e38\u7528\u7684\u3002 \u6709\u4e9b\u65f6\u5019\uff0c\u6211\u4eec\u7684\u9519\u8bef\u5728\u5faa\u73af\u91cc\u53d1\u751f\uff0c\u8981\u600e\u4e48\u529e\u5462\uff1f\u6bcfde\u4e00\u6b21bug\u6309\u4e0a\u4e07\u516b\u5343\u6b21Step Into\u4e48\uff1fJetBrains\u81ea\u7136\u662f\u6ca1\u6709\u8fd9\u4e48\u777f\u667a\u7684\u3002\u53f3\u952e\u70b9\u51fb\u4f60\u521a\u8bbe\u7f6e\u597d\u7684\u65ad\u70b9\uff0c\u4f1a\u5f39\u51fa\u4e00\u4e2a\u5bf9\u8bdd\u6846\u8ba9\u4f60\u8bbe\u7f6e\u4e2d\u65ad\u7684\u6761\u4ef6\u3002\u8fd9\u91cc\u7528\u4ee3\u7801\u63cf\u8ff0\u4e00\u4e0b\u5c31\u53ef\u4ee5\u5566\u3002 \u73af\u5883 # \u9996\u5148\u5148\u63d0\u4e00\u4e0b\u6587\u4ef6\u5939\u7684\u6807\u5fd7\uff0c\u6709\u4e9b\u65f6\u5019\u8fd9\u662f\u5f88\u91cd\u8981\u7684\uff0c\u5c24\u5176\u662f\u5728\u4f60\u4e0d\u77e5\u4f55\u6545\u6253\u5f00\u4e86\u4e00\u4e2a\u5f88\u5927\u5305\u542b\u5f88\u591a\u9879\u76ee\u7684\u6587\u4ef6\u5939\u7684\u65f6\u5019\u3002\u4e5f\u5f88\u7b80\u5355\uff0c\u53f3\u952e\u70b9\u4e00\u4e0b\u6587\u4ef6\u5939\u627e\u5230Mark Directory as\u5c31\u597d\u3002 Intellij IDEA # \u5728Project Structure\u91cc\u8bbe\u7f6e\u73af\u5883\u3002 \u4f9d\u8d56\u4e5f\u5728\u8fd9\u91cc\u8bbe\u7f6e\uff0c\u4e0d\u8fc7\u73b0\u5728\u8fd9\u4e2a\u5e74\u4ee3\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u7528Maven\u5462\uff1f PyCharm # \u4e0eJava\u4e0d\u540c\uff0cPyCharm\u5e76\u6ca1\u6709\u5355\u72ec\u7684\u9879\u76ee\u8bbe\u7f6e\uff0c\u73af\u5883\u662f\u5728\u8bbe\u7f6e\u91cc\u7684Project\u4e00\u680f\u8fdb\u884c\u8bbe\u7f6e\u7684\u3002\u5728\u8fd9\u91cc\u53ef\u4ee5\u4f7f\u7528Conda\u521b\u5efa\u865a\u62df\u73af\u5883\uff0c\u4e5f\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528venv\u521b\u5efa\u865a\u62df\u73af\u5883\u3002\u5bf9\u4e8e\u61d2\u60f0\u7684\u6211\u6765\u8bf4\u2026\u2026\u81ea\u7136\u662f\u53ea\u7528\u4e00\u4e2a\u6839\u73af\u5883\u5566\uff08\u8fd9\u662f\u4e00\u4e2a\u4e0d\u597d\u7684\u4e60\u60ef\u5343\u4e07\u4e0d\u8981\u5b66\u6211\uff09\u3002 \u7ed3\u8bed \u5514\uff0c\u4ed4\u7ec6\u60f3\u60f3\uff0c\u597d\u50cf\u4e5f\u6ca1\u4ec0\u4e48\u9700\u8981\u5199\u7684\u4e86\uff1f\u76f8\u6bd4VIM\u6765\u8bf4\uff0cIDE\u4f53\u79ef\u8981\u5927\u6570\u5343\u500d\uff0c\u529f\u80fd\u81ea\u7136\u4e5f\u4f1a\u5f3a\u5f88\u591a\u500d\u3002\u4ece\u5feb\u6377\u952e\u6bd4\u5982sout = System.out.println()\u3001Ctrl /\u6ce8\u91ca\u4ee3\u7801\u3001Ctrl Tab/Shift Tab\u8c03\u6574\u884c\u8ddd\uff0c\u5230\u81ea\u52a8\u683c\u5f0f\u5316\u3001\u81ea\u52a8\u6ce8\u91ca\u3001\u81ea\u52a8\u751f\u6210\u6784\u9020\u5668\uff0c\u6709\u592a\u591a\u80fd\u5199\u7684\u5185\u5bb9\u6ca1\u6709\u529e\u6cd5\u5728\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\u8be6\u5c3d\u63cf\u8ff0\u3002\u66f4\u591a\u7684\u9700\u8981\u5728\u5b9e\u9645\u4ee3\u7801\u5f53\u4e2d\u53bb\u4f53\u4f1a\u3002\u90a3\u4e48\uff0c\u6211\u4eec\u4eca\u5929\u5c31\u5230\u8fd9\u91cc\u5427~","title":"JetBrains\u4f7f\u7528\u6307\u5357"},{"location":"document/jetbrains/#jetbrains","text":"\u4eca\u5929\u7fa4\u91cc\u6709\u540c\u5b66\u8bf4\u6211IDEA\u754c\u9762\u5341\u5206\u5947\u7279\uff0c\u8ba8\u8bba\u4e4b\u540e\u53d1\u73b0\u5f88\u591a\u540c\u5b66\u90fd\u5bf9IDE\u7684\u63d2\u4ef6\u4e0d\u592a\u719f\u6089\uff0c\u8fd9\u91cc\u7b80\u5355\u8ba8\u8bba\u4e00\u4e0b\u5982\u4f55\u6f02\u4eae\u7684\u4f7f\u7528JetBrains\u5168\u5bb6\u6876\u3002 \u9996\u5148\uff0c\u6765\u4e00\u5f20\u6211\u7684PyCharm\u754c\u9762\u622a\u56fe\u3002","title":"JetBrains\u4f7f\u7528\u6307\u5357"},{"location":"document/jetbrains/#_1","text":"\u6211\u4eec\u8fd8\u662f\u4ece\u63d2\u4ef6\u5f00\u59cb\u5427\uff08\u7531\u4e8ePython\u6211\u5199\u7684\u76f8\u5bf9\u8f83\u5c11\u4e00\u4e9b\uff0c\u5e76\u4e14\u66f4\u5e38\u7528\u5b87\u5b99\u6700\u5f3aIDE\uff0c\u6240\u4ee5\u63d2\u4ef6\u6bd4\u8f83\u5c11\u4e00\u4e9b\uff09\uff0c\u6211\u4e3b\u8981\u7528\u5230\u7684\u63d2\u4ef6\u5217\u8868\u5982\u4e0b\uff1a \u8fd9\u91cc\u5f3a\u70c8\u63a8\u8350Material Theme UI\u8fd9\u4e2a\u63d2\u4ef6\uff08\u867d\u7136\u6211\u66f4\u559c\u6b22Fluent Design\uff0c\u4f46\u8fd9\u4e2a\u4f3c\u4e4e\u6ca1\u4eba\u505a\u5c31\u53ea\u80fd\u5c06\u5c31\u4e00\u4e0b\u4e86\uff09\uff0c\u5b83\u80fd\u8ba9\u4f60\u7684\u6574\u4e2a\u5fc3\u60c5\u90fd\u597d\u8d77\u6765\u3002\u5176\u6b21Power Mode II\u80fd\u8ba9\u4f60\u6572\u4ee3\u7801\u65f6\u51fa\u73b0Kira-Kira\u7684\u6548\u679c\uff08\u4f46\u6211\u5f3a\u70c8\u5efa\u8bae\u4f60\u540c\u65f6\u5728\u9009\u9879\u4e2d\u53bb\u6389\u55b7\u706b\uff0c\u5b8c\u5168\u662f\u753b\u86c7\u6dfb\u8db3\u597d\u561b\uff1f\uff01\uff09\u3002CodeGlance\u80fd\u8ba9\u4f60\u5927\u81f4\u7684\u770b\u5230\u4ee3\u7801\u7684\u60c5\u51b5\uff08\u5728\u5c4f\u5e55\u6700\u53f3\u4fa7\uff09\u3002\u6700\u91cd\u8981\u7684\u83ab\u8fc7\u4e8eRainbow Brackets\uff0c\u5c24\u5176\u662f\u5728\u4f60\u8ffd\u6c42\u4e00\u884c\u4ee3\u7801\u65f6\uff0c\u8ba9\u4f60\u80fd\u5bf9\u62ec\u53f7\u7684\u4f7f\u7528\u60c5\u51b5\u4e00\u76ee\u4e86\u7136\u3002\u6b64\u5916LiveEdit\u80fd\u5141\u8bb8\u4f60\u548c\u522b\u4eba\u540c\u65f6\u5de5\u4f5c\uff0c\u5e26\u59b9\u5199\u4ee3\u7801\u4ec0\u4e48\u7684\u6ca1\u6709\u4ec0\u4e48\u6bd4\u8fd9\u4e2a\u66f4\u597d\u4e86\uff08\u5f53\u7136\u8ba9\u5979\u505a\u6000\u91cc\u5e2e\u5979\u5199\u9664\u5916\uff09\u3002\u5982\u679c\u4f60\u662f\u4e00\u4e2aVIM\u7231\u597d\u8005\u7684\u8bdd\uff0cIdeaVim\u80fd\u5f88\u6709\u9650\u7684\u5b9e\u73b0\u4e00\u4e9b\u529f\u80fd\uff1b\u5982\u679c\u4f60\u4e0d\u662f\u4e00\u4e2aVIM\u7231\u597d\u8005\u7684\u8bdd\uff0c\u7528VIM\u5c31\u80fd\u5e2e\u52a9\u4f60\u628a\u53f3\u624b\u4ece\u607c\u4eba\u7684\u9f20\u6807\u64cd\u4f5c\u5f53\u4e2d\u89e3\u653e\u51fa\u6765\uff0c\u771f\u7684\u4e0d\u8003\u8651\u6210\u4e3a\u4e00\u4e0b\u5417\uff1f\u54e6\u5bf9\u4e86\uff0cGitToolBox\u548cGitLab Projects\u4e5f\u5f88\u6709\u7528\uff0c\u80fd\u5728\u4ee3\u7801\u5f53\u4e2d\u663e\u793a\u8fd9\u884c\u5783\u573e\u662f\u8c01\u5728\u4ec0\u4e48\u65f6\u5019\u6700\u540e\u7f16\u8f91\u7684\uff0c\u7529\u9505\u795e\u5668\uff08\u6240\u4ee5\u4ee3\u7801\u662f\u4ec0\u4e48\u5783\u573e\uff1f\uff09\u3002\u6700\u540e\uff0c\u8fd8\u6709\u4f20\u8bf4\u4e2d\u811a\u8e22IntelliSense\u7684TabNine\uff0c\u8fd9\u4e2a\u7edd\u5bf9\u597d\u7528\uff0c\u4fe1\u6211\u3002","title":"\u63d2\u4ef6"},{"location":"document/jetbrains/#_2","text":"\u8bf4\u5230\u754c\u9762\uff0c\u5f88\u591a\u4eba\u90fd\u95ee\u6211\u80cc\u666f\u56fe\u7247\u662f\u600e\u4e48\u505a\u5230\u7684\u3002\u8fd9\u4e2a\u4e1c\u897f\uff0c\u5bf9\u4e8eVS\u6765\u8bf4\u662f\u9700\u8981\u4e13\u95e8\u88c5\u4e00\u4e2a\u63d2\u4ef6\uff0c\u4f46\u4f18\u79c0\u7684JetBrains\u5df2\u7ecf\u673a\u667a\u7684\u5185\u7f6e\u4e86\u8fd9\u79cd\u529f\u80fd\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u5b57\u4f53\u5b57\u53f7\u7b49\u7b49\u7b49\u7b49\uff0c\u4e00\u5207\u7684\u4e00\u5207\u5c3d\u5728Appearance\u5f53\u4e2d\u3002 \u5982\u56fe\u8bbe\u7f6e\u597d\u56fe\u7247\uff0c\u6211\u4eec\u5c31\u80fd\u5feb\u4e50\u7684\u65e5\u5728\u6821\u56ed\u4e86\uff08\u8bef\uff09\u3002","title":"\u7f8e\u5316"},{"location":"document/jetbrains/#_3","text":"\u63a5\u4e0b\u6765\u8bf4\u4e00\u4e2a\u6b63\u7ecf\u7684\u4ee3\u7801\u6280\u5de7\u3002 \u6253\u65ad\u70b9\uff08\u6211\u6ca1\u60f3\u5230\u5c45\u7136\u8fd9\u4e48\u591a\u4eba\u4e0d\u4f1a\u8fd9\u4e2a\uff0c\u8f9b\u82e6\u4e86\uff09\u3002 \u6240\u8c13\u65ad\u70b9\uff0c\u5c31\u662f\u7a0b\u5e8f\u8fd0\u884c\u5230\u8fd9\u91cc\u904d\u6682\u505c\u7684\u70b9\u3002\u4ece\u6b64\u5904\u5f00\u59cb\uff0c\u4f60\u5c06\u624b\u52a8\u4e00\u884c\u4e00\u884c\u7684\u6267\u884c\u4ee3\u7801\uff0c\u89c2\u5bdf\u5404\u4e2a\u53d8\u91cf\u770b\u770b\u662f\u5426\u6709\u975e\u671f\u5f85\u7684\u7ed3\u679c\u3002\u4ee5\u4e0b\u591a\u56fe\u6740\u732b\u9884\u8b66\u3002 \u9996\u5148\uff0c\u6211\u4eec\u5728\u6000\u7591\u51fa\u95ee\u9898\u4ee3\u7801\u4e4b\u524d\u7684\u884c\u53f7\u53f3\u4fa7\u6309\u4e00\u4e0b\uff0c\u4f1a\u51fa\u73b0\u8fd9\u6837\u7684\u4e00\u4e2a\u5c0f\u7ea2\u70b9\uff0c\u5373\u8868\u793a\u4f60\u5728\u8fd9\u91cc\u6253\u4e86\u4e00\u4e2a\u65ad\u70b9\u3002\u4e0e\u4ee5\u5f80\u4e0d\u540c\u7684\u662f\uff0c\u8c03\u8bd5\u7684\u65f6\u5019\u6211\u4eec\u4f1a\u6309\u8fd9\u4e2a\u7ea2\u8272\u7684\u5c0f\u866b\u5b50\uff0c\u5feb\u6377\u952e\u4e3aAlt F5\u3002 \u968f\u540e\uff0c\u4ee3\u7801\u4f1a\u6267\u884c\u5230\u4ee3\u7801\u4e4b\u524d\u4e00\u884c\u505c\u6b62\u3002 \u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0c\u4e0b\u9762\u7684\u8c03\u8bd5\u9762\u677f\u4e2d\u663e\u793a\u51fa\u4e86\u76ee\u524d\u7684\u53d8\u91cf\u53ca\u5176\u503c\u3002 \u6211\u4eec\u53ef\u4ee5\u5728\u8fd9\u91cc\u9009\u62e9\u6267\u884c\u4e0b\u4e00\u884c\u4ee3\u7801\u3002\u4ed6\u5de6\u8fb9\u9ec4\u8272\u5411\u4e0b\u7bad\u5934\u4e5f\u662f\u6267\u884c\u4e0b\u4e00\u884c\u4ee3\u7801\uff0c\u4f46\u4ed6\u6267\u884c\u7684\u662f\u4efb\u4f55\u4e0b\u4e00\u884c\u4ee3\u7801\u3002\u5982\u679c\u4f60\u7528\u5e93\u7684\u8bdd\uff0c\u90a3\u53ef\u80fd\u4f1a\u5728\u8fd9\u91cc\u8df3\u5f88\u591a\u6b21\u3002\u800c\u8fd9\u4e2a\u84dd\u8272\u7684\u5411\u4e0b\u7bad\u5934\u5219\u4f1a\u5ffd\u7565\u5e93\u7684\u4ee3\u7801\u3002\u66f4\u5de6\u8fb9\u7d2b\u8272\u7bad\u5934\u5219\u662f\u53ea\u6267\u884c\u672c\u6587\u4ef6\u5185\u7684\u4ee3\u7801\uff0c\u8fd9\u4e2a\u5b9e\u9645\u4e0a\u662f\u6700\u5e38\u7528\u7684\u3002 \u6709\u4e9b\u65f6\u5019\uff0c\u6211\u4eec\u7684\u9519\u8bef\u5728\u5faa\u73af\u91cc\u53d1\u751f\uff0c\u8981\u600e\u4e48\u529e\u5462\uff1f\u6bcfde\u4e00\u6b21bug\u6309\u4e0a\u4e07\u516b\u5343\u6b21Step Into\u4e48\uff1fJetBrains\u81ea\u7136\u662f\u6ca1\u6709\u8fd9\u4e48\u777f\u667a\u7684\u3002\u53f3\u952e\u70b9\u51fb\u4f60\u521a\u8bbe\u7f6e\u597d\u7684\u65ad\u70b9\uff0c\u4f1a\u5f39\u51fa\u4e00\u4e2a\u5bf9\u8bdd\u6846\u8ba9\u4f60\u8bbe\u7f6e\u4e2d\u65ad\u7684\u6761\u4ef6\u3002\u8fd9\u91cc\u7528\u4ee3\u7801\u63cf\u8ff0\u4e00\u4e0b\u5c31\u53ef\u4ee5\u5566\u3002","title":"\u4ee3\u7801"},{"location":"document/jetbrains/#_4","text":"\u9996\u5148\u5148\u63d0\u4e00\u4e0b\u6587\u4ef6\u5939\u7684\u6807\u5fd7\uff0c\u6709\u4e9b\u65f6\u5019\u8fd9\u662f\u5f88\u91cd\u8981\u7684\uff0c\u5c24\u5176\u662f\u5728\u4f60\u4e0d\u77e5\u4f55\u6545\u6253\u5f00\u4e86\u4e00\u4e2a\u5f88\u5927\u5305\u542b\u5f88\u591a\u9879\u76ee\u7684\u6587\u4ef6\u5939\u7684\u65f6\u5019\u3002\u4e5f\u5f88\u7b80\u5355\uff0c\u53f3\u952e\u70b9\u4e00\u4e0b\u6587\u4ef6\u5939\u627e\u5230Mark Directory as\u5c31\u597d\u3002","title":"\u73af\u5883"},{"location":"document/jetbrains/#intellij-idea","text":"\u5728Project Structure\u91cc\u8bbe\u7f6e\u73af\u5883\u3002 \u4f9d\u8d56\u4e5f\u5728\u8fd9\u91cc\u8bbe\u7f6e\uff0c\u4e0d\u8fc7\u73b0\u5728\u8fd9\u4e2a\u5e74\u4ee3\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u7528Maven\u5462\uff1f","title":"Intellij IDEA"},{"location":"document/jetbrains/#pycharm","text":"\u4e0eJava\u4e0d\u540c\uff0cPyCharm\u5e76\u6ca1\u6709\u5355\u72ec\u7684\u9879\u76ee\u8bbe\u7f6e\uff0c\u73af\u5883\u662f\u5728\u8bbe\u7f6e\u91cc\u7684Project\u4e00\u680f\u8fdb\u884c\u8bbe\u7f6e\u7684\u3002\u5728\u8fd9\u91cc\u53ef\u4ee5\u4f7f\u7528Conda\u521b\u5efa\u865a\u62df\u73af\u5883\uff0c\u4e5f\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528venv\u521b\u5efa\u865a\u62df\u73af\u5883\u3002\u5bf9\u4e8e\u61d2\u60f0\u7684\u6211\u6765\u8bf4\u2026\u2026\u81ea\u7136\u662f\u53ea\u7528\u4e00\u4e2a\u6839\u73af\u5883\u5566\uff08\u8fd9\u662f\u4e00\u4e2a\u4e0d\u597d\u7684\u4e60\u60ef\u5343\u4e07\u4e0d\u8981\u5b66\u6211\uff09\u3002 \u7ed3\u8bed \u5514\uff0c\u4ed4\u7ec6\u60f3\u60f3\uff0c\u597d\u50cf\u4e5f\u6ca1\u4ec0\u4e48\u9700\u8981\u5199\u7684\u4e86\uff1f\u76f8\u6bd4VIM\u6765\u8bf4\uff0cIDE\u4f53\u79ef\u8981\u5927\u6570\u5343\u500d\uff0c\u529f\u80fd\u81ea\u7136\u4e5f\u4f1a\u5f3a\u5f88\u591a\u500d\u3002\u4ece\u5feb\u6377\u952e\u6bd4\u5982sout = System.out.println()\u3001Ctrl /\u6ce8\u91ca\u4ee3\u7801\u3001Ctrl Tab/Shift Tab\u8c03\u6574\u884c\u8ddd\uff0c\u5230\u81ea\u52a8\u683c\u5f0f\u5316\u3001\u81ea\u52a8\u6ce8\u91ca\u3001\u81ea\u52a8\u751f\u6210\u6784\u9020\u5668\uff0c\u6709\u592a\u591a\u80fd\u5199\u7684\u5185\u5bb9\u6ca1\u6709\u529e\u6cd5\u5728\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\u8be6\u5c3d\u63cf\u8ff0\u3002\u66f4\u591a\u7684\u9700\u8981\u5728\u5b9e\u9645\u4ee3\u7801\u5f53\u4e2d\u53bb\u4f53\u4f1a\u3002\u90a3\u4e48\uff0c\u6211\u4eec\u4eca\u5929\u5c31\u5230\u8fd9\u91cc\u5427~","title":"PyCharm"},{"location":"document/literature_management/","text":"\u524d\u8a00 \u6700\u8fd1\u6765\u897f\u6e56\u5927\u5b66\u505a\u8bbf\u95ee\u5b66\u751f\uff0c\u6b63\u513f\u516b\u7ecf\u8fc7\u4e0a\u4e86\u4e00\u5929\u5230\u665a\u641e\u7814\u7a76\u7684\u5b66\u672f\u751f\u6d3b\uff08\u5176\u5b9e\u8fd8\u662f\u6709\u4e24\u95e8\u8bfe\u8981\u4fee\u4f46\u662f\u6bd5\u7adf\u538b\u529b\u5c0f\u4e86\u5f88\u591a\uff09\u3002\u968f\u4e4b\u800c\u6765\u7684 \u7b56\u7565\u6a21\u5f0f\uff08Strategy Pattern, Policy Pattern\uff09 # \u7b56\u7565\u6a21\u5f0f \u7b56\u7565\u6a21\u5f0f\u5728\u8fd0\u884c\u65f6\u9009\u62e9\u7b97\u6cd5\u3002\u4ee3\u7801\u5e76\u4e0d\u76f4\u63a5\u5b9e\u73b0\u5355\u4e2a\u7b97\u6cd5\uff0c\u800c\u662f\u63a5\u6536\u8fd0\u884c\u65f6\u6307\u4ee4\uff0c\u4ee5\u6307\u793a\u5728\u4e00\u7cfb\u5217\u7b97\u6cd5\u4e2d\u8981\u4f7f\u7528\u54ea\u4e2a\u3002 \u7b56\u7565\u6a21\u5f0f\u5f53\u4e2d\u7684\u63a5\u53e3\u662f\u56fa\u5b9a\u7684\uff0c\u56e0\u6b64\u8c03\u7528\u65f6\u4e0d\u8bb8\u66f4\u6539\u65b9\u6cd5\u3002 \u7ed3\u6784 \u7b56\u7565\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u4e0a\u4e0b\u6587\uff08Context\uff09\uff1a\u5f15\u7528\u7b56\u7565\u7684\u5bf9\u8c61 \u7b56\u7565\uff08Strategy\uff09\uff1a\u7b56\u7565\u7684\u516c\u5171\u63a5\u53e3\uff0c\u5177\u4f53\u7b56\u7565\u90fd\u5c06\u5b9e\u73b0\u8fd9\u4e2a\u63a5\u53e3 \u5177\u4f53\u7b56\u7565\uff08Concrete Strategy\uff09\uff1a\u7b56\u7565\u7684\u5177\u4f53\u5b9e\u73b0\uff0c\u5305\u542b\u4e86\u5177\u4f53\u7684\u7b97\u6cd5\u4ee3\u7801 \u7b56\u7565\u6a21\u5f0f from abc import ABC , abstractmethod class ChickenCooker ( ABC ): # \u7b56\u7565 @abstractmethod def cook ( self ): pass class FriedChickenCooker ( ChickenCooker ): # \u5177\u4f53\u7b56\u75651 def cook ( self ): print ( \"Cooking fried chicken!\" ) class GrilledChickenCooker ( ChickenCooker ): # \u5177\u4f53\u7b56\u75652 def cook ( self ): print ( \"Cooking grilled chicken!\" ) class Kitchen ( object ): # \u4e0a\u4e0b\u6587 def __init__ ( self ): self . _strategy = None @property def strategy ( self ): return self . _strategy @strategy . setter def strategy ( self , strategy ): self . _strategy = strategy def cook ( self ): self . _strategy . cook () \u4f18\u70b9 \u901a\u8fc7\u628a\u7b97\u6cd5\u7684\u8c03\u7528\u653e\u5230\u4e0a\u4e0b\u6587\u5f53\u4e2d\uff0c\u628a\u5b9e\u73b0\u653e\u5230\u4e86\u7b56\u7565\u5f53\u4e2d\u800c\u5b9e\u73b0\u4e86\u4e24\u8005\u7684\u5206\u79bb \u63d0\u4f9b\u76f8\u540c\u884c\u4e3a\u7684\u4e0d\u540c\u5b9e\u73b0\uff1a\u540c\u6837\u662f\u505a\u9e21\uff0c\u6709\u5f88\u591a\u79cd\u4e0d\u540c\u7684\u505a\u6cd5 \u53ef\u4ee5\u7b80\u5355\u7684\u6dfb\u52a0\u65b0\u7684\u7b56\u7565\uff1a\u4ec5\u9700\u521b\u5efa\u4e00\u4e2a\u65b0\u7684Beggar Chicken\u5c31\u53ef\u4ee5\u5b9e\u73b0\u53eb\u82b1\u9e21 \u53ef\u4ee5\u5c06\u90e8\u5206\u4ee3\u7801\u653e\u5230\u7b56\u7565\u5f53\u4e2d\u800c\u907f\u514d\u91cd\u590d\u4ee3\u7801\uff1a\u65e0\u8bba\u662f\u70b8\u9e21\u8fd8\u662f\u70e4\u9e21\uff0c\u4f60\u90fd\u5148\u8981\u5207\u9e21 \u7f3a\u70b9 \u4e0a\u4e0b\u6587\u9700\u8981\u5bf9\u5b9e\u73b0\u6709\u8db3\u591f\u7684\u4e86\u89e3\u6765\u9009\u62e9\u6070\u5f53\u7684\u65b9\u6cd5\uff1a\u4f60\u8981\u77e5\u9053\u505a\u51fa\u6765\u662f\u4ec0\u4e48\u9e21 \u4f1a\u9020\u6210\u5f88\u591a\u7684\u5177\u4f53\u7b56\u7565\u7c7b\uff1a\u8fd9\u5bf9Python\u53ef\u80fd\u4e0d\u662f\u4ec0\u4e48\u95ee\u9898\uff0c\u4f46\u5bf9\u4e8eJava\u8fd9\u6837\u6bcf\u4e00\u4e2a\u7c7b\u90fd\u9700\u8981\u4e00\u4e2a\u6587\u4ef6\u7684\u8bed\u8a00\u6765\u8bf4\u2026\u2026 \u89c2\u5bdf\u8005\u6a21\u5f0f\uff08Observer Pattern\uff09 # \u89c2\u5bdf\u8005\u6a21\u5f0f \u89c2\u5bdf\u8005\u6a21\u5f0f\u4e2d\u4e00\u4e2a\u5bf9\u8c61\uff08\u4e3b\u4f53\uff08Subject\uff09\u6216\u53ef\u89c2\u5bdf\uff08Observable\uff09\uff09\u7ef4\u62a4\u4e00\u4e2a\u5217\u8868\u7684\u5bf9\u8c61\uff08\u89c2\u5bdf\u8005\uff08Observer\uff09\uff09\uff0c\u5e76\u5728\u81ea\u8eab\u7684\u72b6\u6001\u53d1\u751f\u6539\u53d8\u65f6\u901a\u77e5\u89c2\u5bdf\u8005\u3002 \u89c2\u5bdf\u8005\u6a21\u5f0f\u5bb9\u6613\u548c\u53d1\u5e03/\u8ba2\u9605\u6a21\u5f0f\uff08Publish/Subscribe Pattern\uff09\u6df7\u6dc6\uff0c\u4e24\u8005\u7684\u533a\u522b\u4e3b\u8981\u5728\u4e8e\u53d1\u5e03/\u8ba2\u9605\u6a21\u5f0f\u6709\u4e00\u4e2a\u4e2d\u95f4\u4ef6\u8d1f\u8d23\u6d88\u606f\u7684\u8f6c\u53d1\uff0c\u56e0\u6b64\u53d1\u5e03\u8005\u548c\u8ba2\u9605\u8005\u4e0d\u9700\u8981\u5bf9\u5f7c\u6b64\u6709\u4efb\u4f55\u4e86\u89e3\u3002\u4f46\u5728\u89c2\u5bdf\u8005\u6a21\u5f0f\u4e2d\uff0c\u4e3b\u4f53\u9700\u8981\u5bf9\u89c2\u5bdf\u8005\u7684\u901a\u77e5\u65b9\u6cd5\u6709\u6240\u4e86\u89e3\u3002 \u7ed3\u6784 \u89c2\u5bdf\u8005\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e24\u79cd\u89d2\u8272\u6784\u6210\uff1a \u4e3b\u4f53\uff08Subject\uff09\u6216\u53ef\u89c2\u5bdf\uff08Observable\uff09 \u89c2\u5bdf\u8005\uff08Observer\uff09 \u89c2\u5bdf\u8005\u6a21\u5f0f from enum import Enum class Kitchen ( object ): # \u4e3b\u4f53 def __init__ ( self ): self . _waiters = [ Waiter ( i ) for _ in range ( 10 )] def collect_order ( self ): [ waiter . collect_order () for waiter in self . _waiters ] class Waiter ( object ): # \u89c2\u5bdf\u8005 def __init__ ( self , i : int ): self . id = i self . status = WaiterStatus . Free def collect_order ( self ): print ( 'Coming' ) if self . status != WaiterStatus . Busy else print ( 'Busy' ) class WaiterStatus ( Enum ): Free = 0 Busy = 1 \u4f18\u70b9 \u964d\u4f4e\u4e86\u4e3b\u4f53\u548c\u89c2\u5bdf\u8005\u4e4b\u95f4\u7684\u8026\u5408 \u7f3a\u70b9 \u4e3b\u4f53\u548c\u89c2\u5bdf\u8005\u4e4b\u95f4\u4ecd\u5b58\u5728\u8026\u5408 \u89c2\u5bdf\u8005\u8f83\u591a\u65f6\u901a\u77e5\u53d1\u5e03\u4f1a\u5f71\u54cd\u6027\u80fd \u5916\u89c2\u6a21\u5f0f\uff08Facade Pattern\uff09 # \u5916\u89c2\u6a21\u5f0f \u7c7b\u4f3c\u4e8e\u5efa\u7b51\u4e2d\u7684\u5916\u5899\uff0c\u4e00\u4e2a\u5916\u89c2\u662f\u63a9\u76d6\u4e86\u66f4\u590d\u6742\u7684\u57fa\u7840\u6216\u7ed3\u6784\u4ee3\u7801\u800c\u5145\u5f53\u5bf9\u5916\u63a5\u53e3\u7684\u5bf9\u8c61\u3002 \u4e00\u4e2a\u5927\u578b\u53a8\u623f\u7531\u5f88\u591a\u5b50\u90e8\u5206\u6784\u6210\u2013\u6253\u8377\u3001\u51b7\u83dc\u3001\u84b8\u83dc\u3001\u9762\u6848\u3001\u6c34\u53f0\u3001\u7827\u677f\u3001\u70ed\u7076\uff0c\u800c\u5bf9\u4e8e\u8d1f\u8d23\u4e0b\u5355\u7684\u670d\u52a1\u5458\u6765\u8bf4\uff0c\u5b83\u5e76\u4e0d\u9700\u8981\u4e86\u89e3\u8fd9\u8bb8\u591a\u3002 \u7ed3\u6784 \u5916\u89c2\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u5ba2\u6237\uff08Client\uff09\uff1a\u8bbf\u95ee\u5916\u89c2\u7684\u5bf9\u8c61 \u5916\u89c2\uff08Facade\uff09\uff1a\u5c06\u5b50\u7cfb\u7edf\u5305\u88c5\u7684\u516c\u5171\u63a5\u53e3 \u5b50\u7cfb\u7edf\uff08Subsystem\uff09\uff1a\u5b50\u7cfb\u7edf\u7684\u5177\u4f53\u5b9e\u73b0 \u5916\u89c2\u6a21\u5f0f class Kitchen ( object ): # \u5916\u89c2 def __init__ ( self ): self . prepare = Prepare () self . cold = Cold () self . steam = Steam () self . noodles = Noodles () self . wash = Wash () self . chop = Chop () self . stove = Stove () def add_order ( self ): self . prepare . prepare () self . cold . cook () self . steam . cook () self . noodles . cook () self . wash . wash () self . chop . chop () self . stove . cook () self . collect_order () \u4f18\u70b9 \u5bf9\u5ba2\u6237\u5c4f\u853d\u4e86\u5b50\u7cfb\u7edf\uff0c\u964d\u4f4e\u4e86\u8026\u5408 \u7f3a\u70b9 \u96be\u4ee5\u5bf9\u5ba2\u6237\u5b9a\u5236\u9700\u6c42 \u65b0\u589e\u5b50\u7cfb\u7edf\u53ef\u80fd\u4f1a\u9700\u8981\u5916\u89c2\u548c\u5ba2\u6237\u4f5c\u51fa\u4fee\u6539 \u5355\u4f8b\u6a21\u5f0f\uff08Singleton Pattern\uff09 # \u5355\u4f8b\u6a21\u5f0f \u5c06\u7c7b\u7684\u5b9e\u4f8b\u5316\u9650\u5236\u4e3a\u552f\u4e00\u7684\u5355\u4e2a\u5b9e\u4f8b\u3002 \u4e00\u4e2a\u5927\u578b\u9152\u5e97\u53ef\u80fd\u62e5\u6709\u5f88\u591a\u5458\u5de5\u751a\u81f3\u591a\u4e2a\u53a8\u623f\uff0c\u4f46\u4ed6\u6c38\u8fdc\u53ea\u6709\u4e00\u4e2a\u603b\u53a8\u5e08\u957f\u3002 \u7ed3\u6784 \u5355\u4f8b\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u5ba2\u6237\uff08Client\uff09\uff1a\u8bbf\u95ee\u5355\u4f8b\u7684\u5bf9\u8c61 \u5355\u4f8b\uff08Singleton\uff09\uff1a\u5305\u542b\u4e00\u4e2a\u5b9e\u4f8b\u4e14\u4f1a\u81ea\u52a8\u521b\u5efa\u8be5\u5b9e\u4f8b\u7684\u7c7b \u5355\u4f8b\u6a21\u5f0f class ChiefHeadChef ( object ): __chief_head_chef = None def __new__ ( cls ): if not cls . __chief_head_chef : cls . __chief_head_chef = object . __new__ ( cls ) return cls . __chief_head_chef \u4f18\u70b9 \u5355\u4f8b\u548c\u5ba2\u6237\u9ad8\u5ea6\u8026\u5408\uff0c\u6bcf\u4e2a\u5ba2\u6237\u5bf9\u5355\u4f8b\u505a\u51fa\u7684\u4fee\u6539\u90fd\u5c06\u5f71\u54cd\u5176\u4ed6\u5ba2\u6237 \u7f3a\u70b9 \u5355\u4f8b\u548c\u5ba2\u6237\u9ad8\u5ea6\u8026\u5408\uff0c\u6bcf\u4e2a\u5ba2\u6237\u5bf9\u5355\u4f8b\u505a\u51fa\u7684\u4fee\u6539\u90fd\u5c06\u5f71\u54cd\u5176\u4ed6\u5ba2\u6237","title":"\u6587\u732e\u7ba1\u7406"},{"location":"document/literature_management/#strategy-pattern-policy-pattern","text":"\u7b56\u7565\u6a21\u5f0f \u7b56\u7565\u6a21\u5f0f\u5728\u8fd0\u884c\u65f6\u9009\u62e9\u7b97\u6cd5\u3002\u4ee3\u7801\u5e76\u4e0d\u76f4\u63a5\u5b9e\u73b0\u5355\u4e2a\u7b97\u6cd5\uff0c\u800c\u662f\u63a5\u6536\u8fd0\u884c\u65f6\u6307\u4ee4\uff0c\u4ee5\u6307\u793a\u5728\u4e00\u7cfb\u5217\u7b97\u6cd5\u4e2d\u8981\u4f7f\u7528\u54ea\u4e2a\u3002 \u7b56\u7565\u6a21\u5f0f\u5f53\u4e2d\u7684\u63a5\u53e3\u662f\u56fa\u5b9a\u7684\uff0c\u56e0\u6b64\u8c03\u7528\u65f6\u4e0d\u8bb8\u66f4\u6539\u65b9\u6cd5\u3002 \u7ed3\u6784 \u7b56\u7565\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u4e0a\u4e0b\u6587\uff08Context\uff09\uff1a\u5f15\u7528\u7b56\u7565\u7684\u5bf9\u8c61 \u7b56\u7565\uff08Strategy\uff09\uff1a\u7b56\u7565\u7684\u516c\u5171\u63a5\u53e3\uff0c\u5177\u4f53\u7b56\u7565\u90fd\u5c06\u5b9e\u73b0\u8fd9\u4e2a\u63a5\u53e3 \u5177\u4f53\u7b56\u7565\uff08Concrete Strategy\uff09\uff1a\u7b56\u7565\u7684\u5177\u4f53\u5b9e\u73b0\uff0c\u5305\u542b\u4e86\u5177\u4f53\u7684\u7b97\u6cd5\u4ee3\u7801 \u7b56\u7565\u6a21\u5f0f from abc import ABC , abstractmethod class ChickenCooker ( ABC ): # \u7b56\u7565 @abstractmethod def cook ( self ): pass class FriedChickenCooker ( ChickenCooker ): # \u5177\u4f53\u7b56\u75651 def cook ( self ): print ( \"Cooking fried chicken!\" ) class GrilledChickenCooker ( ChickenCooker ): # \u5177\u4f53\u7b56\u75652 def cook ( self ): print ( \"Cooking grilled chicken!\" ) class Kitchen ( object ): # \u4e0a\u4e0b\u6587 def __init__ ( self ): self . _strategy = None @property def strategy ( self ): return self . _strategy @strategy . setter def strategy ( self , strategy ): self . _strategy = strategy def cook ( self ): self . _strategy . cook () \u4f18\u70b9 \u901a\u8fc7\u628a\u7b97\u6cd5\u7684\u8c03\u7528\u653e\u5230\u4e0a\u4e0b\u6587\u5f53\u4e2d\uff0c\u628a\u5b9e\u73b0\u653e\u5230\u4e86\u7b56\u7565\u5f53\u4e2d\u800c\u5b9e\u73b0\u4e86\u4e24\u8005\u7684\u5206\u79bb \u63d0\u4f9b\u76f8\u540c\u884c\u4e3a\u7684\u4e0d\u540c\u5b9e\u73b0\uff1a\u540c\u6837\u662f\u505a\u9e21\uff0c\u6709\u5f88\u591a\u79cd\u4e0d\u540c\u7684\u505a\u6cd5 \u53ef\u4ee5\u7b80\u5355\u7684\u6dfb\u52a0\u65b0\u7684\u7b56\u7565\uff1a\u4ec5\u9700\u521b\u5efa\u4e00\u4e2a\u65b0\u7684Beggar Chicken\u5c31\u53ef\u4ee5\u5b9e\u73b0\u53eb\u82b1\u9e21 \u53ef\u4ee5\u5c06\u90e8\u5206\u4ee3\u7801\u653e\u5230\u7b56\u7565\u5f53\u4e2d\u800c\u907f\u514d\u91cd\u590d\u4ee3\u7801\uff1a\u65e0\u8bba\u662f\u70b8\u9e21\u8fd8\u662f\u70e4\u9e21\uff0c\u4f60\u90fd\u5148\u8981\u5207\u9e21 \u7f3a\u70b9 \u4e0a\u4e0b\u6587\u9700\u8981\u5bf9\u5b9e\u73b0\u6709\u8db3\u591f\u7684\u4e86\u89e3\u6765\u9009\u62e9\u6070\u5f53\u7684\u65b9\u6cd5\uff1a\u4f60\u8981\u77e5\u9053\u505a\u51fa\u6765\u662f\u4ec0\u4e48\u9e21 \u4f1a\u9020\u6210\u5f88\u591a\u7684\u5177\u4f53\u7b56\u7565\u7c7b\uff1a\u8fd9\u5bf9Python\u53ef\u80fd\u4e0d\u662f\u4ec0\u4e48\u95ee\u9898\uff0c\u4f46\u5bf9\u4e8eJava\u8fd9\u6837\u6bcf\u4e00\u4e2a\u7c7b\u90fd\u9700\u8981\u4e00\u4e2a\u6587\u4ef6\u7684\u8bed\u8a00\u6765\u8bf4\u2026\u2026","title":"\u7b56\u7565\u6a21\u5f0f\uff08Strategy Pattern, Policy Pattern\uff09"},{"location":"document/literature_management/#observer-pattern","text":"\u89c2\u5bdf\u8005\u6a21\u5f0f \u89c2\u5bdf\u8005\u6a21\u5f0f\u4e2d\u4e00\u4e2a\u5bf9\u8c61\uff08\u4e3b\u4f53\uff08Subject\uff09\u6216\u53ef\u89c2\u5bdf\uff08Observable\uff09\uff09\u7ef4\u62a4\u4e00\u4e2a\u5217\u8868\u7684\u5bf9\u8c61\uff08\u89c2\u5bdf\u8005\uff08Observer\uff09\uff09\uff0c\u5e76\u5728\u81ea\u8eab\u7684\u72b6\u6001\u53d1\u751f\u6539\u53d8\u65f6\u901a\u77e5\u89c2\u5bdf\u8005\u3002 \u89c2\u5bdf\u8005\u6a21\u5f0f\u5bb9\u6613\u548c\u53d1\u5e03/\u8ba2\u9605\u6a21\u5f0f\uff08Publish/Subscribe Pattern\uff09\u6df7\u6dc6\uff0c\u4e24\u8005\u7684\u533a\u522b\u4e3b\u8981\u5728\u4e8e\u53d1\u5e03/\u8ba2\u9605\u6a21\u5f0f\u6709\u4e00\u4e2a\u4e2d\u95f4\u4ef6\u8d1f\u8d23\u6d88\u606f\u7684\u8f6c\u53d1\uff0c\u56e0\u6b64\u53d1\u5e03\u8005\u548c\u8ba2\u9605\u8005\u4e0d\u9700\u8981\u5bf9\u5f7c\u6b64\u6709\u4efb\u4f55\u4e86\u89e3\u3002\u4f46\u5728\u89c2\u5bdf\u8005\u6a21\u5f0f\u4e2d\uff0c\u4e3b\u4f53\u9700\u8981\u5bf9\u89c2\u5bdf\u8005\u7684\u901a\u77e5\u65b9\u6cd5\u6709\u6240\u4e86\u89e3\u3002 \u7ed3\u6784 \u89c2\u5bdf\u8005\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e24\u79cd\u89d2\u8272\u6784\u6210\uff1a \u4e3b\u4f53\uff08Subject\uff09\u6216\u53ef\u89c2\u5bdf\uff08Observable\uff09 \u89c2\u5bdf\u8005\uff08Observer\uff09 \u89c2\u5bdf\u8005\u6a21\u5f0f from enum import Enum class Kitchen ( object ): # \u4e3b\u4f53 def __init__ ( self ): self . _waiters = [ Waiter ( i ) for _ in range ( 10 )] def collect_order ( self ): [ waiter . collect_order () for waiter in self . _waiters ] class Waiter ( object ): # \u89c2\u5bdf\u8005 def __init__ ( self , i : int ): self . id = i self . status = WaiterStatus . Free def collect_order ( self ): print ( 'Coming' ) if self . status != WaiterStatus . Busy else print ( 'Busy' ) class WaiterStatus ( Enum ): Free = 0 Busy = 1 \u4f18\u70b9 \u964d\u4f4e\u4e86\u4e3b\u4f53\u548c\u89c2\u5bdf\u8005\u4e4b\u95f4\u7684\u8026\u5408 \u7f3a\u70b9 \u4e3b\u4f53\u548c\u89c2\u5bdf\u8005\u4e4b\u95f4\u4ecd\u5b58\u5728\u8026\u5408 \u89c2\u5bdf\u8005\u8f83\u591a\u65f6\u901a\u77e5\u53d1\u5e03\u4f1a\u5f71\u54cd\u6027\u80fd","title":"\u89c2\u5bdf\u8005\u6a21\u5f0f\uff08Observer Pattern\uff09"},{"location":"document/literature_management/#facade-pattern","text":"\u5916\u89c2\u6a21\u5f0f \u7c7b\u4f3c\u4e8e\u5efa\u7b51\u4e2d\u7684\u5916\u5899\uff0c\u4e00\u4e2a\u5916\u89c2\u662f\u63a9\u76d6\u4e86\u66f4\u590d\u6742\u7684\u57fa\u7840\u6216\u7ed3\u6784\u4ee3\u7801\u800c\u5145\u5f53\u5bf9\u5916\u63a5\u53e3\u7684\u5bf9\u8c61\u3002 \u4e00\u4e2a\u5927\u578b\u53a8\u623f\u7531\u5f88\u591a\u5b50\u90e8\u5206\u6784\u6210\u2013\u6253\u8377\u3001\u51b7\u83dc\u3001\u84b8\u83dc\u3001\u9762\u6848\u3001\u6c34\u53f0\u3001\u7827\u677f\u3001\u70ed\u7076\uff0c\u800c\u5bf9\u4e8e\u8d1f\u8d23\u4e0b\u5355\u7684\u670d\u52a1\u5458\u6765\u8bf4\uff0c\u5b83\u5e76\u4e0d\u9700\u8981\u4e86\u89e3\u8fd9\u8bb8\u591a\u3002 \u7ed3\u6784 \u5916\u89c2\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u5ba2\u6237\uff08Client\uff09\uff1a\u8bbf\u95ee\u5916\u89c2\u7684\u5bf9\u8c61 \u5916\u89c2\uff08Facade\uff09\uff1a\u5c06\u5b50\u7cfb\u7edf\u5305\u88c5\u7684\u516c\u5171\u63a5\u53e3 \u5b50\u7cfb\u7edf\uff08Subsystem\uff09\uff1a\u5b50\u7cfb\u7edf\u7684\u5177\u4f53\u5b9e\u73b0 \u5916\u89c2\u6a21\u5f0f class Kitchen ( object ): # \u5916\u89c2 def __init__ ( self ): self . prepare = Prepare () self . cold = Cold () self . steam = Steam () self . noodles = Noodles () self . wash = Wash () self . chop = Chop () self . stove = Stove () def add_order ( self ): self . prepare . prepare () self . cold . cook () self . steam . cook () self . noodles . cook () self . wash . wash () self . chop . chop () self . stove . cook () self . collect_order () \u4f18\u70b9 \u5bf9\u5ba2\u6237\u5c4f\u853d\u4e86\u5b50\u7cfb\u7edf\uff0c\u964d\u4f4e\u4e86\u8026\u5408 \u7f3a\u70b9 \u96be\u4ee5\u5bf9\u5ba2\u6237\u5b9a\u5236\u9700\u6c42 \u65b0\u589e\u5b50\u7cfb\u7edf\u53ef\u80fd\u4f1a\u9700\u8981\u5916\u89c2\u548c\u5ba2\u6237\u4f5c\u51fa\u4fee\u6539","title":"\u5916\u89c2\u6a21\u5f0f\uff08Facade Pattern\uff09"},{"location":"document/literature_management/#singleton-pattern","text":"\u5355\u4f8b\u6a21\u5f0f \u5c06\u7c7b\u7684\u5b9e\u4f8b\u5316\u9650\u5236\u4e3a\u552f\u4e00\u7684\u5355\u4e2a\u5b9e\u4f8b\u3002 \u4e00\u4e2a\u5927\u578b\u9152\u5e97\u53ef\u80fd\u62e5\u6709\u5f88\u591a\u5458\u5de5\u751a\u81f3\u591a\u4e2a\u53a8\u623f\uff0c\u4f46\u4ed6\u6c38\u8fdc\u53ea\u6709\u4e00\u4e2a\u603b\u53a8\u5e08\u957f\u3002 \u7ed3\u6784 \u5355\u4f8b\u6a21\u5f0f\u7531\u4ee5\u4e0b\u4e09\u79cd\u89d2\u8272\u6784\u6210\uff1a \u5ba2\u6237\uff08Client\uff09\uff1a\u8bbf\u95ee\u5355\u4f8b\u7684\u5bf9\u8c61 \u5355\u4f8b\uff08Singleton\uff09\uff1a\u5305\u542b\u4e00\u4e2a\u5b9e\u4f8b\u4e14\u4f1a\u81ea\u52a8\u521b\u5efa\u8be5\u5b9e\u4f8b\u7684\u7c7b \u5355\u4f8b\u6a21\u5f0f class ChiefHeadChef ( object ): __chief_head_chef = None def __new__ ( cls ): if not cls . __chief_head_chef : cls . __chief_head_chef = object . __new__ ( cls ) return cls . __chief_head_chef \u4f18\u70b9 \u5355\u4f8b\u548c\u5ba2\u6237\u9ad8\u5ea6\u8026\u5408\uff0c\u6bcf\u4e2a\u5ba2\u6237\u5bf9\u5355\u4f8b\u505a\u51fa\u7684\u4fee\u6539\u90fd\u5c06\u5f71\u54cd\u5176\u4ed6\u5ba2\u6237 \u7f3a\u70b9 \u5355\u4f8b\u548c\u5ba2\u6237\u9ad8\u5ea6\u8026\u5408\uff0c\u6bcf\u4e2a\u5ba2\u6237\u5bf9\u5355\u4f8b\u505a\u51fa\u7684\u4fee\u6539\u90fd\u5c06\u5f71\u54cd\u5176\u4ed6\u5ba2\u6237","title":"\u5355\u4f8b\u6a21\u5f0f\uff08Singleton Pattern\uff09"},{"location":"document/torch.distributed/","text":"\u524d\u8a00 \u6211\u8fd8\u8bb0\u5f97PyTorch 1.4\u53d1\u5e03\u65f6\uff0c\u770b\u5230PyTorch\u7684\u5206\u5e03\u5f0f\u6709\u65b0\u7684\u6539\u52a8\u540e\u8fd8\u4e13\u95e8\u6d6a\u8d39\u4e86\u4e00\u4e2a\u4e0b\u5348\u7684\u65f6\u95f4\u53bb\u67e5DDP\uff0c\u7814\u7a76NCCL\u7b49\u7b49\u3002\u7136\u9e45\uff0c\u4e00\u77e5\u534a\u89e3\u7684\u6211\u5728\u9762\u8bd5\u65f6\u88ab\u95ee\u5230PyTorch\u7684\u5206\u5e03\u5f0f\u901a\u4fe1\u4e4b\u540e\u77ac\u95f4\u8d25\u4e0b\u9635\u6765555555\uff08\u5176\u5b9e\u4e0b\u6765\u60f3\u60f3\u8fd8\u662f\u53ef\u4ee5\u82df\u82df\u7684\u2026\u2026\uff09\u3002\u5546\u6c64\u7684\u9762\u8bd5\uff0c\u603b\u80fd\u5e26\u7ed9\u4f60\u65e0\u5c3d\u7684\u60ca\u5413\u3002\u5d29\u5b8c\u627e\u6211\u5ed6\u54e5\u6c42\u5b89\u6170\u65f6\u624d\u53d1\u73b0\u4ed6\u4e5f\u6ca1\u641e\u6e05\u563f\u563f\uff0c\u77ac\u95f4\u8f7b\u677e\u4e86\u4e0d\u5c11\u3002\u6240\u4ee5\uff0c\u5c31\u6709\u4e86\u6211\u4eec\u4eca\u5929\u7684\u8fd9\u7bc7\u6587\u7ae0~ \u672c\u6587\u5bf9PyTorch 1.6.0\u7684 torch.distributed \u8fdb\u884c\u7b80\u8981\u63cf\u8ff0\u3002 \u5386\u53f2 # \u5728\u5f00\u59cb\u6b63\u6587\u4e4b\u524d\u6211\u4eec\u5148\u7b80\u8981\u56de\u987e\u4e00\u4e0bPyTorch\u7684\u5386\u53f2\u3002 PyTorch # PyTorch\u5c06\u6570\u636e\u7ec4\u7ec7\u4e3a\u5f20\u91cf\uff08\u4e5f\u5c31\u662f\u4e00\u4e2an\u7ef4\u6570\u7ec4\uff09\uff1b\u800c\u6a21\u5757\u5b9a\u4e49\u4e86\u5c06\u8f93\u5165\u5230\u8f93\u51fa\u7684\u8f6c\u6362\uff0c\u5176\u4e2d\u6a21\u5757\u7684\u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u5728\u4ed6\u7684\u6210\u5458\u51fd\u6570 forward \u4e2d\u5b9a\u4e49\u3002\u4e00\u4e2a\u5e94\u7528\u7531\u4ed6\u7684\u6a21\u5757\u901a\u8fc7\u5728 forward \u51fd\u6570\u4e2d\u5b9a\u4e49\u7684\u591a\u4e2a\u539f\u751f\u6a21\u5757\uff08 nn.Linear \u3001 nn.Conv2d \uff09\u3001\u7528\u6237\u81ea\u5b9a\u4e49\u7684\u6a21\u5757\uff08 backbone \u3001 neck \u3001 head \uff09\u548c\u51fd\u6570\uff08 nn.ReLU \uff09\u7684\u7ec4\u5408\u800c\u6784\u6210\u3002\u5178\u578b\u7684\u8bad\u7ec3\u8fed\u4ee3\u5305\u62ec\u4f7f\u7528\u8f93\u5165\u548c\u6807\u7b7e\u4ea7\u751f\u635f\u5931\u7684\u524d\u5411\u4f20\u64ad\uff0c\u8ba1\u7b97\u53c2\u6570\u7684\u68af\u5ea6\u7684\u53cd\u5411\u4f20\u64ad\u4ee5\u53ca\u4f7f\u7528\u68af\u5ea6\u66f4\u65b0\u53c2\u6570\u7684\u4f18\u5316\u5668\u6b65\u8fdb\u3002\u66f4\u5177\u4f53\u5730\u8bf4\uff0c\u5728\u524d\u5411\u4f20\u64ad\u4e2dPyTorch\u4f1a\u6784\u5efa\u4e00\u4e2a\u81ea\u52a8\u68af\u5ea6\u56fe\u6765\u8bb0\u5f55\u6240\u6267\u884c\u7684\u52a8\u4f5c\u3002\u7136\u540e\u5728\u53cd\u5411\u4f20\u64ad\u4e2d\uff0c\u5b83\u4f7f\u7528\u81ea\u52a8\u68af\u5ea6\u56fe\u8fdb\u884c\u53cd\u5411\u4f20\u64ad\u4ee5\u751f\u6210\u68af\u5ea6\u3002\u6700\u540e\uff0c\u4f18\u5316\u5668\u5c06\u68af\u5ea6\u5e94\u7528\u4e8e\u66f4\u65b0\u53c2\u6570\u3002\u8bad\u7ec3\u53cd\u590d\u91cd\u590d\u8fd9\u4e09\u4e2a\u6b65\u9aa4\u76f4\u5230\u6a21\u578b\u6536\u655b\u3002 PyTorch\u5e76\u884c\u8bad\u7ec3 # \u968f\u7740\u8bad\u7ec3\u6570\u636e\u7684\u589e\u5e7f\u4ee5\u53ca\u6a21\u578b\u89c4\u6a21\u7684\u6269\u5927\uff0c\u5206\u5e03\u5f0f\u8bad\u7ec3\u7684\u91cd\u8981\u6027\u4e5f\u8d8a\u6765\u8d8a\u5f3a\u3002PyTorch\u9996\u5148\u5728 multiprocessing \u7684\u57fa\u7840\u4e0a\u63d0\u51fa\u4e86 torch.multiprocessing \uff0c\u4f46\u7531\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u9650\u5236\u800c\u5e26\u6765\u4e86\u79cd\u79cd\u5c40\u9650\uff08\u5982CUDA API\u8981\u6c42\u5bfc\u51fa\u5230\u5176\u4ed6\u8fdb\u7a0b\u7684\u5206\u914d\u5728\u4ecd\u88ab\u4f7f\u7528\u65f6\u4fdd\u6301\u6709\u6548\uff09\u3002\u968f\u540e\uff0cPyTorch\u57280.1\u4e2d\u63d0\u51fa\u4e86\u6539\u8fdb\u7684 nn.DataParallel \uff0c\u5b83\u4f7f\u7528\u5355\u8fdb\u7a0b\u591a\u7ebf\u7a0b\u7684\u65b9\u5f0f\uff0c\u5728\u6bcf\u6b21\u524d\u5411\u8fc7\u7a0b\u4e2d\u901a\u8fc7 scatter \u5c06\u6570\u636e\u5206\u914d\u7ed9GPUs\uff0c\u8c03\u7528 replica \u51fd\u6570\u5728\u5404\u4e2aGPU\u4e0a\u521b\u5efa\u6a21\u578b\u7684\u526f\u672c\uff0c\u7136\u540e\u4f7f\u7528 parallel_apply \u5728\u5404\u4e2aGPU\u4e0a\u5b8c\u6210\u524d\u5411\u4f20\u64ad\uff0c\u5e76\u901a\u8fc7 gather \u5c06\u6240\u6709\u8f93\u51fa\u805a\u96c6\u5230\u9996\u5f20GPU\u4e0a\u5f97\u5230\u635f\u5931\uff0c\u63a5\u7740\u635f\u5931\u88ab scatter \u5230GPUs\u4e0a\u8fdb\u884c\u53cd\u5411\u4f20\u64ad\u5f97\u5230\u68af\u5ea6\uff0c\u6700\u540e\u68af\u5ea6\u88ab all_reduce \u5230GPU0\u4e0a\u66f4\u65b0\u6743\u91cd\u3002\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u8fd9\u79cd\u65b9\u5f0f\u4f1a\u5bf9GPU0\u4ea7\u751f\u5de8\u5927\u7684\u538b\u529b\uff0c\u800c\u5355\u8fdb\u7a0b\u591a\u7ebf\u7a0b\u7684\u65b9\u5f0f\u4e5f\u4e0d\u5141\u8bb8\u5728\u591a\u53f0\u673a\u5668\u4e0a\u5206\u5e03\u5f0f\u7684\u8bad\u7ec3\u3002\u968f\u540e\uff0cPyTorch\u57280.3.0\u4e2d\u5f15\u5165\u4e86 nn.DistributedDataParallel \u4ee5\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\uff0c\u5e76\u57281.0\u4e2d\u5f15\u5165\u4e86c10d\u6a21\u5757\u6765\u66ff\u4ee3\u4f20\u7edf\u7684THD\u4ee5\u5927\u5e45\u63d0\u5347\u901a\u4fe1\u6548\u7387\u3002\u4f46\u968f\u7740\u6a21\u578b\u7684\u589e\u5927\uff0c\u5355\u53f0\u673a\u5668\u5df2\u7ecf\u4e0d\u80fd\u5bb9\u4e0b\u6574\u4e2a\u6a21\u578b\uff0c\u800c\u4e14 nn.DistributedDataParallel \u5e76\u4e0d\u9002\u5408\u53c2\u6570\u670d\u52a1\u5668\uff0cPyTorch\u53c8\u57281.3\u4e2d\u5f15\u5165\u4e86 distributed.rpc \u6765\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002 \u7ed3\u6784 # \u5bf9\u4e8e\u73b0\u884c\u7248\u672c\uff0c torch.distributed \u7531\u4ee5\u4e0b\u4e09\u4e2a\u91cd\u8981\u7ec4\u6210\u90e8\u5206\u6784\u6210\u3002 \u5206\u5e03\u5f0f\u6570\u636e\u5e76\u884c - Distributed Data-Parallel (DDP) DDP\u662f\u6700\u5e38\u89c1\u7684\u591aGPU\u8bad\u7ec3\u8303\u5f0f\uff0c\u5b83\u652f\u6301\u591a\u673a\u591a\u5361\u8bad\u7ec3\uff0c\u5e76\u5141\u8bb8\u5c06\u6a21\u578b\u5206\u5e03\u5728\u540c\u4e00\u4e3b\u673a\u7684\u591a\u5f20\u663e\u5361\u4e2d\u3002 \u8fdc\u7a0b\u8fc7\u7a0b\u8c03\u7528 - RPC-Based Distributed (RPC) RPC\u65e8\u5728\u652f\u6301\u4e0d\u9002\u7528\u4e8e\u6570\u636e\u5e76\u884c\u8bad\u7ec3\u7684\u5e38\u89c4\u8bad\u7ec3\u7ed3\u6784\uff0c\u4f8b\u5982\u5206\u5e03\u5f0f\u7ba1\u9053\u5e76\u884c\uff08\u6a21\u578b\u5206\u5e03\u4e8e\u591a\u53f0\u4e3b\u673a\u4e0a\uff09\uff0c\u53c2\u6570\u670d\u52a1\u5668\u8303\u5f0f\uff08\u6a21\u578b\u53c2\u6570\u4e0e\u8bad\u7ec3\u5668\u4f4d\u4e8e\u4e0d\u540c\u673a\u5668\u4e0a\uff09\u4ee5\u53caDDP\u4e0e\u5176\u4ed6\u8bad\u7ec3\u8303\u5f0f\u7684\u7ec4\u5408\u3002 \u805a\u5408\u901a\u4fe1 - Collective Communication (c10d) C10d\u5e93\u652f\u6301\u7ec4\u5185\u8fdb\u7a0b\u95f4\u7684\u5f20\u91cf\u53d1\u9001\u3002\u4ed6\u63d0\u4f9b\u805a\u5408\u901a\u4fe1API\uff08\u5982 all_reduce \u548c all_gather \uff09\u4ee5\u53caP2P\u901a\u4fe1API\uff08\u5982 send \u548c isend \uff09\u3002DDP\u548cRPC\uff08\u8fdb\u7a0b\u7ec4\u540e\u7aef\uff09\u5728v1.6.0\u4e2d\u90fd\u57fa\u4e8ec10d\uff0c\u5176\u4e2d\u524d\u8005\u4f7f\u7528\u805a\u5408\u901a\u4fe1\uff0c\u800c\u540e\u8005\u4f7f\u7528P2P\u901a\u4fe1\u3002C10d\u662f\u4e00\u4e2a\u4f4e\u7ea7\u7684\u901a\u4fe1API\uff0c\u4ec5\u5bf9\u540e\u7aef\u7684\u539f\u8bed\u8fdb\u884c\u5c01\u88c5\uff0c\u800c\u5728\u6b64\u57fa\u7840\u4e0a\u7684DDP\u548cRPC\u80fd\u6ee1\u8db3\u5927\u591a\u6570\u5206\u5e03\u5f0f\u8bad\u7ec3\u65b9\u6848\u7684\u9700\u6c42\uff0c\u56e0\u6b64\u5f00\u53d1\u4eba\u5458\u901a\u5e38\u65e0\u9700\u4f7f\u7528\u8fd9\u4e2aAPI\u3002\u4e8b\u5b9e\u4e0a\uff0c\u76f4\u63a5\u8c03\u7528\u8fd9\u4e2aAPI\u4e5f\u662f\u88ab\u4e0d\u5efa\u8bae\u7684\uff0c\u56e0\u4e3a\u624b\u52a8\u8c03\u7528\u6b64API\u8fdb\u884c\u901a\u4fe1\u548c\u8ba1\u7b97\u5c06\u65e0\u6cd5\u5e94\u7528\u5230DDP\u548cRPC\u7684\u6027\u80fd\u4f18\u5316\u3002\u4f46\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u6b64API\u4ecd\u7136\u5f88\u6709\u5e2e\u52a9\u3002\u4e00\u4e2a\u793a\u4f8b\u662f\u5206\u5e03\u5f0f\u53c2\u6570\u5e73\u5747\uff0c\u5176\u4e2d\u5e94\u7528\u7a0b\u5e8f\u5e0c\u671b\u5728\u53cd\u5411\u4f20\u64ad\u4e4b\u540e\u8ba1\u7b97\u6240\u6709\u6a21\u578b\u53c2\u6570\u7684\u5e73\u5747\u503c\uff0c\u800c\u4e0d\u662f\u4f7f\u7528DDP\u6765\u4f20\u9012\u68af\u5ea6\u3002\u8fd9\u53ef\u4ee5\u4f7f\u901a\u4fe1\u4e0e\u8ba1\u7b97\u8131\u94a9\uff0c\u5e76\u5141\u8bb8\u5bf9\u901a\u4fe1\u5185\u5bb9\u8fdb\u884c\u66f4\u7ec6\u7c92\u5ea6\u7684\u63a7\u5236\u3002 \u4f7f\u7528PyTorch\u7f16\u5199\u5206\u5e03\u5f0f\u5e94\u7528\u7a0b\u5e8f \u63d0\u4f9b\u4e86\u4f7f\u7528c10d API\u901a\u4fe1\u7684\u793a\u4f8b\u3002 \u5206\u5e03\u5f0f\u6570\u636e\u5e76\u884c\uff08DDP\uff09 # DDP\u5728\u6bcf\u4e2a\u8ba1\u7b97\u8d44\u6e90\uff08GPU\uff09\u4e0a\u521b\u5efa\u6a21\u578b\u526f\u672c\u6765\u72ec\u7acb\u7684\u751f\u6210\u68af\u5ea6\uff0c\u7136\u540e\u5728\u6bcf\u4e2a\u8fed\u4ee3\u4e2d\u4ea4\u6d41\u8fd9\u4e9b\u68af\u5ea6\u4f7f\u5f97\u6a21\u578b\u526f\u672c\u4e00\u81f4\u3002PyTorch\u4f7f\u7528\u4e86\u591a\u79cd\u6280\u672f\u6765\u52a0\u901f\u5e76\u884c\u8fd0\u7b97\uff0c\u5305\u62ec\u68af\u5ea6\u5408\u6876\uff08bucketing gradients\uff09\u3001\u8ba1\u7b97\u901a\u4fe1\u91cd\u53e0\uff08overlapping computation with communication\uff09\u4ee5\u53ca\u68af\u5ea6\u540c\u6b65\u8df3\u8fc7\uff08skipping gradient synchronization\uff09\u3002\u8bc4\u4f30\u8868\u660e\uff0cPyTorch\u53ef\u4ee5\u5728256\u4e2aGPU\u4e0a\u8fbe\u5230\u63a5\u8fd1\u7ebf\u6027\u7684\u53ef\u6269\u5c55\u6027\u3002 DDP\u7684\u6bcf\u4e00\u4e2a\u8fdb\u7a0b\u90fd\u5bf9\u5e94\u4e00\u4e2a\u72ec\u7acb\u7684\u8bad\u7ec3\u8fc7\u7a0b\uff0c\u5b83\u62e5\u6709\u81ea\u5df1\u7684\u6a21\u578b\u526f\u672c\uff0c\u81ea\u5df1\u7684\u4f18\u5316\u5668\uff0c\u5f53\u7136\u4e5f\u63a7\u5236\u4e00\u5f20GPU\u3002DDP\u901a\u8fc7\u786e\u4fdd\u4ee5\u4e0b\u4e24\u70b9\u6765\u786e\u4fdd\u7b97\u6cd5\u7684\u6b63\u786e\u6027\uff08\u5373\u5176\u8bad\u7ec3\u7ed3\u679c\u4e0e\u5355\u5361\u8bad\u7ec3\u7ed3\u679c\u4e00\u81f4\uff09\u3002 \u6240\u6709\u6a21\u578b\u526f\u672c\u7684\u521d\u59cb\u72b6\u6001\u76f8\u540c \u6240\u6709\u4f18\u5316\u5668\u6bcf\u6b21\u6b65\u8fdb\u4f7f\u7528\u7684\u53c2\u6570\u68af\u5ea6\u76f8\u540c DDP\u7684\u7ed3\u6784\u5982\u53f3\u56fe\u6240\u793a\uff0c\u5b83\u4e3b\u8981\u5305\u62ec\u4e86Python API\u548cC++\u7684\u68af\u5ea6\u4e0b\u964d\u7b97\u6cd5\u3002\u6240\u6709\u7684\u901a\u4fe1\u901a\u8fc7c10d\u8c03\u7528\u5e95\u5c42\u901a\u4fe1\u6846\u67b6\u3002 DDP\u7684API\u4e0eDP\u7c7b\u4f3c\uff0c\u5747\u662f\u4e00\u4e2a\u6a21\u7ec4\u3002\u5728\u672c\u6587\u4e2d\uff0c\u6211\u4eec\u5c06\u5ffd\u7565\u63a5\u53e3\u7684\u8bbe\u8ba1\u800c\u5173\u6ce8\u5e95\u5c42\u7684\u8fd0\u7b97\u6d41\u7a0b\u3002\u5982\u679c\u4f60\u5bf9\u5176\u611f\u5174\u8da3\uff0c\u6211\u4eec\u9f13\u52b1\u4f60\u9605\u8bfb PyTorch Distributed: Experiences on Accelerating Data Parallel Training \u7684\u7b2c3.1\u8282\u4ee5\u83b7\u5f97\u66f4\u591a\u7ec6\u8282\u3002 \u68af\u5ea6\u89c4\u7ea6 # DDP\u7684\u68af\u5ea6\u89c4\u7ea6\u4e00\u76f4\u5728\u8fdb\u5316\uff0c\u8ba9\u6211\u4eec\u4ece\u4e00\u4e2a\u7b80\u5355\u7684\u7b97\u6cd5\u5f00\u59cb\u5e76\u9010\u6b65\u7406\u89e3\u73b0\u884c\u7248\u672c\u4e2d\u7684\u7b97\u6cd5\u3002 \u56de\u987e\u6211\u4eec\u4e4b\u524d\u63d0\u5230\u7684\uff0cDDP\u901a\u8fc7\u786e\u4fdd\u6240\u6709\u6a21\u578b\u526f\u672c\u7684\u521d\u59cb\u72b6\u6001\u76f8\u540c\u548c\u6240\u6709\u4f18\u5316\u5668\u6bcf\u6b21\u6b65\u8fdb\u4f7f\u7528\u7684\u53c2\u6570\u68af\u5ea6\u76f8\u540c\u6765\u786e\u4fdd\u7b97\u6cd5\u7684\u6b63\u786e\u6027\u3002\u6211\u4eec\u5f88\u5bb9\u6613\u60f3\u5230\uff0c\u524d\u8005\u53ef\u4ee5\u5f88\u7b80\u5355\u7684\u901a\u8fc7\u5728\u6784\u5efaDDP\u65f6\u5c06\u6a21\u578b\u6bcd\u672c\u5e7f\u64ad\u5230\u6240\u6709\u8fdb\u7a0b\u6765\u5b9e\u73b0\u3002\u540e\u8005\u5219\u53ef\u4ee5\u901a\u8fc7\u5728\u53cd\u5411\u4f20\u64ad\u4e0e\u4f18\u5316\u5668\u6b65\u8fdb\u4e4b\u95f4\u63d2\u5165\u4e00\u4e2a\u68af\u5ea6\u540c\u6b65\u9636\u6bb5\uff0c\u901a\u8fc7 AllReduce \u805a\u5408\u901a\u4fe1\u6765\u8ba1\u7b97\u6bcf\u4e2a\u53c2\u6570\u7684\u68af\u5ea6\u7684\u5e73\u5747\u503c\u5e76\u5c06\u7ed3\u679c\u540c\u6b65\u7ed9\u6bcf\u4e2a\u8fdb\u7a0b\u4ee5\u5b9e\u73b0\u3002\u4f46\u8fd9\u6837\u4f1a\u5e26\u6765\u4e24\u4e2a\u95ee\u9898\uff1a \u805a\u5408\u901a\u4fe1\u5728\u5c0f\u5f20\u91cf\u4e0a\u7684\u8868\u73b0\u4e0d\u4f73\uff0c\u8fd9\u5728\u5e26\u6709\u5927\u91cf\u5c0f\u53c2\u6570\u7684\u5927\u578b\u6a21\u578b\u4e0a\u5c24\u4e3a\u7a81\u51fa\u3002 \u68af\u5ea6\u7684\u8ba1\u7b97\u4e0e\u540c\u6b65\u88ab\u5206\u4e3a\u4e24\u4e2a\u9636\u6bb5\uff0c\u8fd9\u4f7f\u5f97\u6211\u4eec\u65e0\u6cd5\u901a\u8fc7\u8ba1\u7b97\u901a\u4fe1\u91cd\u53e0\u6765\u63d0\u9ad8\u6a21\u578b\u6548\u7387\u3002 \u68af\u5ea6\u5408\u6876\uff08bucketing gradients\uff09 # \u805a\u5408\u901a\u4fe1\u5728\u5c0f\u5f20\u91cf\u4f20\u8f93\u4e0a\u7684\u8868\u73b0\u6b20\u4f73\uff0c\u4f46\u5b83\u7684\u6027\u80fd\u968f\u7740\u5f20\u91cf\u7684\u5c3a\u5bf8\u589e\u5927\u800c\u63d0\u5347\u3002\u53f3\u56fe\u7684a\u3001b\u5b50\u56fe\u5c55\u793a\u4e86\u4e00\u4e2a60MiB\u5927\u5c0f\u7684 torch.float32 \u53c2\u6570\u76f8\u5bf9\u4e8e\u6bcf\u6b21 AllReduce \u4e0d\u540c\u6570\u91cf\u7684\u53c2\u6570\u7684\u603b\u8fd0\u884c\u65f6\u95f4\u3002\u4e3a\u4e86\u6700\u5927\u5316\u5e26\u5bbd\u5229\u7528\uff0c AllReduce \u64cd\u4f5c\u88ab\u8bbe\u8ba1\u4e3a\u5f02\u6b65\u8c03\u7528\uff0c\u5e76\u5728\u53cd\u5411\u4f20\u64ad\u65f6\u963b\u585e\u3002\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0cDDP\u7b49\u5f85\u8f83\u77ed\u65f6\u95f4\u540e\u5c06\u591a\u4e2a\u68af\u5ea6\u5b58\u50a8\u5230\u4e00\u4e2a\u6876\u91cc\u540e\u6267\u884c\u4e00\u4e2a AllReduce \u64cd\u4f5c\u53ef\u4ee5\u663e\u8457\u964d\u4f4e\u901a\u4fe1\u5ef6\u8fdf\u3002\u53f3\u56fe\u7684c\u3001d\u5b50\u56fe\u5c55\u793a\u4e86\u4e00\u4e2a\u5305\u542b\u5927\u7ea660M\u4e2a\u53c2\u6570\u7684ResNet152\u7f51\u7edc\u7684\u53cd\u5411\u4f20\u64ad\u8ba1\u7b97\u65f6\u95f4\uff0c\u5176\u4e2dx\u8f74\u4ee3\u8868\u5c31\u865a\u7684\u68af\u5ea6\u7684\u6570\u91cf\u3002GPU\u4e0a\u7684\u53cd\u5411\u4f20\u64ad\u5927\u7ea6\u9700\u8981250\u6beb\u79d2\u4ee5\u5b8c\u6210\uff0c\u8fd9\u4e0eNVLink\u4e0a\u7684NCCL\u6570\u91cf\u7ea7\u76f8\u540c\u3002\u8fd9\u4e9b\u5b9e\u9a8c\u8868\u660e\uff0c\u5982\u679c\u53c2\u6570\u6876\u76f8\u5bf9\u5c0f\uff0cDDP\u53ef\u4ee5\u5728\u53cd\u5411\u4f20\u64ad\u7684\u540c\u65f6\u542f\u52a8 AllReduce \u64cd\u4f5c\uff0c\u4f7f\u901a\u4fe1\u4e0e\u8ba1\u7b97\u91cd\u53e0\u3002 \u8ba1\u7b97\u901a\u4fe1\u91cd\u53e0\uff08overlapping computation with communication\uff09 # \u901a\u8fc7\u5408\u6876\uff0cDDP\u4ec5\u9700\u8981\u5728\u542f\u52a8\u901a\u4fe1\u4e4b\u524d\u7b49\u5f85\u6876\u4e2d\u6240\u6709\u7684\u68af\u5ea6\u5b8c\u6210\u8ba1\u7b97\u3002\u6b64\u65f6\uff0c\u5728\u6574\u4e2a\u7f51\u7edc\u5b8c\u6210\u53cd\u5411\u4f20\u64ad\u540e\u518d\u8fdb\u884c AllReduce \u64cd\u4f5c\u4fbf\u4e0d\u518d\u8db3\u591f\uff0c\u800c\u5e94\u8be5\u5728\u6bcf\u4e00\u4e2a\u6876\u5b8c\u6210\u53cd\u5411\u4f20\u64ad\u540e\u90fd\u8fdb\u884c AllReduce \u64cd\u4f5c\u3002DDP\u4e3a\u6bcf\u4e00\u4e2a\u68af\u5ea6\u7d2f\u52a0\u5668\u6ce8\u518c\u4e00\u4e2a\u81ea\u52a8\u6c42\u5bfc\u94a9\u5b50\uff0c\u5e76\u5728\u76f8\u5e94\u7684\u7d2f\u52a0\u5668\u66f4\u65b0\u68af\u5ea6\u540e\u6fc0\u6d3b\u3002\u5f53\u4e00\u4e2a\u6876\u5185\u7684\u6240\u6709\u94a9\u5b50\u90fd\u88ab\u6fc0\u6d3b\u65f6\uff0c\u6700\u540e\u4e00\u4e2a\u88ab\u6fc0\u6d3b\u7684\u94a9\u5b50\u4f1a\u89e6\u53d1 AllReduce \u64cd\u4f5c\u3002 \u8fdb\u7a0b\u7684\u89c4\u7ea6\u987a\u5e8f\u91cd\u8981 \u6240\u6709\u8fdb\u7a0b\u5fc5\u987b\u6309\u7167\u76f8\u540c\u7684\u987a\u5e8f\u8fdb\u884c\u89c4\u7ea6\uff0c\u5426\u5219 AllReduce \u7684\u7ed3\u679c\u53ef\u80fd\u4e0d\u5339\u914d\u3002\u5982\u4e0a\u56fe\u7684a\u5b50\u56fe\u6240\u793a\uff0c\u8fdb\u7a0b2\u7684g2\u53c2\u6570\u5728\u6700\u540e\u88ab\u8ba1\u7b97\u51fa\uff0c\u4f7f\u5f97g1&2\u53c2\u6570\u6876\u5728g3&4\u53c2\u6570\u6876\u540e\u89c4\u7ea6\uff0c\u5bfc\u81f4\u4e24\u4e2a\u8fdb\u7a0b\u7684 AllReduce \u9519\u4f4d\u3002\u56e0\u6b64\uff0c\u6240\u6709\u8fdb\u7a0b\u90fd\u4f7f\u7528\u76f8\u540c\u7684\u5b58\u50a8\u987a\u5e8f\uff0c\u5e76\u4e14i\u53f7\u6876\u542f\u52a8AllReduce\u4e4b\u524di+1\u53f7\u6876\u65e0\u6cd5\u542f\u52a8\u89c4\u7ea6\u3002\u5728PyTorch 1.6\u4e2d\uff0c model.parameters() \u7684\u76f8\u53cd\u987a\u5e8f\u88ab\u7528\u4f5c\u53c2\u6570\u6876\u987a\u5e8f\u3002\u5047\u8bbe\u5c42\u4ee5\u4e0e\u524d\u5411\u4f20\u64ad\u4e2d\u76f8\u8fd1\u7684\u987a\u5e8f\u88ab\u6ce8\u518c\uff0c\u90a3\u4e48\u5b83\u7684\u53cd\u5411\u4e5f\u5373\u662f\u53cd\u5411\u4f20\u64ad\u4e2d\u68af\u5ea6\u7684\u8ba1\u7b97\u987a\u5e8f\u3002 \u6bcf\u4e00\u4e2a\u8fed\u4ee3\u4e2d\u53c2\u4e0e\u8bad\u7ec3\u7684\u7f51\u7edc\u53ef\u80fd\u4e0d\u540c \u4e00\u4e2a\u8fed\u4ee3\u53ef\u80fd\u53ea\u8bad\u7ec3\u4e00\u4e2a\u6a21\u578b\u7684\u5b50\u56fe\uff08\u6bd4\u5982\u9884\u70ed\u65f6\u6211\u4eec\u5e38\u5e38\u56fa\u5b9abackbone\uff09\uff0c\u5e76\u4e14\u8be5\u5b50\u56fe\u4e5f\u53ef\u80fd\u968f\u7740\u8fed\u4ee3\u800c\u53d1\u751f\u53d8\u5316\u3002\u8fd9\u610f\u5473\u7740\u67d0\u4e9b\u68af\u5ea6\u5728\u67d0\u4e9b\u8fed\u4ee3\u4e2d\u53ef\u80fd\u88ab\u8df3\u8fc7\u3002\u4f46\u662f\uff0c\u68af\u5ea6\u5230\u6876\u7684\u6620\u5c04\u662f\u5728\u6784\u5efa\u65f6\u5373\u88ab\u5efa\u7acb\u7684\u3002\u8fd9\u4f7f\u5f97\u88ab\u8df3\u8fc7\u7684\u68af\u5ea6\u5c06\u8ba9\u67d0\u4e9b\u6876\u6c38\u8fdc\u65e0\u6cd5\u51c6\u5907\uff0c\u4ece\u800c\u963b\u585e\u53cd\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002\u5982\u4e0a\u56fe\u7684b\u5b50\u56fe\u6240\u793a\uff0cg3\u53c2\u6570\u5728\u67d0\u6b21\u8fed\u4ee3\u4e2d\u88ab\u8df3\u8fc7\uff0c\u56e0\u6b64g3&4\u53c2\u6570\u6876\u65e0\u6cd5\u51c6\u5907\u3002\u4e3a\u4e86\u89e3\u51b3\u6b64\u95ee\u9898\uff0cDDP\u904d\u5386\u4ece\u524d\u5411\u4f20\u64ad\u7684\u8f93\u51fa\u5f20\u91cf\u5f97\u5230\u7684\u81ea\u52a8\u6c42\u5bfc\u56fe\u6765\u627e\u5230\u6240\u6709\u7684\u53c2\u4e0e\u53c2\u6570\uff0c\u7136\u540e\u5c06\u672a\u53c2\u4e0e\u7684\u53c2\u6570\u76f4\u63a5\u6807\u8bb0\u4e3a\u5c31\u7eea\u3002 \u68af\u5ea6\u540c\u6b65\u8df3\u8fc7\uff08skipping gradient synchronization\uff09 # \u5e76\u884c\u8bad\u7ec3\u7684\u6700\u5927\u5ef6\u8fdf\u6765\u6e90\u662f\u540c\u6b65\u3002\u90a3\u4e48\uff0c\u6211\u4eec\u4e00\u5b9a\u8981\u6bcf\u4e2a\u8fed\u4ee3\u90fd\u6267\u884c\u540c\u6b65\u4e48\uff1f\u7b54\u6848\u81ea\u7136\u662f\u5426\u5b9a\u7684\u3002\u5728\u5c40\u90e8\u6267\u884cn\u6b21\u8bad\u7ec3\u8fed\u4ee3\u4e4b\u540e\u518d\u6267\u884c\u4e00\u6b21 AllReduce \u53ef\u4ee5\u5728\u5f88\u5927\u7a0b\u5ea6\u4e0a\u51cf\u5c11\u68af\u5ea6\u540c\u6b65\u3002\u8fd9\u540c\u65f6\u6709\u52a9\u4e8e\u8bad\u7ec3\u4e00\u4e2a\u8d85\u5927\u7684\uff0c\u65e0\u6cd5\u4e00\u6b21\u6027\u653e\u5165\u663e\u5b58\u7684\u8f93\u5165\u6279\u2013\u6211\u4eec\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u6279\u5212\u5206\u6210\u51e0\u4e2a\u5c0f\u6279\uff0c\u7136\u540e\u5728\u8fd9\u4e9b\u5c0f\u6279\u4e0a\u8fdb\u884c\u524d\u5411\u4e0e\u53cd\u5411\u4f20\u64ad\uff0c\u518d\u5f53\u6574\u4e2a\u6279\u8bad\u7ec3\u5b8c\u6210\u4e4b\u540e\u53d1\u8d77\u68af\u5ea6\u540c\u6b65\u3002 \u7406\u8bba\u4e0a\u6765\u8bf4\uff0c\u68af\u5ea6\u540c\u6b65\u8df3\u8fc7\u7684\u8ba1\u7b97\u7ed3\u679c\u4e0e\u4e0d\u8df3\u8fc7\u7684\u7ed3\u679c\u662f\u76f8\u540c\u7684\uff0c\u56e0\u4e3a\u68af\u5ea6\u53ea\u662f\u5355\u7eaf\u7684\u88ab\u7d2f\u52a0\u5230\u4e86\u540c\u4e00\u4e2a\u5f20\u91cf\u4e0a\u3002\u4f46\u4e0a\u4e00\u8282\u63d0\u5230\uff0c\u6bcf\u4e00\u4e2a\u8fed\u4ee3\u4e2d\u53c2\u4e0e\u8bad\u7ec3\u7684\u7f51\u7edc\u53ef\u80fd\u4e0d\u540c\uff0c\u68af\u5ea6\u540c\u6b65\u8df3\u8fc7\u4e0e\u4e4b\u524d\u63d0\u5230\u7684\u63aa\u65bd\u76f8\u51b2\u7a81\u3002\u6b64\u5916\uff0cDDP\u4e5f\u65e0\u6cd5\u77e5\u9053\u63a5\u4e0b\u6765\u7684\u53cd\u5411\u4f20\u64ad\u5e94\u5f53\u8fdb\u884c\u68af\u5ea6\u7d2f\u52a0\u8fd8\u662f\u540c\u6b65\uff0c\u56e0\u6b64PyTorch\u4f7f\u7528 ddp.no_sync() \u4ee5\u4f5c\u4e3a\u7d2f\u52a0\u7684\u6807\u8bc6\u3002","title":"PyTorch\u5206\u5e03\u5f0f"},{"location":"document/torch.distributed/#_1","text":"\u5728\u5f00\u59cb\u6b63\u6587\u4e4b\u524d\u6211\u4eec\u5148\u7b80\u8981\u56de\u987e\u4e00\u4e0bPyTorch\u7684\u5386\u53f2\u3002","title":"\u5386\u53f2"},{"location":"document/torch.distributed/#pytorch","text":"PyTorch\u5c06\u6570\u636e\u7ec4\u7ec7\u4e3a\u5f20\u91cf\uff08\u4e5f\u5c31\u662f\u4e00\u4e2an\u7ef4\u6570\u7ec4\uff09\uff1b\u800c\u6a21\u5757\u5b9a\u4e49\u4e86\u5c06\u8f93\u5165\u5230\u8f93\u51fa\u7684\u8f6c\u6362\uff0c\u5176\u4e2d\u6a21\u5757\u7684\u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u5728\u4ed6\u7684\u6210\u5458\u51fd\u6570 forward \u4e2d\u5b9a\u4e49\u3002\u4e00\u4e2a\u5e94\u7528\u7531\u4ed6\u7684\u6a21\u5757\u901a\u8fc7\u5728 forward \u51fd\u6570\u4e2d\u5b9a\u4e49\u7684\u591a\u4e2a\u539f\u751f\u6a21\u5757\uff08 nn.Linear \u3001 nn.Conv2d \uff09\u3001\u7528\u6237\u81ea\u5b9a\u4e49\u7684\u6a21\u5757\uff08 backbone \u3001 neck \u3001 head \uff09\u548c\u51fd\u6570\uff08 nn.ReLU \uff09\u7684\u7ec4\u5408\u800c\u6784\u6210\u3002\u5178\u578b\u7684\u8bad\u7ec3\u8fed\u4ee3\u5305\u62ec\u4f7f\u7528\u8f93\u5165\u548c\u6807\u7b7e\u4ea7\u751f\u635f\u5931\u7684\u524d\u5411\u4f20\u64ad\uff0c\u8ba1\u7b97\u53c2\u6570\u7684\u68af\u5ea6\u7684\u53cd\u5411\u4f20\u64ad\u4ee5\u53ca\u4f7f\u7528\u68af\u5ea6\u66f4\u65b0\u53c2\u6570\u7684\u4f18\u5316\u5668\u6b65\u8fdb\u3002\u66f4\u5177\u4f53\u5730\u8bf4\uff0c\u5728\u524d\u5411\u4f20\u64ad\u4e2dPyTorch\u4f1a\u6784\u5efa\u4e00\u4e2a\u81ea\u52a8\u68af\u5ea6\u56fe\u6765\u8bb0\u5f55\u6240\u6267\u884c\u7684\u52a8\u4f5c\u3002\u7136\u540e\u5728\u53cd\u5411\u4f20\u64ad\u4e2d\uff0c\u5b83\u4f7f\u7528\u81ea\u52a8\u68af\u5ea6\u56fe\u8fdb\u884c\u53cd\u5411\u4f20\u64ad\u4ee5\u751f\u6210\u68af\u5ea6\u3002\u6700\u540e\uff0c\u4f18\u5316\u5668\u5c06\u68af\u5ea6\u5e94\u7528\u4e8e\u66f4\u65b0\u53c2\u6570\u3002\u8bad\u7ec3\u53cd\u590d\u91cd\u590d\u8fd9\u4e09\u4e2a\u6b65\u9aa4\u76f4\u5230\u6a21\u578b\u6536\u655b\u3002","title":"PyTorch"},{"location":"document/torch.distributed/#pytorch_1","text":"\u968f\u7740\u8bad\u7ec3\u6570\u636e\u7684\u589e\u5e7f\u4ee5\u53ca\u6a21\u578b\u89c4\u6a21\u7684\u6269\u5927\uff0c\u5206\u5e03\u5f0f\u8bad\u7ec3\u7684\u91cd\u8981\u6027\u4e5f\u8d8a\u6765\u8d8a\u5f3a\u3002PyTorch\u9996\u5148\u5728 multiprocessing \u7684\u57fa\u7840\u4e0a\u63d0\u51fa\u4e86 torch.multiprocessing \uff0c\u4f46\u7531\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u9650\u5236\u800c\u5e26\u6765\u4e86\u79cd\u79cd\u5c40\u9650\uff08\u5982CUDA API\u8981\u6c42\u5bfc\u51fa\u5230\u5176\u4ed6\u8fdb\u7a0b\u7684\u5206\u914d\u5728\u4ecd\u88ab\u4f7f\u7528\u65f6\u4fdd\u6301\u6709\u6548\uff09\u3002\u968f\u540e\uff0cPyTorch\u57280.1\u4e2d\u63d0\u51fa\u4e86\u6539\u8fdb\u7684 nn.DataParallel \uff0c\u5b83\u4f7f\u7528\u5355\u8fdb\u7a0b\u591a\u7ebf\u7a0b\u7684\u65b9\u5f0f\uff0c\u5728\u6bcf\u6b21\u524d\u5411\u8fc7\u7a0b\u4e2d\u901a\u8fc7 scatter \u5c06\u6570\u636e\u5206\u914d\u7ed9GPUs\uff0c\u8c03\u7528 replica \u51fd\u6570\u5728\u5404\u4e2aGPU\u4e0a\u521b\u5efa\u6a21\u578b\u7684\u526f\u672c\uff0c\u7136\u540e\u4f7f\u7528 parallel_apply \u5728\u5404\u4e2aGPU\u4e0a\u5b8c\u6210\u524d\u5411\u4f20\u64ad\uff0c\u5e76\u901a\u8fc7 gather \u5c06\u6240\u6709\u8f93\u51fa\u805a\u96c6\u5230\u9996\u5f20GPU\u4e0a\u5f97\u5230\u635f\u5931\uff0c\u63a5\u7740\u635f\u5931\u88ab scatter \u5230GPUs\u4e0a\u8fdb\u884c\u53cd\u5411\u4f20\u64ad\u5f97\u5230\u68af\u5ea6\uff0c\u6700\u540e\u68af\u5ea6\u88ab all_reduce \u5230GPU0\u4e0a\u66f4\u65b0\u6743\u91cd\u3002\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u8fd9\u79cd\u65b9\u5f0f\u4f1a\u5bf9GPU0\u4ea7\u751f\u5de8\u5927\u7684\u538b\u529b\uff0c\u800c\u5355\u8fdb\u7a0b\u591a\u7ebf\u7a0b\u7684\u65b9\u5f0f\u4e5f\u4e0d\u5141\u8bb8\u5728\u591a\u53f0\u673a\u5668\u4e0a\u5206\u5e03\u5f0f\u7684\u8bad\u7ec3\u3002\u968f\u540e\uff0cPyTorch\u57280.3.0\u4e2d\u5f15\u5165\u4e86 nn.DistributedDataParallel \u4ee5\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\uff0c\u5e76\u57281.0\u4e2d\u5f15\u5165\u4e86c10d\u6a21\u5757\u6765\u66ff\u4ee3\u4f20\u7edf\u7684THD\u4ee5\u5927\u5e45\u63d0\u5347\u901a\u4fe1\u6548\u7387\u3002\u4f46\u968f\u7740\u6a21\u578b\u7684\u589e\u5927\uff0c\u5355\u53f0\u673a\u5668\u5df2\u7ecf\u4e0d\u80fd\u5bb9\u4e0b\u6574\u4e2a\u6a21\u578b\uff0c\u800c\u4e14 nn.DistributedDataParallel \u5e76\u4e0d\u9002\u5408\u53c2\u6570\u670d\u52a1\u5668\uff0cPyTorch\u53c8\u57281.3\u4e2d\u5f15\u5165\u4e86 distributed.rpc \u6765\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002","title":"PyTorch\u5e76\u884c\u8bad\u7ec3"},{"location":"document/torch.distributed/#_2","text":"\u5bf9\u4e8e\u73b0\u884c\u7248\u672c\uff0c torch.distributed \u7531\u4ee5\u4e0b\u4e09\u4e2a\u91cd\u8981\u7ec4\u6210\u90e8\u5206\u6784\u6210\u3002 \u5206\u5e03\u5f0f\u6570\u636e\u5e76\u884c - Distributed Data-Parallel (DDP) DDP\u662f\u6700\u5e38\u89c1\u7684\u591aGPU\u8bad\u7ec3\u8303\u5f0f\uff0c\u5b83\u652f\u6301\u591a\u673a\u591a\u5361\u8bad\u7ec3\uff0c\u5e76\u5141\u8bb8\u5c06\u6a21\u578b\u5206\u5e03\u5728\u540c\u4e00\u4e3b\u673a\u7684\u591a\u5f20\u663e\u5361\u4e2d\u3002 \u8fdc\u7a0b\u8fc7\u7a0b\u8c03\u7528 - RPC-Based Distributed (RPC) RPC\u65e8\u5728\u652f\u6301\u4e0d\u9002\u7528\u4e8e\u6570\u636e\u5e76\u884c\u8bad\u7ec3\u7684\u5e38\u89c4\u8bad\u7ec3\u7ed3\u6784\uff0c\u4f8b\u5982\u5206\u5e03\u5f0f\u7ba1\u9053\u5e76\u884c\uff08\u6a21\u578b\u5206\u5e03\u4e8e\u591a\u53f0\u4e3b\u673a\u4e0a\uff09\uff0c\u53c2\u6570\u670d\u52a1\u5668\u8303\u5f0f\uff08\u6a21\u578b\u53c2\u6570\u4e0e\u8bad\u7ec3\u5668\u4f4d\u4e8e\u4e0d\u540c\u673a\u5668\u4e0a\uff09\u4ee5\u53caDDP\u4e0e\u5176\u4ed6\u8bad\u7ec3\u8303\u5f0f\u7684\u7ec4\u5408\u3002 \u805a\u5408\u901a\u4fe1 - Collective Communication (c10d) C10d\u5e93\u652f\u6301\u7ec4\u5185\u8fdb\u7a0b\u95f4\u7684\u5f20\u91cf\u53d1\u9001\u3002\u4ed6\u63d0\u4f9b\u805a\u5408\u901a\u4fe1API\uff08\u5982 all_reduce \u548c all_gather \uff09\u4ee5\u53caP2P\u901a\u4fe1API\uff08\u5982 send \u548c isend \uff09\u3002DDP\u548cRPC\uff08\u8fdb\u7a0b\u7ec4\u540e\u7aef\uff09\u5728v1.6.0\u4e2d\u90fd\u57fa\u4e8ec10d\uff0c\u5176\u4e2d\u524d\u8005\u4f7f\u7528\u805a\u5408\u901a\u4fe1\uff0c\u800c\u540e\u8005\u4f7f\u7528P2P\u901a\u4fe1\u3002C10d\u662f\u4e00\u4e2a\u4f4e\u7ea7\u7684\u901a\u4fe1API\uff0c\u4ec5\u5bf9\u540e\u7aef\u7684\u539f\u8bed\u8fdb\u884c\u5c01\u88c5\uff0c\u800c\u5728\u6b64\u57fa\u7840\u4e0a\u7684DDP\u548cRPC\u80fd\u6ee1\u8db3\u5927\u591a\u6570\u5206\u5e03\u5f0f\u8bad\u7ec3\u65b9\u6848\u7684\u9700\u6c42\uff0c\u56e0\u6b64\u5f00\u53d1\u4eba\u5458\u901a\u5e38\u65e0\u9700\u4f7f\u7528\u8fd9\u4e2aAPI\u3002\u4e8b\u5b9e\u4e0a\uff0c\u76f4\u63a5\u8c03\u7528\u8fd9\u4e2aAPI\u4e5f\u662f\u88ab\u4e0d\u5efa\u8bae\u7684\uff0c\u56e0\u4e3a\u624b\u52a8\u8c03\u7528\u6b64API\u8fdb\u884c\u901a\u4fe1\u548c\u8ba1\u7b97\u5c06\u65e0\u6cd5\u5e94\u7528\u5230DDP\u548cRPC\u7684\u6027\u80fd\u4f18\u5316\u3002\u4f46\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u6b64API\u4ecd\u7136\u5f88\u6709\u5e2e\u52a9\u3002\u4e00\u4e2a\u793a\u4f8b\u662f\u5206\u5e03\u5f0f\u53c2\u6570\u5e73\u5747\uff0c\u5176\u4e2d\u5e94\u7528\u7a0b\u5e8f\u5e0c\u671b\u5728\u53cd\u5411\u4f20\u64ad\u4e4b\u540e\u8ba1\u7b97\u6240\u6709\u6a21\u578b\u53c2\u6570\u7684\u5e73\u5747\u503c\uff0c\u800c\u4e0d\u662f\u4f7f\u7528DDP\u6765\u4f20\u9012\u68af\u5ea6\u3002\u8fd9\u53ef\u4ee5\u4f7f\u901a\u4fe1\u4e0e\u8ba1\u7b97\u8131\u94a9\uff0c\u5e76\u5141\u8bb8\u5bf9\u901a\u4fe1\u5185\u5bb9\u8fdb\u884c\u66f4\u7ec6\u7c92\u5ea6\u7684\u63a7\u5236\u3002 \u4f7f\u7528PyTorch\u7f16\u5199\u5206\u5e03\u5f0f\u5e94\u7528\u7a0b\u5e8f \u63d0\u4f9b\u4e86\u4f7f\u7528c10d API\u901a\u4fe1\u7684\u793a\u4f8b\u3002","title":"\u7ed3\u6784"},{"location":"document/torch.distributed/#ddp","text":"DDP\u5728\u6bcf\u4e2a\u8ba1\u7b97\u8d44\u6e90\uff08GPU\uff09\u4e0a\u521b\u5efa\u6a21\u578b\u526f\u672c\u6765\u72ec\u7acb\u7684\u751f\u6210\u68af\u5ea6\uff0c\u7136\u540e\u5728\u6bcf\u4e2a\u8fed\u4ee3\u4e2d\u4ea4\u6d41\u8fd9\u4e9b\u68af\u5ea6\u4f7f\u5f97\u6a21\u578b\u526f\u672c\u4e00\u81f4\u3002PyTorch\u4f7f\u7528\u4e86\u591a\u79cd\u6280\u672f\u6765\u52a0\u901f\u5e76\u884c\u8fd0\u7b97\uff0c\u5305\u62ec\u68af\u5ea6\u5408\u6876\uff08bucketing gradients\uff09\u3001\u8ba1\u7b97\u901a\u4fe1\u91cd\u53e0\uff08overlapping computation with communication\uff09\u4ee5\u53ca\u68af\u5ea6\u540c\u6b65\u8df3\u8fc7\uff08skipping gradient synchronization\uff09\u3002\u8bc4\u4f30\u8868\u660e\uff0cPyTorch\u53ef\u4ee5\u5728256\u4e2aGPU\u4e0a\u8fbe\u5230\u63a5\u8fd1\u7ebf\u6027\u7684\u53ef\u6269\u5c55\u6027\u3002 DDP\u7684\u6bcf\u4e00\u4e2a\u8fdb\u7a0b\u90fd\u5bf9\u5e94\u4e00\u4e2a\u72ec\u7acb\u7684\u8bad\u7ec3\u8fc7\u7a0b\uff0c\u5b83\u62e5\u6709\u81ea\u5df1\u7684\u6a21\u578b\u526f\u672c\uff0c\u81ea\u5df1\u7684\u4f18\u5316\u5668\uff0c\u5f53\u7136\u4e5f\u63a7\u5236\u4e00\u5f20GPU\u3002DDP\u901a\u8fc7\u786e\u4fdd\u4ee5\u4e0b\u4e24\u70b9\u6765\u786e\u4fdd\u7b97\u6cd5\u7684\u6b63\u786e\u6027\uff08\u5373\u5176\u8bad\u7ec3\u7ed3\u679c\u4e0e\u5355\u5361\u8bad\u7ec3\u7ed3\u679c\u4e00\u81f4\uff09\u3002 \u6240\u6709\u6a21\u578b\u526f\u672c\u7684\u521d\u59cb\u72b6\u6001\u76f8\u540c \u6240\u6709\u4f18\u5316\u5668\u6bcf\u6b21\u6b65\u8fdb\u4f7f\u7528\u7684\u53c2\u6570\u68af\u5ea6\u76f8\u540c DDP\u7684\u7ed3\u6784\u5982\u53f3\u56fe\u6240\u793a\uff0c\u5b83\u4e3b\u8981\u5305\u62ec\u4e86Python API\u548cC++\u7684\u68af\u5ea6\u4e0b\u964d\u7b97\u6cd5\u3002\u6240\u6709\u7684\u901a\u4fe1\u901a\u8fc7c10d\u8c03\u7528\u5e95\u5c42\u901a\u4fe1\u6846\u67b6\u3002 DDP\u7684API\u4e0eDP\u7c7b\u4f3c\uff0c\u5747\u662f\u4e00\u4e2a\u6a21\u7ec4\u3002\u5728\u672c\u6587\u4e2d\uff0c\u6211\u4eec\u5c06\u5ffd\u7565\u63a5\u53e3\u7684\u8bbe\u8ba1\u800c\u5173\u6ce8\u5e95\u5c42\u7684\u8fd0\u7b97\u6d41\u7a0b\u3002\u5982\u679c\u4f60\u5bf9\u5176\u611f\u5174\u8da3\uff0c\u6211\u4eec\u9f13\u52b1\u4f60\u9605\u8bfb PyTorch Distributed: Experiences on Accelerating Data Parallel Training \u7684\u7b2c3.1\u8282\u4ee5\u83b7\u5f97\u66f4\u591a\u7ec6\u8282\u3002","title":"\u5206\u5e03\u5f0f\u6570\u636e\u5e76\u884c\uff08DDP\uff09"},{"location":"document/torch.distributed/#_3","text":"DDP\u7684\u68af\u5ea6\u89c4\u7ea6\u4e00\u76f4\u5728\u8fdb\u5316\uff0c\u8ba9\u6211\u4eec\u4ece\u4e00\u4e2a\u7b80\u5355\u7684\u7b97\u6cd5\u5f00\u59cb\u5e76\u9010\u6b65\u7406\u89e3\u73b0\u884c\u7248\u672c\u4e2d\u7684\u7b97\u6cd5\u3002 \u56de\u987e\u6211\u4eec\u4e4b\u524d\u63d0\u5230\u7684\uff0cDDP\u901a\u8fc7\u786e\u4fdd\u6240\u6709\u6a21\u578b\u526f\u672c\u7684\u521d\u59cb\u72b6\u6001\u76f8\u540c\u548c\u6240\u6709\u4f18\u5316\u5668\u6bcf\u6b21\u6b65\u8fdb\u4f7f\u7528\u7684\u53c2\u6570\u68af\u5ea6\u76f8\u540c\u6765\u786e\u4fdd\u7b97\u6cd5\u7684\u6b63\u786e\u6027\u3002\u6211\u4eec\u5f88\u5bb9\u6613\u60f3\u5230\uff0c\u524d\u8005\u53ef\u4ee5\u5f88\u7b80\u5355\u7684\u901a\u8fc7\u5728\u6784\u5efaDDP\u65f6\u5c06\u6a21\u578b\u6bcd\u672c\u5e7f\u64ad\u5230\u6240\u6709\u8fdb\u7a0b\u6765\u5b9e\u73b0\u3002\u540e\u8005\u5219\u53ef\u4ee5\u901a\u8fc7\u5728\u53cd\u5411\u4f20\u64ad\u4e0e\u4f18\u5316\u5668\u6b65\u8fdb\u4e4b\u95f4\u63d2\u5165\u4e00\u4e2a\u68af\u5ea6\u540c\u6b65\u9636\u6bb5\uff0c\u901a\u8fc7 AllReduce \u805a\u5408\u901a\u4fe1\u6765\u8ba1\u7b97\u6bcf\u4e2a\u53c2\u6570\u7684\u68af\u5ea6\u7684\u5e73\u5747\u503c\u5e76\u5c06\u7ed3\u679c\u540c\u6b65\u7ed9\u6bcf\u4e2a\u8fdb\u7a0b\u4ee5\u5b9e\u73b0\u3002\u4f46\u8fd9\u6837\u4f1a\u5e26\u6765\u4e24\u4e2a\u95ee\u9898\uff1a \u805a\u5408\u901a\u4fe1\u5728\u5c0f\u5f20\u91cf\u4e0a\u7684\u8868\u73b0\u4e0d\u4f73\uff0c\u8fd9\u5728\u5e26\u6709\u5927\u91cf\u5c0f\u53c2\u6570\u7684\u5927\u578b\u6a21\u578b\u4e0a\u5c24\u4e3a\u7a81\u51fa\u3002 \u68af\u5ea6\u7684\u8ba1\u7b97\u4e0e\u540c\u6b65\u88ab\u5206\u4e3a\u4e24\u4e2a\u9636\u6bb5\uff0c\u8fd9\u4f7f\u5f97\u6211\u4eec\u65e0\u6cd5\u901a\u8fc7\u8ba1\u7b97\u901a\u4fe1\u91cd\u53e0\u6765\u63d0\u9ad8\u6a21\u578b\u6548\u7387\u3002","title":"\u68af\u5ea6\u89c4\u7ea6"},{"location":"document/torch.distributed/#bucketing-gradients","text":"\u805a\u5408\u901a\u4fe1\u5728\u5c0f\u5f20\u91cf\u4f20\u8f93\u4e0a\u7684\u8868\u73b0\u6b20\u4f73\uff0c\u4f46\u5b83\u7684\u6027\u80fd\u968f\u7740\u5f20\u91cf\u7684\u5c3a\u5bf8\u589e\u5927\u800c\u63d0\u5347\u3002\u53f3\u56fe\u7684a\u3001b\u5b50\u56fe\u5c55\u793a\u4e86\u4e00\u4e2a60MiB\u5927\u5c0f\u7684 torch.float32 \u53c2\u6570\u76f8\u5bf9\u4e8e\u6bcf\u6b21 AllReduce \u4e0d\u540c\u6570\u91cf\u7684\u53c2\u6570\u7684\u603b\u8fd0\u884c\u65f6\u95f4\u3002\u4e3a\u4e86\u6700\u5927\u5316\u5e26\u5bbd\u5229\u7528\uff0c AllReduce \u64cd\u4f5c\u88ab\u8bbe\u8ba1\u4e3a\u5f02\u6b65\u8c03\u7528\uff0c\u5e76\u5728\u53cd\u5411\u4f20\u64ad\u65f6\u963b\u585e\u3002\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0cDDP\u7b49\u5f85\u8f83\u77ed\u65f6\u95f4\u540e\u5c06\u591a\u4e2a\u68af\u5ea6\u5b58\u50a8\u5230\u4e00\u4e2a\u6876\u91cc\u540e\u6267\u884c\u4e00\u4e2a AllReduce \u64cd\u4f5c\u53ef\u4ee5\u663e\u8457\u964d\u4f4e\u901a\u4fe1\u5ef6\u8fdf\u3002\u53f3\u56fe\u7684c\u3001d\u5b50\u56fe\u5c55\u793a\u4e86\u4e00\u4e2a\u5305\u542b\u5927\u7ea660M\u4e2a\u53c2\u6570\u7684ResNet152\u7f51\u7edc\u7684\u53cd\u5411\u4f20\u64ad\u8ba1\u7b97\u65f6\u95f4\uff0c\u5176\u4e2dx\u8f74\u4ee3\u8868\u5c31\u865a\u7684\u68af\u5ea6\u7684\u6570\u91cf\u3002GPU\u4e0a\u7684\u53cd\u5411\u4f20\u64ad\u5927\u7ea6\u9700\u8981250\u6beb\u79d2\u4ee5\u5b8c\u6210\uff0c\u8fd9\u4e0eNVLink\u4e0a\u7684NCCL\u6570\u91cf\u7ea7\u76f8\u540c\u3002\u8fd9\u4e9b\u5b9e\u9a8c\u8868\u660e\uff0c\u5982\u679c\u53c2\u6570\u6876\u76f8\u5bf9\u5c0f\uff0cDDP\u53ef\u4ee5\u5728\u53cd\u5411\u4f20\u64ad\u7684\u540c\u65f6\u542f\u52a8 AllReduce \u64cd\u4f5c\uff0c\u4f7f\u901a\u4fe1\u4e0e\u8ba1\u7b97\u91cd\u53e0\u3002","title":"\u68af\u5ea6\u5408\u6876\uff08bucketing gradients\uff09"},{"location":"document/torch.distributed/#overlapping-computation-with-communication","text":"\u901a\u8fc7\u5408\u6876\uff0cDDP\u4ec5\u9700\u8981\u5728\u542f\u52a8\u901a\u4fe1\u4e4b\u524d\u7b49\u5f85\u6876\u4e2d\u6240\u6709\u7684\u68af\u5ea6\u5b8c\u6210\u8ba1\u7b97\u3002\u6b64\u65f6\uff0c\u5728\u6574\u4e2a\u7f51\u7edc\u5b8c\u6210\u53cd\u5411\u4f20\u64ad\u540e\u518d\u8fdb\u884c AllReduce \u64cd\u4f5c\u4fbf\u4e0d\u518d\u8db3\u591f\uff0c\u800c\u5e94\u8be5\u5728\u6bcf\u4e00\u4e2a\u6876\u5b8c\u6210\u53cd\u5411\u4f20\u64ad\u540e\u90fd\u8fdb\u884c AllReduce \u64cd\u4f5c\u3002DDP\u4e3a\u6bcf\u4e00\u4e2a\u68af\u5ea6\u7d2f\u52a0\u5668\u6ce8\u518c\u4e00\u4e2a\u81ea\u52a8\u6c42\u5bfc\u94a9\u5b50\uff0c\u5e76\u5728\u76f8\u5e94\u7684\u7d2f\u52a0\u5668\u66f4\u65b0\u68af\u5ea6\u540e\u6fc0\u6d3b\u3002\u5f53\u4e00\u4e2a\u6876\u5185\u7684\u6240\u6709\u94a9\u5b50\u90fd\u88ab\u6fc0\u6d3b\u65f6\uff0c\u6700\u540e\u4e00\u4e2a\u88ab\u6fc0\u6d3b\u7684\u94a9\u5b50\u4f1a\u89e6\u53d1 AllReduce \u64cd\u4f5c\u3002 \u8fdb\u7a0b\u7684\u89c4\u7ea6\u987a\u5e8f\u91cd\u8981 \u6240\u6709\u8fdb\u7a0b\u5fc5\u987b\u6309\u7167\u76f8\u540c\u7684\u987a\u5e8f\u8fdb\u884c\u89c4\u7ea6\uff0c\u5426\u5219 AllReduce \u7684\u7ed3\u679c\u53ef\u80fd\u4e0d\u5339\u914d\u3002\u5982\u4e0a\u56fe\u7684a\u5b50\u56fe\u6240\u793a\uff0c\u8fdb\u7a0b2\u7684g2\u53c2\u6570\u5728\u6700\u540e\u88ab\u8ba1\u7b97\u51fa\uff0c\u4f7f\u5f97g1&2\u53c2\u6570\u6876\u5728g3&4\u53c2\u6570\u6876\u540e\u89c4\u7ea6\uff0c\u5bfc\u81f4\u4e24\u4e2a\u8fdb\u7a0b\u7684 AllReduce \u9519\u4f4d\u3002\u56e0\u6b64\uff0c\u6240\u6709\u8fdb\u7a0b\u90fd\u4f7f\u7528\u76f8\u540c\u7684\u5b58\u50a8\u987a\u5e8f\uff0c\u5e76\u4e14i\u53f7\u6876\u542f\u52a8AllReduce\u4e4b\u524di+1\u53f7\u6876\u65e0\u6cd5\u542f\u52a8\u89c4\u7ea6\u3002\u5728PyTorch 1.6\u4e2d\uff0c model.parameters() \u7684\u76f8\u53cd\u987a\u5e8f\u88ab\u7528\u4f5c\u53c2\u6570\u6876\u987a\u5e8f\u3002\u5047\u8bbe\u5c42\u4ee5\u4e0e\u524d\u5411\u4f20\u64ad\u4e2d\u76f8\u8fd1\u7684\u987a\u5e8f\u88ab\u6ce8\u518c\uff0c\u90a3\u4e48\u5b83\u7684\u53cd\u5411\u4e5f\u5373\u662f\u53cd\u5411\u4f20\u64ad\u4e2d\u68af\u5ea6\u7684\u8ba1\u7b97\u987a\u5e8f\u3002 \u6bcf\u4e00\u4e2a\u8fed\u4ee3\u4e2d\u53c2\u4e0e\u8bad\u7ec3\u7684\u7f51\u7edc\u53ef\u80fd\u4e0d\u540c \u4e00\u4e2a\u8fed\u4ee3\u53ef\u80fd\u53ea\u8bad\u7ec3\u4e00\u4e2a\u6a21\u578b\u7684\u5b50\u56fe\uff08\u6bd4\u5982\u9884\u70ed\u65f6\u6211\u4eec\u5e38\u5e38\u56fa\u5b9abackbone\uff09\uff0c\u5e76\u4e14\u8be5\u5b50\u56fe\u4e5f\u53ef\u80fd\u968f\u7740\u8fed\u4ee3\u800c\u53d1\u751f\u53d8\u5316\u3002\u8fd9\u610f\u5473\u7740\u67d0\u4e9b\u68af\u5ea6\u5728\u67d0\u4e9b\u8fed\u4ee3\u4e2d\u53ef\u80fd\u88ab\u8df3\u8fc7\u3002\u4f46\u662f\uff0c\u68af\u5ea6\u5230\u6876\u7684\u6620\u5c04\u662f\u5728\u6784\u5efa\u65f6\u5373\u88ab\u5efa\u7acb\u7684\u3002\u8fd9\u4f7f\u5f97\u88ab\u8df3\u8fc7\u7684\u68af\u5ea6\u5c06\u8ba9\u67d0\u4e9b\u6876\u6c38\u8fdc\u65e0\u6cd5\u51c6\u5907\uff0c\u4ece\u800c\u963b\u585e\u53cd\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002\u5982\u4e0a\u56fe\u7684b\u5b50\u56fe\u6240\u793a\uff0cg3\u53c2\u6570\u5728\u67d0\u6b21\u8fed\u4ee3\u4e2d\u88ab\u8df3\u8fc7\uff0c\u56e0\u6b64g3&4\u53c2\u6570\u6876\u65e0\u6cd5\u51c6\u5907\u3002\u4e3a\u4e86\u89e3\u51b3\u6b64\u95ee\u9898\uff0cDDP\u904d\u5386\u4ece\u524d\u5411\u4f20\u64ad\u7684\u8f93\u51fa\u5f20\u91cf\u5f97\u5230\u7684\u81ea\u52a8\u6c42\u5bfc\u56fe\u6765\u627e\u5230\u6240\u6709\u7684\u53c2\u4e0e\u53c2\u6570\uff0c\u7136\u540e\u5c06\u672a\u53c2\u4e0e\u7684\u53c2\u6570\u76f4\u63a5\u6807\u8bb0\u4e3a\u5c31\u7eea\u3002","title":"\u8ba1\u7b97\u901a\u4fe1\u91cd\u53e0\uff08overlapping computation with communication\uff09"},{"location":"document/torch.distributed/#skipping-gradient-synchronization","text":"\u5e76\u884c\u8bad\u7ec3\u7684\u6700\u5927\u5ef6\u8fdf\u6765\u6e90\u662f\u540c\u6b65\u3002\u90a3\u4e48\uff0c\u6211\u4eec\u4e00\u5b9a\u8981\u6bcf\u4e2a\u8fed\u4ee3\u90fd\u6267\u884c\u540c\u6b65\u4e48\uff1f\u7b54\u6848\u81ea\u7136\u662f\u5426\u5b9a\u7684\u3002\u5728\u5c40\u90e8\u6267\u884cn\u6b21\u8bad\u7ec3\u8fed\u4ee3\u4e4b\u540e\u518d\u6267\u884c\u4e00\u6b21 AllReduce \u53ef\u4ee5\u5728\u5f88\u5927\u7a0b\u5ea6\u4e0a\u51cf\u5c11\u68af\u5ea6\u540c\u6b65\u3002\u8fd9\u540c\u65f6\u6709\u52a9\u4e8e\u8bad\u7ec3\u4e00\u4e2a\u8d85\u5927\u7684\uff0c\u65e0\u6cd5\u4e00\u6b21\u6027\u653e\u5165\u663e\u5b58\u7684\u8f93\u5165\u6279\u2013\u6211\u4eec\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u6279\u5212\u5206\u6210\u51e0\u4e2a\u5c0f\u6279\uff0c\u7136\u540e\u5728\u8fd9\u4e9b\u5c0f\u6279\u4e0a\u8fdb\u884c\u524d\u5411\u4e0e\u53cd\u5411\u4f20\u64ad\uff0c\u518d\u5f53\u6574\u4e2a\u6279\u8bad\u7ec3\u5b8c\u6210\u4e4b\u540e\u53d1\u8d77\u68af\u5ea6\u540c\u6b65\u3002 \u7406\u8bba\u4e0a\u6765\u8bf4\uff0c\u68af\u5ea6\u540c\u6b65\u8df3\u8fc7\u7684\u8ba1\u7b97\u7ed3\u679c\u4e0e\u4e0d\u8df3\u8fc7\u7684\u7ed3\u679c\u662f\u76f8\u540c\u7684\uff0c\u56e0\u4e3a\u68af\u5ea6\u53ea\u662f\u5355\u7eaf\u7684\u88ab\u7d2f\u52a0\u5230\u4e86\u540c\u4e00\u4e2a\u5f20\u91cf\u4e0a\u3002\u4f46\u4e0a\u4e00\u8282\u63d0\u5230\uff0c\u6bcf\u4e00\u4e2a\u8fed\u4ee3\u4e2d\u53c2\u4e0e\u8bad\u7ec3\u7684\u7f51\u7edc\u53ef\u80fd\u4e0d\u540c\uff0c\u68af\u5ea6\u540c\u6b65\u8df3\u8fc7\u4e0e\u4e4b\u524d\u63d0\u5230\u7684\u63aa\u65bd\u76f8\u51b2\u7a81\u3002\u6b64\u5916\uff0cDDP\u4e5f\u65e0\u6cd5\u77e5\u9053\u63a5\u4e0b\u6765\u7684\u53cd\u5411\u4f20\u64ad\u5e94\u5f53\u8fdb\u884c\u68af\u5ea6\u7d2f\u52a0\u8fd8\u662f\u540c\u6b65\uff0c\u56e0\u6b64PyTorch\u4f7f\u7528 ddp.no_sync() \u4ee5\u4f5c\u4e3a\u7d2f\u52a0\u7684\u6807\u8bc6\u3002","title":"\u68af\u5ea6\u540c\u6b65\u8df3\u8fc7\uff08skipping gradient synchronization\uff09"},{"location":"instant_food/MyKuali%E6%A7%9F%E5%9F%8E%E7%99%BD%E5%92%96%E5%96%B1%E9%9D%A2/","text":"\u9762\u997c\u91cd\u91cf\uff1aN/A \u51c0\u91cd\u91cf\uff1a110g \u52a0\u6c34\u91cf\uff1a350ml \u65f6\u957f3\u5206\u949f","title":"MyKuali\u69df\u57ce\u767d\u5496\u55b1\u9762"},{"location":"instant_food/introduction/","text":"\u524d\u8a00 \u6211\u4eec\u6bcf\u5929\u90fd\u8981\u82b1\u8d39\u5927\u7ea62\u4e2a\u5c0f\u65f6\u5403\u996d\uff0c\u4e00\u5e74\u7d2f\u79ef\u8d77\u6765\u591a\u8fbe730\u4e2a\u5c0f\u65f6\u3002\u5982\u679c\u80fd\u5c06\u8fd9\u4e9b\u5b9d\u8d35\u7684\u65f6\u95f4\u8282\u7ea6\u51fa\u6765\u8bad\u6a21\u578b\u7684\u8bdd\u2026\u2026\u90a3\u771f\u662f\u518d\u7f8e\u5999\u4e0d\u8fc7\u4e86\u3002 \u6839\u636e\u70ed\u529b\u5b66\u7b2c\u4e8c\u5b9a\u5f8b\uff0c\u6211\u4eec\u603b\u9700\u8981\u5403\u996d\u6765\u4ea7\u751f\u70ed\u91cf\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u5927\u591a\u6570\u65f6\u95f4\u6211\u4eec\u90fd\u53ea\u662f\u4e3a\u4e86\u679c\u8179\u800c\u5403\u996d\uff0c\u90a3\u4e48\u5982\u679c\u6211\u4eec\u4f7f\u7528\u65b9\u4fbf\u9762\u6216\u8005\u5176\u4ed6\u901f\u98df\u98df\u54c1\u6765\u4ee3\u66ff\u53bb\u5403\u4fbf\u5229\u8702\u7684\u8bdd\uff0c\u60f3\u5fc5\u80fd\u8282\u7ea6\u51fa\u4e0d\u8ba1\u5176\u6570\u7684\u5b9d\u8d35\u65f6\u95f4\u3002\u56e0\u6b64\uff0c\u8fd9\u7cfb\u5217\u6587\u7ae0\u8bde\u751f\u4e86\u3002\u6211\u4eec\u5c06\u8bc4\u6d4b\u5168\u4e16\u754c\u5404\u79cd\u901f\u98df\u98df\u54c1\uff0c\u4ece\u6700\u5e38\u89c1\u7684\u65b9\u4fbf\u9762\u3001\u81ea\u70ed\u7c73\u996d\u5230\u4f20\u7edf\u7684\u538b\u7f29\u997c\u5e72\u518d\u5230\u5bcc\u6709\u4e2d\u56fd\u7279\u8272\u7684\u81ea\u70ed\u706b\u9505\u3002\u6211\u4eec\u5e0c\u671b\u80fd\u8ba9\u65e0\u8bba\u662f\u56e0\u4e3a\u8bba\u6587\u3001\u7ade\u8d5b\u3001\u8003\u8bd5\u6291\u6216\u662f\u5176\u4ed6\u800c\u57cb\u9996\u4e8e\u6848\u7684\u4f60\u80fd\u5403\u5230\u4e00\u987f\u76f8\u5bf9\u7f8e\u5473\u7684\u4fbf\u9910\u3002 \u8fdb\u5165\u672c\u8bc4\u6d4b\u7684\u4ea7\u54c1\u53ea\u9700\u6ee1\u8db3\u4ee5\u4e0b\u4e24\u6761\u5373\u53ef\uff1a \u6761\u4ef6 \u65b9\u4fbf \u2013 \u4f7f\u7528\u6c34\u6216\u8005\u5fae\u6ce2\u7089\u5373\u53ef\u70f9\u8c03\u3002 \u901f\u98df \u2013 \u70f9\u8c03\u65f6\u95f4\u4e0d\u5e94\u8d85\u8fc7\u4e94\u5206\u949f\u3002 \u6211\u4eec\u5145\u5206\u7406\u89e3\u5e02\u9762\u4e0a\u6709\u5f88\u591a\u4f18\u79c0\u7684\u9700\u8981\u6c34\u716e\u7684\u65b9\u4fbf\u9762\u3002\u4f46\u6211\u4eec\u76f8\u4fe1\u5982\u679c\u4f60\u6709\u716e\u9762\u7684\u65f6\u95f4\uff0c\u90a3\u4e48\u5e94\u8be5\u4e5f\u4e0d\u7f3a\u5c11\u70b9\u4e00\u4e2a\u5916\u5356\u6216\u8005\u53bb\u4e00\u8d9f\u4fbf\u5229\u8702\u7684\u65f6\u95f4\uff0c\u800c\u8fd9\u901a\u5e38\u80fd\u5e26\u7ed9\u4f60\u66f4\u591a\u5e78\u798f\u3002 \u5c3d\u7ba1\u53e3\u5473\u662f\u4e00\u4ef6\u975e\u5e38\u4e3b\u89c2\u7684\u4e8b\u60c5\uff0c\u6211\u4eec\u8fd8\u662f\u5e0c\u671b\u80fd\u5f15\u5165\u4e00\u7cfb\u5217\u7684\u6807\u51c6\u5316\u6210\u7ee9\u6765\u5e2e\u52a9\u4f60\u505a\u51fa\u51b3\u5b9a\u3002\u8fd9\u4e9b\u6807\u51c6\u5305\u62ec\uff1a \u8bc4\u6d4b\u6807\u51c6 ^\\star ^\\star \u70f9\u996a\u65f6\u957f \u8fa3\u5ea6 \u6e05\u6d17\u96be\u5ea6 ^\\star ^\\star \uff1a\u8bc4\u6d4b\u6807\u51c6\u6709\u5f85\u63d0\u5347\u3002 \u5728\u6d4b\u5217\u8868\uff1a \u56fd\u5bb6 \u79cd\u7c7b \u54c1\u724c \u54c1\u540d \u98ce\u5473 \u70f9\u996a\u65b9\u5f0f \u4e2d\u56fd \u65b9\u4fbf\u9762 \u8001\u9042\u8bb0 \u8001\u90d1\u5dde\u70e9\u9762-\u9ebb\u8fa3\u7f8a\u8089\u5473 \u6d78\u6ce1 \u4e2d\u56fd \u65b9\u4fbf\u7c89\u4e1d \u8001\u5218\u5934 \u6dee\u5357\u725b\u8089\u6c64-\u8fa3\u5473 \u6d78\u6ce1 \u65b0\u52a0\u5761 \u65b9\u4fbf\u9762 KOKA \u661f\u6d32\u53fb\u6c99 \u6d78\u6ce1 \u65b0\u52a0\u5761 \u65b9\u4fbf\u9762 KOKA \u9e21\u6c64 \u6d78\u6ce1 \u65b0\u52a0\u5761 \u65b9\u4fbf\u9762 KOKA \u6cf0\u5f0f\u9178\u8fa3 \u6d78\u6ce1 \u65b0\u52a0\u5761 \u65b9\u4fbf\u9762 KOKA \u5496\u55b1 \u6d78\u6ce1 \u9a6c\u6765\u897f\u4e9a \u65b9\u4fbf\u9762 Vit\u2019s \u69df\u57ce\u4e9a\u53c2\u53fb\u6c99 \u6d78\u6ce1 \u9a6c\u6765\u897f\u4e9a \u65b9\u4fbf\u9762 Vit\u2019s \u69df\u57ce\u798f\u5efa\u867e\u9762 \u6d78\u6ce1 \u9a6c\u6765\u897f\u4e9a \u65b9\u4fbf\u9762 Vit\u2019s \u69df\u57ce\u767d\u5496\u55b1\u9762 \u6d78\u6ce1 \u9a6c\u6765\u897f\u4e9a \u65b9\u4fbf\u9762 MyKuali \u69df\u57ce\u767d\u5496\u55b1\u9762 \u6d78\u6ce1 \u9a6c\u6765\u897f\u4e9a \u65b9\u4fbf\u9762 MyKuali \u69df\u57ce\u9999\u8fa3\u867e\u6c64\u9762 \u6d78\u6ce1 \u9a6c\u6765\u897f\u4e9a \u65b9\u4fbf\u9762 MyKuali \u69df\u57ce\u7ea2\u9178\u8fa3\u6c64\u9762 \u6d78\u6ce1 \u6cf0\u56fd \u65b9\u4fbf\u9762 YumYum \u51ac\u9634\u529f\uff08\u9178\u8fa3\u867e\u6c64\uff09 \u6d78\u6ce1 \u6cf0\u56fd \u65b9\u4fbf\u9762 YumYum \u51ac\u9634\u529f\uff08\u9178\u8fa3\u867e\u6d53\u6c64\uff09 \u6d78\u6ce1 \u8d8a\u5357 \u65b9\u4fbf\u62cc\u9762 RunningEgg \u9999\u8fa3\u54b8\u86cb\u9ec4\u98ce\u5473\u62cc\u9762 \u6d78\u6ce1","title":"\u901f\u98df\u98df\u54c1\u306e\u8bc4\u6d4b"},{"location":"k8s/command_line_interface/","text":"\u547d\u4ee4\u884c\u63a5\u53e3 # \u547d\u4ee4\u884c\u63a5\u53e3\uff08Command Line Interface, CLI\uff09\u6c38\u8fdc\u662f\u6700\u91cd\u8981\u7684\u90e8\u5206\u3002 \u5728\u8fd9\u7bc7\u6587\u7ae0\u5f53\u4e2d\uff0c\u6211\u4eec\u4f1a\u63cf\u8ff0Kubernetes\u547d\u4ee4\u884c\u63a5\u53e3\u7684\u57fa\u7840\u64cd\u4f5c\u3002\u4ece\u68c0\u67e5Kubernetes\u5404\u7ec4\u4ef6\u7684\u5065\u5eb7\u72b6\u6001\u5f00\u59cb\uff0c\u5230\u624b\u52a8\u5b8c\u6210\u4e00\u4e2aDeployment\u7684\u4f38\u7f29\u542f\u505c\u3002 \u5e9f\u8bdd\u4e0d\u591a\u8bf4\uff0c\u5c31\u6b64\u5f00\u59cb\u5427\u3002","title":"Kuberenetes\u547d\u4ee4\u884c\u63a5\u53e3"},{"location":"k8s/command_line_interface/#_1","text":"\u547d\u4ee4\u884c\u63a5\u53e3\uff08Command Line Interface, CLI\uff09\u6c38\u8fdc\u662f\u6700\u91cd\u8981\u7684\u90e8\u5206\u3002 \u5728\u8fd9\u7bc7\u6587\u7ae0\u5f53\u4e2d\uff0c\u6211\u4eec\u4f1a\u63cf\u8ff0Kubernetes\u547d\u4ee4\u884c\u63a5\u53e3\u7684\u57fa\u7840\u64cd\u4f5c\u3002\u4ece\u68c0\u67e5Kubernetes\u5404\u7ec4\u4ef6\u7684\u5065\u5eb7\u72b6\u6001\u5f00\u59cb\uff0c\u5230\u624b\u52a8\u5b8c\u6210\u4e00\u4e2aDeployment\u7684\u4f38\u7f29\u542f\u505c\u3002 \u5e9f\u8bdd\u4e0d\u591a\u8bf4\uff0c\u5c31\u6b64\u5f00\u59cb\u5427\u3002","title":"\u547d\u4ee4\u884c\u63a5\u53e3"},{"location":"k8s/component/","text":"Kubernetes\u7684\u7ec4\u4ef6\u53ef\u4ee5\u5206\u4e3a\u4e09\u7c7b\u2013\u7ba1\u7406\u7ec4\u4ef6\uff08Master Components\uff09\u3001\u8282\u70b9\u7ec4\u4ef6\uff08Nodes Components\uff09\u548c\u63d2\u4ef6\uff08Addons\uff09\u3002 \u4e3b\u8282\u70b9\uff08Master Node\uff09\u548c\u4ece\u8282\u70b9\uff08Worker Node\uff09 \u7ba1\u7406\u7ec4\u4ef6\u53ef\u4ee5\u8fd0\u884c\u5728\u96c6\u7fa4\u5f53\u4e2d\u7684\u4efb\u4f55\u4e00\u4e2a\u8282\u70b9\u4e4b\u4e0a\uff0c\u4f46\u6211\u4eec\u901a\u5e38\u4f1a\u5c06\u6240\u6709\u7ba1\u7406\u7ec4\u4ef6\u8fd0\u884c\u5728\u67d0\u4e00\u4e2a\u6216\u591a\u4e2a\u8282\u70b9\u4e4b\u4e0a\uff0c\u5e76\u4e14\u4e0d\u5728\u8fd9\u4e9b\u8282\u70b9\u4e0a\u8fd0\u884c\u4efb\u4f55\u7528\u6237\u5bb9\u5668\u3002\u5bf9\u4e8e\u8fd9\u4e00\u4e2a\u6216\u51e0\u4e2a\u8282\u70b9\uff0c\u6211\u4eec\u5c06\u5176\u79f0\u4e3a\u4e3b\u8282\u70b9\uff08Master Node\uff09\u3002\u5bf9\u4e8e\u5176\u4ed6\u6240\u6709\u8282\u70b9\uff0c\u6211\u4eec\u5c06\u5176\u79f0\u4e3a\u4ece\u8282\u70b9\u6216\u8005\u5de5\u4f5c\u8282\u70b9\uff08Worker Node\uff09\u3002 \u4e00\u822c\u800c\u8a00\uff0c\u4e00\u4e2aKubernetes\u96c6\u7fa4\u81f3\u5c11\u9700\u8981\u4e00\u4e2a\u4e3b\u8282\u70b9\u548c\u4e00\u4e2a\u4ece\u8282\u70b9\u3002 \u7ba1\u7406\u7ec4\u4ef6\uff08Master Components\uff09 # \u7ba1\u7406\u7ec4\u4ef6 \u7ba1\u7406\u7ec4\u4ef6\u53ef\u4ee5\u5728\u4efb\u4f55\u4e00\u4e2a\u8282\u70b9\u4e0a\u8fd0\u884c\uff0c\u5b83\u4e3a\u96c6\u7fa4\u63d0\u4f9b\u63a7\u5236\u5e73\u9762\uff0c\u5305\u62ec\u505a\u51fa\u5168\u5c40\u6027\u51b3\u7b56\u4ee5\u53ca\u68c0\u6d4b\u548c\u54cd\u5e94\u96c6\u7fa4\u4e8b\u4ef6 \u7ba1\u7406\u7ec4\u4ef6\u7531\u5305\u62ec\u4ee5\u4e0b\u4e94\u4e2a\u7ec4\u4ef6\uff1a API\u670d\u52a1\u5668\uff08kube-apiserver\uff09 etcd \u8c03\u5ea6\u5668\uff08kube-scheduler\uff09 \u63a7\u5236\u5668\u7ba1\u7406\u5668\uff08kube-controller-manager\uff09 \u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668\uff08cloud-controller-manager\uff09 API\u670d\u52a1\u5668\uff08kube-apiserver\uff09 # API\u670d\u52a1\u5668 API\u670d\u52a1\u5668\u8d1f\u8d23\u5c06Kubernetes API\u5bf9\u5916\u66b4\u9732\u3002 Kubernetes API \u670d\u52a1\u5668\u7684\u4e3b\u8981\u5b9e\u73b0\u662f kube-apiserver \u3002 kube-apiserver \u88ab\u8bbe\u8ba1\u4e3a\u6c34\u5e73\u6269\u5c55\u2013\u5373\u901a\u8fc7\u90e8\u7f72\u66f4\u591a\u5b9e\u4f8b\u6765\u5b9e\u73b0\u4f38\u7f29\u3002\u4f60\u53ef\u4ee5\u8fd0\u884c\u591a\u4e2a kube-apiserver \u5b9e\u4f8b\u5e76\u4e14\u5747\u8861\u6bcf\u4e2a\u5b9e\u4f8b\u7684\u6d41\u91cf\u3002 etcd # etcd etcd \u662f\u4e00\u4e2a\u5206\u5e03\u5f0f\u7684\u9ad8\u53ef\u7528\u952e\u503c\u5b58\u50a8\u3002etcd\u88abKubernetes\u7528\u4e8e\u5b58\u50a8\u6240\u6709\u6570\u636e\u3002 \u5907\u4efd etcd\u4e00\u822c\u4f1a\u88ab\u5b9a\u671f\u5907\u4efd\uff0c\u4ee5\u4fbf\u4e8e\u5728\u707e\u96be\u6027\u60c5\u51b5\u4e0b\u6062\u590dKubernetes\u96c6\u7fa4\u3002 \u60a8\u53ef\u4ee5\u5728 etcd\u5b98\u65b9\u6587\u6863 \u4e2d\u627e\u5230\u6709\u5173etcd\u7684\u8be6\u7ec6\u4fe1\u606f\u3002 \u8c03\u5ea6\u5668\uff08kube-scheduler\uff09 # \u8c03\u5ea6\u5668 \u8c03\u5ea6\u5668\u8d1f\u8d23\u76d1\u89c6\u6240\u6709\u65b0\u521b\u5efa\u7684pods\uff0c\u5e76\u5bf9\u5176\u5206\u914d\u4e00\u4e2a\u8282\u70b9\u6765\u8fd0\u884c\u3002 \u63a7\u5236\u5668\u7ba1\u7406\u5668\uff08kube-controller-manager\uff09 # \u63a7\u5236\u5668\u7ba1\u7406\u5668 \u63a7\u5236\u5668\u7ba1\u7406\u5668\u8d1f\u8d23\u8fd0\u884c \u7ba1\u7406\u5668 \u3002 \u903b\u8f91\u4e0a\uff0c\u6bcf\u4e00\u4e2a\u63a7\u5236\u5668\u90fd\u662f\u4e00\u4e2a\u5355\u72ec\u7684\u8fdb\u7a0b\u3002\u4f46\u51fa\u4e8e\u964d\u4f4e\u590d\u6742\u6027\u7684\u8003\u8651\uff0c\u4ed6\u4eec\u90fd\u88ab\u7f16\u8bd1\u6210\u4e00\u4e2a\u5355\u72ec\u7684\u4e8c\u8fdb\u5236\u6587\u4ef6\u5e76\u4e14\u5728\u4e00\u4e2a\u5355\u72ec\u7684\u8fdb\u7a0b\u5f53\u4e2d\u8fd0\u884c\u3002 \u8fd9\u4e9b\u63a7\u5236\u5668\u5305\u62ec\uff1a \u8282\u70b9\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u8282\u70b9\u53d1\u73b0\u5e76\u5728\u8282\u70b9\u4e0b\u7ebf\u65f6\u54cd\u5e94\u3002 \u526f\u672c\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u6839\u636e\u526f\u672c\u63a7\u5236\u5668\u5bf9\u8c61\u7ef4\u62a4pods\u7684\u6570\u91cf\u3002 \u7aef\u70b9\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u586b\u5145\u7aef\u70b9\u5bf9\u8c61\uff08\u5373\u52a0\u5165\u670d\u52a1\u548cpods\uff09\u3002 \u670d\u52a1\u8d26\u6237\u4e0e\u6807\u8bc6\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u4e3a\u65b0\u7684\u540d\u79f0\u7a7a\u95f4\u521b\u5efa\u9ed8\u8ba4\u5e10\u6237\u548cAPI\u8bbf\u95ee\u6807\u8bc6\u3002 \u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668\uff08cloud-controller-manager\uff09 # \u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668\u662fKubernetes 1.6\u7248\u4e2d\u5f15\u5165\u7684alpha\u529f\u80fd\u3002 \u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668 \u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668\u8d1f\u8d23\u8fd0\u884c\u4e0e\u5e95\u5c42\u4e91\u63d0\u4f9b\u5546\u4ea4\u4e92\u7684\u63a7\u5236\u5668\u3002 \u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668\u4ec5\u8fd0\u884c\u7279\u5b9a\u4e8e\u4e91\u63d0\u4f9b\u5546\u7684\u63a7\u5236\u5668\u5faa\u73af\u3002\u60a8\u5fc5\u987b\u5728\u63a7\u5236\u5668\u7ba1\u7406\u5668\u4e2d\u7981\u7528\u8fd9\u4e9b\u63a7\u5236\u5668\u5faa\u73af\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u5728\u542f\u52a8\u63a7\u5236\u5668\u7ba1\u7406\u5668\u65f6\u5c06\u2013cloud-provider\u6807\u5fd7\u8bbe\u7f6e\u4e3aexternal\u6765\u7981\u7528\u63a7\u5236\u5668\u5faa\u73af\u3002 \u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668\u5141\u8bb8\u4e91\u4f9b\u5e94\u5546\u7684\u4ee3\u7801\u548cKubernetes\u4ee3\u7801\u5f7c\u6b64\u72ec\u7acb\u5730\u53d1\u5c55\u3002\u5728\u4ee5\u524d\u7684\u7248\u672c\u4e2d\uff0c\u6838\u5fc3\u7684Kubernetes\u4ee3\u7801\u4f9d\u8d56\u4e8e\u7279\u5b9a\u4e8e\u4e91\u63d0\u4f9b\u5546\u7684\u4ee3\u7801\u6765\u5b9e\u73b0\u529f\u80fd\u3002\u5728\u5c06\u6765\u7684\u7248\u672c\u4e2d\uff0c\u5e94\u7531\u4e91\u4f9b\u5e94\u5546\u81ea\u5df1\u7ef4\u62a4\u7279\u5b9a\u4e8e\u4e91\u4f9b\u5e94\u5546\u7684\u4ee3\u7801\uff0c\u5e76\u5728\u8fd0\u884cKubernetes\u65f6\u5c06\u5176\u94fe\u63a5\u5230\u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668\u3002 \u4ee5\u4e0b\u63a7\u5236\u5668\u5177\u6709\u4e91\u63d0\u4f9b\u7a0b\u5e8f\u4f9d\u8d56\uff1a \u8282\u70b9\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u68c0\u67e5\u4e91\u63d0\u4f9b\u8005\u4ee5\u786e\u5b9a\u8282\u70b9\u505c\u6b62\u54cd\u5e94\u540e\u662f\u5426\u5df2\u5728\u4e91\u4e2d\u5220\u9664\u8be5\u8282\u70b9 \u8def\u7531\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u5728\u57fa\u7840\u4e91\u57fa\u7840\u67b6\u6784\u4e2d\u8bbe\u7f6e\u8def\u7531 \u670d\u52a1\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u521b\u5efa\uff0c\u66f4\u65b0\u548c\u5220\u9664\u4e91\u63d0\u4f9b\u5546\u8d1f\u8f7d\u5e73\u8861\u5668 \u5377\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u521b\u5efa\uff0c\u9644\u52a0\u548c\u5b89\u88c5\u5377\uff0c\u4ee5\u53ca\u4e0e\u4e91\u63d0\u4f9b\u5546\u4ea4\u4e92\u4ee5\u7f16\u6392\u5377 \u8282\u70b9\u7ec4\u4ef6\uff08Nodes Components\uff09 # \u8282\u70b9\u7ec4\u4ef6 \u8282\u70b9\u7ec4\u4ef6\u5219\u9700\u8981\u5728\u6bcf\u4e00\u4e2a\u8282\u70b9\u4e0a\u8fd0\u884c\uff0c\u5b83\u7ef4\u62a4\u8fd0\u884c\u7684Pod\u5e76\u63d0\u4f9bKubernetes\u8fd0\u884c\u65f6\u73af\u5883 \u8282\u70b9\u7ec4\u4ef6\u5305\u62ec\u4ee5\u4e0b\u4e09\u4e2a\u7ec4\u4ef6\uff1a kubelet kube-proxy \u5bb9\u5668\u8fd0\u884c\u65f6\uff08Container Runtime\uff09 kubelet # kubelet kubelet\u662f\u4e00\u4e2a\u4ee3\u7406\uff0c\u8d1f\u8d23\u786e\u4fdd\u5bb9\u5668\u5728\u5bb9\u5668\u4e2d\u8fd0\u884c\u3002 kubelet\u5305\u542b\u901a\u8fc7\u5404\u79cd\u673a\u5236\u63d0\u4f9b\u7684\u4e00\u7ec4PodSpecs\uff08pod\u53c2\u6570\uff09\uff0c\u5e76\u786e\u4fdd\u8fd9\u4e9bPodSpecs\u4e2d\u63cf\u8ff0\u7684\u5bb9\u5668\u8fd0\u884c\u6b63\u5e38\u3002 Kubelet\u4e0d\u7ba1\u7406\u975eKubernetes\u521b\u5efa\u7684\u5bb9\u5668\u3002 kube-proxy # kube-proxy kube-proxy\u662f\u4e00\u4e2a\u7f51\u7edc\u4ee3\u7406\uff0c\u5b9e\u73b0\u4e86Kubernetes\u670d\u52a1\u6982\u5ff5\u7684\u4e00\u90e8\u5206\u3002 kube-proxy\u7ef4\u62a4\u8282\u70b9\u4e0a\u7684\u7f51\u7edc\u89c4\u5219\u3002\u8fd9\u4e9b\u7f51\u7edc\u89c4\u5219\u5141\u8bb8\u4ece\u96c6\u7fa4\u5185\u90e8\u6216\u5916\u90e8\u7684\u7f51\u7edc\u4f1a\u8bdd\u4e0epod\u8fdb\u884c\u7f51\u7edc\u901a\u4fe1\u3002 \u5982\u679c\u6709kube-proxy\uff0c\u5219kube-proxy\u4f7f\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u6570\u636e\u5305\u8fc7\u6ee4\u5c42\u3002\u5426\u5219\uff0ckube-proxy\u4f1a\u8f6c\u53d1\u6d41\u91cf\u672c\u8eab\u3002 \u5bb9\u5668\u8fd0\u884c\u65f6\uff08Container Runtime\uff09 # \u5bb9\u5668\u8fd0\u884c\u65f6 \u5bb9\u5668\u8fd0\u884c\u65f6\u662f\u8d1f\u8d23\u8fd0\u884c\u5bb9\u5668\u7684\u8f6f\u4ef6\u3002 Kubernetes\u652f\u6301\u591a\u79cd\u5bb9\u5668\u8fd0\u884c\u65f6\uff1a Docker \uff0c containerd \uff0c cri-o \uff0c rktlet \u4ee5\u53ca Kubernetes CRI\uff08\u5bb9\u5668\u8fd0\u884c\u65f6\u63a5\u53e3\uff09 \u7684\u4efb\u4f55\u5b9e\u73b0\u3002 \u63d2\u4ef6\uff08Addons\uff09 # \u63d2\u4ef6 \u63d2\u4ef6\u4e3aKubernetes\u96c6\u7fa4\u63d0\u4f9b\u9644\u52a0\u7279\u6027\u3002 \u7531\u4e8e\u63d2\u4ef6\u63d0\u4f9b\u7684\u7279\u6027\u662f\u96c6\u7fa4\u7b49\u7ea7\u7684\uff0c\u63d2\u4ef6\u7684\u547d\u540d\u7a7a\u95f4\u8d44\u6e90\u5c5e\u4e8e kube-system \u547d\u540d\u7a7a\u95f4\u3002 \u672c\u8282\u63d0\u4f9b\u4e00\u90e8\u5206\u63d2\u4ef6\u7684\u63cf\u8ff0\uff0c\u6709\u5173\u5177\u4f53\u7684\u5185\u5bb9\uff0c\u656c\u8bf7\u53c2\u9605 \u63d2\u4ef6 \u3002 DNS # DNS \u51e0\u4e4e\u6240\u6709\u7684\u63d2\u4ef6\u90fd\u662f\u9009\u88c5\u7684\uff0c\u4f46DNS\u662f\u4e00\u4e2a\u4f8b\u5916\u3002\u6bcf\u4e00\u4e2aKubernetes\u96c6\u7fa4\u90fd\u5e94\u8be5\u6709 Cluster DNS \u3002 Cluster DNS\u662f\u4e00\u4e2aDNS\u670d\u52a1\u5668\uff0c\u548c\u60a8\u90e8\u7f72\u73af\u5883\u4e2d\u7684\u5176\u4ed6DNS\u670d\u52a1\u5668\u4e00\u8d77\u5de5\u4f5c\uff0c\u4e3aKubernetes\u670d\u52a1\u63d0\u4f9bDNS\u8bb0\u5f55\u3002 Kubernetes\u4f1a\u81ea\u52a8\u5c06\u8fd9\u4e2aDNS\u670d\u52a1\u5668\u5305\u542b\u5728\u7531\u5176\u542f\u52a8\u7684\u5bb9\u5668\u7684DNS\u641c\u7d22\u4e2d\u3002 Web UI\uff08\u4eea\u8868\u677f\uff09 # \u4eea\u8868\u677f \u4eea\u8868\u677f\u662fKubernetes\u96c6\u7fa4\u7684\u901a\u7528\u57fa\u4e8eWeb\u7684UI\u3002\u5b83\u5141\u8bb8\u7528\u6237\u7ba1\u7406\u96c6\u7fa4\u4e2d\u8fd0\u884c\u7684\u5e94\u7528\u7a0b\u5e8f\u4ee5\u53ca\u96c6\u7fa4\u672c\u8eab\u5e76\u8fdb\u884c\u6545\u969c\u6392\u9664\u3002 \u5bb9\u5668\u8d44\u6e90\u76d1\u63a7\uff08Container Resource Monitoring\uff09 # \u5bb9\u5668\u8d44\u6e90\u76d1\u63a7 \u5bb9\u5668\u8d44\u6e90\u76d1\u63a7 \u5728\u4e2d\u592e\u6570\u636e\u5e93\u4e2d\u8bb0\u5f55\u6709\u5173\u5bb9\u5668\u7684\u4e00\u822c\u65f6\u95f4\u5e8f\u5217\u6307\u6807\uff0c\u5e76\u63d0\u4f9b\u7528\u4e8e\u6d4f\u89c8\u8be5\u6570\u636e\u7684UI\u3002 \u96c6\u7fa4\u7ea7\u65e5\u5fd7\uff08Cluster-level Logging\uff09 # \u96c6\u7fa4\u7ea7\u65e5\u5fd7 \u96c6\u7fa4\u7ea7\u65e5\u5fd7 \u673a\u5236\u8d1f\u8d23\u901a\u8fc7\u641c\u7d22/\u6d4f\u89c8\u63a5\u53e3\u5c06\u5bb9\u5668\u65e5\u5fd7\u4fdd\u5b58\u5230\u4e2d\u592e\u65e5\u5fd7\u5b58\u50a8\u4e2d\u3002","title":"\u7ec4\u4ef6"},{"location":"k8s/component/#master-components","text":"\u7ba1\u7406\u7ec4\u4ef6 \u7ba1\u7406\u7ec4\u4ef6\u53ef\u4ee5\u5728\u4efb\u4f55\u4e00\u4e2a\u8282\u70b9\u4e0a\u8fd0\u884c\uff0c\u5b83\u4e3a\u96c6\u7fa4\u63d0\u4f9b\u63a7\u5236\u5e73\u9762\uff0c\u5305\u62ec\u505a\u51fa\u5168\u5c40\u6027\u51b3\u7b56\u4ee5\u53ca\u68c0\u6d4b\u548c\u54cd\u5e94\u96c6\u7fa4\u4e8b\u4ef6 \u7ba1\u7406\u7ec4\u4ef6\u7531\u5305\u62ec\u4ee5\u4e0b\u4e94\u4e2a\u7ec4\u4ef6\uff1a API\u670d\u52a1\u5668\uff08kube-apiserver\uff09 etcd \u8c03\u5ea6\u5668\uff08kube-scheduler\uff09 \u63a7\u5236\u5668\u7ba1\u7406\u5668\uff08kube-controller-manager\uff09 \u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668\uff08cloud-controller-manager\uff09","title":"\u7ba1\u7406\u7ec4\u4ef6\uff08Master Components\uff09"},{"location":"k8s/component/#apikube-apiserver","text":"API\u670d\u52a1\u5668 API\u670d\u52a1\u5668\u8d1f\u8d23\u5c06Kubernetes API\u5bf9\u5916\u66b4\u9732\u3002 Kubernetes API \u670d\u52a1\u5668\u7684\u4e3b\u8981\u5b9e\u73b0\u662f kube-apiserver \u3002 kube-apiserver \u88ab\u8bbe\u8ba1\u4e3a\u6c34\u5e73\u6269\u5c55\u2013\u5373\u901a\u8fc7\u90e8\u7f72\u66f4\u591a\u5b9e\u4f8b\u6765\u5b9e\u73b0\u4f38\u7f29\u3002\u4f60\u53ef\u4ee5\u8fd0\u884c\u591a\u4e2a kube-apiserver \u5b9e\u4f8b\u5e76\u4e14\u5747\u8861\u6bcf\u4e2a\u5b9e\u4f8b\u7684\u6d41\u91cf\u3002","title":"API\u670d\u52a1\u5668\uff08kube-apiserver\uff09"},{"location":"k8s/component/#etcd","text":"etcd etcd \u662f\u4e00\u4e2a\u5206\u5e03\u5f0f\u7684\u9ad8\u53ef\u7528\u952e\u503c\u5b58\u50a8\u3002etcd\u88abKubernetes\u7528\u4e8e\u5b58\u50a8\u6240\u6709\u6570\u636e\u3002 \u5907\u4efd etcd\u4e00\u822c\u4f1a\u88ab\u5b9a\u671f\u5907\u4efd\uff0c\u4ee5\u4fbf\u4e8e\u5728\u707e\u96be\u6027\u60c5\u51b5\u4e0b\u6062\u590dKubernetes\u96c6\u7fa4\u3002 \u60a8\u53ef\u4ee5\u5728 etcd\u5b98\u65b9\u6587\u6863 \u4e2d\u627e\u5230\u6709\u5173etcd\u7684\u8be6\u7ec6\u4fe1\u606f\u3002","title":"etcd"},{"location":"k8s/component/#kube-scheduler","text":"\u8c03\u5ea6\u5668 \u8c03\u5ea6\u5668\u8d1f\u8d23\u76d1\u89c6\u6240\u6709\u65b0\u521b\u5efa\u7684pods\uff0c\u5e76\u5bf9\u5176\u5206\u914d\u4e00\u4e2a\u8282\u70b9\u6765\u8fd0\u884c\u3002","title":"\u8c03\u5ea6\u5668\uff08kube-scheduler\uff09"},{"location":"k8s/component/#kube-controller-manager","text":"\u63a7\u5236\u5668\u7ba1\u7406\u5668 \u63a7\u5236\u5668\u7ba1\u7406\u5668\u8d1f\u8d23\u8fd0\u884c \u7ba1\u7406\u5668 \u3002 \u903b\u8f91\u4e0a\uff0c\u6bcf\u4e00\u4e2a\u63a7\u5236\u5668\u90fd\u662f\u4e00\u4e2a\u5355\u72ec\u7684\u8fdb\u7a0b\u3002\u4f46\u51fa\u4e8e\u964d\u4f4e\u590d\u6742\u6027\u7684\u8003\u8651\uff0c\u4ed6\u4eec\u90fd\u88ab\u7f16\u8bd1\u6210\u4e00\u4e2a\u5355\u72ec\u7684\u4e8c\u8fdb\u5236\u6587\u4ef6\u5e76\u4e14\u5728\u4e00\u4e2a\u5355\u72ec\u7684\u8fdb\u7a0b\u5f53\u4e2d\u8fd0\u884c\u3002 \u8fd9\u4e9b\u63a7\u5236\u5668\u5305\u62ec\uff1a \u8282\u70b9\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u8282\u70b9\u53d1\u73b0\u5e76\u5728\u8282\u70b9\u4e0b\u7ebf\u65f6\u54cd\u5e94\u3002 \u526f\u672c\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u6839\u636e\u526f\u672c\u63a7\u5236\u5668\u5bf9\u8c61\u7ef4\u62a4pods\u7684\u6570\u91cf\u3002 \u7aef\u70b9\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u586b\u5145\u7aef\u70b9\u5bf9\u8c61\uff08\u5373\u52a0\u5165\u670d\u52a1\u548cpods\uff09\u3002 \u670d\u52a1\u8d26\u6237\u4e0e\u6807\u8bc6\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u4e3a\u65b0\u7684\u540d\u79f0\u7a7a\u95f4\u521b\u5efa\u9ed8\u8ba4\u5e10\u6237\u548cAPI\u8bbf\u95ee\u6807\u8bc6\u3002","title":"\u63a7\u5236\u5668\u7ba1\u7406\u5668\uff08kube-controller-manager\uff09"},{"location":"k8s/component/#cloud-controller-manager","text":"\u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668\u662fKubernetes 1.6\u7248\u4e2d\u5f15\u5165\u7684alpha\u529f\u80fd\u3002 \u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668 \u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668\u8d1f\u8d23\u8fd0\u884c\u4e0e\u5e95\u5c42\u4e91\u63d0\u4f9b\u5546\u4ea4\u4e92\u7684\u63a7\u5236\u5668\u3002 \u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668\u4ec5\u8fd0\u884c\u7279\u5b9a\u4e8e\u4e91\u63d0\u4f9b\u5546\u7684\u63a7\u5236\u5668\u5faa\u73af\u3002\u60a8\u5fc5\u987b\u5728\u63a7\u5236\u5668\u7ba1\u7406\u5668\u4e2d\u7981\u7528\u8fd9\u4e9b\u63a7\u5236\u5668\u5faa\u73af\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u5728\u542f\u52a8\u63a7\u5236\u5668\u7ba1\u7406\u5668\u65f6\u5c06\u2013cloud-provider\u6807\u5fd7\u8bbe\u7f6e\u4e3aexternal\u6765\u7981\u7528\u63a7\u5236\u5668\u5faa\u73af\u3002 \u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668\u5141\u8bb8\u4e91\u4f9b\u5e94\u5546\u7684\u4ee3\u7801\u548cKubernetes\u4ee3\u7801\u5f7c\u6b64\u72ec\u7acb\u5730\u53d1\u5c55\u3002\u5728\u4ee5\u524d\u7684\u7248\u672c\u4e2d\uff0c\u6838\u5fc3\u7684Kubernetes\u4ee3\u7801\u4f9d\u8d56\u4e8e\u7279\u5b9a\u4e8e\u4e91\u63d0\u4f9b\u5546\u7684\u4ee3\u7801\u6765\u5b9e\u73b0\u529f\u80fd\u3002\u5728\u5c06\u6765\u7684\u7248\u672c\u4e2d\uff0c\u5e94\u7531\u4e91\u4f9b\u5e94\u5546\u81ea\u5df1\u7ef4\u62a4\u7279\u5b9a\u4e8e\u4e91\u4f9b\u5e94\u5546\u7684\u4ee3\u7801\uff0c\u5e76\u5728\u8fd0\u884cKubernetes\u65f6\u5c06\u5176\u94fe\u63a5\u5230\u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668\u3002 \u4ee5\u4e0b\u63a7\u5236\u5668\u5177\u6709\u4e91\u63d0\u4f9b\u7a0b\u5e8f\u4f9d\u8d56\uff1a \u8282\u70b9\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u68c0\u67e5\u4e91\u63d0\u4f9b\u8005\u4ee5\u786e\u5b9a\u8282\u70b9\u505c\u6b62\u54cd\u5e94\u540e\u662f\u5426\u5df2\u5728\u4e91\u4e2d\u5220\u9664\u8be5\u8282\u70b9 \u8def\u7531\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u5728\u57fa\u7840\u4e91\u57fa\u7840\u67b6\u6784\u4e2d\u8bbe\u7f6e\u8def\u7531 \u670d\u52a1\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u521b\u5efa\uff0c\u66f4\u65b0\u548c\u5220\u9664\u4e91\u63d0\u4f9b\u5546\u8d1f\u8f7d\u5e73\u8861\u5668 \u5377\u63a7\u5236\u5668\uff1a\u8d1f\u8d23\u521b\u5efa\uff0c\u9644\u52a0\u548c\u5b89\u88c5\u5377\uff0c\u4ee5\u53ca\u4e0e\u4e91\u63d0\u4f9b\u5546\u4ea4\u4e92\u4ee5\u7f16\u6392\u5377","title":"\u4e91\u63a7\u5236\u5668\u7ba1\u7406\u5668\uff08cloud-controller-manager\uff09"},{"location":"k8s/component/#nodes-components","text":"\u8282\u70b9\u7ec4\u4ef6 \u8282\u70b9\u7ec4\u4ef6\u5219\u9700\u8981\u5728\u6bcf\u4e00\u4e2a\u8282\u70b9\u4e0a\u8fd0\u884c\uff0c\u5b83\u7ef4\u62a4\u8fd0\u884c\u7684Pod\u5e76\u63d0\u4f9bKubernetes\u8fd0\u884c\u65f6\u73af\u5883 \u8282\u70b9\u7ec4\u4ef6\u5305\u62ec\u4ee5\u4e0b\u4e09\u4e2a\u7ec4\u4ef6\uff1a kubelet kube-proxy \u5bb9\u5668\u8fd0\u884c\u65f6\uff08Container Runtime\uff09","title":"\u8282\u70b9\u7ec4\u4ef6\uff08Nodes Components\uff09"},{"location":"k8s/component/#kubelet","text":"kubelet kubelet\u662f\u4e00\u4e2a\u4ee3\u7406\uff0c\u8d1f\u8d23\u786e\u4fdd\u5bb9\u5668\u5728\u5bb9\u5668\u4e2d\u8fd0\u884c\u3002 kubelet\u5305\u542b\u901a\u8fc7\u5404\u79cd\u673a\u5236\u63d0\u4f9b\u7684\u4e00\u7ec4PodSpecs\uff08pod\u53c2\u6570\uff09\uff0c\u5e76\u786e\u4fdd\u8fd9\u4e9bPodSpecs\u4e2d\u63cf\u8ff0\u7684\u5bb9\u5668\u8fd0\u884c\u6b63\u5e38\u3002 Kubelet\u4e0d\u7ba1\u7406\u975eKubernetes\u521b\u5efa\u7684\u5bb9\u5668\u3002","title":"kubelet"},{"location":"k8s/component/#kube-proxy","text":"kube-proxy kube-proxy\u662f\u4e00\u4e2a\u7f51\u7edc\u4ee3\u7406\uff0c\u5b9e\u73b0\u4e86Kubernetes\u670d\u52a1\u6982\u5ff5\u7684\u4e00\u90e8\u5206\u3002 kube-proxy\u7ef4\u62a4\u8282\u70b9\u4e0a\u7684\u7f51\u7edc\u89c4\u5219\u3002\u8fd9\u4e9b\u7f51\u7edc\u89c4\u5219\u5141\u8bb8\u4ece\u96c6\u7fa4\u5185\u90e8\u6216\u5916\u90e8\u7684\u7f51\u7edc\u4f1a\u8bdd\u4e0epod\u8fdb\u884c\u7f51\u7edc\u901a\u4fe1\u3002 \u5982\u679c\u6709kube-proxy\uff0c\u5219kube-proxy\u4f7f\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u6570\u636e\u5305\u8fc7\u6ee4\u5c42\u3002\u5426\u5219\uff0ckube-proxy\u4f1a\u8f6c\u53d1\u6d41\u91cf\u672c\u8eab\u3002","title":"kube-proxy"},{"location":"k8s/component/#container-runtime","text":"\u5bb9\u5668\u8fd0\u884c\u65f6 \u5bb9\u5668\u8fd0\u884c\u65f6\u662f\u8d1f\u8d23\u8fd0\u884c\u5bb9\u5668\u7684\u8f6f\u4ef6\u3002 Kubernetes\u652f\u6301\u591a\u79cd\u5bb9\u5668\u8fd0\u884c\u65f6\uff1a Docker \uff0c containerd \uff0c cri-o \uff0c rktlet \u4ee5\u53ca Kubernetes CRI\uff08\u5bb9\u5668\u8fd0\u884c\u65f6\u63a5\u53e3\uff09 \u7684\u4efb\u4f55\u5b9e\u73b0\u3002","title":"\u5bb9\u5668\u8fd0\u884c\u65f6\uff08Container Runtime\uff09"},{"location":"k8s/component/#addons","text":"\u63d2\u4ef6 \u63d2\u4ef6\u4e3aKubernetes\u96c6\u7fa4\u63d0\u4f9b\u9644\u52a0\u7279\u6027\u3002 \u7531\u4e8e\u63d2\u4ef6\u63d0\u4f9b\u7684\u7279\u6027\u662f\u96c6\u7fa4\u7b49\u7ea7\u7684\uff0c\u63d2\u4ef6\u7684\u547d\u540d\u7a7a\u95f4\u8d44\u6e90\u5c5e\u4e8e kube-system \u547d\u540d\u7a7a\u95f4\u3002 \u672c\u8282\u63d0\u4f9b\u4e00\u90e8\u5206\u63d2\u4ef6\u7684\u63cf\u8ff0\uff0c\u6709\u5173\u5177\u4f53\u7684\u5185\u5bb9\uff0c\u656c\u8bf7\u53c2\u9605 \u63d2\u4ef6 \u3002","title":"\u63d2\u4ef6\uff08Addons\uff09"},{"location":"k8s/component/#dns","text":"DNS \u51e0\u4e4e\u6240\u6709\u7684\u63d2\u4ef6\u90fd\u662f\u9009\u88c5\u7684\uff0c\u4f46DNS\u662f\u4e00\u4e2a\u4f8b\u5916\u3002\u6bcf\u4e00\u4e2aKubernetes\u96c6\u7fa4\u90fd\u5e94\u8be5\u6709 Cluster DNS \u3002 Cluster DNS\u662f\u4e00\u4e2aDNS\u670d\u52a1\u5668\uff0c\u548c\u60a8\u90e8\u7f72\u73af\u5883\u4e2d\u7684\u5176\u4ed6DNS\u670d\u52a1\u5668\u4e00\u8d77\u5de5\u4f5c\uff0c\u4e3aKubernetes\u670d\u52a1\u63d0\u4f9bDNS\u8bb0\u5f55\u3002 Kubernetes\u4f1a\u81ea\u52a8\u5c06\u8fd9\u4e2aDNS\u670d\u52a1\u5668\u5305\u542b\u5728\u7531\u5176\u542f\u52a8\u7684\u5bb9\u5668\u7684DNS\u641c\u7d22\u4e2d\u3002","title":"DNS"},{"location":"k8s/component/#web-ui","text":"\u4eea\u8868\u677f \u4eea\u8868\u677f\u662fKubernetes\u96c6\u7fa4\u7684\u901a\u7528\u57fa\u4e8eWeb\u7684UI\u3002\u5b83\u5141\u8bb8\u7528\u6237\u7ba1\u7406\u96c6\u7fa4\u4e2d\u8fd0\u884c\u7684\u5e94\u7528\u7a0b\u5e8f\u4ee5\u53ca\u96c6\u7fa4\u672c\u8eab\u5e76\u8fdb\u884c\u6545\u969c\u6392\u9664\u3002","title":"Web UI\uff08\u4eea\u8868\u677f\uff09"},{"location":"k8s/component/#container-resource-monitoring","text":"\u5bb9\u5668\u8d44\u6e90\u76d1\u63a7 \u5bb9\u5668\u8d44\u6e90\u76d1\u63a7 \u5728\u4e2d\u592e\u6570\u636e\u5e93\u4e2d\u8bb0\u5f55\u6709\u5173\u5bb9\u5668\u7684\u4e00\u822c\u65f6\u95f4\u5e8f\u5217\u6307\u6807\uff0c\u5e76\u63d0\u4f9b\u7528\u4e8e\u6d4f\u89c8\u8be5\u6570\u636e\u7684UI\u3002","title":"\u5bb9\u5668\u8d44\u6e90\u76d1\u63a7\uff08Container Resource Monitoring\uff09"},{"location":"k8s/component/#cluster-level-logging","text":"\u96c6\u7fa4\u7ea7\u65e5\u5fd7 \u96c6\u7fa4\u7ea7\u65e5\u5fd7 \u673a\u5236\u8d1f\u8d23\u901a\u8fc7\u641c\u7d22/\u6d4f\u89c8\u63a5\u53e3\u5c06\u5bb9\u5668\u65e5\u5fd7\u4fdd\u5b58\u5230\u4e2d\u592e\u65e5\u5fd7\u5b58\u50a8\u4e2d\u3002","title":"\u96c6\u7fa4\u7ea7\u65e5\u5fd7\uff08Cluster-level Logging\uff09"},{"location":"k8s/deployments/","text":"Deployments # Deployments\uff08\u90e8\u7f72\uff09\u53ef\u4ee5\u7406\u89e3\u4e3aDocker Swarm\u5f53\u4e2d\u7684Service\uff08\u670d\u52a1\uff09\uff0c\u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5e76\u4e0d\u4f1a\u624b\u52a8\u521b\u5efa\u524d\u6587\u5f53\u4e2d\u6240\u63d0\u5230\u7684Pods\uff0c\u800c\u662f\u901a\u8fc7\u521b\u5efa\u4e00\u4e2aDeployment\uff0c\u518d\u7531Deployment\u4f9d\u636e\u8c03\u5ea6\u539f\u5219\u53bb\u521b\u5efaPods\u3002 \u7b80\u5355\u6765\u8bf4\uff0cDeployments\u5c31\u662f\u7b80\u5355\u7684\u5728Pods\u7684\u57fa\u7840\u4e0a\u589e\u52a0\u4e86\u8c03\u5ea6\u3002\u6211\u4eec\u53ef\u4ee5\u5bf9Deployments\u8fdb\u884c\u6eda\u52a8\u66f4\u65b0\u4ee5\u53ca\u56de\u6eda\uff0cKubernetes\u8fd8\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86Horizontal Pod Autoscaling\uff08\u6c34\u5e73\u81ea\u52a8\u4f38\u7f29\uff09\uff08\u5f53\u7136\u4f60\u4e5f\u53ef\u4ee5\u9009\u62e9\u81ea\u5df1\u53bb\u5199\u4f38\u7f29\u811a\u672c\uff09\u3002 \u7b80\u800c\u8a00\u4e4b\uff0c\u5b8c\u6210\u4e00\u4e2aDeployment\uff0c\u4f60\u7684\u4eba\u751f\u624d\u7b97\u5706\u6ee1\u3002 \u63cf\u8ff0\u6587\u4ef6 # Deployments\u7684\u63cf\u8ff0\u6587\u4ef6\u53ef\u4ee5\u770b\u4f5c\u662fPods\u63cf\u8ff0\u6587\u4ef6\u7684\u4e00\u4e2a\u7236\u96c6\u3002 apiVersion: apps/v1 kind: Deployment metadata: name: demo-deployment namespace: demo labels: app: demo annotations: - name: demo spec: replicas: 32 selector: matchLabels: app: demo template: metadata: labels: app: demo spec: restartPolicy: Always containers: - name: demo image: demo/demo:dev resources: limits: nvidia.com/gpu: 1 requests: nvidia.com/gpu: 1 volumeMounts: - name: logs mountPath: /usr/local/demo/logs volumes: - name: logs hostPath: path: /usr/local/demo/logs \u5b8c\u6210\u90e8\u7f72 # \u5982Pods\u4e00\u6837\uff0c\u5bf9\u4e0a\u9762\u7684\u5185\u5bb9\u505a\u51fa\u7b80\u5355\u7684\u4fee\u6539\u5c31\u80fd\u90e8\u7f72\u7b2c\u4e00\u4e2a\u771f\u00b7\u5e94\u7528\u3002 \u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\u6211\u4eec\u4f1a\u7b80\u8981\u4ecb\u7ecdKubernetes\u7684\u547d\u4ee4\u884c\u63a5\u53e3\uff08Command Line Interface\uff09\u7684\u4e00\u4e9b\u57fa\u7840\u64cd\u4f5c\uff0c\u8ba9\u4f60\u80fd\u771f\u6b63\u5f00\u59cb\u7528\u4e0aKubernetes\u3002","title":"Deployments"},{"location":"k8s/deployments/#deployments","text":"Deployments\uff08\u90e8\u7f72\uff09\u53ef\u4ee5\u7406\u89e3\u4e3aDocker Swarm\u5f53\u4e2d\u7684Service\uff08\u670d\u52a1\uff09\uff0c\u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5e76\u4e0d\u4f1a\u624b\u52a8\u521b\u5efa\u524d\u6587\u5f53\u4e2d\u6240\u63d0\u5230\u7684Pods\uff0c\u800c\u662f\u901a\u8fc7\u521b\u5efa\u4e00\u4e2aDeployment\uff0c\u518d\u7531Deployment\u4f9d\u636e\u8c03\u5ea6\u539f\u5219\u53bb\u521b\u5efaPods\u3002 \u7b80\u5355\u6765\u8bf4\uff0cDeployments\u5c31\u662f\u7b80\u5355\u7684\u5728Pods\u7684\u57fa\u7840\u4e0a\u589e\u52a0\u4e86\u8c03\u5ea6\u3002\u6211\u4eec\u53ef\u4ee5\u5bf9Deployments\u8fdb\u884c\u6eda\u52a8\u66f4\u65b0\u4ee5\u53ca\u56de\u6eda\uff0cKubernetes\u8fd8\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86Horizontal Pod Autoscaling\uff08\u6c34\u5e73\u81ea\u52a8\u4f38\u7f29\uff09\uff08\u5f53\u7136\u4f60\u4e5f\u53ef\u4ee5\u9009\u62e9\u81ea\u5df1\u53bb\u5199\u4f38\u7f29\u811a\u672c\uff09\u3002 \u7b80\u800c\u8a00\u4e4b\uff0c\u5b8c\u6210\u4e00\u4e2aDeployment\uff0c\u4f60\u7684\u4eba\u751f\u624d\u7b97\u5706\u6ee1\u3002","title":"Deployments"},{"location":"k8s/deployments/#_1","text":"Deployments\u7684\u63cf\u8ff0\u6587\u4ef6\u53ef\u4ee5\u770b\u4f5c\u662fPods\u63cf\u8ff0\u6587\u4ef6\u7684\u4e00\u4e2a\u7236\u96c6\u3002 apiVersion: apps/v1 kind: Deployment metadata: name: demo-deployment namespace: demo labels: app: demo annotations: - name: demo spec: replicas: 32 selector: matchLabels: app: demo template: metadata: labels: app: demo spec: restartPolicy: Always containers: - name: demo image: demo/demo:dev resources: limits: nvidia.com/gpu: 1 requests: nvidia.com/gpu: 1 volumeMounts: - name: logs mountPath: /usr/local/demo/logs volumes: - name: logs hostPath: path: /usr/local/demo/logs","title":"\u63cf\u8ff0\u6587\u4ef6"},{"location":"k8s/deployments/#_2","text":"\u5982Pods\u4e00\u6837\uff0c\u5bf9\u4e0a\u9762\u7684\u5185\u5bb9\u505a\u51fa\u7b80\u5355\u7684\u4fee\u6539\u5c31\u80fd\u90e8\u7f72\u7b2c\u4e00\u4e2a\u771f\u00b7\u5e94\u7528\u3002 \u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\u6211\u4eec\u4f1a\u7b80\u8981\u4ecb\u7ecdKubernetes\u7684\u547d\u4ee4\u884c\u63a5\u53e3\uff08Command Line Interface\uff09\u7684\u4e00\u4e9b\u57fa\u7840\u64cd\u4f5c\uff0c\u8ba9\u4f60\u80fd\u771f\u6b63\u5f00\u59cb\u7528\u4e0aKubernetes\u3002","title":"\u5b8c\u6210\u90e8\u7f72"},{"location":"k8s/installation/","text":"\u5b89\u88c5 # \u7f51\u4e0akubernetes\u5404\u79cd\u5b89\u88c5\u6559\u7a0b\u4e0d\u5c11\uff0c\u4f46\u8981\u4e48\u662f\u4e0a\u53e4\u65f6\u671f\u7684\u7248\u672c\uff0c\u8981\u4e48\u4e09\u8a00\u4e24\u8bed\u5306\u5306\u5e26\u8fc7\u3002\u5c24\u5176\u662f\u5728\u6211\u4eec\u8fd8\u9700\u8981\u7528\u5230\u663e\u5361\u7684\u60c5\u51b5\u4e0b\u2026\u2026\u2026\u2026 \u8fd9\u91cc\u603b\u7ed3\u4e00\u4e0b\u81ea\u5df1\u5b89\u88c5kubernetes\u7684\u5168\u90e8\u8fc7\u7a0b\u3002 \u5982\u679c\u4f60\u8fd8\u6ca1\u6709\u5b89\u88c5Docker\uff0c\u8bf7\u5148\u53c2\u8003 \u8fd9\u7bc7\u6587\u7ae0 \u5b89\u88c5Docker\u3002 # \u6dfb\u52a0kubernetes\u4ed3\u5e93 curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add - cat <<EOF >/etc/apt/sources.list.d/kubernetes.list deb https://apt.kubernetes.io/ kubernetes-xenial main EOF # \u66f4\u65b0\u4ed3\u5e93 apt-get update apt-get install kubelet kubeadm kubectl \u62c9\u53d6\u4f9d\u8d56\u955c\u50cf # \u672c\u6b65\u9aa4\u4ec5\u9002\u7528\u4e8e\u4f4d\u4e8eGFW\u5f71\u54cd\u8303\u56f4\u5185\u7684\u4e3b\u673a \u8fd0\u884c\u4ee5\u4e0b\u811a\u672c\uff08\u5982\u679c\u60a8\u9884\u671f\u5b89\u88c5\u7684kubernetes\u7248\u672c\u4e0d\u662fv1.13.2\uff0c\u8bf7\u8fd0\u884ckubeadm config images list\u5e76\u4f9d\u636e\u8fd4\u56de\u7ed3\u679c\u8fd0\u884c\u811a\u672c\uff09\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #!/bin/bash set -e if [ -n \" $1 \" ] ; then K8S_VERSION = $1 else K8S_VERSION = v1.13.2 fi if [ -n \" $2 \" ] ; then DASHBOARD_VERSION = $2 else DASHBOARD_VERSION = v1.10.1 fi if [ -n \" $3 \" ] ; then ETCD_VERSION = $3 else ETCD_VERSION =3 .2.24 fi if [ -n \" $4 \" ] ; then PAUSE_VERSION = $4 else PAUSE_VERSION =3 .1 fi if [ -n \" $5 \" ] ; then DNS_VERSION = $5 else DNS_VERSION =1 .2.6 fi if [ -n \" $6 \" ] ; then FLANNEL_VERSION = $6 else FLANNEL_VERSION = v0.10.0-amd64 fi ## \u62c9\u53d6\u955c\u50cf docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager: $K8S_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler: $K8S_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy: $K8S_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver: $K8S_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kubernetes-dashboard-amd64: $DASHBOARD_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/etcd: $ETCD_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/pause: $PAUSE_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/coredns: $DNS_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/kubernetes_containers/flannel: $FLANNEL_VERSION ## \u4fee\u6539\u6807\u7b7e docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager: $K8S_VERSION k8s.gcr.io/kube-controller-manager: $K8S_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler: $K8S_VERSION k8s.gcr.io/kube-scheduler: $K8S_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy: $K8S_VERSION k8s.gcr.io/kube-proxy: $K8S_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver: $K8S_VERSION k8s.gcr.io kube-apiserver: $K8S_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kubernetes-dashboard-amd64: $DASHBOARD_VERSION k8s.gcr.io/kubernetes-dashboard-amd64: $DASHBOARD_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/etcd: $ETCD_VERSION k8s.gcr.io/etcd: $ETCD_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/pause: $PAUSE_VERSION k8s.gcr.io/pause: $PAUSE_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/coredns: $DNS_VERSION k8s.gcr.io/coredns: $DNS_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/kubernetes_containers/flannel: $FLANNEL_VERSION quay.io/coreos/flannel: $FLANNEL_VERSION ## \u5220\u9664\u539f\u59cb\u6807\u7b7e docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager: $K8S_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler: $K8S_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy: $K8S_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver: $K8S_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/kubernetes-dashboard-amd64: $DASHBOARD_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/etcd: $ETCD_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/pause: $PAUSE_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/coredns: $DNS_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/kubernetes_containers/flannel: $FLANNEL_VERSION \u521d\u59cb\u5316kubernetes # \u51fa\u4e8e\u5bf9\u7f51\u7edc\u901f\u5ea6\u7684\u8003\u8651\uff0c\u6211\u4eec\u4f7f\u7528\u4e86Flannel\u4f5c\u4e3a\u7f51\u7edc\u6a21\u578b\uff0c\u4e0d\u540c\u7f51\u7edc\u6a21\u578b\u7684\u521d\u59cb\u5316\u53c2\u6570\u53ef\u80fd\u4e0d\u4e00\u6837\uff0c\u8bf7\u4f9d\u636e\u6307\u5bfc\u521d\u59cb\u5316 kubeadm init --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=<ip-address> \u5bfc\u51fa\u914d\u7f6e\u6587\u4ef6 # \u5bfc\u51fa\u914d\u7f6e\u6587\u4ef6\u662f\u5341\u5206\u5fc5\u8981\u7684\uff0ckubernetes\u4f1a\u4ece\u5f53\u524d\u64cd\u4f5c\u7528\u6237\u7684~/.kube\u76ee\u5f55\u4e0b\u8bfb\u53d6\u914d\u7f6e\u6587\u4ef6 # \u5bf9\u4e8e\u666e\u901a\u7528\u6237 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config # \u5bf9\u4e8eroot\u7528\u6237 export KUBECONFIG=/etc/kubernetes/admin.conf \u5982\u679c\u914d\u7f6e\u6587\u4ef6\u65e0\u6cd5\u8bfb\u53d6\uff0c\u60a8\u5728\u63a5\u4e0b\u6765\u7684\u64cd\u4f5c\u5f53\u4e2d\u53ef\u80fd\u4f1a\u770b\u5230\u5982\u4e0b\u9519\u8bef\u4e4b\u4e00\uff1a Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of \u201ccrypto/rsa: verification error\u201d while trying to verify candidate authority certificate \u201ckubernetes\u201d) The connection to the server localhost:8080 was refused - did you specify the right host or port? The connection to the server localhost:6443 was refused - did you specify the right host or port? \u90e8\u7f72kubernetes\u7f51\u7edc\u6a21\u578b # \u5982\u679c\u60a8\u9009\u62e9\u4e86\u5176\u4ed6\u7f51\u7edc\u6a21\u578b\uff0c\u8bf7\u4f9d\u636e\u6307\u5bfc\u5b8c\u6210\u672c\u6b65\u9aa4 sysctl net.bridge.bridge-nf-call-iptables=1 kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml **\u90e8\u7f72NVIDIA\u8bbe\u5907\u63d2\u4ef6** docker pull nvidia/k8s-device-plugin:1.11 # \u5982\u679c\u65e0\u6cd5\u76f4\u63a5\u62c9\u53d6\u955c\u50cf # git clone https://github.com/NVIDIA/k8s-device-plugin.git && cd k8s-device-plugin # docker build -t nvidia/k8s-device-plugin:1.11 . docker run --security-opt=no-new-privileges --cap-drop=ALL --network=none -dit -v /var/lib/kubelet/device-plugins:/var/lib/kubelet/device-plugins nvidia/k8s-device-plugin:1.11 kubectl create -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/v1.11/nvidia-device-plugin.yml **\u90e8\u7f72kubernetes dashboard** kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml \u5b89\u88c5\u7ed3\u675f # \u81f3\u6b64\uff0ckubernetes\u5df2\u7ecf\u6210\u529f\u5728\u60a8\u7684\u673a\u5668\u4e0a\u5b89\u88c5\uff0c\u8fd0\u884c kubectl get pods --all-namespaces \u68c0\u89c6\u6240\u6709pod\u7684\u8fd0\u884c\u60c5\u51b5 \u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u4ecb\u7ecd\u5982\u4f55\u90e8\u7f72\u7b2c\u4e00\u4e2a\u5e94\u7528\u3002","title":"\u5b89\u88c5"},{"location":"k8s/installation/#_1","text":"\u7f51\u4e0akubernetes\u5404\u79cd\u5b89\u88c5\u6559\u7a0b\u4e0d\u5c11\uff0c\u4f46\u8981\u4e48\u662f\u4e0a\u53e4\u65f6\u671f\u7684\u7248\u672c\uff0c\u8981\u4e48\u4e09\u8a00\u4e24\u8bed\u5306\u5306\u5e26\u8fc7\u3002\u5c24\u5176\u662f\u5728\u6211\u4eec\u8fd8\u9700\u8981\u7528\u5230\u663e\u5361\u7684\u60c5\u51b5\u4e0b\u2026\u2026\u2026\u2026 \u8fd9\u91cc\u603b\u7ed3\u4e00\u4e0b\u81ea\u5df1\u5b89\u88c5kubernetes\u7684\u5168\u90e8\u8fc7\u7a0b\u3002 \u5982\u679c\u4f60\u8fd8\u6ca1\u6709\u5b89\u88c5Docker\uff0c\u8bf7\u5148\u53c2\u8003 \u8fd9\u7bc7\u6587\u7ae0 \u5b89\u88c5Docker\u3002 # \u6dfb\u52a0kubernetes\u4ed3\u5e93 curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add - cat <<EOF >/etc/apt/sources.list.d/kubernetes.list deb https://apt.kubernetes.io/ kubernetes-xenial main EOF # \u66f4\u65b0\u4ed3\u5e93 apt-get update apt-get install kubelet kubeadm kubectl","title":"\u5b89\u88c5"},{"location":"k8s/installation/#_2","text":"\u672c\u6b65\u9aa4\u4ec5\u9002\u7528\u4e8e\u4f4d\u4e8eGFW\u5f71\u54cd\u8303\u56f4\u5185\u7684\u4e3b\u673a \u8fd0\u884c\u4ee5\u4e0b\u811a\u672c\uff08\u5982\u679c\u60a8\u9884\u671f\u5b89\u88c5\u7684kubernetes\u7248\u672c\u4e0d\u662fv1.13.2\uff0c\u8bf7\u8fd0\u884ckubeadm config images list\u5e76\u4f9d\u636e\u8fd4\u56de\u7ed3\u679c\u8fd0\u884c\u811a\u672c\uff09\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #!/bin/bash set -e if [ -n \" $1 \" ] ; then K8S_VERSION = $1 else K8S_VERSION = v1.13.2 fi if [ -n \" $2 \" ] ; then DASHBOARD_VERSION = $2 else DASHBOARD_VERSION = v1.10.1 fi if [ -n \" $3 \" ] ; then ETCD_VERSION = $3 else ETCD_VERSION =3 .2.24 fi if [ -n \" $4 \" ] ; then PAUSE_VERSION = $4 else PAUSE_VERSION =3 .1 fi if [ -n \" $5 \" ] ; then DNS_VERSION = $5 else DNS_VERSION =1 .2.6 fi if [ -n \" $6 \" ] ; then FLANNEL_VERSION = $6 else FLANNEL_VERSION = v0.10.0-amd64 fi ## \u62c9\u53d6\u955c\u50cf docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager: $K8S_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler: $K8S_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy: $K8S_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver: $K8S_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kubernetes-dashboard-amd64: $DASHBOARD_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/etcd: $ETCD_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/pause: $PAUSE_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/coredns: $DNS_VERSION docker pull registry.cn-hangzhou.aliyuncs.com/kubernetes_containers/flannel: $FLANNEL_VERSION ## \u4fee\u6539\u6807\u7b7e docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager: $K8S_VERSION k8s.gcr.io/kube-controller-manager: $K8S_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler: $K8S_VERSION k8s.gcr.io/kube-scheduler: $K8S_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy: $K8S_VERSION k8s.gcr.io/kube-proxy: $K8S_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver: $K8S_VERSION k8s.gcr.io kube-apiserver: $K8S_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kubernetes-dashboard-amd64: $DASHBOARD_VERSION k8s.gcr.io/kubernetes-dashboard-amd64: $DASHBOARD_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/etcd: $ETCD_VERSION k8s.gcr.io/etcd: $ETCD_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/pause: $PAUSE_VERSION k8s.gcr.io/pause: $PAUSE_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/coredns: $DNS_VERSION k8s.gcr.io/coredns: $DNS_VERSION docker tag registry.cn-hangzhou.aliyuncs.com/kubernetes_containers/flannel: $FLANNEL_VERSION quay.io/coreos/flannel: $FLANNEL_VERSION ## \u5220\u9664\u539f\u59cb\u6807\u7b7e docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager: $K8S_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler: $K8S_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy: $K8S_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver: $K8S_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/kubernetes-dashboard-amd64: $DASHBOARD_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/etcd: $ETCD_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/pause: $PAUSE_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/coredns: $DNS_VERSION docker rmi registry.cn-hangzhou.aliyuncs.com/kubernetes_containers/flannel: $FLANNEL_VERSION","title":"\u62c9\u53d6\u4f9d\u8d56\u955c\u50cf"},{"location":"k8s/installation/#kubernetes","text":"\u51fa\u4e8e\u5bf9\u7f51\u7edc\u901f\u5ea6\u7684\u8003\u8651\uff0c\u6211\u4eec\u4f7f\u7528\u4e86Flannel\u4f5c\u4e3a\u7f51\u7edc\u6a21\u578b\uff0c\u4e0d\u540c\u7f51\u7edc\u6a21\u578b\u7684\u521d\u59cb\u5316\u53c2\u6570\u53ef\u80fd\u4e0d\u4e00\u6837\uff0c\u8bf7\u4f9d\u636e\u6307\u5bfc\u521d\u59cb\u5316 kubeadm init --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=<ip-address>","title":"\u521d\u59cb\u5316kubernetes"},{"location":"k8s/installation/#_3","text":"\u5bfc\u51fa\u914d\u7f6e\u6587\u4ef6\u662f\u5341\u5206\u5fc5\u8981\u7684\uff0ckubernetes\u4f1a\u4ece\u5f53\u524d\u64cd\u4f5c\u7528\u6237\u7684~/.kube\u76ee\u5f55\u4e0b\u8bfb\u53d6\u914d\u7f6e\u6587\u4ef6 # \u5bf9\u4e8e\u666e\u901a\u7528\u6237 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config # \u5bf9\u4e8eroot\u7528\u6237 export KUBECONFIG=/etc/kubernetes/admin.conf \u5982\u679c\u914d\u7f6e\u6587\u4ef6\u65e0\u6cd5\u8bfb\u53d6\uff0c\u60a8\u5728\u63a5\u4e0b\u6765\u7684\u64cd\u4f5c\u5f53\u4e2d\u53ef\u80fd\u4f1a\u770b\u5230\u5982\u4e0b\u9519\u8bef\u4e4b\u4e00\uff1a Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of \u201ccrypto/rsa: verification error\u201d while trying to verify candidate authority certificate \u201ckubernetes\u201d) The connection to the server localhost:8080 was refused - did you specify the right host or port? The connection to the server localhost:6443 was refused - did you specify the right host or port?","title":"\u5bfc\u51fa\u914d\u7f6e\u6587\u4ef6"},{"location":"k8s/installation/#kubernetes_1","text":"\u5982\u679c\u60a8\u9009\u62e9\u4e86\u5176\u4ed6\u7f51\u7edc\u6a21\u578b\uff0c\u8bf7\u4f9d\u636e\u6307\u5bfc\u5b8c\u6210\u672c\u6b65\u9aa4 sysctl net.bridge.bridge-nf-call-iptables=1 kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml **\u90e8\u7f72NVIDIA\u8bbe\u5907\u63d2\u4ef6** docker pull nvidia/k8s-device-plugin:1.11 # \u5982\u679c\u65e0\u6cd5\u76f4\u63a5\u62c9\u53d6\u955c\u50cf # git clone https://github.com/NVIDIA/k8s-device-plugin.git && cd k8s-device-plugin # docker build -t nvidia/k8s-device-plugin:1.11 . docker run --security-opt=no-new-privileges --cap-drop=ALL --network=none -dit -v /var/lib/kubelet/device-plugins:/var/lib/kubelet/device-plugins nvidia/k8s-device-plugin:1.11 kubectl create -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/v1.11/nvidia-device-plugin.yml **\u90e8\u7f72kubernetes dashboard** kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml","title":"\u90e8\u7f72kubernetes\u7f51\u7edc\u6a21\u578b"},{"location":"k8s/installation/#_4","text":"\u81f3\u6b64\uff0ckubernetes\u5df2\u7ecf\u6210\u529f\u5728\u60a8\u7684\u673a\u5668\u4e0a\u5b89\u88c5\uff0c\u8fd0\u884c kubectl get pods --all-namespaces \u68c0\u89c6\u6240\u6709pod\u7684\u8fd0\u884c\u60c5\u51b5 \u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u4ecb\u7ecd\u5982\u4f55\u90e8\u7f72\u7b2c\u4e00\u4e2a\u5e94\u7528\u3002","title":"\u5b89\u88c5\u7ed3\u675f"},{"location":"k8s/introduction/","text":"Kubernetes\uff0c\u4f5c\u4e3aGoogle\u5728\u8fd0\u884c\u591a\u5e74\u7684Borg\u57fa\u7840\u4e0a\u5f00\u53d1\u7684\u5f00\u6e90\u5bb9\u5668\u7f16\u6392\u7cfb\u7edf\uff0c\u5728\u90e8\u7f72\u3001\u4f38\u7f29\u53ca\u7ba1\u7406\u65b9\u9762\u5177\u6709\u5f3a\u5927\u7684\u80fd\u529b\u3002 \u548c\u5f88\u591a\u521d\u5b66\u8005\u6240\u60f3\u7684\u4e0d\u4e00\u6837\uff0ckubernetes\u5e76\u975e\u662f\u4e3aDocker\u800c\u751f\u7684\u3002\u4e8b\u5b9e\u4e0a\uff0c\u4ed6\u8fd8\u652f\u6301Rocket\u8fd9\u6837\u7684\u5bb9\u5668\u6280\u672f\u3002\u4f46\u5728\u672c\u7ad9\u5f53\u4e2d\uff0c\u6211\u4eec\u5c06\u4e0d\u4f1a\u8ba8\u8bbakubernetes\u5728\u5176\u4ed6\u5bb9\u5668\u6280\u672f\u4e0a\u7684\u5e94\u7528\u3002\u6211\u4eec\u9f13\u52b1\u60a8\u5728\u7f51\u4e0a\u5bfb\u627e\u5176\u4ed6\u4fe1\u606f\uff0c\u5982\u679c\u60a8\u6709\u8fd9\u65b9\u9762\u7684\u9700\u6c42\uff0c\u6211\u4eec\u540c\u65f6\u5f88\u6b22\u8fce\u60a8\u5c06\u60a8\u6240\u627e\u5230\u7684\u5185\u5bb9\u6574\u7406\u6210\u6587\u7ae0\u5e76\u63d0\u4ea4\u5728\u672c\u7ad9\u5f53\u4e2d\u3002 \u5f53\u4f60\u90e8\u7f72Kubernetes\u7684\u65f6\u5019\uff0c\u4f60\u90e8\u7f72\u7684\u5b9e\u9645\u4e0a\u662f\u4e00\u6574\u4e2a\u96c6\u7fa4\u3002","title":"\u5bfc\u8bba"},{"location":"k8s/pods/","text":"Pods # \u5bf9\u4e8eKubernetes\u6765\u8bf4\uff0c\u6700\u5c0f\u7684\u90e8\u7f72\u5355\u5143\u662f\u4e00\u4e2aPod\u3002 \u6b63\u5982\u4ed6\u7684\u540d\u5b57\uff08\u8c46\u835a\uff09\u90a3\u6837\uff0c\u4e00\u4e2aPod\u53ef\u4ee5\u5305\u542b\u591a\u4e2a\u5bb9\u5668\uff0c\u4ed6\u4eec\u5171\u4eab\u547d\u540d\u7a7a\u95f4\u3001\u6570\u636e\u5377\u3001\u7f51\u7edc\u5e76\u53ef\u4ee5\u8fdb\u884c\u8fdb\u7a0b\u95f4\u901a\u4fe1\u3002 \u76f8\u6bd4\u5bb9\u5668\uff0cPods\u5728\u8fd9\u91cc\u66f4\u50cf\u4e00\u4e2a\u865a\u62df\u673a\u2013\u5982\u679c\u4f60\u628a\u5b8c\u6210\u4e00\u4e2a\u4efb\u52a1\u6240\u9700\u7684\u6240\u6709\u5bb9\u5668\u90fd\u653e\u5728\u4e00\u4e2aPod\u5f53\u4e2d\uff0c\u90a3\u8fd9\u5c31\u76f8\u5f53\u4e8e\u4e00\u4e2a\u72ec\u7acb\u7684\u8282\u70b9\u4e86\uff01 \u63cf\u8ff0\u6587\u4ef6 # \u4e00\u4e2a\u7b80\u5355\u7684Pod\u7684\u63cf\u8ff0\u6587\u4ef6\u5982\u4e0b\u6240\u793a\uff1a apiVersion: v1 kind: Pod metadata: name: demo namespace: demo labels: app: demo annotations: - name: demo spec: restartPolicy: Always containers: - name: demo image: demo/demo:dev resources: limits: nvidia.com/gpu: 1 requests: nvidia.com/gpu: 1 volumeMounts: - name: logs mountPath: /usr/local/demo/logs volumes: - name: logs hostPath: path: /usr/local/demo/logs \u5b8c\u6210\u90e8\u7f72 # \u5bf9\u4e0a\u9762\u7684\u5185\u5bb9\u505a\u51fa\u5c11\u8bb8\u4fee\u6539\uff08\u6bd4\u5982\u4f60\u53ef\u80fd\u4e0d\u9700\u8981\u6302\u8f7d\u65e5\u5fd7\u6587\u4ef6\uff0c\u4e5f\u4e0d\u9700\u8981\u4f7f\u7528GPU\uff09\u5e76\u5728\u672c\u5730\u5e94\u7528\uff0c\u4f60\u7684\u7b2c\u4e00\u4e2a\u5e94\u7528\u5c31\u5b8c\u6210\u90e8\u7f72\u4e86\u3002 \u4f46\u662f\uff0c\u4f5c\u4e3a\u6700\u5c0f\u7684\u90e8\u7f72\u5355\u5143\uff0c\u6211\u4eec\u4ec5\u4ec5\u662f\u5c06\u51e0\u4e2a\u5bb9\u5668\u5408\u5e76\u5728\u4e86\u4e00\u4e2a\u5355\u5143\u5f53\u4e2d\uff0c\u800c\u5e76\u6ca1\u6709\u5b9e\u73b0\u5176\u4ed6\u7684\u529f\u80fd\u2013\u6bd4\u5982\u8bf4\uff0c\u6700\u91cd\u8981\u7684\uff0c\u5bb9\u5668\u8c03\u5ea6\u3002 \u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\u6211\u4eec\u5c06\u4f1a\u7b80\u8981\u4ecb\u7ecdDeployments\uff0c\u5b8c\u6210\u4e00\u4e2a\u771f\u6b63\u7684\u5e94\u7528\u90e8\u7f72\u3002","title":"Pods"},{"location":"k8s/pods/#pods","text":"\u5bf9\u4e8eKubernetes\u6765\u8bf4\uff0c\u6700\u5c0f\u7684\u90e8\u7f72\u5355\u5143\u662f\u4e00\u4e2aPod\u3002 \u6b63\u5982\u4ed6\u7684\u540d\u5b57\uff08\u8c46\u835a\uff09\u90a3\u6837\uff0c\u4e00\u4e2aPod\u53ef\u4ee5\u5305\u542b\u591a\u4e2a\u5bb9\u5668\uff0c\u4ed6\u4eec\u5171\u4eab\u547d\u540d\u7a7a\u95f4\u3001\u6570\u636e\u5377\u3001\u7f51\u7edc\u5e76\u53ef\u4ee5\u8fdb\u884c\u8fdb\u7a0b\u95f4\u901a\u4fe1\u3002 \u76f8\u6bd4\u5bb9\u5668\uff0cPods\u5728\u8fd9\u91cc\u66f4\u50cf\u4e00\u4e2a\u865a\u62df\u673a\u2013\u5982\u679c\u4f60\u628a\u5b8c\u6210\u4e00\u4e2a\u4efb\u52a1\u6240\u9700\u7684\u6240\u6709\u5bb9\u5668\u90fd\u653e\u5728\u4e00\u4e2aPod\u5f53\u4e2d\uff0c\u90a3\u8fd9\u5c31\u76f8\u5f53\u4e8e\u4e00\u4e2a\u72ec\u7acb\u7684\u8282\u70b9\u4e86\uff01","title":"Pods"},{"location":"k8s/pods/#_1","text":"\u4e00\u4e2a\u7b80\u5355\u7684Pod\u7684\u63cf\u8ff0\u6587\u4ef6\u5982\u4e0b\u6240\u793a\uff1a apiVersion: v1 kind: Pod metadata: name: demo namespace: demo labels: app: demo annotations: - name: demo spec: restartPolicy: Always containers: - name: demo image: demo/demo:dev resources: limits: nvidia.com/gpu: 1 requests: nvidia.com/gpu: 1 volumeMounts: - name: logs mountPath: /usr/local/demo/logs volumes: - name: logs hostPath: path: /usr/local/demo/logs","title":"\u63cf\u8ff0\u6587\u4ef6"},{"location":"k8s/pods/#_2","text":"\u5bf9\u4e0a\u9762\u7684\u5185\u5bb9\u505a\u51fa\u5c11\u8bb8\u4fee\u6539\uff08\u6bd4\u5982\u4f60\u53ef\u80fd\u4e0d\u9700\u8981\u6302\u8f7d\u65e5\u5fd7\u6587\u4ef6\uff0c\u4e5f\u4e0d\u9700\u8981\u4f7f\u7528GPU\uff09\u5e76\u5728\u672c\u5730\u5e94\u7528\uff0c\u4f60\u7684\u7b2c\u4e00\u4e2a\u5e94\u7528\u5c31\u5b8c\u6210\u90e8\u7f72\u4e86\u3002 \u4f46\u662f\uff0c\u4f5c\u4e3a\u6700\u5c0f\u7684\u90e8\u7f72\u5355\u5143\uff0c\u6211\u4eec\u4ec5\u4ec5\u662f\u5c06\u51e0\u4e2a\u5bb9\u5668\u5408\u5e76\u5728\u4e86\u4e00\u4e2a\u5355\u5143\u5f53\u4e2d\uff0c\u800c\u5e76\u6ca1\u6709\u5b9e\u73b0\u5176\u4ed6\u7684\u529f\u80fd\u2013\u6bd4\u5982\u8bf4\uff0c\u6700\u91cd\u8981\u7684\uff0c\u5bb9\u5668\u8c03\u5ea6\u3002 \u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\u6211\u4eec\u5c06\u4f1a\u7b80\u8981\u4ecb\u7ecdDeployments\uff0c\u5b8c\u6210\u4e00\u4e2a\u771f\u6b63\u7684\u5e94\u7528\u90e8\u7f72\u3002","title":"\u5b8c\u6210\u90e8\u7f72"},{"location":"math/introduction/","text":"\u5bfc\u8bba # \u4f17\u6240\u5468\u77e5\uff0c\u8ba1\u7b97\u673a\u79d1\u5b66\u662f\u5e94\u7528\u6570\u5b66\u7684\u5206\u652f\u3002\u4ece\u4e8c\u5143\u8fd0\u7b97\u5230\u6392\u5e8f\u7b97\u6cd5\u518d\u5230\u52a8\u6001\u89c4\u5212\uff0c\u4ece\u753b\u4e00\u6761\u7ebf\u5230\u56fe\u5f62\u65cb\u8f6c\u518d\u5230\u7279\u5f81\u63d0\u53d6\u3002\u6570\u5b66\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\u7684\u7075\u9b42\u3002 \u672c\u7ae0\u65e8\u5728\u5bf9\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u5e94\u7528\u5230\u7684\u6570\u5b66\u77e5\u8bc6\u8fdb\u884c\u7b80\u5355\u7684\u5f52\u7eb3\u3002","title":"\u5bfc\u8bba"},{"location":"math/introduction/#_1","text":"\u4f17\u6240\u5468\u77e5\uff0c\u8ba1\u7b97\u673a\u79d1\u5b66\u662f\u5e94\u7528\u6570\u5b66\u7684\u5206\u652f\u3002\u4ece\u4e8c\u5143\u8fd0\u7b97\u5230\u6392\u5e8f\u7b97\u6cd5\u518d\u5230\u52a8\u6001\u89c4\u5212\uff0c\u4ece\u753b\u4e00\u6761\u7ebf\u5230\u56fe\u5f62\u65cb\u8f6c\u518d\u5230\u7279\u5f81\u63d0\u53d6\u3002\u6570\u5b66\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\u7684\u7075\u9b42\u3002 \u672c\u7ae0\u65e8\u5728\u5bf9\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u5e94\u7528\u5230\u7684\u6570\u5b66\u77e5\u8bc6\u8fdb\u884c\u7b80\u5355\u7684\u5f52\u7eb3\u3002","title":"\u5bfc\u8bba"},{"location":"math/linear_algebra/","text":"\u7ebf\u6027\u4ee3\u6570 # \u7ebf\u6027\u4ee3\u6570\u662f\u73b0\u4ee3\u673a\u5668\u5b66\u4e60\u7b97\u6cd5\u4e2d\u6700\u91cd\u8981\u7684\u4e00\u4e2a\u90e8\u5206\u3002\u672c\u6587\u5c06\u4ece\u7fa4\u3001\u5411\u91cf\u7684\u5b9a\u4e49\u5f00\u59cb\uff0c\u5f15\u5165\u5411\u91cf\u5b50\u7a7a\u95f4\uff0c\u5e76\u89e3\u91ca\u5217\u7a7a\u95f4\u3001\u96f6\u7a7a\u95f4\u4ee5\u53ca\u5176\u4ed6\u5185\u5bb9\u3002 \u6570\u5b66\u6e90\u4e8e\u7fa4\u3002 \u7fa4 # \u5b9a\u4e49 1.1 - \u7fa4 \u7fa4 (G, \\otimes) (G, \\otimes) \u662f\u7531\u4e00\u4e2a\u96c6\u5408 G G \u53ca\u4e00\u4e2a\u8fd0\u7b97 \\otimes \\otimes \u6240\u6784\u6210\u4e14\u7b26\u5408\u4e0b\u5217\u56db\u4e2a\u6027\u8d28\u7684\u4ee3\u6570\u7ed3\u6784\uff1a \u95ed\u5408\u6027 - \u5bf9\u4e8e\u6240\u6709 x, y \\in G x, y \\in G \uff0c\u90fd\u6709 x \\otimes y \\in G x \\otimes y \\in G \u3002 \u7ed3\u5408\u5f8b - \u5bf9\u4e8e\u6240\u6709 x, y, c \\in G x, y, c \\in G \uff0c\u90fd\u6709 (x \\otimes y) \\otimes c = (x \\otimes y) \\otimes c (x \\otimes y) \\otimes c = (x \\otimes y) \\otimes c \u3002 \u5355\u4f4d\u5143 - \u5bf9\u4e8e\u6240\u6709 x \\in G x \\in G \uff0c\u5b58\u5728 e \\in G e \\in G \uff0c\u4f7f\u5f97 x \\otimes e = x x \\otimes e = x \uff0c\u4e14 e \\otimes x = x e \\otimes x = x \u3002 \u9006\u5143 - \u5bf9\u4e8e\u6240\u6709 x \\in G x \\in G \uff0c\u5b58\u5728 y \\in G y \\in G \uff0c\u4f7f\u5f97 x \\otimes y = e x \\otimes y = e \uff0c\u4e14 y \\otimes x = e y \\otimes x = e \u3002 \u5728\u6b64\u57fa\u7840\u4e4b\u4e0a\u6211\u4eec\u8fd8\u53ef\u4ee5\u5b9a\u4e49\u963f\u8d1d\u5c14\u7fa4\u3002 \u5b9a\u4e49 1.2 - \u963f\u8d1d\u5c14\u7fa4 \u963f\u8d1d\u5c14\u7fa4 (G, \\oplus) (G, \\oplus) \u662f\u7531\u4e00\u4e2a\u96c6\u5408 G G \u53ca\u4e00\u4e2a\u8fd0\u7b97 \\oplus \\oplus \u6240\u6784\u6210\u4e14\u7b26\u5408\u4e0b\u5217\u56db\u4e2a\u6027\u8d28\u7684\u4ee3\u6570\u7ed3\u6784\uff1a \u4ea4\u6362\u5f8b - \u5bf9\u4e8e\u6240\u6709 x, y \\in G x, y \\in G \uff0c\u90fd\u6709 x \\oplus y = y \\oplus x x \\oplus y = y \\oplus x \u3002 \u6211\u4eec\u5e38\u89c1\u7684\u52a0\u6cd5\u3001\u4e58\u6cd5\u90fd\u5b9a\u4e49\u4e8e\u963f\u8d1d\u5c14\u7fa4\u4e0a\u3002 \u5411\u91cf # \u4ec0\u4e48\u662f\u5411\u91cf\uff1f\u521d\u4e2d\u6570\u5b66\u544a\u8bc9\u6211\u4eec\uff1a\u5177\u6709\u65b9\u5411\u7684\u91cf\u3002\u672c\u6587\u8ba8\u8bba\u7684\u5411\u91cf\u5219\u76f8\u5bf9\u6765\u8bf4\u66f4\u62bd\u8c61\u4e00\u4e9b\u3002\u5177\u4f53\u800c\u8a00\uff0c\u672c\u6587\u5f53\u4e2d\u7684\u5411\u91cf\u5b9a\u4e49\u5982\u4e0b\uff1a \u5b9a\u4e49 2.1 - \u5411\u91cf \u5bf9\u4e8e\u6240\u6709 x x \u548c y y \uff0c x, y x, y \u5728\u52a0\u6cd5\u4e0b\u95ed\u5408\u3002 \u5bf9\u4e8e\u6240\u6709 x x \u548c \\lambda \\in \\mathbb{R} \\lambda \\in \\mathbb{R} \uff0c \\lambda x \\lambda x \u5728\u4e58\u6cd5\u4e0b\u95ed\u5408\u3002 \u57fa\u4e8e\u4e0a\u8ff0\u5b9a\u4e49\uff0c\u5f88\u591a\u76f4\u89c9\u4e0a\u5e76\u4e0d\u662f\u5411\u91cf\u7684\u4e1c\u897f\u5176\u5b9e\u4e5f\u662f\u5411\u91cf\uff0c\u6bd4\u5982\u591a\u9879\u5f0f\u3002 \u4f46\u5728\u5e94\u7528\u5f53\u4e2d\uff0c\u6211\u4eec\u66f4\u5e38\u5173\u6ce8\u5b9a\u4e49\u5728 \\mathbb{R^n} \\mathbb{R^n} \u4e0a\u7684\u5411\u91cf\u3002\u56e0\u4e3a\u5927\u591a\u6570\u8ba1\u7b97\u673a\u79d1\u5b66\u6d89\u53ca\u5230\u7684\u5411\u91cf\u5185\u5bb9\u662f\u5b9a\u4e49\u5728 \\mathbb{R^n} \\mathbb{R^n} \u4e0a\u7684\u3002 \u6709\u5173\u77e9\u9635\u53ca\u5176\u52a0\u6cd5\u4e58\u6cd5\u9006\u8f6c\u7f6e\u5bf9\u79f0\u7b49\u7b49\u7684\u5b9a\u4e49\uff0c\u4e92\u8054\u7f51\u4e0a\u5df2\u6709\u5f88\u591a\u5185\u5bb9\uff0c\u6b64\u5904\u4e0d\u518d\u8d58\u8ff0\u3002 \u5b9a\u4e49 2.2 - \u4e00\u822c\u7ebf\u6027\u7fa4 \u975e\u5947\u5f02\u77e9\u9635 \\mathit{A} \\in \\mathbb{R^{n \\times n}} \\mathit{A} \\in \\mathbb{R^{n \\times n}} \u4ee5\u53ca\u4ed6\u7684\u77e9\u9635\u4e58\u6cd5\u8fd0\u7b97\u6784\u6210\u4e00\u822c\u7ebf\u6027\u7fa4\uff0c\u5199\u505a GL_n\\mathbb{R} GL_n\\mathbb{R} \uff0c\u6216\u8005 GL(n, \\mathbb{R}) GL(n, \\mathbb{R}) \u3002 \u5bf9\u4e8e n \\geq 2 n \\geq 2 \u65f6\uff0c\u4e00\u822c\u7ebf\u6027\u7fa4\u4e3a\u975e\u963f\u8d1d\u5c14\u7fa4\u3002 \u5b9a\u4e49 2.3 - \u5411\u91cf\u7a7a\u95f4 \u5411\u91cf\u7a7a\u95f4 V = (\\mathcal{V}, +, \\cdot) V = (\\mathcal{V}, +, \\cdot) \u662f\u7531\u4e00\u4e2a\u96c6\u5408 \\mathcal{V} \\mathcal{V} \u4ee5\u53ca\u5728\u8fd9\u4e2a\u96c6\u5408\u4e0a\u5b9a\u4e49\u7684\u4e24\u4e2a\u8fd0\u7b97\uff1a + : \\mathcal{V} \\times \\mathcal{V} \\rightarrow \\mathcal{V} + : \\mathcal{V} \\times \\mathcal{V} \\rightarrow \\mathcal{V} \\cdot : \\mathbb{R} \\times \\mathcal{V} \\rightarrow \\mathcal{V} \\cdot : \\mathbb{R} \\times \\mathcal{V} \\rightarrow \\mathcal{V} \u4e14\u7b26\u5408\u4e0b\u5217\u56db\u4e2a\u6027\u8d28\u7684\u4ee3\u6570\u7ed3\u6784\uff1a V = (\\mathcal{V}, +) V = (\\mathcal{V}, +) \u662f\u4e00\u4e2a\u963f\u8d1d\u5c14\u7fa4\u3002 \u5206\u914d\u5f8b - a. \u5bf9\u4e8e\u6240\u6709 \\lambda \\in R \\lambda \\in R \uff0c x, y \\in \\mathcal{V} x, y \\in \\mathcal{V} \uff0c\u90fd\u6709 \\lambda \\cdot (x + y) = \\lambda \\cdot x + \\lambda \\cdot y \\lambda \\cdot (x + y) = \\lambda \\cdot x + \\lambda \\cdot y b. \u5bf9\u4e8e\u6240\u6709 \\lambda \\mu \\in R \\lambda \\mu \\in R \uff0c x \\in \\mathcal{V} x \\in \\mathcal{V} \uff0c\u90fd\u6709 (\\lambda + \\mu) \\cdot x) = \\lambda \\cdot x + \\mu \\cdot x (\\lambda + \\mu) \\cdot x) = \\lambda \\cdot x + \\mu \\cdot x \u7ed3\u5408\u5f8b - \u5bf9\u4e8e\u6240\u6709 \\lambda \\mu \\in R \\lambda \\mu \\in R \uff0c x \\in \\mathcal{V} x \\in \\mathcal{V} \uff0c\u90fd\u6709 \\lambda \\cdot (\\mu \\cdot x) = (\\lambda \\cdot \\mu) \\cdot x \\lambda \\cdot (\\mu \\cdot x) = (\\lambda \\cdot \\mu) \\cdot x \u5355\u4f4d\u5143 - \u5bf9\u4e8e\u6240\u6709 x \\in \\mathcal{V} x \\in \\mathcal{V} \uff0c\u90fd\u6709 1 \\cdot x = x 1 \\cdot x = x \u5b9a\u4e49 2.4 - \u5411\u91cf\u5b50\u7a7a\u95f4 \u5bf9\u4e8e\u5411\u91cf\u7a7a\u95f4 V = (\\mathcal{V}, +, \\cdot) V = (\\mathcal{V}, +, \\cdot) \uff0c\u82e5\u5411\u91cf\u7a7a\u95f4 U U \u6ee1\u8db3 \\mathcal{U} \\subseteq \\mathcal{V}, \\mathcal{U} \\neq \\emptyset \\mathcal{U} \\subseteq \\mathcal{V}, \\mathcal{U} \\neq \\emptyset \uff0c\u90a3\u4e48\u6211\u4eec\u79f0 U = (\\mathcal{U}, +, \\cdot) U = (\\mathcal{U}, +, \\cdot) \u662f V V \u7684\u5411\u91cf\u5b50\u7a7a\u95f4\u3002 \u5b9a\u4e49 2.5 - \u5f20\u6210\u4e0e\u751f\u6210\u96c6 \u5bf9\u4e8e\u5411\u91cf\u7a7a\u95f4 V = (\\mathcal{V}, +, \\cdot) V = (\\mathcal{V}, +, \\cdot) \u548c\u5411\u91cf\u96c6 \\mathcal{A} = \\{x_1, \\ldots, x_n\\} \\subseteq \\mathcal{V} \\mathcal{A} = \\{x_1, \\ldots, x_n\\} \\subseteq \\mathcal{V} \uff0c\u82e5\u6bcf\u4e00\u4e2a\u5411\u91cf \\mathcal{v} \\in \\mathcal{V} \\mathcal{v} \\in \\mathcal{V} \u90fd\u53ef\u4ee5\u8868\u793a\u4e3a x_1, \\ldots, x_n x_1, \\ldots, x_n \u7684\u7ebf\u6027\u7ec4\u5408\uff0c\u90a3\u4e48\u6211\u4eec\u79f0\u5411\u91cf\u96c6 A A \u662f\u5411\u91cf\u7a7a\u95f4 \\mathcal{V} \\mathcal{V} \u7684\u751f\u6210\u96c6\uff0c\u5411\u91cf\u96c6A \\mathcal{A} \\mathcal{A} \u7684\u5411\u91cf\u4eec\u7684\u7ebf\u6027\u7ec4\u5408\u6784\u6210\u7684\u96c6\u5408\u79f0\u4e3aA\u7684\u5f20\u6210\u3002 \u5b9a\u4e49 2.6 \u57fa \u5bf9\u4e8e\u5411\u91cf\u7a7a\u95f4 V = (\\mathcal{V}, +, \\cdot) V = (\\mathcal{V}, +, \\cdot) \u548c\u5411\u91cf\u7a7a\u95f4 V = (\\mathcal{V}, +, \\cdot) V = (\\mathcal{V}, +, \\cdot) \u7684\u751f\u6210\u96c6 \\mathcal{A} = \\{x_1, \\ldots, x_n\\} \\subseteq \\mathcal{V} \\mathcal{A} = \\{x_1, \\ldots, x_n\\} \\subseteq \\mathcal{V} \uff0c\u82e5\u4e0d\u5b58\u5728\u66f4\u5c0f\u7684\u96c6 B \\subset A \\subseteq \\mathcal{V} B \\subset A \\subseteq \\mathcal{V} \u5f20\u6210 \\mathcal{V} \\mathcal{V} \uff0c\u90a3\u4e48\u6211\u4eec\u79f0 \\mathcal{A} \\mathcal{A} \u4e3a\u6700\u5c0f\u751f\u6210\u96c6\u3002\u6bcf\u4e2a V V \u7684\u7ebf\u6027\u65e0\u5173\u7684\u751f\u6210\u96c6\u90fd\u662f\u6700\u5c0f\u7684\uff0c\u4e5f\u88ab\u79f0\u4e3a V V \u7684\u57fa\u3002","title":"\u7ebf\u6027\u4ee3\u6570"},{"location":"math/linear_algebra/#_1","text":"\u7ebf\u6027\u4ee3\u6570\u662f\u73b0\u4ee3\u673a\u5668\u5b66\u4e60\u7b97\u6cd5\u4e2d\u6700\u91cd\u8981\u7684\u4e00\u4e2a\u90e8\u5206\u3002\u672c\u6587\u5c06\u4ece\u7fa4\u3001\u5411\u91cf\u7684\u5b9a\u4e49\u5f00\u59cb\uff0c\u5f15\u5165\u5411\u91cf\u5b50\u7a7a\u95f4\uff0c\u5e76\u89e3\u91ca\u5217\u7a7a\u95f4\u3001\u96f6\u7a7a\u95f4\u4ee5\u53ca\u5176\u4ed6\u5185\u5bb9\u3002 \u6570\u5b66\u6e90\u4e8e\u7fa4\u3002","title":"\u7ebf\u6027\u4ee3\u6570"},{"location":"math/linear_algebra/#_2","text":"\u5b9a\u4e49 1.1 - \u7fa4 \u7fa4 (G, \\otimes) (G, \\otimes) \u662f\u7531\u4e00\u4e2a\u96c6\u5408 G G \u53ca\u4e00\u4e2a\u8fd0\u7b97 \\otimes \\otimes \u6240\u6784\u6210\u4e14\u7b26\u5408\u4e0b\u5217\u56db\u4e2a\u6027\u8d28\u7684\u4ee3\u6570\u7ed3\u6784\uff1a \u95ed\u5408\u6027 - \u5bf9\u4e8e\u6240\u6709 x, y \\in G x, y \\in G \uff0c\u90fd\u6709 x \\otimes y \\in G x \\otimes y \\in G \u3002 \u7ed3\u5408\u5f8b - \u5bf9\u4e8e\u6240\u6709 x, y, c \\in G x, y, c \\in G \uff0c\u90fd\u6709 (x \\otimes y) \\otimes c = (x \\otimes y) \\otimes c (x \\otimes y) \\otimes c = (x \\otimes y) \\otimes c \u3002 \u5355\u4f4d\u5143 - \u5bf9\u4e8e\u6240\u6709 x \\in G x \\in G \uff0c\u5b58\u5728 e \\in G e \\in G \uff0c\u4f7f\u5f97 x \\otimes e = x x \\otimes e = x \uff0c\u4e14 e \\otimes x = x e \\otimes x = x \u3002 \u9006\u5143 - \u5bf9\u4e8e\u6240\u6709 x \\in G x \\in G \uff0c\u5b58\u5728 y \\in G y \\in G \uff0c\u4f7f\u5f97 x \\otimes y = e x \\otimes y = e \uff0c\u4e14 y \\otimes x = e y \\otimes x = e \u3002 \u5728\u6b64\u57fa\u7840\u4e4b\u4e0a\u6211\u4eec\u8fd8\u53ef\u4ee5\u5b9a\u4e49\u963f\u8d1d\u5c14\u7fa4\u3002 \u5b9a\u4e49 1.2 - \u963f\u8d1d\u5c14\u7fa4 \u963f\u8d1d\u5c14\u7fa4 (G, \\oplus) (G, \\oplus) \u662f\u7531\u4e00\u4e2a\u96c6\u5408 G G \u53ca\u4e00\u4e2a\u8fd0\u7b97 \\oplus \\oplus \u6240\u6784\u6210\u4e14\u7b26\u5408\u4e0b\u5217\u56db\u4e2a\u6027\u8d28\u7684\u4ee3\u6570\u7ed3\u6784\uff1a \u4ea4\u6362\u5f8b - \u5bf9\u4e8e\u6240\u6709 x, y \\in G x, y \\in G \uff0c\u90fd\u6709 x \\oplus y = y \\oplus x x \\oplus y = y \\oplus x \u3002 \u6211\u4eec\u5e38\u89c1\u7684\u52a0\u6cd5\u3001\u4e58\u6cd5\u90fd\u5b9a\u4e49\u4e8e\u963f\u8d1d\u5c14\u7fa4\u4e0a\u3002","title":"\u7fa4"},{"location":"math/linear_algebra/#_3","text":"\u4ec0\u4e48\u662f\u5411\u91cf\uff1f\u521d\u4e2d\u6570\u5b66\u544a\u8bc9\u6211\u4eec\uff1a\u5177\u6709\u65b9\u5411\u7684\u91cf\u3002\u672c\u6587\u8ba8\u8bba\u7684\u5411\u91cf\u5219\u76f8\u5bf9\u6765\u8bf4\u66f4\u62bd\u8c61\u4e00\u4e9b\u3002\u5177\u4f53\u800c\u8a00\uff0c\u672c\u6587\u5f53\u4e2d\u7684\u5411\u91cf\u5b9a\u4e49\u5982\u4e0b\uff1a \u5b9a\u4e49 2.1 - \u5411\u91cf \u5bf9\u4e8e\u6240\u6709 x x \u548c y y \uff0c x, y x, y \u5728\u52a0\u6cd5\u4e0b\u95ed\u5408\u3002 \u5bf9\u4e8e\u6240\u6709 x x \u548c \\lambda \\in \\mathbb{R} \\lambda \\in \\mathbb{R} \uff0c \\lambda x \\lambda x \u5728\u4e58\u6cd5\u4e0b\u95ed\u5408\u3002 \u57fa\u4e8e\u4e0a\u8ff0\u5b9a\u4e49\uff0c\u5f88\u591a\u76f4\u89c9\u4e0a\u5e76\u4e0d\u662f\u5411\u91cf\u7684\u4e1c\u897f\u5176\u5b9e\u4e5f\u662f\u5411\u91cf\uff0c\u6bd4\u5982\u591a\u9879\u5f0f\u3002 \u4f46\u5728\u5e94\u7528\u5f53\u4e2d\uff0c\u6211\u4eec\u66f4\u5e38\u5173\u6ce8\u5b9a\u4e49\u5728 \\mathbb{R^n} \\mathbb{R^n} \u4e0a\u7684\u5411\u91cf\u3002\u56e0\u4e3a\u5927\u591a\u6570\u8ba1\u7b97\u673a\u79d1\u5b66\u6d89\u53ca\u5230\u7684\u5411\u91cf\u5185\u5bb9\u662f\u5b9a\u4e49\u5728 \\mathbb{R^n} \\mathbb{R^n} \u4e0a\u7684\u3002 \u6709\u5173\u77e9\u9635\u53ca\u5176\u52a0\u6cd5\u4e58\u6cd5\u9006\u8f6c\u7f6e\u5bf9\u79f0\u7b49\u7b49\u7684\u5b9a\u4e49\uff0c\u4e92\u8054\u7f51\u4e0a\u5df2\u6709\u5f88\u591a\u5185\u5bb9\uff0c\u6b64\u5904\u4e0d\u518d\u8d58\u8ff0\u3002 \u5b9a\u4e49 2.2 - \u4e00\u822c\u7ebf\u6027\u7fa4 \u975e\u5947\u5f02\u77e9\u9635 \\mathit{A} \\in \\mathbb{R^{n \\times n}} \\mathit{A} \\in \\mathbb{R^{n \\times n}} \u4ee5\u53ca\u4ed6\u7684\u77e9\u9635\u4e58\u6cd5\u8fd0\u7b97\u6784\u6210\u4e00\u822c\u7ebf\u6027\u7fa4\uff0c\u5199\u505a GL_n\\mathbb{R} GL_n\\mathbb{R} \uff0c\u6216\u8005 GL(n, \\mathbb{R}) GL(n, \\mathbb{R}) \u3002 \u5bf9\u4e8e n \\geq 2 n \\geq 2 \u65f6\uff0c\u4e00\u822c\u7ebf\u6027\u7fa4\u4e3a\u975e\u963f\u8d1d\u5c14\u7fa4\u3002 \u5b9a\u4e49 2.3 - \u5411\u91cf\u7a7a\u95f4 \u5411\u91cf\u7a7a\u95f4 V = (\\mathcal{V}, +, \\cdot) V = (\\mathcal{V}, +, \\cdot) \u662f\u7531\u4e00\u4e2a\u96c6\u5408 \\mathcal{V} \\mathcal{V} \u4ee5\u53ca\u5728\u8fd9\u4e2a\u96c6\u5408\u4e0a\u5b9a\u4e49\u7684\u4e24\u4e2a\u8fd0\u7b97\uff1a + : \\mathcal{V} \\times \\mathcal{V} \\rightarrow \\mathcal{V} + : \\mathcal{V} \\times \\mathcal{V} \\rightarrow \\mathcal{V} \\cdot : \\mathbb{R} \\times \\mathcal{V} \\rightarrow \\mathcal{V} \\cdot : \\mathbb{R} \\times \\mathcal{V} \\rightarrow \\mathcal{V} \u4e14\u7b26\u5408\u4e0b\u5217\u56db\u4e2a\u6027\u8d28\u7684\u4ee3\u6570\u7ed3\u6784\uff1a V = (\\mathcal{V}, +) V = (\\mathcal{V}, +) \u662f\u4e00\u4e2a\u963f\u8d1d\u5c14\u7fa4\u3002 \u5206\u914d\u5f8b - a. \u5bf9\u4e8e\u6240\u6709 \\lambda \\in R \\lambda \\in R \uff0c x, y \\in \\mathcal{V} x, y \\in \\mathcal{V} \uff0c\u90fd\u6709 \\lambda \\cdot (x + y) = \\lambda \\cdot x + \\lambda \\cdot y \\lambda \\cdot (x + y) = \\lambda \\cdot x + \\lambda \\cdot y b. \u5bf9\u4e8e\u6240\u6709 \\lambda \\mu \\in R \\lambda \\mu \\in R \uff0c x \\in \\mathcal{V} x \\in \\mathcal{V} \uff0c\u90fd\u6709 (\\lambda + \\mu) \\cdot x) = \\lambda \\cdot x + \\mu \\cdot x (\\lambda + \\mu) \\cdot x) = \\lambda \\cdot x + \\mu \\cdot x \u7ed3\u5408\u5f8b - \u5bf9\u4e8e\u6240\u6709 \\lambda \\mu \\in R \\lambda \\mu \\in R \uff0c x \\in \\mathcal{V} x \\in \\mathcal{V} \uff0c\u90fd\u6709 \\lambda \\cdot (\\mu \\cdot x) = (\\lambda \\cdot \\mu) \\cdot x \\lambda \\cdot (\\mu \\cdot x) = (\\lambda \\cdot \\mu) \\cdot x \u5355\u4f4d\u5143 - \u5bf9\u4e8e\u6240\u6709 x \\in \\mathcal{V} x \\in \\mathcal{V} \uff0c\u90fd\u6709 1 \\cdot x = x 1 \\cdot x = x \u5b9a\u4e49 2.4 - \u5411\u91cf\u5b50\u7a7a\u95f4 \u5bf9\u4e8e\u5411\u91cf\u7a7a\u95f4 V = (\\mathcal{V}, +, \\cdot) V = (\\mathcal{V}, +, \\cdot) \uff0c\u82e5\u5411\u91cf\u7a7a\u95f4 U U \u6ee1\u8db3 \\mathcal{U} \\subseteq \\mathcal{V}, \\mathcal{U} \\neq \\emptyset \\mathcal{U} \\subseteq \\mathcal{V}, \\mathcal{U} \\neq \\emptyset \uff0c\u90a3\u4e48\u6211\u4eec\u79f0 U = (\\mathcal{U}, +, \\cdot) U = (\\mathcal{U}, +, \\cdot) \u662f V V \u7684\u5411\u91cf\u5b50\u7a7a\u95f4\u3002 \u5b9a\u4e49 2.5 - \u5f20\u6210\u4e0e\u751f\u6210\u96c6 \u5bf9\u4e8e\u5411\u91cf\u7a7a\u95f4 V = (\\mathcal{V}, +, \\cdot) V = (\\mathcal{V}, +, \\cdot) \u548c\u5411\u91cf\u96c6 \\mathcal{A} = \\{x_1, \\ldots, x_n\\} \\subseteq \\mathcal{V} \\mathcal{A} = \\{x_1, \\ldots, x_n\\} \\subseteq \\mathcal{V} \uff0c\u82e5\u6bcf\u4e00\u4e2a\u5411\u91cf \\mathcal{v} \\in \\mathcal{V} \\mathcal{v} \\in \\mathcal{V} \u90fd\u53ef\u4ee5\u8868\u793a\u4e3a x_1, \\ldots, x_n x_1, \\ldots, x_n \u7684\u7ebf\u6027\u7ec4\u5408\uff0c\u90a3\u4e48\u6211\u4eec\u79f0\u5411\u91cf\u96c6 A A \u662f\u5411\u91cf\u7a7a\u95f4 \\mathcal{V} \\mathcal{V} \u7684\u751f\u6210\u96c6\uff0c\u5411\u91cf\u96c6A \\mathcal{A} \\mathcal{A} \u7684\u5411\u91cf\u4eec\u7684\u7ebf\u6027\u7ec4\u5408\u6784\u6210\u7684\u96c6\u5408\u79f0\u4e3aA\u7684\u5f20\u6210\u3002 \u5b9a\u4e49 2.6 \u57fa \u5bf9\u4e8e\u5411\u91cf\u7a7a\u95f4 V = (\\mathcal{V}, +, \\cdot) V = (\\mathcal{V}, +, \\cdot) \u548c\u5411\u91cf\u7a7a\u95f4 V = (\\mathcal{V}, +, \\cdot) V = (\\mathcal{V}, +, \\cdot) \u7684\u751f\u6210\u96c6 \\mathcal{A} = \\{x_1, \\ldots, x_n\\} \\subseteq \\mathcal{V} \\mathcal{A} = \\{x_1, \\ldots, x_n\\} \\subseteq \\mathcal{V} \uff0c\u82e5\u4e0d\u5b58\u5728\u66f4\u5c0f\u7684\u96c6 B \\subset A \\subseteq \\mathcal{V} B \\subset A \\subseteq \\mathcal{V} \u5f20\u6210 \\mathcal{V} \\mathcal{V} \uff0c\u90a3\u4e48\u6211\u4eec\u79f0 \\mathcal{A} \\mathcal{A} \u4e3a\u6700\u5c0f\u751f\u6210\u96c6\u3002\u6bcf\u4e2a V V \u7684\u7ebf\u6027\u65e0\u5173\u7684\u751f\u6210\u96c6\u90fd\u662f\u6700\u5c0f\u7684\uff0c\u4e5f\u88ab\u79f0\u4e3a V V \u7684\u57fa\u3002","title":"\u5411\u91cf"},{"location":"math/probability/","text":"\u6982\u7387\u8d28\u91cf\u51fd\u6570 # \u6982\u7387\u5bc6\u5ea6\u51fd\u6570 # \u7d2f\u79ef\u5206\u5e03\u51fd\u6570 #","title":"\u6982\u7387"},{"location":"math/probability/#_1","text":"","title":"\u6982\u7387\u8d28\u91cf\u51fd\u6570"},{"location":"math/probability/#_2","text":"","title":"\u6982\u7387\u5bc6\u5ea6\u51fd\u6570"},{"location":"math/probability/#_3","text":"","title":"\u7d2f\u79ef\u5206\u5e03\u51fd\u6570"},{"location":"ml/distribution/","text":"\u672c\u6587\u4e2d\u6211\u4eec\u5c06\u8ba8\u8bba\u5206\u5e03\u3002 \u6982\u7387\u8d28\u91cf\u51fd\u6570\uff08Probability Mass Function\uff09 \u5bf9\u4e8e \u79bb\u6563\u76ee\u6807\u7a7a\u95f4 \\mathcal{T} \\mathcal{T} \uff0c\u6211\u4eec\u5c06 \u79bb\u6563\u968f\u673a\u53d8\u91cf X X \u4e3a\u67d0\u4e2a\u7279\u5b9a\u503c x \\in \\mathcal{T} x \\in \\mathcal{T} \u7684\u6982\u7387\u79f0\u4f5c\u5b83\u7684\u6982\u7387\u8d28\u91cf\u51fd\u6570\uff0c\u8bb0\u4f5c P(X = x) P(X = x) \u7d2f\u79ef\u5206\u5e03\u51fd\u6570\uff08Cumulative Distribution Function\uff09 \u5bf9\u4e8e \u8fde\u7eed\u76ee\u6807\u7a7a\u95f4 \\mathcal{T} \\mathcal{T} \uff0c\u6211\u4eec\u5c06 \u968f\u673a\u53d8\u91cf X X \u5728\u7279\u5b9a\u533a\u95f4 a, b \\in \\mathcal{T}, a \\leq b a, b \\in \\mathcal{T}, a \\leq b \u7684\u6982\u7387\u79f0\u4f5c\u5b83\u7684\u7d2f\u79ef\u5206\u5e03\u51fd\u6570\uff0c\u8bb0\u4f5c P(a \\leq X \\leq b) P(a \\leq X \\leq b) \u7d2f\u79ef\u5206\u5e03\u51fd\u6570\u662f\u6982\u7387\u5bc6\u5ea6\u51fd\u6570\uff08Probability Density Function\uff09\u7684\u79ef\u5206 \u6839\u636e\u60ef\u4f8b\uff0c\u6211\u4eec\u4e5f\u5c06 X X \u5c0f\u4e8e\u67d0\u4e2a\u7279\u5b9a\u503c x \\in \\mathcal{T} x \\in \\mathcal{T} \u8bb0\u4f5c P(X < x) P(X < x) \u79bb\u6563\u5206\u5e03 # \u8fb9\u7f18\u6982\u7387\uff08Marginal Probability\uff09 \u8fb9\u7f18\u6982\u7387\u5373\u4e3a\u6982\u7387\u8d28\u91cf\u51fd\u6570 \u6211\u4eec\u7528 X ~ P(X = x) X ~ P(X = x) \u6765\u8868\u793a X X \u4f9d\u636e P(X = x) P(X = x) \u5206\u5e03 \u8054\u5408\u6982\u7387\uff08Joint Probability\uff09 \u5bf9\u4e8e\u79bb\u6563\u76ee\u6807\u7a7a\u95f4 \\mathcal{T} \\mathcal{T} \uff0c\u6211\u4eec\u5c06\u79bb\u6563\u968f\u673a\u53d8\u91cf X, Y X, Y \u4e0e\u67d0\u4e24\u4e2a\u7279\u5b9a\u503c x, y \\in \\mathcal{T} x, y \\in \\mathcal{T} \u76f8\u7b49\uff0c\u5373 X = x, Y = y X = x, Y = y \u7684\u6982\u7387\u79f0\u4f5c\u5b83\u4eec\u7684\u8054\u5408\u6982\u7387\uff0c\u8bb0\u4f5c P(X = x, Y = y) P(X = x, Y = y) \u6839\u636e\u8d1d\u53f6\u65af\u5b9a\u7406\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230 P(X = x, Y = y) = P(X = x)P(X = x | Y = y) P(X = x, Y = y) = P(X = x)P(X = x | Y = y) \u6761\u4ef6\u6982\u7387\uff08Conditional Probability\uff09 \u5bf9\u4e8e\u79bb\u6563\u76ee\u6807\u7a7a\u95f4 \\mathcal{T} \\mathcal{T} \uff0c\u6211\u4eec\u5c06\u79bb\u6563\u968f\u673a\u53d8\u91cf X, Y X, Y \u4e0e\u67d0\u4e24\u4e2a\u7279\u5b9a\u503c x, y \\in \\mathcal{T} x, y \\in \\mathcal{T} \u5728 Y = y Y = y \u65f6 X = x X = x \u7684\u6982\u7387\u79f0\u4f5c\u6761\u4ef6\u6982\u7387\uff0c\u8bb0\u4f5c P(X = x | Y = y) P(X = x | Y = y) \u6839\u636e\u8d1d\u53f6\u65af\u5b9a\u7406\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230 P(X = x | Y = y) = \\frac{P(X = x, Y = y)}{(Y = y)} P(X = x | Y = y) = \\frac{P(X = x, Y = y)}{(Y = y)}","title":"\u5206\u5e03"},{"location":"ml/distribution/#_1","text":"\u8fb9\u7f18\u6982\u7387\uff08Marginal Probability\uff09 \u8fb9\u7f18\u6982\u7387\u5373\u4e3a\u6982\u7387\u8d28\u91cf\u51fd\u6570 \u6211\u4eec\u7528 X ~ P(X = x) X ~ P(X = x) \u6765\u8868\u793a X X \u4f9d\u636e P(X = x) P(X = x) \u5206\u5e03 \u8054\u5408\u6982\u7387\uff08Joint Probability\uff09 \u5bf9\u4e8e\u79bb\u6563\u76ee\u6807\u7a7a\u95f4 \\mathcal{T} \\mathcal{T} \uff0c\u6211\u4eec\u5c06\u79bb\u6563\u968f\u673a\u53d8\u91cf X, Y X, Y \u4e0e\u67d0\u4e24\u4e2a\u7279\u5b9a\u503c x, y \\in \\mathcal{T} x, y \\in \\mathcal{T} \u76f8\u7b49\uff0c\u5373 X = x, Y = y X = x, Y = y \u7684\u6982\u7387\u79f0\u4f5c\u5b83\u4eec\u7684\u8054\u5408\u6982\u7387\uff0c\u8bb0\u4f5c P(X = x, Y = y) P(X = x, Y = y) \u6839\u636e\u8d1d\u53f6\u65af\u5b9a\u7406\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230 P(X = x, Y = y) = P(X = x)P(X = x | Y = y) P(X = x, Y = y) = P(X = x)P(X = x | Y = y) \u6761\u4ef6\u6982\u7387\uff08Conditional Probability\uff09 \u5bf9\u4e8e\u79bb\u6563\u76ee\u6807\u7a7a\u95f4 \\mathcal{T} \\mathcal{T} \uff0c\u6211\u4eec\u5c06\u79bb\u6563\u968f\u673a\u53d8\u91cf X, Y X, Y \u4e0e\u67d0\u4e24\u4e2a\u7279\u5b9a\u503c x, y \\in \\mathcal{T} x, y \\in \\mathcal{T} \u5728 Y = y Y = y \u65f6 X = x X = x \u7684\u6982\u7387\u79f0\u4f5c\u6761\u4ef6\u6982\u7387\uff0c\u8bb0\u4f5c P(X = x | Y = y) P(X = x | Y = y) \u6839\u636e\u8d1d\u53f6\u65af\u5b9a\u7406\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230 P(X = x | Y = y) = \\frac{P(X = x, Y = y)}{(Y = y)} P(X = x | Y = y) = \\frac{P(X = x, Y = y)}{(Y = y)}","title":"\u79bb\u6563\u5206\u5e03"},{"location":"nlp/introduction/","text":"\u81ea\u7136\u8bed\u8a00\u5904\u7406\uff08Nature Language Processing (NLP)\uff09 # \u81ea\u7136\u8bed\u8a00\u5904\u7406\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\u4e0e\u8bed\u8a00\u5b66\u7684\u4ea4\u53c9\u5b66\u79d1\uff0c\u5b83\u4e3b\u8981\u5305\u62ec\u8ba4\u77e5\u3001\u7406\u89e3\u548c\u751f\u6210\u3002 \u201c\u81ea\u7136\u8bed\u8a00\u5904\u7406\u4eba\u5de5\u667a\u80fd\u7687\u51a0\u4e0a\u7684\u660e\u73e0\u201d \u2013 \u5468\u660e \u81ea\u7136\u8bed\u8a00\u5904\u7406\u76f8\u4fe1\u65e0\u9700\u6211\u518d\u8d58\u8ff0\uff0c\u5e7f\u4e3a\u4eba\u77e5\u7684\u56fe\u7075\u6d4b\u8bd5\u5b9e\u9645\u4e0a\u5c31\u662f\u6709\u5173\u81ea\u7136\u8bed\u8a00\u5904\u7406\u3002\u76f8\u6bd4\u4e8e\u5176\u4ed6\u9886\u57df\uff0c\u5728\u81ea\u7136\u8bed\u8a00\u5904\u7406\u65b9\u9762\u6211\u4eec\u8fd8\u6ca1\u6709\u5f88\u5927\u7684\u8fdb\u5c55\uff0c\u4f46\u4eceSiri\u5230\u73b0\u5728\u7684\u5c0f\u7231\uff0c\u81ea\u7136\u8bed\u8a00\u5904\u7406\u4e5f\u5df2\u7ecf\u8d8a\u6765\u8d8a\u591a\u7684\u8fdb\u5165\u6211\u4eec\u7684\u751f\u6d3b\u5f53\u4e2d\u3002 \u4e0e\u5f80\u5e38\u4e00\u6837\uff0c\u672c\u7ae0\u8282\u5c06\u4ece\u4f20\u7edf\u7684\u68c0\u7d22\u5f00\u59cb\u9010\u6e10\u6df1\u5165\uff0c\u6700\u7ec8\u5230\u8fbe\u6df1\u5ea6\u795e\u7ecf\u7f51\u7edc\u3002","title":"\u81ea\u7136\u8bed\u8a00\u5904\u7406"},{"location":"nlp/introduction/#nature-language-processing-nlp","text":"\u81ea\u7136\u8bed\u8a00\u5904\u7406\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\u4e0e\u8bed\u8a00\u5b66\u7684\u4ea4\u53c9\u5b66\u79d1\uff0c\u5b83\u4e3b\u8981\u5305\u62ec\u8ba4\u77e5\u3001\u7406\u89e3\u548c\u751f\u6210\u3002 \u201c\u81ea\u7136\u8bed\u8a00\u5904\u7406\u4eba\u5de5\u667a\u80fd\u7687\u51a0\u4e0a\u7684\u660e\u73e0\u201d \u2013 \u5468\u660e \u81ea\u7136\u8bed\u8a00\u5904\u7406\u76f8\u4fe1\u65e0\u9700\u6211\u518d\u8d58\u8ff0\uff0c\u5e7f\u4e3a\u4eba\u77e5\u7684\u56fe\u7075\u6d4b\u8bd5\u5b9e\u9645\u4e0a\u5c31\u662f\u6709\u5173\u81ea\u7136\u8bed\u8a00\u5904\u7406\u3002\u76f8\u6bd4\u4e8e\u5176\u4ed6\u9886\u57df\uff0c\u5728\u81ea\u7136\u8bed\u8a00\u5904\u7406\u65b9\u9762\u6211\u4eec\u8fd8\u6ca1\u6709\u5f88\u5927\u7684\u8fdb\u5c55\uff0c\u4f46\u4eceSiri\u5230\u73b0\u5728\u7684\u5c0f\u7231\uff0c\u81ea\u7136\u8bed\u8a00\u5904\u7406\u4e5f\u5df2\u7ecf\u8d8a\u6765\u8d8a\u591a\u7684\u8fdb\u5165\u6211\u4eec\u7684\u751f\u6d3b\u5f53\u4e2d\u3002 \u4e0e\u5f80\u5e38\u4e00\u6837\uff0c\u672c\u7ae0\u8282\u5c06\u4ece\u4f20\u7edf\u7684\u68c0\u7d22\u5f00\u59cb\u9010\u6e10\u6df1\u5165\uff0c\u6700\u7ec8\u5230\u8fbe\u6df1\u5ea6\u795e\u7ecf\u7f51\u7edc\u3002","title":"\u81ea\u7136\u8bed\u8a00\u5904\u7406\uff08Nature Language Processing (NLP)\uff09"},{"location":"nlp/tf-idf/","text":"tf-idf # tf-idf\u662f\u4e00\u79cd\u5e38\u7528\u7684\u52a0\u6743\u7b97\u6cd5\uff0c\u7528\u4e8e\u6316\u6398\u6587\u7ae0\u4e2d\u7684\u5173\u952e\u8bcd\u5341\u5206\u6709\u6548\u3002","title":"tf-idf"},{"location":"nlp/tf-idf/#tf-idf","text":"tf-idf\u662f\u4e00\u79cd\u5e38\u7528\u7684\u52a0\u6743\u7b97\u6cd5\uff0c\u7528\u4e8e\u6316\u6398\u6587\u7ae0\u4e2d\u7684\u5173\u952e\u8bcd\u5341\u5206\u6709\u6548\u3002","title":"tf-idf"},{"location":"nlp/word_processing/","text":"\u6587\u672c\u5904\u7406\uff08Text Processing\uff09 # \u5f88\u591a\u65f6\u5019\uff0c\u81ea\u7136\u8bed\u8a00\u5904\u7406\u7684\u7b2c\u4e00\u6b65\u603b\u662f\u6587\u672c\u5904\u7406\u3002\u968f\u540e\u6211\u4eec\u518d\u5bf9\u5b8c\u6210\u6587\u672c\u5904\u7406\u540e\u7684\u5185\u5bb9\u8fdb\u884c\u8fdb\u4e00\u6b65\u64cd\u4f5c\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u6587\u672c\u5904\u7406\u53ef\u4ee5\u5206\u6210\u4ee5\u4e0b\u56db\u4e2a\u6b65\u9aa4\uff1a \u5206\u8bcd\uff08Tokenization\uff09 \u5f52\u4e00\u5316\uff08Normalization\uff09 \u8bcd\u5e72\u63d0\u53d6\uff08Stemming\uff09\u548c\u8bcd\u5f62\u8fd8\u539f\uff08Lemmatization\uff09 \u505c\u7528\u8bcd\uff08Stop Word\uff09 \u6211\u4eec\u4f1a\u5728\u63a5\u4e0b\u6765\u9010\u4e2a\u8ba8\u8bba\u3002 \u5206\u8bcd\uff08Tokenization\uff09 # \u5206\u8bcd\u6307\u7684\u662f\u5c06\u5b57\u7b26\u4e32\u7684\u5e8f\u5217\u5206\u5272\u6210\u4e00\u4e2a\u4e00\u4e2a\u5355\u8bcd\u3002 \u542c\u8d77\u6765\u8fd9\u4e2a\u5f88\u7b80\u5355\uff0c\u5c24\u5176\u662f\u9488\u5bf9\u82f1\u8bed\u8fd9\u6837\u6700\u5c0f\u5355\u4f4d\u4e3a\u5355\u8bcd\u7684\u8bed\u8a00\u6765\u8bf4\u3002 str.split() \u4e86\u4e0d\u5c31\u5f97\u4e86\u4e48\uff1f\u4f46\u8fd9\u6837\u7684\u5206\u8bcd\u4f1a\u5bfc\u81f4\u8bcd\u5e8f\u7684\u4e22\u5931\uff0c\u6211\u4eec\u4e5f\u5c06\u8fd9\u6837\u5206\u8bcd\u7684\u7ed3\u679c\u79f0\u4e3a\u8bcd\u888b\u6a21\u578b\uff08bag-of-words model\uff09\u2013\u88c5\u6ee1\u4e00\u5806\u5355\u8bcd\u7684\u888b\u5b50\uff0c\u975e\u5e38\u5f62\u8c61\u3002\u8fd9\u4e2a\u6a21\u578b\u5bf9\u4e8e\u4fe1\u606f\u68c0\u7d22\u6765\u8bf4\u8fd8\u5f88\u6709\u7528\uff0c\u4f46\u5bf9\u4e8e\u81ea\u7136\u8bed\u8a00\u5904\u7406\u6765\u8bf4\uff0c\u8fd8\u5dee\u4e86\u4e9b\u4ec0\u4e48\u3002 \u5f52\u4e00\u5316\uff08Normalization\uff09 # \u5f52\u4e00\u5316\u6307\u7684\u662f\u5c06\u5355\u8bcd\u7684\u4e0d\u540c\u5f62\u6001\u751a\u81f3\u4e8e\u540c\u4e49\u7684\u4e0d\u540c\u5355\u8bcd\u8fdb\u884c\u5408\u5e76\u3002 \u8bcd\u5e72\u63d0\u53d6\uff08Stemming\uff09\u548c\u8bcd\u5f62\u8fd8\u539f\uff08Lemmatization\uff09 # \u8bcd\u5e72\u63d0\u53d6\uff08Stemming\uff09\u548c\u8bcd\u5f62\u8fd8\u539f\uff08Lemmatization\uff09\u975e\u5e38\u76f8\u4f3c\uff0c\u4ed6\u4eec\u7684\u76ee\u6807\u90fd\u662f\u5c06\u5355\u8bcd\u7684\u5c48\u6298\u5f62\u6001\u6216\u6d3e\u751f\u5f62\u6001\u7b80\u5316\u6216\u5f52\u5e76\u4e3a\u8bcd\u5e72\uff08stem\uff09\u3002\u5bf9\u4e8e\u5355\u8bcd\u62e5\u6709\u5355\u590d\u6570\u5f62\u5f0f\u4ee5\u53ca\u8bed\u6001\u53d8\u5316\u7684\u8bed\u8a00\u6765\u8bf4\uff0c\u8fd9\u4e2a\u6b65\u9aa4\u662f\u5341\u5206\u5fc5\u8981\u7684\u3002\u4f46\u5bf9\u4e8e\u4ec0\u4e48\u90fd\u6ca1\u6709\u7684\u4e2d\u6587\u6765\u8bf4\uff0c\u8fd8\u662f\u76f4\u63a5\u8df3\u5230\u4e0b\u4e00\u6b65\u7684\u505c\u7528\u8bcd\u66f4\u5b9e\u5728\u4e00\u4e9b\u3002 \u8bcd\u5e72\u63d0\u53d6 \u8bcd\u5e72\u63d0\u53d6\u4e3b\u8981\u901a\u8fc7\u5bf9\u5355\u8bcd\u8fdb\u884c\u7f29\u51cf\u800c\u8fbe\u5230\u76ee\u6807\u3002\u90e8\u5206\u60c5\u51b5\u4e0b\uff0c\u7f29\u51cf\u540e\u7684\u5355\u8bcd\u5c06\u4e0d\u518d\u662f\u8be5\u8bed\u8a00\u7684\u5355\u8bcd\u4e4b\u4e00\uff0c\u8fd9\u4f7f\u5f97\u5176\u7c92\u5ea6\u76f8\u5bf9\u66f4\u7c97\u3002\u6240\u4ee5\u8bcd\u5e72\u63d0\u53d6\u4e3b\u8981\u5e94\u7528\u4e8e\u4fe1\u606f\u68c0\u7d22\u9886\u57df\u3002 \u8bcd\u5f62\u8fd8\u539f \u8bcd\u5f62\u8fd8\u539f\u4e3b\u8981\u901a\u8fc7\u5c06\u5355\u8bcd\u8fd8\u539f\u56de\u539f\u5f62\u800c\u8fbe\u5230\u76ee\u6807\u3002\u76f8\u6bd4\u800c\u8a00\uff0c\u8fd9\u5c06\u8981\u590d\u6742\u4e0d\u5c11\uff0c\u4f46\u7ed3\u679c\u4e00\u5b9a\u662f\u5b57\u5178\u5f53\u4e2d\u5b58\u5728\u7684\u8bcd\u6c47\uff0c\u7c92\u5ea6\u66f4\u7ec6\u3002\u6240\u4ee5\u8bcd\u5f62\u8fd8\u539f\u4e3b\u8981\u5e94\u7528\u4e8e\u81ea\u7136\u8bed\u8a00\u5904\u7406\u9886\u57df\u3002 \u505c\u7528\u8bcd # \u505c\u7528\u8bcd\u6307\u7684\u662f\u4e2d\u6587\u5f53\u4e2d\u7684\u201c\u7684\u201d\u3001\u201c\u5417\u201d\u7b49\u7b49\uff0c\u82f1\u6587\u5f53\u4e2d\u7684\u201cthe\u201d\u3001\u201ca\u201d\u3001\u201can\u201d\u3001\u201cto\u201d\u3001\u201cof\u201d\u7b49\u8bcd\u8bed\u3002\u8fd9\u4e9b\u8bcd\u4f1a\u5728\u6587\u7ae0\u5f53\u4e2d\u5927\u91cf\u51fa\u73b0\uff0c\u800c\u5b9e\u9645\u4e0a\u5bf9\u4e8e\u8ba1\u7b97\u673a\u6765\u8bf4\u5374\u5f88\u5c11\u6709\u610f\u4e49\u3002\u901a\u5e38\u60c5\u51b5\u4e0b\u6211\u4eec\u90fd\u4f1a\u9009\u62e9\u5c06\u5176\u5ffd\u7565\u6389\u4ee5\u63d0\u9ad8\u6027\u80fd\u3002","title":"\u6587\u672c\u5904\u7406"},{"location":"nlp/word_processing/#text-processing","text":"\u5f88\u591a\u65f6\u5019\uff0c\u81ea\u7136\u8bed\u8a00\u5904\u7406\u7684\u7b2c\u4e00\u6b65\u603b\u662f\u6587\u672c\u5904\u7406\u3002\u968f\u540e\u6211\u4eec\u518d\u5bf9\u5b8c\u6210\u6587\u672c\u5904\u7406\u540e\u7684\u5185\u5bb9\u8fdb\u884c\u8fdb\u4e00\u6b65\u64cd\u4f5c\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u6587\u672c\u5904\u7406\u53ef\u4ee5\u5206\u6210\u4ee5\u4e0b\u56db\u4e2a\u6b65\u9aa4\uff1a \u5206\u8bcd\uff08Tokenization\uff09 \u5f52\u4e00\u5316\uff08Normalization\uff09 \u8bcd\u5e72\u63d0\u53d6\uff08Stemming\uff09\u548c\u8bcd\u5f62\u8fd8\u539f\uff08Lemmatization\uff09 \u505c\u7528\u8bcd\uff08Stop Word\uff09 \u6211\u4eec\u4f1a\u5728\u63a5\u4e0b\u6765\u9010\u4e2a\u8ba8\u8bba\u3002","title":"\u6587\u672c\u5904\u7406\uff08Text Processing\uff09"},{"location":"nlp/word_processing/#tokenization","text":"\u5206\u8bcd\u6307\u7684\u662f\u5c06\u5b57\u7b26\u4e32\u7684\u5e8f\u5217\u5206\u5272\u6210\u4e00\u4e2a\u4e00\u4e2a\u5355\u8bcd\u3002 \u542c\u8d77\u6765\u8fd9\u4e2a\u5f88\u7b80\u5355\uff0c\u5c24\u5176\u662f\u9488\u5bf9\u82f1\u8bed\u8fd9\u6837\u6700\u5c0f\u5355\u4f4d\u4e3a\u5355\u8bcd\u7684\u8bed\u8a00\u6765\u8bf4\u3002 str.split() \u4e86\u4e0d\u5c31\u5f97\u4e86\u4e48\uff1f\u4f46\u8fd9\u6837\u7684\u5206\u8bcd\u4f1a\u5bfc\u81f4\u8bcd\u5e8f\u7684\u4e22\u5931\uff0c\u6211\u4eec\u4e5f\u5c06\u8fd9\u6837\u5206\u8bcd\u7684\u7ed3\u679c\u79f0\u4e3a\u8bcd\u888b\u6a21\u578b\uff08bag-of-words model\uff09\u2013\u88c5\u6ee1\u4e00\u5806\u5355\u8bcd\u7684\u888b\u5b50\uff0c\u975e\u5e38\u5f62\u8c61\u3002\u8fd9\u4e2a\u6a21\u578b\u5bf9\u4e8e\u4fe1\u606f\u68c0\u7d22\u6765\u8bf4\u8fd8\u5f88\u6709\u7528\uff0c\u4f46\u5bf9\u4e8e\u81ea\u7136\u8bed\u8a00\u5904\u7406\u6765\u8bf4\uff0c\u8fd8\u5dee\u4e86\u4e9b\u4ec0\u4e48\u3002","title":"\u5206\u8bcd\uff08Tokenization\uff09"},{"location":"nlp/word_processing/#normalization","text":"\u5f52\u4e00\u5316\u6307\u7684\u662f\u5c06\u5355\u8bcd\u7684\u4e0d\u540c\u5f62\u6001\u751a\u81f3\u4e8e\u540c\u4e49\u7684\u4e0d\u540c\u5355\u8bcd\u8fdb\u884c\u5408\u5e76\u3002","title":"\u5f52\u4e00\u5316\uff08Normalization\uff09"},{"location":"nlp/word_processing/#stemminglemmatization","text":"\u8bcd\u5e72\u63d0\u53d6\uff08Stemming\uff09\u548c\u8bcd\u5f62\u8fd8\u539f\uff08Lemmatization\uff09\u975e\u5e38\u76f8\u4f3c\uff0c\u4ed6\u4eec\u7684\u76ee\u6807\u90fd\u662f\u5c06\u5355\u8bcd\u7684\u5c48\u6298\u5f62\u6001\u6216\u6d3e\u751f\u5f62\u6001\u7b80\u5316\u6216\u5f52\u5e76\u4e3a\u8bcd\u5e72\uff08stem\uff09\u3002\u5bf9\u4e8e\u5355\u8bcd\u62e5\u6709\u5355\u590d\u6570\u5f62\u5f0f\u4ee5\u53ca\u8bed\u6001\u53d8\u5316\u7684\u8bed\u8a00\u6765\u8bf4\uff0c\u8fd9\u4e2a\u6b65\u9aa4\u662f\u5341\u5206\u5fc5\u8981\u7684\u3002\u4f46\u5bf9\u4e8e\u4ec0\u4e48\u90fd\u6ca1\u6709\u7684\u4e2d\u6587\u6765\u8bf4\uff0c\u8fd8\u662f\u76f4\u63a5\u8df3\u5230\u4e0b\u4e00\u6b65\u7684\u505c\u7528\u8bcd\u66f4\u5b9e\u5728\u4e00\u4e9b\u3002 \u8bcd\u5e72\u63d0\u53d6 \u8bcd\u5e72\u63d0\u53d6\u4e3b\u8981\u901a\u8fc7\u5bf9\u5355\u8bcd\u8fdb\u884c\u7f29\u51cf\u800c\u8fbe\u5230\u76ee\u6807\u3002\u90e8\u5206\u60c5\u51b5\u4e0b\uff0c\u7f29\u51cf\u540e\u7684\u5355\u8bcd\u5c06\u4e0d\u518d\u662f\u8be5\u8bed\u8a00\u7684\u5355\u8bcd\u4e4b\u4e00\uff0c\u8fd9\u4f7f\u5f97\u5176\u7c92\u5ea6\u76f8\u5bf9\u66f4\u7c97\u3002\u6240\u4ee5\u8bcd\u5e72\u63d0\u53d6\u4e3b\u8981\u5e94\u7528\u4e8e\u4fe1\u606f\u68c0\u7d22\u9886\u57df\u3002 \u8bcd\u5f62\u8fd8\u539f \u8bcd\u5f62\u8fd8\u539f\u4e3b\u8981\u901a\u8fc7\u5c06\u5355\u8bcd\u8fd8\u539f\u56de\u539f\u5f62\u800c\u8fbe\u5230\u76ee\u6807\u3002\u76f8\u6bd4\u800c\u8a00\uff0c\u8fd9\u5c06\u8981\u590d\u6742\u4e0d\u5c11\uff0c\u4f46\u7ed3\u679c\u4e00\u5b9a\u662f\u5b57\u5178\u5f53\u4e2d\u5b58\u5728\u7684\u8bcd\u6c47\uff0c\u7c92\u5ea6\u66f4\u7ec6\u3002\u6240\u4ee5\u8bcd\u5f62\u8fd8\u539f\u4e3b\u8981\u5e94\u7528\u4e8e\u81ea\u7136\u8bed\u8a00\u5904\u7406\u9886\u57df\u3002","title":"\u8bcd\u5e72\u63d0\u53d6\uff08Stemming\uff09\u548c\u8bcd\u5f62\u8fd8\u539f\uff08Lemmatization\uff09"},{"location":"nlp/word_processing/#_1","text":"\u505c\u7528\u8bcd\u6307\u7684\u662f\u4e2d\u6587\u5f53\u4e2d\u7684\u201c\u7684\u201d\u3001\u201c\u5417\u201d\u7b49\u7b49\uff0c\u82f1\u6587\u5f53\u4e2d\u7684\u201cthe\u201d\u3001\u201ca\u201d\u3001\u201can\u201d\u3001\u201cto\u201d\u3001\u201cof\u201d\u7b49\u8bcd\u8bed\u3002\u8fd9\u4e9b\u8bcd\u4f1a\u5728\u6587\u7ae0\u5f53\u4e2d\u5927\u91cf\u51fa\u73b0\uff0c\u800c\u5b9e\u9645\u4e0a\u5bf9\u4e8e\u8ba1\u7b97\u673a\u6765\u8bf4\u5374\u5f88\u5c11\u6709\u610f\u4e49\u3002\u901a\u5e38\u60c5\u51b5\u4e0b\u6211\u4eec\u90fd\u4f1a\u9009\u62e9\u5c06\u5176\u5ffd\u7565\u6389\u4ee5\u63d0\u9ad8\u6027\u80fd\u3002","title":"\u505c\u7528\u8bcd"},{"location":"optimisation/affine_convex/","text":"\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u7b80\u8981\u4ecb\u7ecd\u4eff\u5c04\u548c\u51f8\u7684\u6982\u5ff5\u3002 \u4eff\u5c04 # \u76f4\u7ebf\u7684\u5b9a\u4e49\u60f3\u5fc5\u521d\u4e2d\u90fd\u5df2\u7ecf\u5b66\u8fc7\uff0c\u8fd9\u91cc\u6211\u4eec\u7b80\u5355\u590d\u4e60\u4e00\u4e0b\uff1a \u76f4\u7ebf\uff08line\uff09 \u7a7a\u95f4 \\mathbb{R}^n \\mathbb{R}^n \u4e2d\u7684\u4e24\u4e2a\u70b9 x_1, x_2, x_1 \\neq x_2 x_1, x_2, x_1 \\neq x_2 \u53ef\u4ee5\u552f\u4e00\u786e\u5b9a\u4e00\u6761\u76f4\u7ebf\u3002\u8fd9\u6761\u76f4\u7ebf\u53ef\u4ee5\u88ab\u53c2\u6570\u5316\u7684\u63cf\u8ff0\u4e3a x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ \\theta \\in \\mathbb{R} x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ \\theta \\in \\mathbb{R} \u6211\u4eec\u5f88\u5bb9\u6613\u53d1\u73b0\uff0c x = x_1 x = x_1 \u65f6\uff0c \\theta = 1 \\theta = 1 \uff1b x = x_2 x = x_2 \u65f6\uff0c \\theta = 0 \\theta = 0 \u3002\u7531\u6b64\uff0c\u6211\u4eec\u77e5\u9053\u4e86\u7ebf\u6bb5\u88ab\u5982\u4f55\u63cf\u8ff0\uff1a \u7ebf\u6bb5\uff08line segment\uff09 \u7a7f\u8fc7\u4e24\u70b9 x_1, x_2 \\in \\mathbb{R}^n, x_1 \\neq x_2 x_1, x_2 \\in \\mathbb{R}^n, x_1 \\neq x_2 \u7684\u7ebf\u6bb5\u53ef\u4ee5\u88ab\u53c2\u6570\u5316\u7684\u63cf\u8ff0\u4e3a x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ 0 \\leq \\theta \\leq 1 x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ 0 \\leq \\theta \\leq 1 \u901a\u8fc7\u53d8\u5316\uff0c\u76f4\u7ebf\u8fd8\u53ef\u4ee5\u88ab\u8868\u8fbe\u4e3a x = x_2 + \\theta (x_1 - x_2) \\ s.t. \\ \\theta \\in \\mathbb{R} x = x_2 + \\theta (x_1 - x_2) \\ s.t. \\ \\theta \\in \\mathbb{R} \u3002\u8fd9\u7ed9\u4e86\u6211\u4eec\u53e6\u4e00\u79cd\u89e3\u8bfb\u2013 x x \u662f \u57fa\u70b9 x_2 x_2 \u4e0e \u65b9\u5411 x_1 - x_2 x_1 - x_2 \u6309\u53c2\u6570 \\theta \\theta \u7f29\u653e\u4e4b\u548c\u3002 \u56e0\u6b64\uff0c \\theta \\theta \u7ed9\u51fa\u4e86\u4ece x_2 x_2 \u5230 x_1 x_1 \u7684\u5206\u6570\u3002\u5f53 \\theta \\theta \u4ece0\u589e\u5927\u52301\u65f6\uff0c\u70b9 x x \u4ece x_2 x_2 \u79fb\u52a8\u5230 x_1 x_1 \uff1b\u5f53 \\theta \\theta \u5728\u6b64\u533a\u95f4\u4ee5\u5916\u65f6\uff0c\u70b9 x x \u4f4d\u4e8e x_1 x_1 \u5230 x_2 x_2 \u4ee5\u5916\u7684\u7ebf\u4e0a\u3002 \u5728\u590d\u4e60\u4e86\u76f4\u7ebf\u4e4b\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u7ed9\u4eff\u5c04\u96c6\u505a\u4e00\u4e2a\u5b9a\u4e49\uff1a \u4eff\u5c04\u96c6 \u5bf9\u4e8e\u96c6\u5408 C \\subseteq \\mathbb{R} C \\subseteq \\mathbb{R} \uff0c\u82e5\u7ecf\u8fc7\u8be5\u96c6\u5408\u4e0a\u4efb\u610f\u4e24\u70b9 x_1, x_2 \\in C, x_1 \\neq x_2 x_1, x_2 \\in C, x_1 \\neq x_2 \u7684\u76f4\u7ebf\u4e0a\u7684\u70b9\u90fd\u5728\u8be5\u96c6\u5408\u4e2d\uff0c\u90a3\u4e48\u6211\u4eec\u79f0\u96c6\u5408 C C \u4e3a\u4e00\u4e2a\u4eff\u5c04\u96c6\u3002 \u7ebf\u6027\u65b9\u7a0b \\{x \\mid Ax = b\\} \\{x \\mid Ax = b\\} \u7684\u89e3\u5373\u662f\u4e00\u4e2a\u4eff\u5c04\u96c6\uff0c\u53cd\u8fc7\u6765\u6bcf\u4e00\u4e2a\u4eff\u5c04\u96c6\u4e5f\u90fd\u53ef\u4ee5\u8868\u793a\u4e3a\u4e00\u4e2a\u7ebf\u6027\u65b9\u7a0b\u7cfb\u7edf\u7684\u89e3\u96c6\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u6709\u65f6\u5019\u5c06\u4eff\u5c04\u96c6\u6210\u4e3a\u7ebf\u6027\uff08linear\uff09\u3002 \u6709\u540c\u5b66\u53ef\u4ee5\u53d1\u73b0\uff0c\u4eff\u5c04\u96c6\u4e0e\u7ebf\u6027\u5b50\u7a7a\u95f4\u975e\u5e38\u76f8\u4f3c\u3002\u4e8b\u5b9e\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u4e00\u4e2a\u4eff\u5c04\u96c6\u770b\u4f5c\u662f\u4e00\u4e2a\u7ebf\u6027\u5b50\u7a7a\u95f4\u6839\u636e\u4e00\u4e2a\u56fa\u5b9a\u5411\u91cf\u5e73\u79fb\u800c\u5f97\u5230\u7684\u3002\u5bf9\u4e8e\u4eff\u5c04\u96c6 C C \u4e0e\u5176\u4e0a\u4e00\u70b9 x_0 x_0 \uff0c\u96c6\u5408 V = C - x_0 = \\{x - x_0 \\mid x \\in C\\} V = C - x_0 = \\{x - x_0 \\mid x \\in C\\} \u662f\u4e00\u4e2a\u5b50\u7a7a\u95f4\u3002 \u8bc1\u660e V = C - x_0 V = C - x_0 \u5bf9\u4e8e\u5411\u91cf\u52a0\u6cd5\u4e0e\u6807\u91cf\u4e58\u6cd5\u95ed\u5408 \u5bf9\u4e8e v_1, v_2 \\in V, \\alpha, \\beta \\in \\mathbb{R} v_1, v_2 \\in V, \\alpha, \\beta \\in \\mathbb{R} \uff0c\u6211\u4eec\u6709 v_1 + x_0, v_2 + x_0 \\in C v_1 + x_0, v_2 + x_0 \\in C \uff0c\u6240\u4ee5 \\alpha v_1 + \\beta v_2 + x_0 = \\alpha (v_1 + x_0) + \\beta (v_2 + x_0) + (1 -\\alpha - \\beta) x_0 \\in C \\alpha v_1 + \\beta v_2 + x_0 = \\alpha (v_1 + x_0) + \\beta (v_2 + x_0) + (1 -\\alpha - \\beta) x_0 \\in C \uff0c\u7531\u4e8e C C \u662f\u4eff\u5c04\u96c6\u3001 \\alpha + \\beta + (1 -\\alpha - \\beta) = 1, \\alpha v_1 + \\beta v_2 + x_0 \\in C \\alpha + \\beta + (1 -\\alpha - \\beta) = 1, \\alpha v_1 + \\beta v_2 + x_0 \\in C \uff0c\u6613\u5f97 \\alpha v_1 + \\beta v_2 \\in V \\alpha v_1 + \\beta v_2 \\in V \u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u4eff\u5c04\u96c6 C C \u8868\u8ff0\u4e3a C = V + x_0 = \\{v + x_0 \\mid v \\in V\\} C = V + x_0 = \\{v + x_0 \\mid v \\in V\\} \uff0c x_0 x_0 \u4e3a C C \u4e0a\u4efb\u610f\u4e00\u70b9\u3002\u6211\u4eec\u5c06\u5b50\u7a7a\u95f4 V V \u79f0\u4f5c\u4eff\u5c04\u96c6 C C \u76f8\u5173\u7684\u5b50\u7a7a\u95f4\uff0c\u5c06\u5b50\u7a7a\u95f4 V V \u7684\u7ef4\u5ea6\u79f0\u4f5c\u4eff\u5c04\u96c6 C C \u7684\u7ef4\u5ea6\u3002 \u7b80\u5355\u4e86\u89e3\u4e86\u76f4\u7ebf\u4e0e\u4eff\u5c04\u96c6\u4e4b\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u5ef6\u4f38\u51fa\u4eff\u5c04\u7ec4\u5408\uff1a \u4eff\u5c04\u7ec4\u5408\uff08affine combination\uff09 \u5bf9\u4e8e\u7ebf\u6027\u7ec4\u5408 \\sum_{i=1}^n \\theta_i x_i \\sum_{i=1}^n \\theta_i x_i \uff0c\u82e5\u5176\u6ee1\u8db3 \\sum_{i=1}^n \\theta_i = 1 \\sum_{i=1}^n \\theta_i = 1 \u5219\u6211\u4eec\u79f0\u5176\u4e3a\u4eff\u5c04\u7ec4\u5408\u3002 \u4eff\u5c04\u96c6 C C \u5305\u542b\u4e86\u8be5\u96c6\u5408\u4e2d\u4efb\u610f\u70b9\u7684\u4eff\u5c04\u7ec4\u5408\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u5bf9\u4e8e x_1, x_2, x_n \\in C, \\sum_{i=1}^n \\theta_i = 1 x_1, x_2, x_n \\in C, \\sum_{i=1}^n \\theta_i = 1 \uff0c \\sum_{i=1}^n \\theta_i x_i \\in C \\sum_{i=1}^n \\theta_i x_i \\in C \u3002 \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u4eff\u5c04\u7ec4\u5408\u5176\u5b9e\u53ef\u4ee5\u88ab\u770b\u6210\u4e00\u4e2a\u6240\u6709\u7cfb\u6570\u4e4b\u548c\u4e3a1\u7684\u7279\u6b8a\u7684\u7ebf\u6027\u7ec4\u5408\u3002\u8fd9\u6837\u7684\u7279\u6027\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u629b\u5f03\u539f\u70b9\uff0c\u800c\u5c06\u4efb\u610f\u7684\u70b9\u89c6\u4e3a\u539f\u70b9\uff0c\u6211\u4eec\u90fd\u53ef\u4ee5\u4f7f\u7528\u540c\u6837\u7684\u7ebf\u6027\u7ec4\u5408\u53bb\u63cf\u8ff0\u540c\u4e00\u4e2a\u70b9\u3002 \ud83c\udf30 \u5bf9\u4e8e\u539f\u70b9\u4ee5\u53ca\u7a7a\u95f4\u4e0a\u4efb\u610f\u4e00\u70b9 p p \uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5411\u91cf a,\\ b a,\\ b \u5206\u522b\u8868\u8ff0\u4e3a a + b a + b \u4e0e p + (a - p) + (b - p) p + (a - p) + (b - p) \u3002\u7531\u6b64\uff0c\u6211\u4eec\u901a\u8fc7\u4eff\u5c04\u7ec4\u5408\u53bb\u63cf\u8ff0\u53e6\u4e00\u70b9\u65f6\uff0c\u4e24\u4e2a\u63cf\u8ff0\u5206\u522b\u4e3a \\theta a + (1 - \\theta) b \\theta a + (1 - \\theta) b \u4e0e p + \\theta (a - p) + (1 - \\theta) (b - p) = p + \\theta a - \\theta p + (1 - \\theta) b - (1 - \\theta) p = \\theta a + (1 - \\theta) b p + \\theta (a - p) + (1 - \\theta) (b - p) = p + \\theta a - \\theta p + (1 - \\theta) b - (1 - \\theta) p = \\theta a + (1 - \\theta) b \uff1b\u6211\u4eec\u5f88\u5bb9\u6613\u53d1\u73b0\u4e24\u4e2a\u63cf\u8ff0\u4e0e\u5176\u8d77\u59cb\u70b9\u6ca1\u6709\u5173\u7cfb\u3002 \u96c6\u5408 S S \u7684\u4eff\u5c04\u5305 aff(S) aff(S) \u6307\u7684\u662f\u5305\u542b\u96c6\u5408 S S \u7684\u6700\u5c0f\u4eff\u5c04\u96c6\uff0c\u5b83\u88ab\u5b9a\u4e49\u4e3a: \u4eff\u5c04\u5305\uff08affine hull\uff09 aff(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, x_i \\in S, \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} aff(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, x_i \\in S, \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} \u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u4eff\u5c04\u96c6 C C \u6709 S \\subseteq C S \\subseteq C \uff0c\u90a3\u4e48 aff(S) \\subseteq C aff(S) \\subseteq C \u3002 \u51f8 # \u6211\u4eec\u6ce8\u610f\u5230\u5230\u73b0\u5728\u4e3a\u6b62\u6211\u4eec\u4e00\u76f4\u5728\u8ba8\u8bba\u4eff\u5c04\uff0c\u800c\u6ca1\u6709\u8fdb\u5165\u771f\u6b63\u7684\u4e3b\u9898\u2013\u51f8\u3002\u4e8b\u5b9e\u4e0a\uff0c\u6211\u4eec\u5df2\u7ecf\u5dee\u4e0d\u591a\u5b66\u4e60\u4e86\u51f8\u7684\u6240\u6709\u6982\u5ff5\u4e86\u2013\u4ec5\u4ec5\u5c06\u4eff\u5c04\u7684\u76f4\u7ebf\u6362\u6210\u7ebf\u6bb5\uff0c\u6211\u4eec\u5c31\u80fd\u5f97\u5230\u51f8\u3002 \u51f8\u96c6 \u5bf9\u4e8e\u96c6\u5408 C \\subseteq \\mathbb{R} C \\subseteq \\mathbb{R} \uff0c\u82e5\u7ecf\u8fc7\u8be5\u96c6\u5408\u4e0a\u4efb\u610f\u4e24\u70b9 x_1, x_2 \\in C, x_1 \\neq x_2 x_1, x_2 \\in C, x_1 \\neq x_2 \u7684 \u7ebf\u6bb5 \u4e0a\u7684\u70b9\u90fd\u5728\u8be5\u96c6\u5408\u4e2d\uff0c\u90a3\u4e48\u6211\u4eec\u79f0\u96c6\u5408 C C \u4e3a\u4e00\u4e2a\u51f8\u96c6\u3002 \u51f8\u7ec4\u5408\uff08convex combination\uff09 \u5bf9\u4e8e\u7ebf\u6027\u7ec4\u5408 \\sum_{i=1}^n \\theta_i x_i \\sum_{i=1}^n \\theta_i x_i \uff0c\u82e5\u5176\u6ee1\u8db3 \\sum_{i=1}^n \\theta_i = 1 \\sum_{i=1}^n \\theta_i = 1 \u5e76\u4e14 \\forall \\theta_i, \\theta_i \\geq 0 \\forall \\theta_i, \\theta_i \\geq 0 \u5219\u6211\u4eec\u79f0\u5176\u4e3a\u51f8\u7ec4\u5408\u3002 \u51f8\u5305\uff08convex hull\uff09 conv(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, conv(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, x_i \\geq 0 x_i \\geq 0 , \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} , \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} | \u6211\u4eec\u5f88\u5bb9\u6613\u60f3\u5230\uff0c\u5e38\u89c1\u7684\u4e09\u89d2\u5f62\u3001\u65b9\u5f62\u3001\u5706\u5f62\u90fd\u662f\u51f8\u7684\uff1b\u800c\u661f\u5f62\u5219\u662f\u975e\u51f8\u7684\uff0c\u56e0\u4e3a\u4efb\u610f\u4e24\u70b9\u4e4b\u95f4\u5b58\u5728\u6709\u4e9b\u70b9\u4e0d\u5728\u96c6\u5408\u4e4b\u5185\u3002 \u975e\u51f8\u96c6\u4e94\u89d2\u661f\u7684\u51f8\u5305\u662f \u51f8\u96c6\u4e94\u8fb9\u5f62\u3002 \u5982\u4f55\u5224\u65ad\u4e00\u4e2a\u51fd\u6570\u662f\u5426\u662f\u51f8\u7684 \u8fd9\u4e2a\u95ee\u9898\u770b\u4f3c\u5341\u5206\u7b80\u5355\u3002\u6211\u4eec\u53ea\u9700\u8981\u6839\u636e\u51f8\u96c6\u7684\u5b9a\u4e49\uff0c\u9009\u53d6\u96c6\u5408\u4e2d\u7684\u6bcf\u4e00\u4e2a\u70b9\u5bf9\u7136\u540e\u5224\u65ad\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u7ebf\u6bb5\u4e0a\u7684\u70b9\u662f\u5426\u662f\u51f8\u7684\u5373\u53ef\u3002\u5bf9\u4e8e\u4e00\u4e2a\u6709\u7740 n n \u4e2a\u70b9\u7684\u96c6\u5408\uff0c\u4e0a\u8ff0\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4ec5\u4ec5\u4e3a O(n?n) O(n?n) \uff0c\u8fd9\u751a\u81f3\u662f\u4e00\u4e2a\u591a\u9879\u5f0f\u65f6\u95f4\u7684\u7b97\u6cd5\u3002\u4f46\u662f\u8fd9\u660e\u663e\u8fd8\u6709\u5f88\u5927\u7684\u6539\u8fdb\u7a7a\u95f4\u3002 \u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u4ecb\u7ecd\u4fdd\u7559\u51f8\u6027\u7684\u8fd0\u7b97\uff0c\u8fd9\u4e9b\u8fd0\u7b97\u6709\u52a9\u4e8e\u5224\u5b9a\u4e00\u4e2a\u96c6\u5408\u662f\u5426\u51f8\u4ee5\u53ca\u6784\u5efa\u4e00\u4e2a\u51f8\u96c6\u3002 \u4fdd\u51f8\u8fd0\u7b97 # \u4ea4\u96c6 \u5bf9\u4e8e\u96c6\u5408 S_1, S_2 S_1, S_2 \uff0c\u5982\u679c\u4ed6\u4eec\u662f\u51f8\u96c6\uff0c\u90a3\u4e48 S_1 \\cap S_2 S_1 \\cap S_2 \u4e5f\u662f\u51f8\u96c6\u3002 \u4eff\u5c04\u51fd\u6570 \u5982\u679c\u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m \u662f\u4e00\u4e2a\u653e\u5c04\u51fd\u6570\uff0c\u90a3\u4e48\uff1a f f \u4e0b\u7684\u51f8\u96c6\u7684\u50cf\u4e5f\u662f\u51f8\u7684: S \\subseteq \\mathbb{R}^n \\text{is convex} \\Rightarrow f(S) = \\{f(x) \\mid x \\in S\\} \\text{is convex} S \\subseteq \\mathbb{R}^n \\text{is convex} \\Rightarrow f(S) = \\{f(x) \\mid x \\in S\\} \\text{is convex} f f \u4e0b\u7684\u51f8\u96c6\u7684\u9006\u50cf\u4e5f\u662f\u51f8\u7684: C \\subseteq \\mathbb{R}^m \\text{is convex} \\Rightarrow f^{-1}(C) = \\{x \\mid f(x) \\in C\\} \\text{is convex} C \\subseteq \\mathbb{R}^m \\text{is convex} \\Rightarrow f^{-1}(C) = \\{x \\mid f(x) \\in C\\} \\text{is convex} \u900f\u89c6\u548c\u7ebf\u6027\u5206\u6570\u51fd\u6570 \u900f\u89c6\u51fd\u6570 P: \\mathbb{R}^{n+1} \\rightarrow \\mathbb{R}^n P: \\mathbb{R}^{n+1} \\rightarrow \\mathbb{R}^n \uff1a P(x, t) = x / t, \\quad dom(P) = \\{(x, t) \\mid t > 0\\} P(x, t) = x / t, \\quad dom(P) = \\{(x, t) \\mid t > 0\\} \u7ebf\u6027\u5206\u6570\u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m \uff1a f(x) = \\frac{Ax + b}{c^T + d}, \\quad dom(f) = \\{x \\mid c^Tx + d > 0\\} f(x) = \\frac{Ax + b}{c^T + d}, \\quad dom(f) = \\{x \\mid c^Tx + d > 0\\} \u900f\u89c6\u51fd\u6570\u4e0e\u7ebf\u6027\u5206\u6570\u51fd\u6570\u4e0b\u7684\u51f8\u96c6\u7684\u50cf\u548c\u9006\u50cf\u4e5f\u662f\u51f8\u7684 \u8fd9\u4e9b\u5c5e\u6027\u6269\u5c55\u5230\u65e0\u9650\u4e2a\u96c6\u5408\u7684\u4ea4\u96c6\u4e2d\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c S_\\alpha S_\\alpha \u662f\u51f8\u96c6\u5bf9\u4e8e\u6bcf\u4e00\u4e2a \\alpha \\in A \\alpha \\in A \u90fd\u6210\u7acb\uff0c\u90a3\u4e48 \\cap_{\\alpha \\in A}S_\\alpha \\cap_{\\alpha \\in A}S_\\alpha \u4e5f\u662f\u4e00\u4e2a\u51f8\u96c6\u3002","title":"\u4eff\u5c04\u4e0e\u51f8"},{"location":"optimisation/affine_convex/#_1","text":"\u76f4\u7ebf\u7684\u5b9a\u4e49\u60f3\u5fc5\u521d\u4e2d\u90fd\u5df2\u7ecf\u5b66\u8fc7\uff0c\u8fd9\u91cc\u6211\u4eec\u7b80\u5355\u590d\u4e60\u4e00\u4e0b\uff1a \u76f4\u7ebf\uff08line\uff09 \u7a7a\u95f4 \\mathbb{R}^n \\mathbb{R}^n \u4e2d\u7684\u4e24\u4e2a\u70b9 x_1, x_2, x_1 \\neq x_2 x_1, x_2, x_1 \\neq x_2 \u53ef\u4ee5\u552f\u4e00\u786e\u5b9a\u4e00\u6761\u76f4\u7ebf\u3002\u8fd9\u6761\u76f4\u7ebf\u53ef\u4ee5\u88ab\u53c2\u6570\u5316\u7684\u63cf\u8ff0\u4e3a x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ \\theta \\in \\mathbb{R} x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ \\theta \\in \\mathbb{R} \u6211\u4eec\u5f88\u5bb9\u6613\u53d1\u73b0\uff0c x = x_1 x = x_1 \u65f6\uff0c \\theta = 1 \\theta = 1 \uff1b x = x_2 x = x_2 \u65f6\uff0c \\theta = 0 \\theta = 0 \u3002\u7531\u6b64\uff0c\u6211\u4eec\u77e5\u9053\u4e86\u7ebf\u6bb5\u88ab\u5982\u4f55\u63cf\u8ff0\uff1a \u7ebf\u6bb5\uff08line segment\uff09 \u7a7f\u8fc7\u4e24\u70b9 x_1, x_2 \\in \\mathbb{R}^n, x_1 \\neq x_2 x_1, x_2 \\in \\mathbb{R}^n, x_1 \\neq x_2 \u7684\u7ebf\u6bb5\u53ef\u4ee5\u88ab\u53c2\u6570\u5316\u7684\u63cf\u8ff0\u4e3a x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ 0 \\leq \\theta \\leq 1 x = \\theta x_1 + (1 - \\theta) x_2 \\ s.t. \\ 0 \\leq \\theta \\leq 1 \u901a\u8fc7\u53d8\u5316\uff0c\u76f4\u7ebf\u8fd8\u53ef\u4ee5\u88ab\u8868\u8fbe\u4e3a x = x_2 + \\theta (x_1 - x_2) \\ s.t. \\ \\theta \\in \\mathbb{R} x = x_2 + \\theta (x_1 - x_2) \\ s.t. \\ \\theta \\in \\mathbb{R} \u3002\u8fd9\u7ed9\u4e86\u6211\u4eec\u53e6\u4e00\u79cd\u89e3\u8bfb\u2013 x x \u662f \u57fa\u70b9 x_2 x_2 \u4e0e \u65b9\u5411 x_1 - x_2 x_1 - x_2 \u6309\u53c2\u6570 \\theta \\theta \u7f29\u653e\u4e4b\u548c\u3002 \u56e0\u6b64\uff0c \\theta \\theta \u7ed9\u51fa\u4e86\u4ece x_2 x_2 \u5230 x_1 x_1 \u7684\u5206\u6570\u3002\u5f53 \\theta \\theta \u4ece0\u589e\u5927\u52301\u65f6\uff0c\u70b9 x x \u4ece x_2 x_2 \u79fb\u52a8\u5230 x_1 x_1 \uff1b\u5f53 \\theta \\theta \u5728\u6b64\u533a\u95f4\u4ee5\u5916\u65f6\uff0c\u70b9 x x \u4f4d\u4e8e x_1 x_1 \u5230 x_2 x_2 \u4ee5\u5916\u7684\u7ebf\u4e0a\u3002 \u5728\u590d\u4e60\u4e86\u76f4\u7ebf\u4e4b\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u7ed9\u4eff\u5c04\u96c6\u505a\u4e00\u4e2a\u5b9a\u4e49\uff1a \u4eff\u5c04\u96c6 \u5bf9\u4e8e\u96c6\u5408 C \\subseteq \\mathbb{R} C \\subseteq \\mathbb{R} \uff0c\u82e5\u7ecf\u8fc7\u8be5\u96c6\u5408\u4e0a\u4efb\u610f\u4e24\u70b9 x_1, x_2 \\in C, x_1 \\neq x_2 x_1, x_2 \\in C, x_1 \\neq x_2 \u7684\u76f4\u7ebf\u4e0a\u7684\u70b9\u90fd\u5728\u8be5\u96c6\u5408\u4e2d\uff0c\u90a3\u4e48\u6211\u4eec\u79f0\u96c6\u5408 C C \u4e3a\u4e00\u4e2a\u4eff\u5c04\u96c6\u3002 \u7ebf\u6027\u65b9\u7a0b \\{x \\mid Ax = b\\} \\{x \\mid Ax = b\\} \u7684\u89e3\u5373\u662f\u4e00\u4e2a\u4eff\u5c04\u96c6\uff0c\u53cd\u8fc7\u6765\u6bcf\u4e00\u4e2a\u4eff\u5c04\u96c6\u4e5f\u90fd\u53ef\u4ee5\u8868\u793a\u4e3a\u4e00\u4e2a\u7ebf\u6027\u65b9\u7a0b\u7cfb\u7edf\u7684\u89e3\u96c6\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u6709\u65f6\u5019\u5c06\u4eff\u5c04\u96c6\u6210\u4e3a\u7ebf\u6027\uff08linear\uff09\u3002 \u6709\u540c\u5b66\u53ef\u4ee5\u53d1\u73b0\uff0c\u4eff\u5c04\u96c6\u4e0e\u7ebf\u6027\u5b50\u7a7a\u95f4\u975e\u5e38\u76f8\u4f3c\u3002\u4e8b\u5b9e\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u4e00\u4e2a\u4eff\u5c04\u96c6\u770b\u4f5c\u662f\u4e00\u4e2a\u7ebf\u6027\u5b50\u7a7a\u95f4\u6839\u636e\u4e00\u4e2a\u56fa\u5b9a\u5411\u91cf\u5e73\u79fb\u800c\u5f97\u5230\u7684\u3002\u5bf9\u4e8e\u4eff\u5c04\u96c6 C C \u4e0e\u5176\u4e0a\u4e00\u70b9 x_0 x_0 \uff0c\u96c6\u5408 V = C - x_0 = \\{x - x_0 \\mid x \\in C\\} V = C - x_0 = \\{x - x_0 \\mid x \\in C\\} \u662f\u4e00\u4e2a\u5b50\u7a7a\u95f4\u3002 \u8bc1\u660e V = C - x_0 V = C - x_0 \u5bf9\u4e8e\u5411\u91cf\u52a0\u6cd5\u4e0e\u6807\u91cf\u4e58\u6cd5\u95ed\u5408 \u5bf9\u4e8e v_1, v_2 \\in V, \\alpha, \\beta \\in \\mathbb{R} v_1, v_2 \\in V, \\alpha, \\beta \\in \\mathbb{R} \uff0c\u6211\u4eec\u6709 v_1 + x_0, v_2 + x_0 \\in C v_1 + x_0, v_2 + x_0 \\in C \uff0c\u6240\u4ee5 \\alpha v_1 + \\beta v_2 + x_0 = \\alpha (v_1 + x_0) + \\beta (v_2 + x_0) + (1 -\\alpha - \\beta) x_0 \\in C \\alpha v_1 + \\beta v_2 + x_0 = \\alpha (v_1 + x_0) + \\beta (v_2 + x_0) + (1 -\\alpha - \\beta) x_0 \\in C \uff0c\u7531\u4e8e C C \u662f\u4eff\u5c04\u96c6\u3001 \\alpha + \\beta + (1 -\\alpha - \\beta) = 1, \\alpha v_1 + \\beta v_2 + x_0 \\in C \\alpha + \\beta + (1 -\\alpha - \\beta) = 1, \\alpha v_1 + \\beta v_2 + x_0 \\in C \uff0c\u6613\u5f97 \\alpha v_1 + \\beta v_2 \\in V \\alpha v_1 + \\beta v_2 \\in V \u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u4eff\u5c04\u96c6 C C \u8868\u8ff0\u4e3a C = V + x_0 = \\{v + x_0 \\mid v \\in V\\} C = V + x_0 = \\{v + x_0 \\mid v \\in V\\} \uff0c x_0 x_0 \u4e3a C C \u4e0a\u4efb\u610f\u4e00\u70b9\u3002\u6211\u4eec\u5c06\u5b50\u7a7a\u95f4 V V \u79f0\u4f5c\u4eff\u5c04\u96c6 C C \u76f8\u5173\u7684\u5b50\u7a7a\u95f4\uff0c\u5c06\u5b50\u7a7a\u95f4 V V \u7684\u7ef4\u5ea6\u79f0\u4f5c\u4eff\u5c04\u96c6 C C \u7684\u7ef4\u5ea6\u3002 \u7b80\u5355\u4e86\u89e3\u4e86\u76f4\u7ebf\u4e0e\u4eff\u5c04\u96c6\u4e4b\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u5ef6\u4f38\u51fa\u4eff\u5c04\u7ec4\u5408\uff1a \u4eff\u5c04\u7ec4\u5408\uff08affine combination\uff09 \u5bf9\u4e8e\u7ebf\u6027\u7ec4\u5408 \\sum_{i=1}^n \\theta_i x_i \\sum_{i=1}^n \\theta_i x_i \uff0c\u82e5\u5176\u6ee1\u8db3 \\sum_{i=1}^n \\theta_i = 1 \\sum_{i=1}^n \\theta_i = 1 \u5219\u6211\u4eec\u79f0\u5176\u4e3a\u4eff\u5c04\u7ec4\u5408\u3002 \u4eff\u5c04\u96c6 C C \u5305\u542b\u4e86\u8be5\u96c6\u5408\u4e2d\u4efb\u610f\u70b9\u7684\u4eff\u5c04\u7ec4\u5408\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u5bf9\u4e8e x_1, x_2, x_n \\in C, \\sum_{i=1}^n \\theta_i = 1 x_1, x_2, x_n \\in C, \\sum_{i=1}^n \\theta_i = 1 \uff0c \\sum_{i=1}^n \\theta_i x_i \\in C \\sum_{i=1}^n \\theta_i x_i \\in C \u3002 \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u4eff\u5c04\u7ec4\u5408\u5176\u5b9e\u53ef\u4ee5\u88ab\u770b\u6210\u4e00\u4e2a\u6240\u6709\u7cfb\u6570\u4e4b\u548c\u4e3a1\u7684\u7279\u6b8a\u7684\u7ebf\u6027\u7ec4\u5408\u3002\u8fd9\u6837\u7684\u7279\u6027\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u629b\u5f03\u539f\u70b9\uff0c\u800c\u5c06\u4efb\u610f\u7684\u70b9\u89c6\u4e3a\u539f\u70b9\uff0c\u6211\u4eec\u90fd\u53ef\u4ee5\u4f7f\u7528\u540c\u6837\u7684\u7ebf\u6027\u7ec4\u5408\u53bb\u63cf\u8ff0\u540c\u4e00\u4e2a\u70b9\u3002 \ud83c\udf30 \u5bf9\u4e8e\u539f\u70b9\u4ee5\u53ca\u7a7a\u95f4\u4e0a\u4efb\u610f\u4e00\u70b9 p p \uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5411\u91cf a,\\ b a,\\ b \u5206\u522b\u8868\u8ff0\u4e3a a + b a + b \u4e0e p + (a - p) + (b - p) p + (a - p) + (b - p) \u3002\u7531\u6b64\uff0c\u6211\u4eec\u901a\u8fc7\u4eff\u5c04\u7ec4\u5408\u53bb\u63cf\u8ff0\u53e6\u4e00\u70b9\u65f6\uff0c\u4e24\u4e2a\u63cf\u8ff0\u5206\u522b\u4e3a \\theta a + (1 - \\theta) b \\theta a + (1 - \\theta) b \u4e0e p + \\theta (a - p) + (1 - \\theta) (b - p) = p + \\theta a - \\theta p + (1 - \\theta) b - (1 - \\theta) p = \\theta a + (1 - \\theta) b p + \\theta (a - p) + (1 - \\theta) (b - p) = p + \\theta a - \\theta p + (1 - \\theta) b - (1 - \\theta) p = \\theta a + (1 - \\theta) b \uff1b\u6211\u4eec\u5f88\u5bb9\u6613\u53d1\u73b0\u4e24\u4e2a\u63cf\u8ff0\u4e0e\u5176\u8d77\u59cb\u70b9\u6ca1\u6709\u5173\u7cfb\u3002 \u96c6\u5408 S S \u7684\u4eff\u5c04\u5305 aff(S) aff(S) \u6307\u7684\u662f\u5305\u542b\u96c6\u5408 S S \u7684\u6700\u5c0f\u4eff\u5c04\u96c6\uff0c\u5b83\u88ab\u5b9a\u4e49\u4e3a: \u4eff\u5c04\u5305\uff08affine hull\uff09 aff(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, x_i \\in S, \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} aff(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, x_i \\in S, \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} \u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u4eff\u5c04\u96c6 C C \u6709 S \\subseteq C S \\subseteq C \uff0c\u90a3\u4e48 aff(S) \\subseteq C aff(S) \\subseteq C \u3002","title":"\u4eff\u5c04"},{"location":"optimisation/affine_convex/#_2","text":"\u6211\u4eec\u6ce8\u610f\u5230\u5230\u73b0\u5728\u4e3a\u6b62\u6211\u4eec\u4e00\u76f4\u5728\u8ba8\u8bba\u4eff\u5c04\uff0c\u800c\u6ca1\u6709\u8fdb\u5165\u771f\u6b63\u7684\u4e3b\u9898\u2013\u51f8\u3002\u4e8b\u5b9e\u4e0a\uff0c\u6211\u4eec\u5df2\u7ecf\u5dee\u4e0d\u591a\u5b66\u4e60\u4e86\u51f8\u7684\u6240\u6709\u6982\u5ff5\u4e86\u2013\u4ec5\u4ec5\u5c06\u4eff\u5c04\u7684\u76f4\u7ebf\u6362\u6210\u7ebf\u6bb5\uff0c\u6211\u4eec\u5c31\u80fd\u5f97\u5230\u51f8\u3002 \u51f8\u96c6 \u5bf9\u4e8e\u96c6\u5408 C \\subseteq \\mathbb{R} C \\subseteq \\mathbb{R} \uff0c\u82e5\u7ecf\u8fc7\u8be5\u96c6\u5408\u4e0a\u4efb\u610f\u4e24\u70b9 x_1, x_2 \\in C, x_1 \\neq x_2 x_1, x_2 \\in C, x_1 \\neq x_2 \u7684 \u7ebf\u6bb5 \u4e0a\u7684\u70b9\u90fd\u5728\u8be5\u96c6\u5408\u4e2d\uff0c\u90a3\u4e48\u6211\u4eec\u79f0\u96c6\u5408 C C \u4e3a\u4e00\u4e2a\u51f8\u96c6\u3002 \u51f8\u7ec4\u5408\uff08convex combination\uff09 \u5bf9\u4e8e\u7ebf\u6027\u7ec4\u5408 \\sum_{i=1}^n \\theta_i x_i \\sum_{i=1}^n \\theta_i x_i \uff0c\u82e5\u5176\u6ee1\u8db3 \\sum_{i=1}^n \\theta_i = 1 \\sum_{i=1}^n \\theta_i = 1 \u5e76\u4e14 \\forall \\theta_i, \\theta_i \\geq 0 \\forall \\theta_i, \\theta_i \\geq 0 \u5219\u6211\u4eec\u79f0\u5176\u4e3a\u51f8\u7ec4\u5408\u3002 \u51f8\u5305\uff08convex hull\uff09 conv(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, conv(S) = \\{\\sum_{i=1}^k \\theta_i x_i \\mid k > 0, x_i \\geq 0 x_i \\geq 0 , \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} , \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^n \\theta_i = 1\\} | \u6211\u4eec\u5f88\u5bb9\u6613\u60f3\u5230\uff0c\u5e38\u89c1\u7684\u4e09\u89d2\u5f62\u3001\u65b9\u5f62\u3001\u5706\u5f62\u90fd\u662f\u51f8\u7684\uff1b\u800c\u661f\u5f62\u5219\u662f\u975e\u51f8\u7684\uff0c\u56e0\u4e3a\u4efb\u610f\u4e24\u70b9\u4e4b\u95f4\u5b58\u5728\u6709\u4e9b\u70b9\u4e0d\u5728\u96c6\u5408\u4e4b\u5185\u3002 \u975e\u51f8\u96c6\u4e94\u89d2\u661f\u7684\u51f8\u5305\u662f \u51f8\u96c6\u4e94\u8fb9\u5f62\u3002 \u5982\u4f55\u5224\u65ad\u4e00\u4e2a\u51fd\u6570\u662f\u5426\u662f\u51f8\u7684 \u8fd9\u4e2a\u95ee\u9898\u770b\u4f3c\u5341\u5206\u7b80\u5355\u3002\u6211\u4eec\u53ea\u9700\u8981\u6839\u636e\u51f8\u96c6\u7684\u5b9a\u4e49\uff0c\u9009\u53d6\u96c6\u5408\u4e2d\u7684\u6bcf\u4e00\u4e2a\u70b9\u5bf9\u7136\u540e\u5224\u65ad\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u7ebf\u6bb5\u4e0a\u7684\u70b9\u662f\u5426\u662f\u51f8\u7684\u5373\u53ef\u3002\u5bf9\u4e8e\u4e00\u4e2a\u6709\u7740 n n \u4e2a\u70b9\u7684\u96c6\u5408\uff0c\u4e0a\u8ff0\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4ec5\u4ec5\u4e3a O(n?n) O(n?n) \uff0c\u8fd9\u751a\u81f3\u662f\u4e00\u4e2a\u591a\u9879\u5f0f\u65f6\u95f4\u7684\u7b97\u6cd5\u3002\u4f46\u662f\u8fd9\u660e\u663e\u8fd8\u6709\u5f88\u5927\u7684\u6539\u8fdb\u7a7a\u95f4\u3002 \u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u4ecb\u7ecd\u4fdd\u7559\u51f8\u6027\u7684\u8fd0\u7b97\uff0c\u8fd9\u4e9b\u8fd0\u7b97\u6709\u52a9\u4e8e\u5224\u5b9a\u4e00\u4e2a\u96c6\u5408\u662f\u5426\u51f8\u4ee5\u53ca\u6784\u5efa\u4e00\u4e2a\u51f8\u96c6\u3002","title":"\u51f8"},{"location":"optimisation/affine_convex/#_3","text":"\u4ea4\u96c6 \u5bf9\u4e8e\u96c6\u5408 S_1, S_2 S_1, S_2 \uff0c\u5982\u679c\u4ed6\u4eec\u662f\u51f8\u96c6\uff0c\u90a3\u4e48 S_1 \\cap S_2 S_1 \\cap S_2 \u4e5f\u662f\u51f8\u96c6\u3002 \u4eff\u5c04\u51fd\u6570 \u5982\u679c\u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m \u662f\u4e00\u4e2a\u653e\u5c04\u51fd\u6570\uff0c\u90a3\u4e48\uff1a f f \u4e0b\u7684\u51f8\u96c6\u7684\u50cf\u4e5f\u662f\u51f8\u7684: S \\subseteq \\mathbb{R}^n \\text{is convex} \\Rightarrow f(S) = \\{f(x) \\mid x \\in S\\} \\text{is convex} S \\subseteq \\mathbb{R}^n \\text{is convex} \\Rightarrow f(S) = \\{f(x) \\mid x \\in S\\} \\text{is convex} f f \u4e0b\u7684\u51f8\u96c6\u7684\u9006\u50cf\u4e5f\u662f\u51f8\u7684: C \\subseteq \\mathbb{R}^m \\text{is convex} \\Rightarrow f^{-1}(C) = \\{x \\mid f(x) \\in C\\} \\text{is convex} C \\subseteq \\mathbb{R}^m \\text{is convex} \\Rightarrow f^{-1}(C) = \\{x \\mid f(x) \\in C\\} \\text{is convex} \u900f\u89c6\u548c\u7ebf\u6027\u5206\u6570\u51fd\u6570 \u900f\u89c6\u51fd\u6570 P: \\mathbb{R}^{n+1} \\rightarrow \\mathbb{R}^n P: \\mathbb{R}^{n+1} \\rightarrow \\mathbb{R}^n \uff1a P(x, t) = x / t, \\quad dom(P) = \\{(x, t) \\mid t > 0\\} P(x, t) = x / t, \\quad dom(P) = \\{(x, t) \\mid t > 0\\} \u7ebf\u6027\u5206\u6570\u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m \uff1a f(x) = \\frac{Ax + b}{c^T + d}, \\quad dom(f) = \\{x \\mid c^Tx + d > 0\\} f(x) = \\frac{Ax + b}{c^T + d}, \\quad dom(f) = \\{x \\mid c^Tx + d > 0\\} \u900f\u89c6\u51fd\u6570\u4e0e\u7ebf\u6027\u5206\u6570\u51fd\u6570\u4e0b\u7684\u51f8\u96c6\u7684\u50cf\u548c\u9006\u50cf\u4e5f\u662f\u51f8\u7684 \u8fd9\u4e9b\u5c5e\u6027\u6269\u5c55\u5230\u65e0\u9650\u4e2a\u96c6\u5408\u7684\u4ea4\u96c6\u4e2d\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c S_\\alpha S_\\alpha \u662f\u51f8\u96c6\u5bf9\u4e8e\u6bcf\u4e00\u4e2a \\alpha \\in A \\alpha \\in A \u90fd\u6210\u7acb\uff0c\u90a3\u4e48 \\cap_{\\alpha \\in A}S_\\alpha \\cap_{\\alpha \\in A}S_\\alpha \u4e5f\u662f\u4e00\u4e2a\u51f8\u96c6\u3002","title":"\u4fdd\u51f8\u8fd0\u7b97"},{"location":"optimisation/ball_cone/","text":"\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u4ecb\u7ecd\u6b27\u51e0\u91cc\u5f97\u7403\uff08Euclidean Ball\uff09\u3001\u692d\u7403\uff08Ellipsoid\uff09\u4e0e\u9525\uff08cone\uff09\u3002 \u5728\u4e0a\u4e00\u8282\uff0c\u6211\u4eec\u9996\u5148\u590d\u4e60\u4e86\u76f4\u7ebf\u548c\u7ebf\u6bb5\u7684\u5b9a\u4e49\u3002\u672c\u8282\uff0c\u8ba9\u6211\u4eec\u4ece\u9525\u5f00\u59cb\u3002 \u6b27\u51e0\u91cc\u5f97\u7403\u4e0e\u692d\u7403 # \u6b27\u51e0\u91cc\u5f97\u7403 \u4e00\u4e2a \\mathbb{R}^n \\mathbb{R}^n \u4e0a\u7684\u6b27\u51e0\u91cc\u5f97\u7403\u6ee1\u8db3\u5982\u4e0b\u5f62\u5f0f\uff1a B(x_c, r) = \\{x \\mid \\Vert x - x_c \\Vert_2 \\leq r\\} = \\{x \\mid (x - x_c)^T(x - x_c) \\leq r^2\\} \\ s.t. \\ r \\in \\mathbb{R}_+ B(x_c, r) = \\{x \\mid \\Vert x - x_c \\Vert_2 \\leq r\\} = \\{x \\mid (x - x_c)^T(x - x_c) \\leq r^2\\} \\ s.t. \\ r \\in \\mathbb{R}_+ \u5728\u4e0a\u5f0f\u4e2d\uff0c x_c x_c \u4e3a \u5706\u5fc3 \uff0c r r \u4e3a \u534a\u5f84 \u3002 B(x_c, r) B(x_c, r) \u5305\u62ec\u4ee5 x_c x_c \u4e3a\u4e2d\u5fc3\uff0c\u8ddd\u79bb\u4e3a r r \u5185\u7684\u6240\u6709\u70b9\u3002\u6b27\u51e0\u91cc\u5f97\u7403\u8fd8\u5e38\u88ab\u8868\u793a\u4e3a B(x_c, r) = \\{x_c + ru \\mid \\Vert u \\Vert_2 \\leq 1\\} B(x_c, r) = \\{x_c + ru \\mid \\Vert u \\Vert_2 \\leq 1\\} \u8bd5\u8bc1\u660e\u6b27\u51e0\u91cc\u5f97\u7403\u662f\u4e00\u4e2a\u51f8\u96c6 \u5bf9\u4e8e\u6b27\u51e0\u91cc\u5f97\u7403 B(x_c, r) B(x_c, r) \u53ca\u5176\u4e2d\u4e24\u70b9 x_1, x_2 \\in B x_1, x_2 \\in B \uff0c\u6211\u4eec\u6709 \\Vert x_1 - x_c \\Vert_2 \\leq r \\Vert x_1 - x_c \\Vert_2 \\leq r \u4e0e \\Vert x_2 - x_c \\Vert_2 \\leq r \\Vert x_2 - x_c \\Vert_2 \\leq r \uff0c 0 \\leq \\ \\leq 1 0 \\leq \\ \\leq 1 \uff0c\u90a3\u4e48 \\begin{align} \\Vert \\theta x_1 + (1 - \\theta) x_2 - x_c \\Vert_2 &= \\Vert \\theta (x_1 - x_c) + (1 - \\theta) (x_2 - x_c) \\Vert_2 \\\\ &= \\theta \\Vert x_1 - x_c \\Vert_2 + (1 - \\theta) \\Vert x_2 - x_c \\Vert_2 \\\\ &= r \\end{align} \\begin{align} \\Vert \\theta x_1 + (1 - \\theta) x_2 - x_c \\Vert_2 &= \\Vert \\theta (x_1 - x_c) + (1 - \\theta) (x_2 - x_c) \\Vert_2 \\\\ &= \\theta \\Vert x_1 - x_c \\Vert_2 + (1 - \\theta) \\Vert x_2 - x_c \\Vert_2 \\\\ &= r \\end{align} \u4e00\u4e2a\u66f4\u4e00\u822c\u7684\u7403\u88ab\u79f0\u4e3a\u692d\u7403\uff08ellipsoid\uff09\u3002 \u692d\u7403 \\epsilon = \\{x \\mid (x - x_c)^TP^{-1}(x - x_c) \\leq 1\\} \\epsilon = \\{x \\mid (x - x_c)^TP^{-1}(x - x_c) \\leq 1\\} x_c \\in \\mathbb{R}^n x_c \\in \\mathbb{R}^n \u662f\u692d\u7403 \\epsilon \\epsilon \u7684 \u7403\u5fc3 \uff1b P \\in \\mathbb{S}^n_{++} P \\in \\mathbb{S}^n_{++} \u662f\u4e00\u4e2a\u5bf9\u79f0\u7684\u6b63\u5b9a\u77e9\u9635\uff0c\u5b83\u51b3\u5b9a\u4e86\u692d\u7403\u5728\u6bcf\u4e2a\u65b9\u5411\u4ece\u7403\u5fc3 x_c x_c \u4f38\u5f20\u7684\u957f\u5ea6\u3002\u692d\u7403 \\epsilon \\epsilon \u7684\u534a\u8f74\u7684\u957f\u5ea6\u7531 \\sqrt{\\lambda_i} \\sqrt{\\lambda_i} \u7ed9\u51fa\uff0c\u5176\u4e2d \\lambda_i \\lambda_i \u662f P P \u7684\u7279\u5f81\u503c\u3002\u6211\u4eec\u5f88\u5bb9\u6613\u53d1\u73b0\u6b27\u51e0\u91cc\u5f97\u7403\u662f\u692d\u7403\u7684\u4e00\u4e2a\u7279\u6b8a\u60c5\u51b5\u2013\u5f53 P P \u4e3a\u4e00\u4e2a\u5355\u4f4d\u77e9\u9635\u65f6\u3002 (x - x_c)^TP^{-1}(x - x_c) (x - x_c)^TP^{-1}(x - x_c) \u5b9e\u9645\u4e0a\u662f x - x_c x - x_c \u7684p-\u8303\u6570\uff0c\u56e0\u6b64\u4e0a\u5f0f\u6709\u65f6\u4e5f\u5199\u4f5c \\epsilon = \\{x \\mid \\Vert x - x_c \\Vert_p \\leq 1\\} \\epsilon = \\{x \\mid \\Vert x - x_c \\Vert_p \\leq 1\\} \u3002 \u692d\u7403\u8fd8\u5e38\u88ab\u8868\u8fbe\u4e3a \\epsilon = \\{x_c + Au \\mid \\Vert u \\Vert_2 \\leq 1\\} \\epsilon = \\{x_c + Au \\mid \\Vert u \\Vert_2 \\leq 1\\} \uff0c\u5176\u4e2d A A \u662f\u4e00\u4e2a\u975e\u5947\u5f02\u65b9\u9635\uff0c u u \u662f\u4e00\u4e2a\u5355\u4f4d\u7403\u3002\u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u901a\u8fc7\u65b9\u9635 A A \u65cb\u8f6c\u3001\u62c9\u4f38\u8fd9\u4e2a\u5355\u4f4d\u7403\uff0c\u6700\u540e\u518d\u52a0\u4e0a\u504f\u79fb\u91cf x_c x_c \u5f97\u5230\u692d\u7403\u3002\u5728\u8fd9\u4e2a\u8868\u8fbe\u4e2d\u6211\u4eec\u53ef\u4ee5\u5047\u8bbe A A \u662f\u5bf9\u79f0\u3001\u6b63\u5b9a\u7684\u3002 A = P^{1/2} A = P^{1/2} \u65f6\u672c\u5f0f\u4e0e\u4e0a\u5f0f\u76f8\u540c\u3002\u5982\u679c A A \u662f\u5bf9\u79f0\u6b63\u5b9a\u7684\u5947\u5f02\u65b9\u9635\uff0c\u90a3\u4e48\u8fd9\u4e2a\u96c6\u5408\u88ab\u79f0\u4f5c\u9000\u5316\u692d\u7403\uff08degenerate ellipsoid\uff09\uff0c\u5b83\u7684\u4eff\u5c04\u7ef4\u5ea6\u7b49\u4e8e A A \u7684\u79e9\u3002\u9000\u5316\u692d\u7403\u4e0e\u692d\u7403\u90fd\u662f\u51f8\u7684\u3002 \u9525 # \u9525\u7ec4\u5408\uff08conic combination\uff09 \u7a7a\u95f4 \\mathbb{R}^n \\mathbb{R}^n \u4e2d\u7684\u70b9 x \\in \\mathbb{R} x \\in \\mathbb{R} \u5982\u679c\u6ee1\u8db3 x = \\sum_{i=1}^n \\theta_i x_i \\ s.t. \\ \\forall \\theta_i, \\theta_i \\geq 0 x = \\sum_{i=1}^n \\theta_i x_i \\ s.t. \\ \\forall \\theta_i, \\theta_i \\geq 0 \u5219\u6211\u4eec\u5c06\u5176\u6210\u4e3a\u9525\u7ec4\u5408\uff08\u975e\u8d1f\u7ebf\u6027\u7ec4\u5408\uff09\u3002 \u9525\u96c6\uff08conic set\uff09 \u5bf9\u4e8e\u96c6\u5408 C C \uff0c\u5982\u679c\u5176\u4e2d\u6bcf\u4e00\u70b9 x \\in C x \\in C \u5e76\u4e14 \\theta \\geq 0$\uff0c\u90fd\u6709$\\theta x \\in C \\theta \\geq 0$\uff0c\u90fd\u6709$\\theta x \\in C \u90a3\u4e48\u6211\u4eec\u5c06\u8fd9\u4e2a\u96c6\u5408 C C \u79f0\u4f5c\u4e00\u4e2a\u9525\uff08\u975e\u8d1f\u9f50\u6b21\uff09\u3002 \u9525\u5305\uff08conic hull\uff09 \u96c6\u5408 S S \u7684\u9525\u5305\u662f\u6240\u6709\u8be5\u96c6\u5408\u7684\u70b9\u7684\u9525\u7ec4\u5408\u6240\u6784\u6210\u7684\u96c6\u5408\uff0c\u4e5f\u5373 \\{\\sum_{i=1}^k \\theta_i x_i \\mid x_i \\in S, \\theta_i \\geq 0\\} \\{\\sum_{i=1}^k \\theta_i x_i \\mid x_i \\in S, \\theta_i \\geq 0\\} \u534a\u6b63\u5b9a\u9525 # \u5bf9\u79f0\u77e9\u9635 \\mathbb{S}^n = \\{X \\in \\mathbb{R}^{n \\times n} \\mid X = X^T\\} \\mathbb{S}^n = \\{X \\in \\mathbb{R}^{n \\times n} \\mid X = X^T\\} \u5bf9\u79f0\u534a\u6b63\u5b9a\u77e9\u9635 \\mathbb{S}^n_+ = \\{X \\in \\mathbb{S}^n \\mid X \\succeq 0\\} \\mathbb{S}^n_+ = \\{X \\in \\mathbb{S}^n \\mid X \\succeq 0\\} \u5bf9\u79f0\u6b63\u5b9a\u77e9\u9635 \\mathbb{S}^n_{+ +} = \\{X \\in \\mathbb{S}^n \\mid X \\succ 0\\} \\mathbb{S}^n_{+ +} = \\{X \\in \\mathbb{S}^n \\mid X \\succ 0\\} \u8bd5\u8bc1\u660e \\mathbb{S}^n_+ \\mathbb{S}^n_+ \u662f\u4e00\u4e2a\u51f8\u9525 \u5982\u679c \\theta_1, \\theta_2 \\in \\mathbb{R}_+ \\theta_1, \\theta_2 \\in \\mathbb{R}_+ \uff0c A, B \\in \\mathbb{S}^n_+ A, B \\in \\mathbb{S}^n_+ \uff0c\u90a3\u4e48 \\theta_1 A + \\theta_2 B \\in \\mathbb{S}^n_+ \\theta_1 A + \\theta_2 B \\in \\mathbb{S}^n_+ \u3002 \u8303\u5f0f\u7403\u4e0e\u8303\u5f0f\u9525 # \u5bf9\u4e8e \\mathbb{R}^n \\mathbb{R}^n \u4e2d\u7684\u4efb\u610f\u8303\u6570 \\Vert \\cdot \\Vert \\Vert \\cdot \\Vert \uff0c\u8303\u5f0f\u7403\u548c\u8303\u5f0f\u9525\u88ab\u5b9a\u4e49\u4e3a\uff1a \u8303\u5f0f\u7403 B(x_c, r) = \\{x \\mid \\Vert x - x_c \\Vert \\leq r\\} B(x_c, r) = \\{x \\mid \\Vert x - x_c \\Vert \\leq r\\} \u8303\u5f0f\u9525 C(t) = \\{(x, t) \\mid \\Vert x \\Vert \\leq t\\} \\subseteq \\mathbb{R}^{n+1} C(t) = \\{(x, t) \\mid \\Vert x \\Vert \\leq t\\} \\subseteq \\mathbb{R}^{n+1} \u8303\u5f0f\u7403\u548c\u8303\u5f0f\u9525\u90fd\u662f\u51f8\u7684\u3002","title":"\u7403\u4e0e\u9525"},{"location":"optimisation/ball_cone/#_1","text":"\u6b27\u51e0\u91cc\u5f97\u7403 \u4e00\u4e2a \\mathbb{R}^n \\mathbb{R}^n \u4e0a\u7684\u6b27\u51e0\u91cc\u5f97\u7403\u6ee1\u8db3\u5982\u4e0b\u5f62\u5f0f\uff1a B(x_c, r) = \\{x \\mid \\Vert x - x_c \\Vert_2 \\leq r\\} = \\{x \\mid (x - x_c)^T(x - x_c) \\leq r^2\\} \\ s.t. \\ r \\in \\mathbb{R}_+ B(x_c, r) = \\{x \\mid \\Vert x - x_c \\Vert_2 \\leq r\\} = \\{x \\mid (x - x_c)^T(x - x_c) \\leq r^2\\} \\ s.t. \\ r \\in \\mathbb{R}_+ \u5728\u4e0a\u5f0f\u4e2d\uff0c x_c x_c \u4e3a \u5706\u5fc3 \uff0c r r \u4e3a \u534a\u5f84 \u3002 B(x_c, r) B(x_c, r) \u5305\u62ec\u4ee5 x_c x_c \u4e3a\u4e2d\u5fc3\uff0c\u8ddd\u79bb\u4e3a r r \u5185\u7684\u6240\u6709\u70b9\u3002\u6b27\u51e0\u91cc\u5f97\u7403\u8fd8\u5e38\u88ab\u8868\u793a\u4e3a B(x_c, r) = \\{x_c + ru \\mid \\Vert u \\Vert_2 \\leq 1\\} B(x_c, r) = \\{x_c + ru \\mid \\Vert u \\Vert_2 \\leq 1\\} \u8bd5\u8bc1\u660e\u6b27\u51e0\u91cc\u5f97\u7403\u662f\u4e00\u4e2a\u51f8\u96c6 \u5bf9\u4e8e\u6b27\u51e0\u91cc\u5f97\u7403 B(x_c, r) B(x_c, r) \u53ca\u5176\u4e2d\u4e24\u70b9 x_1, x_2 \\in B x_1, x_2 \\in B \uff0c\u6211\u4eec\u6709 \\Vert x_1 - x_c \\Vert_2 \\leq r \\Vert x_1 - x_c \\Vert_2 \\leq r \u4e0e \\Vert x_2 - x_c \\Vert_2 \\leq r \\Vert x_2 - x_c \\Vert_2 \\leq r \uff0c 0 \\leq \\ \\leq 1 0 \\leq \\ \\leq 1 \uff0c\u90a3\u4e48 \\begin{align} \\Vert \\theta x_1 + (1 - \\theta) x_2 - x_c \\Vert_2 &= \\Vert \\theta (x_1 - x_c) + (1 - \\theta) (x_2 - x_c) \\Vert_2 \\\\ &= \\theta \\Vert x_1 - x_c \\Vert_2 + (1 - \\theta) \\Vert x_2 - x_c \\Vert_2 \\\\ &= r \\end{align} \\begin{align} \\Vert \\theta x_1 + (1 - \\theta) x_2 - x_c \\Vert_2 &= \\Vert \\theta (x_1 - x_c) + (1 - \\theta) (x_2 - x_c) \\Vert_2 \\\\ &= \\theta \\Vert x_1 - x_c \\Vert_2 + (1 - \\theta) \\Vert x_2 - x_c \\Vert_2 \\\\ &= r \\end{align} \u4e00\u4e2a\u66f4\u4e00\u822c\u7684\u7403\u88ab\u79f0\u4e3a\u692d\u7403\uff08ellipsoid\uff09\u3002 \u692d\u7403 \\epsilon = \\{x \\mid (x - x_c)^TP^{-1}(x - x_c) \\leq 1\\} \\epsilon = \\{x \\mid (x - x_c)^TP^{-1}(x - x_c) \\leq 1\\} x_c \\in \\mathbb{R}^n x_c \\in \\mathbb{R}^n \u662f\u692d\u7403 \\epsilon \\epsilon \u7684 \u7403\u5fc3 \uff1b P \\in \\mathbb{S}^n_{++} P \\in \\mathbb{S}^n_{++} \u662f\u4e00\u4e2a\u5bf9\u79f0\u7684\u6b63\u5b9a\u77e9\u9635\uff0c\u5b83\u51b3\u5b9a\u4e86\u692d\u7403\u5728\u6bcf\u4e2a\u65b9\u5411\u4ece\u7403\u5fc3 x_c x_c \u4f38\u5f20\u7684\u957f\u5ea6\u3002\u692d\u7403 \\epsilon \\epsilon \u7684\u534a\u8f74\u7684\u957f\u5ea6\u7531 \\sqrt{\\lambda_i} \\sqrt{\\lambda_i} \u7ed9\u51fa\uff0c\u5176\u4e2d \\lambda_i \\lambda_i \u662f P P \u7684\u7279\u5f81\u503c\u3002\u6211\u4eec\u5f88\u5bb9\u6613\u53d1\u73b0\u6b27\u51e0\u91cc\u5f97\u7403\u662f\u692d\u7403\u7684\u4e00\u4e2a\u7279\u6b8a\u60c5\u51b5\u2013\u5f53 P P \u4e3a\u4e00\u4e2a\u5355\u4f4d\u77e9\u9635\u65f6\u3002 (x - x_c)^TP^{-1}(x - x_c) (x - x_c)^TP^{-1}(x - x_c) \u5b9e\u9645\u4e0a\u662f x - x_c x - x_c \u7684p-\u8303\u6570\uff0c\u56e0\u6b64\u4e0a\u5f0f\u6709\u65f6\u4e5f\u5199\u4f5c \\epsilon = \\{x \\mid \\Vert x - x_c \\Vert_p \\leq 1\\} \\epsilon = \\{x \\mid \\Vert x - x_c \\Vert_p \\leq 1\\} \u3002 \u692d\u7403\u8fd8\u5e38\u88ab\u8868\u8fbe\u4e3a \\epsilon = \\{x_c + Au \\mid \\Vert u \\Vert_2 \\leq 1\\} \\epsilon = \\{x_c + Au \\mid \\Vert u \\Vert_2 \\leq 1\\} \uff0c\u5176\u4e2d A A \u662f\u4e00\u4e2a\u975e\u5947\u5f02\u65b9\u9635\uff0c u u \u662f\u4e00\u4e2a\u5355\u4f4d\u7403\u3002\u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u901a\u8fc7\u65b9\u9635 A A \u65cb\u8f6c\u3001\u62c9\u4f38\u8fd9\u4e2a\u5355\u4f4d\u7403\uff0c\u6700\u540e\u518d\u52a0\u4e0a\u504f\u79fb\u91cf x_c x_c \u5f97\u5230\u692d\u7403\u3002\u5728\u8fd9\u4e2a\u8868\u8fbe\u4e2d\u6211\u4eec\u53ef\u4ee5\u5047\u8bbe A A \u662f\u5bf9\u79f0\u3001\u6b63\u5b9a\u7684\u3002 A = P^{1/2} A = P^{1/2} \u65f6\u672c\u5f0f\u4e0e\u4e0a\u5f0f\u76f8\u540c\u3002\u5982\u679c A A \u662f\u5bf9\u79f0\u6b63\u5b9a\u7684\u5947\u5f02\u65b9\u9635\uff0c\u90a3\u4e48\u8fd9\u4e2a\u96c6\u5408\u88ab\u79f0\u4f5c\u9000\u5316\u692d\u7403\uff08degenerate ellipsoid\uff09\uff0c\u5b83\u7684\u4eff\u5c04\u7ef4\u5ea6\u7b49\u4e8e A A \u7684\u79e9\u3002\u9000\u5316\u692d\u7403\u4e0e\u692d\u7403\u90fd\u662f\u51f8\u7684\u3002","title":"\u6b27\u51e0\u91cc\u5f97\u7403\u4e0e\u692d\u7403"},{"location":"optimisation/ball_cone/#_2","text":"\u9525\u7ec4\u5408\uff08conic combination\uff09 \u7a7a\u95f4 \\mathbb{R}^n \\mathbb{R}^n \u4e2d\u7684\u70b9 x \\in \\mathbb{R} x \\in \\mathbb{R} \u5982\u679c\u6ee1\u8db3 x = \\sum_{i=1}^n \\theta_i x_i \\ s.t. \\ \\forall \\theta_i, \\theta_i \\geq 0 x = \\sum_{i=1}^n \\theta_i x_i \\ s.t. \\ \\forall \\theta_i, \\theta_i \\geq 0 \u5219\u6211\u4eec\u5c06\u5176\u6210\u4e3a\u9525\u7ec4\u5408\uff08\u975e\u8d1f\u7ebf\u6027\u7ec4\u5408\uff09\u3002 \u9525\u96c6\uff08conic set\uff09 \u5bf9\u4e8e\u96c6\u5408 C C \uff0c\u5982\u679c\u5176\u4e2d\u6bcf\u4e00\u70b9 x \\in C x \\in C \u5e76\u4e14 \\theta \\geq 0$\uff0c\u90fd\u6709$\\theta x \\in C \\theta \\geq 0$\uff0c\u90fd\u6709$\\theta x \\in C \u90a3\u4e48\u6211\u4eec\u5c06\u8fd9\u4e2a\u96c6\u5408 C C \u79f0\u4f5c\u4e00\u4e2a\u9525\uff08\u975e\u8d1f\u9f50\u6b21\uff09\u3002 \u9525\u5305\uff08conic hull\uff09 \u96c6\u5408 S S \u7684\u9525\u5305\u662f\u6240\u6709\u8be5\u96c6\u5408\u7684\u70b9\u7684\u9525\u7ec4\u5408\u6240\u6784\u6210\u7684\u96c6\u5408\uff0c\u4e5f\u5373 \\{\\sum_{i=1}^k \\theta_i x_i \\mid x_i \\in S, \\theta_i \\geq 0\\} \\{\\sum_{i=1}^k \\theta_i x_i \\mid x_i \\in S, \\theta_i \\geq 0\\}","title":"\u9525"},{"location":"optimisation/ball_cone/#_3","text":"\u5bf9\u79f0\u77e9\u9635 \\mathbb{S}^n = \\{X \\in \\mathbb{R}^{n \\times n} \\mid X = X^T\\} \\mathbb{S}^n = \\{X \\in \\mathbb{R}^{n \\times n} \\mid X = X^T\\} \u5bf9\u79f0\u534a\u6b63\u5b9a\u77e9\u9635 \\mathbb{S}^n_+ = \\{X \\in \\mathbb{S}^n \\mid X \\succeq 0\\} \\mathbb{S}^n_+ = \\{X \\in \\mathbb{S}^n \\mid X \\succeq 0\\} \u5bf9\u79f0\u6b63\u5b9a\u77e9\u9635 \\mathbb{S}^n_{+ +} = \\{X \\in \\mathbb{S}^n \\mid X \\succ 0\\} \\mathbb{S}^n_{+ +} = \\{X \\in \\mathbb{S}^n \\mid X \\succ 0\\} \u8bd5\u8bc1\u660e \\mathbb{S}^n_+ \\mathbb{S}^n_+ \u662f\u4e00\u4e2a\u51f8\u9525 \u5982\u679c \\theta_1, \\theta_2 \\in \\mathbb{R}_+ \\theta_1, \\theta_2 \\in \\mathbb{R}_+ \uff0c A, B \\in \\mathbb{S}^n_+ A, B \\in \\mathbb{S}^n_+ \uff0c\u90a3\u4e48 \\theta_1 A + \\theta_2 B \\in \\mathbb{S}^n_+ \\theta_1 A + \\theta_2 B \\in \\mathbb{S}^n_+ \u3002","title":"\u534a\u6b63\u5b9a\u9525"},{"location":"optimisation/ball_cone/#_4","text":"\u5bf9\u4e8e \\mathbb{R}^n \\mathbb{R}^n \u4e2d\u7684\u4efb\u610f\u8303\u6570 \\Vert \\cdot \\Vert \\Vert \\cdot \\Vert \uff0c\u8303\u5f0f\u7403\u548c\u8303\u5f0f\u9525\u88ab\u5b9a\u4e49\u4e3a\uff1a \u8303\u5f0f\u7403 B(x_c, r) = \\{x \\mid \\Vert x - x_c \\Vert \\leq r\\} B(x_c, r) = \\{x \\mid \\Vert x - x_c \\Vert \\leq r\\} \u8303\u5f0f\u9525 C(t) = \\{(x, t) \\mid \\Vert x \\Vert \\leq t\\} \\subseteq \\mathbb{R}^{n+1} C(t) = \\{(x, t) \\mid \\Vert x \\Vert \\leq t\\} \\subseteq \\mathbb{R}^{n+1} \u8303\u5f0f\u7403\u548c\u8303\u5f0f\u9525\u90fd\u662f\u51f8\u7684\u3002","title":"\u8303\u5f0f\u7403\u4e0e\u8303\u5f0f\u9525"},{"location":"optimisation/convex_concave/","text":"ok\uff0c\u5728\u4e86\u89e3\u4e86\u57fa\u7840\u77e5\u8bc6\u4e4b\u540e\uff0c\u8ba9\u6211\u4eec\u5f00\u59cb\u5165\u95e8\uff1a\u51f8\u51fd\u6570\u4e0e\u51f9\u51fd\u6570 \u51f8\u51fd\u6570\u4e0e\u51f9\u51fd\u6570 # \u51f8\u51fd\u6570 \u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R} f: \\mathbb{R}^n \\rightarrow \\mathbb{R} \u662f\u4e00\u4e2a\u51f8\u51fd\u6570\uff0c\u5982\u679c\u4ed6\u7684\u53d6\u503c\u8303\u56f4 \\mathrm{dom} f \\mathrm{dom} f \u662f\u4e00\u4e2a\u51f8\u96c6\uff0c\u5e76\u4e14 f(\\sum_{i=1}^n \\theta_i x_i) \\leq \\sum_{i=1}^n f(\\theta_i x_i) f(\\sum_{i=1}^n \\theta_i x_i) \\leq \\sum_{i=1}^n f(\\theta_i x_i) \u5bf9\u4e8e\u6240\u6709 x_i \\in \\mathrm{dom} f, \\ \\sum_{i=1}^n \\theta_i = 1, \\ \\forall \\theta_i, 0 \\leq \\theta_i \\leq 1 x_i \\in \\mathrm{dom} f, \\ \\sum_{i=1}^n \\theta_i = 1, \\ \\forall \\theta_i, 0 \\leq \\theta_i \\leq 1 \u90fd\u6210\u7acb \u6211\u4eec\u53ef\u4ee5\u6ce8\u610f\u5230\uff0c \\sum_{i=1}^n \\theta_i x_i \\sum_{i=1}^n \\theta_i x_i \u5176\u5b9e\u662f\u4e00\u4e2a\u51f8\u7ec4\u5408\u3002 \u51f8\u51fd\u6570\u7684\u51e0\u4f55\u610f\u4e49 \u5bf9\u4e8e\u51f8\u51fd\u6570\u4e0a\u4efb\u610f\u4e24\u70b9 x,\\ y x,\\ y \uff0c\u8be5\u4e24\u70b9\u4e4b\u95f4\u7684\u8fde\u7ebf\u4e0d\u4f4e\u4e8e\u8be5\u51f8\u51fd\u6570\u3002 \u6240\u6709\u7684\u8303\u6570\u90fd\u662f\u51f8\u51fd\u6570\u5417 \u662f\u7684 \u4e25\u683c\u51f8\u51fd\u6570 \u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R} f: \\mathbb{R}^n \\rightarrow \\mathbb{R} \u662f\u4e00\u4e2a\u4e25\u683c\u51f8\u51fd\u6570\uff0c\u5982\u679c\u4ed6\u7684\u53d6\u503c\u8303\u56f4 \\mathrm{dom} f \\mathrm{dom} f \u662f\u4e00\u4e2a\u51f8\u96c6\uff0c\u5e76\u4e14 f(\\sum_{i=1}^n \\theta_i x_i) \\lt \\sum_{i=1}^n f(\\theta_i x_i) f(\\sum_{i=1}^n \\theta_i x_i) \\lt \\sum_{i=1}^n f(\\theta_i x_i) \u51f9\u51fd\u6570 \u5982\u679c\u51fd\u6570 f f \u662f\u4e2a\u51f8\u51fd\u6570\uff0c\u90a3\u4e48\u51fd\u6570 -f -f \u662f\u51f9\u51fd\u6570\u3002 \u5982\u679c\u51fd\u6570 f f \u662f\u4e25\u683c\u51f8\u51fd\u6570\uff0c\u90a3\u4e48\u51fd\u6570 -f -f \u662f\u4e25\u683c\u51f9\u51fd\u6570\u3002 \u51f8\u51fd\u6570\u7684\u5224\u5b9a # Restriction of a Convex Function to a Line \u5bf9\u4e8e\u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R} f: \\mathbb{R}^n \\rightarrow \\mathbb{R} \uff0c\u82e5\u8be5\u51fd\u6570\u5728\u6bcf\u4e00\u4e2a\u65b9\u5411\u4e0a g(t) = f(x + tv): \\mathbb{R} \\rightarrow \\mathbb{R} g(t) = f(x + tv): \\mathbb{R} \\rightarrow \\mathbb{R} \u90fd\u662f\u51f8\u7684\uff0c\u5219\u8be5\u51fd\u6570\u662f\u51f8\u7684\u3002 \u8fd9\u4e2a\u65b9\u5f0f\u901a\u8fc7\u5c06\u5224\u5b9a\u4e00\u4e2a\u5b9a\u4e49\u57df\u4e3a \\mathbb{R}^n \\mathbb{R}^n \u7684\u51fd\u6570\u7684\u51f8\u6027\u7684\u95ee\u9898\u8f6c\u6362\u4e3a n n \u4e2a\u5b9a\u4e49\u57df\u4e3a \\mathbb{R} \\mathbb{R} \u7684\u95ee\u9898\u6765\u964d\u4f4e\u8ba1\u7b97\u91cf\uff0c\u4f46\u5176\u4e0d\u9002\u7528\u4e8e\u591a\u53d8\u91cf\u51fd\u6570\u3002 f(X) = \\log \\det x \\begin{align} g(t) &= \\log \\det (X = tV)\\\\ &= \\log \\det X + \\log \\det (I + tX^{-1/2}VX^{1/2})\\\\ &= \\log \\det X + \\sum^n{i=1} \\log (1 + t\\lambda_i)\\\\ \\end{align} \\begin{align} g(t) &= \\log \\det (X = tV)\\\\ &= \\log \\det X + \\log \\det (I + tX^{-1/2}VX^{1/2})\\\\ &= \\log \\det X + \\sum^n{i=1} \\log (1 + t\\lambda_i)\\\\ \\end{align} \u5176\u4e2d \\lambda_i \\lambda_i \u662f X^{-1/2}VX^{1/2} X^{-1/2}VX^{1/2} \u7684\u7279\u5f81\u503c\u3002 \u56e0\u4e3a g g \u5728 t t \u4e2d\u662f\u51f9\u7684\uff0c\u6240\u4ee5f\u662f\u51f9\u51fd\u6570\u3002 \u6269\u5c55\u503c\u5ef6\u7533 \u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R} f: \\mathbb{R}^n \\rightarrow \\mathbb{R} \u7684\u6269\u5c55\u503c\u5ef6\u7533 \\tlide{f} \\tlide{f} \u88ab\u5982\u4e0b\u5b9a\u4e49\uff1a $$\\tlide{f} = \\begin{cases}\\begin{align} f(x), & x \\in \\dom f\\\\ \\infty, & x \\not \\in \\dom f \\end{align}\\end{cases} $\\mathbb{R}\u4e0a\u51f8\u51fd\u6570 \u51f8\u51fd\u6570\uff1a \u4eff\u5c04\uff1a ax + b ax + b \u5e42 ^\\star ^\\star \uff1a x^a, \\ s.t. \\ a \\geq 1 \\text{or} a \\leq 0 x^a, \\ s.t. \\ a \\geq 1 \\text{or} a \\leq 0 \u6307\u6570\uff1a e^{ax} e^{ax} \u8d1f\u71b5 ^\\star ^\\star \uff1a x \\log x x \\log x \u51f9\u51fd\u6570\uff1a \u4eff\u5c04\uff1a ax + b ax + b \u5e42 ^\\star ^\\star \uff1a x^a, \\ s.t. \\ 0 \\leq a \\leq 1 x^a, \\ s.t. \\ 0 \\leq a \\leq 1 \u5bf9\u6570 ^\\star ^\\star \uff1a \\log x \\log x ^\\star ^\\star \uff1a x > 0 x > 0 \u6211\u4eec\u53ef\u4ee5\u6ce8\u610f\u5230\uff0c\u6240\u6709\u7684\u4eff\u5c04\u51fd\u6570\u662f\u65e2\u51f8\u53c8\u51f9\u7684\u3002","title":"\u51f8\u51f9"},{"location":"optimisation/convex_concave/#_1","text":"\u51f8\u51fd\u6570 \u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R} f: \\mathbb{R}^n \\rightarrow \\mathbb{R} \u662f\u4e00\u4e2a\u51f8\u51fd\u6570\uff0c\u5982\u679c\u4ed6\u7684\u53d6\u503c\u8303\u56f4 \\mathrm{dom} f \\mathrm{dom} f \u662f\u4e00\u4e2a\u51f8\u96c6\uff0c\u5e76\u4e14 f(\\sum_{i=1}^n \\theta_i x_i) \\leq \\sum_{i=1}^n f(\\theta_i x_i) f(\\sum_{i=1}^n \\theta_i x_i) \\leq \\sum_{i=1}^n f(\\theta_i x_i) \u5bf9\u4e8e\u6240\u6709 x_i \\in \\mathrm{dom} f, \\ \\sum_{i=1}^n \\theta_i = 1, \\ \\forall \\theta_i, 0 \\leq \\theta_i \\leq 1 x_i \\in \\mathrm{dom} f, \\ \\sum_{i=1}^n \\theta_i = 1, \\ \\forall \\theta_i, 0 \\leq \\theta_i \\leq 1 \u90fd\u6210\u7acb \u6211\u4eec\u53ef\u4ee5\u6ce8\u610f\u5230\uff0c \\sum_{i=1}^n \\theta_i x_i \\sum_{i=1}^n \\theta_i x_i \u5176\u5b9e\u662f\u4e00\u4e2a\u51f8\u7ec4\u5408\u3002 \u51f8\u51fd\u6570\u7684\u51e0\u4f55\u610f\u4e49 \u5bf9\u4e8e\u51f8\u51fd\u6570\u4e0a\u4efb\u610f\u4e24\u70b9 x,\\ y x,\\ y \uff0c\u8be5\u4e24\u70b9\u4e4b\u95f4\u7684\u8fde\u7ebf\u4e0d\u4f4e\u4e8e\u8be5\u51f8\u51fd\u6570\u3002 \u6240\u6709\u7684\u8303\u6570\u90fd\u662f\u51f8\u51fd\u6570\u5417 \u662f\u7684 \u4e25\u683c\u51f8\u51fd\u6570 \u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R} f: \\mathbb{R}^n \\rightarrow \\mathbb{R} \u662f\u4e00\u4e2a\u4e25\u683c\u51f8\u51fd\u6570\uff0c\u5982\u679c\u4ed6\u7684\u53d6\u503c\u8303\u56f4 \\mathrm{dom} f \\mathrm{dom} f \u662f\u4e00\u4e2a\u51f8\u96c6\uff0c\u5e76\u4e14 f(\\sum_{i=1}^n \\theta_i x_i) \\lt \\sum_{i=1}^n f(\\theta_i x_i) f(\\sum_{i=1}^n \\theta_i x_i) \\lt \\sum_{i=1}^n f(\\theta_i x_i) \u51f9\u51fd\u6570 \u5982\u679c\u51fd\u6570 f f \u662f\u4e2a\u51f8\u51fd\u6570\uff0c\u90a3\u4e48\u51fd\u6570 -f -f \u662f\u51f9\u51fd\u6570\u3002 \u5982\u679c\u51fd\u6570 f f \u662f\u4e25\u683c\u51f8\u51fd\u6570\uff0c\u90a3\u4e48\u51fd\u6570 -f -f \u662f\u4e25\u683c\u51f9\u51fd\u6570\u3002","title":"\u51f8\u51fd\u6570\u4e0e\u51f9\u51fd\u6570"},{"location":"optimisation/convex_concave/#_2","text":"Restriction of a Convex Function to a Line \u5bf9\u4e8e\u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R} f: \\mathbb{R}^n \\rightarrow \\mathbb{R} \uff0c\u82e5\u8be5\u51fd\u6570\u5728\u6bcf\u4e00\u4e2a\u65b9\u5411\u4e0a g(t) = f(x + tv): \\mathbb{R} \\rightarrow \\mathbb{R} g(t) = f(x + tv): \\mathbb{R} \\rightarrow \\mathbb{R} \u90fd\u662f\u51f8\u7684\uff0c\u5219\u8be5\u51fd\u6570\u662f\u51f8\u7684\u3002 \u8fd9\u4e2a\u65b9\u5f0f\u901a\u8fc7\u5c06\u5224\u5b9a\u4e00\u4e2a\u5b9a\u4e49\u57df\u4e3a \\mathbb{R}^n \\mathbb{R}^n \u7684\u51fd\u6570\u7684\u51f8\u6027\u7684\u95ee\u9898\u8f6c\u6362\u4e3a n n \u4e2a\u5b9a\u4e49\u57df\u4e3a \\mathbb{R} \\mathbb{R} \u7684\u95ee\u9898\u6765\u964d\u4f4e\u8ba1\u7b97\u91cf\uff0c\u4f46\u5176\u4e0d\u9002\u7528\u4e8e\u591a\u53d8\u91cf\u51fd\u6570\u3002 f(X) = \\log \\det x \\begin{align} g(t) &= \\log \\det (X = tV)\\\\ &= \\log \\det X + \\log \\det (I + tX^{-1/2}VX^{1/2})\\\\ &= \\log \\det X + \\sum^n{i=1} \\log (1 + t\\lambda_i)\\\\ \\end{align} \\begin{align} g(t) &= \\log \\det (X = tV)\\\\ &= \\log \\det X + \\log \\det (I + tX^{-1/2}VX^{1/2})\\\\ &= \\log \\det X + \\sum^n{i=1} \\log (1 + t\\lambda_i)\\\\ \\end{align} \u5176\u4e2d \\lambda_i \\lambda_i \u662f X^{-1/2}VX^{1/2} X^{-1/2}VX^{1/2} \u7684\u7279\u5f81\u503c\u3002 \u56e0\u4e3a g g \u5728 t t \u4e2d\u662f\u51f9\u7684\uff0c\u6240\u4ee5f\u662f\u51f9\u51fd\u6570\u3002 \u6269\u5c55\u503c\u5ef6\u7533 \u51fd\u6570 f: \\mathbb{R}^n \\rightarrow \\mathbb{R} f: \\mathbb{R}^n \\rightarrow \\mathbb{R} \u7684\u6269\u5c55\u503c\u5ef6\u7533 \\tlide{f} \\tlide{f} \u88ab\u5982\u4e0b\u5b9a\u4e49\uff1a $$\\tlide{f} = \\begin{cases}\\begin{align} f(x), & x \\in \\dom f\\\\ \\infty, & x \\not \\in \\dom f \\end{align}\\end{cases} $\\mathbb{R}\u4e0a\u51f8\u51fd\u6570 \u51f8\u51fd\u6570\uff1a \u4eff\u5c04\uff1a ax + b ax + b \u5e42 ^\\star ^\\star \uff1a x^a, \\ s.t. \\ a \\geq 1 \\text{or} a \\leq 0 x^a, \\ s.t. \\ a \\geq 1 \\text{or} a \\leq 0 \u6307\u6570\uff1a e^{ax} e^{ax} \u8d1f\u71b5 ^\\star ^\\star \uff1a x \\log x x \\log x \u51f9\u51fd\u6570\uff1a \u4eff\u5c04\uff1a ax + b ax + b \u5e42 ^\\star ^\\star \uff1a x^a, \\ s.t. \\ 0 \\leq a \\leq 1 x^a, \\ s.t. \\ 0 \\leq a \\leq 1 \u5bf9\u6570 ^\\star ^\\star \uff1a \\log x \\log x ^\\star ^\\star \uff1a x > 0 x > 0 \u6211\u4eec\u53ef\u4ee5\u6ce8\u610f\u5230\uff0c\u6240\u6709\u7684\u4eff\u5c04\u51fd\u6570\u662f\u65e2\u51f8\u53c8\u51f9\u7684\u3002","title":"\u51f8\u51fd\u6570\u7684\u5224\u5b9a"},{"location":"optimisation/dual_cone_generalized_inequality/","text":"\u5728\u4e86\u89e3\u4e86\u9525\u540e\uff0c\u6211\u4eec\u5bf9\u9525\u505a\u66f4\u8fdb\u4e00\u6b65\u7684\u8ba8\u8bba\u3002 \u6b63\u5e38\u9525 # \u6b63\u5e38\u9525\uff08proper cone\uff09 \u4e00\u4e2a\u9525 K \\subseteq \\mathbb{R}^n K \\subseteq \\mathbb{R}^n \u88ab\u79f0\u4f5c\u4e00\u4e2a\u6b63\u5e38\u9525\uff0c\u5f53\uff1a K K \u662f\u51f8\u96c6 K K \u95ed\u5408\uff1a\u5305\u62ec\u4ed6\u7684\u8fb9\u754c K K \u662f\u5b9e\u9525\uff08solid\uff09\uff1a\u5305\u62ec\u975e\u7a7a\u5185\u90e8\uff08interior\uff09 K K \u662f\u5c16\u9525\uff08pointed\uff09\uff1a\u4e0d\u5305\u62ec\u7ebf\uff08line\uff09 \u6b63\u5b9a\u9525\u662f\u4e00\u4e2a\u6b63\u5e38\u9525\u5417 \u662f\u7684 \u6b63\u5e38\u9525 \u975e\u8d1f\u8c61\u9650 K = \\mathbb{R}^n_+ K = \\mathbb{R}^n_+ \u534a\u6b63\u5b9a\u9525 K = \\mathbb{S}^n_+ K = \\mathbb{S}^n_+ [0, 1] [0, 1] \u4e0a\u7684\u975e\u8d1f\u591a\u9879\u5f0f K = \\{x \\in \\mathbb{R}^n \\mid \\sum_{i=1}^n x_nt^{n-1} \\text{for} t \\in [0, 1\\} K = \\{x \\in \\mathbb{R}^n \\mid \\sum_{i=1}^n x_nt^{n-1} \\text{for} t \\in [0, 1\\} \u6b63\u5e38\u9525\u7684\u5bf9\u5076\u9525\u7684\u5bf9\u5076\u9525\u662f\u4ed6\u672c\u8eab\u5417 \u662f\u7684 \u5e7f\u4e49\u4e0d\u7b49\u5f0f # \u5e7f\u4e49\u4e0d\u7b49\u5f0f\uff08generalised inequality\uff09 \u4e00\u4e2a\u7531\u6b63\u5e38\u9525 K K \u5b9a\u4e49\u7684\u5e7f\u4e49\u4e0d\u7b49\u5f0f\u6ee1\u8db3\uff1a x \\preceq_K y \\quad \\Longleftrightarrow \\quad y - k \\in K x \\preceq_K y \\quad \\Longleftrightarrow \\quad y - k \\in K x \\prec_K y \\quad \\Longleftrightarrow \\quad y - k \\in int(K) x \\prec_K y \\quad \\Longleftrightarrow \\quad y - k \\in int(K) \u5e7f\u4e49\u4e0d\u7b49\u5f0f\u662f\u975e\u7ebf\u6027\u7684 \u6211\u4eec\u53ef\u4ee5\u6709 x \\preceq_K y x \\preceq_K y \u548c y \\preceq_K x y \\preceq_K x \u540c\u65f6\u6210\u7acb \u4f46\u662f\u5176\u4ed6\u5c5e\u6027\u90fd\u5f88\u76f8\u4f3c\uff0c\u5982 x \\preceq_K y, u \\preceq_K v \\quad \\Rightarrow x + u \\preceq_K y + v x \\preceq_K y, u \\preceq_K v \\quad \\Rightarrow x + u \\preceq_K y + v \u5e7f\u4e49\u4e0d\u7b49\u5f0f \u5206\u91cf\u4e0d\u7b49\u5f0f\uff08 K = \\mathbb{R}^n_+ K = \\mathbb{R}^n_+ \uff09 x \\preceq_{\\mathbb{R}^n_+} y \\quad \\Longleftrightarrow \\quad \\forall i, x_i \\leq y_i x \\preceq_{\\mathbb{R}^n_+} y \\quad \\Longleftrightarrow \\quad \\forall i, x_i \\leq y_i \u77e9\u9635\u4e0d\u7b49\u5f0f\uff08 K = \\mathbb{S}^n_+ K = \\mathbb{S}^n_+ \uff09 X \\preceq_{\\mathbb{S}^n_+} Y \\quad \\Longleftrightarrow \\quad Y - X \\text{\u534a\u6b63\u5b9a} X \\preceq_{\\mathbb{S}^n_+} Y \\quad \\Longleftrightarrow \\quad Y - X \\text{\u534a\u6b63\u5b9a} \u5bf9\u5076\u9525 # \u5bf9\u5076\u9525 \u4e00\u4e2a\u9525 K K \u7684\u5bf9\u5076\u9525\u662f K^\\star = \\{y \\mid \\forall x \\in K, y^Tx \\geq 0\\} K^\\star = \\{y \\mid \\forall x \\in K, y^Tx \\geq 0\\} \u5bf9\u5076\u9525 K = \\mathbb{R}^n_+ K = \\mathbb{R}^n_+ : K^\\star = \\mathbb{R}^n_+ K^\\star = \\mathbb{R}^n_+ K = \\mathbb{S}^n_+ K = \\mathbb{S}^n_+ : K^\\star = \\mathbb{S}^n_+ K^\\star = \\mathbb{S}^n_+ K = \\{(x, t) \\mid \\Vert x \\Vert_2 \\leq t\\} K = \\{(x, t) \\mid \\Vert x \\Vert_2 \\leq t\\} : K^\\star = \\{(x, t) \\mid \\Vert x \\Vert_2 \\leq t\\} K^\\star = \\{(x, t) \\mid \\Vert x \\Vert_2 \\leq t\\} K = \\{(x, t) \\mid \\Vert x \\Vert_1 \\leq t\\} K = \\{(x, t) \\mid \\Vert x \\Vert_1 \\leq t\\} : K^\\star = \\{(x, t) \\mid \\Vert x \\Vert_\\inf \\leq t\\} K^\\star = \\{(x, t) \\mid \\Vert x \\Vert_\\inf \\leq t\\} \u5176\u4e2d\uff0c\u524d\u4e09\u4e2a\u9525\u7684\u5bf9\u5076\u9525\u4e0e\u5176\u672c\u8eab\u4e00\u81f4\uff0c\u6211\u4eec\u5c06\u5176\u79f0\u4e3a\u81ea\u5bf9\u5076\u9525\uff08self-dual cone\uff09\u3002 \u5bf9\u5076\u6b63\u5e38\u9525 \u6b63\u5e38\u9525\u7684\u5bf9\u5076\u9525\u4e5f\u6b63\u5e38\uff0c\u56e0\u6b64\u53ef\u4ee5\u5b9a\u4e49\u5e7f\u4e49\u4e0d\u7b49\u5f0f\uff1a y \\preceq_{K^\\star} 0, \\quad \\Longleftrightarrow \\quad \\forall x \\succeq_K 0, y^Tx \\geq 0 y \\preceq_{K^\\star} 0, \\quad \\Longleftrightarrow \\quad \\forall x \\succeq_K 0, y^Tx \\geq 0 \u5bf9\u5076\u4e0d\u7b49\u7684\u6700\u5c0f\u4e0e\u6781\u5c0f # \u5bf9\u5076\u4e0d\u7b49\u7684\u6700\u5c0f x x \u662f\u96c6\u5408 S S \u7684\u6700\u5c0f\u5143\uff0c\u5f53\u4e14\u4ec5\u5f53\u5bf9\u4e8e\u6240\u6709 \\lambda \\succ_{K^\\star} 0 \\lambda \\succ_{K^\\star} 0 \uff0c x x \u552f\u4e00\u6700\u5c0f\u5316 S S \u4e0a \\lambda^Tz \\lambda^Tz \u3002 \\forall y \\in S, \\ x \\preceq_K y \\forall y \\in S, \\ x \\preceq_K y \u5bf9\u5076\u4e0d\u7b49\u7684\u6781\u5c0f \u5bf9\u4e8e\u67d0\u4e9b \\lambda \\succ_{K^\\star} 0 \\lambda \\succ_{K^\\star} 0 \uff0c\u5982\u679c x x \u6700\u5c0f\u5316 S S \u4e0a\u7684 \\lambda^Tz \\lambda^Tz \uff0c\u90a3\u4e48 x x \u662f\u96c6\u5408 S S \u7684\u4e00\u4e2a\u6781\u5c0f\u5143\u3002 \u5982\u679c x x \u662f\u96c6\u5408 S S \u7684\u6781\u5c0f\u5143\uff0c\u90a3\u4e48\u5b58\u5728\u4e00\u4e2a\u4e0d\u4e3a\u96f6\u7684 \\lambda \\succ_{K^\\star} 0 \\lambda \\succ_{K^\\star} 0 \u4f7f\u5f97 x x \u6700\u5c0f\u5316 S S \u4e0a \\lambda^Tz \\lambda^Tz \u3002 \\forall y \\in S, \\ y \\preceq_K x \\Rightarrow y = x \\forall y \\in S, \\ y \\preceq_K x \\Rightarrow y = x -\\lambda -\\lambda \u5b9a\u4e49\u4e86\u652f\u6301\u8d85\u5e73\u9762\u3002 \u4e00\u4e2a\u96c6\u5408\u5fc5\u5b9a\u6709\u6700\u5c0f\u5143\u5417 \u4e0d\u662f","title":"\u5bf9\u5076\u9525\u4e0e\u5e7f\u4e49\u4e0d\u7b49\u5f0f"},{"location":"optimisation/dual_cone_generalized_inequality/#_1","text":"\u6b63\u5e38\u9525\uff08proper cone\uff09 \u4e00\u4e2a\u9525 K \\subseteq \\mathbb{R}^n K \\subseteq \\mathbb{R}^n \u88ab\u79f0\u4f5c\u4e00\u4e2a\u6b63\u5e38\u9525\uff0c\u5f53\uff1a K K \u662f\u51f8\u96c6 K K \u95ed\u5408\uff1a\u5305\u62ec\u4ed6\u7684\u8fb9\u754c K K \u662f\u5b9e\u9525\uff08solid\uff09\uff1a\u5305\u62ec\u975e\u7a7a\u5185\u90e8\uff08interior\uff09 K K \u662f\u5c16\u9525\uff08pointed\uff09\uff1a\u4e0d\u5305\u62ec\u7ebf\uff08line\uff09 \u6b63\u5b9a\u9525\u662f\u4e00\u4e2a\u6b63\u5e38\u9525\u5417 \u662f\u7684 \u6b63\u5e38\u9525 \u975e\u8d1f\u8c61\u9650 K = \\mathbb{R}^n_+ K = \\mathbb{R}^n_+ \u534a\u6b63\u5b9a\u9525 K = \\mathbb{S}^n_+ K = \\mathbb{S}^n_+ [0, 1] [0, 1] \u4e0a\u7684\u975e\u8d1f\u591a\u9879\u5f0f K = \\{x \\in \\mathbb{R}^n \\mid \\sum_{i=1}^n x_nt^{n-1} \\text{for} t \\in [0, 1\\} K = \\{x \\in \\mathbb{R}^n \\mid \\sum_{i=1}^n x_nt^{n-1} \\text{for} t \\in [0, 1\\} \u6b63\u5e38\u9525\u7684\u5bf9\u5076\u9525\u7684\u5bf9\u5076\u9525\u662f\u4ed6\u672c\u8eab\u5417 \u662f\u7684","title":"\u6b63\u5e38\u9525"},{"location":"optimisation/dual_cone_generalized_inequality/#_2","text":"\u5e7f\u4e49\u4e0d\u7b49\u5f0f\uff08generalised inequality\uff09 \u4e00\u4e2a\u7531\u6b63\u5e38\u9525 K K \u5b9a\u4e49\u7684\u5e7f\u4e49\u4e0d\u7b49\u5f0f\u6ee1\u8db3\uff1a x \\preceq_K y \\quad \\Longleftrightarrow \\quad y - k \\in K x \\preceq_K y \\quad \\Longleftrightarrow \\quad y - k \\in K x \\prec_K y \\quad \\Longleftrightarrow \\quad y - k \\in int(K) x \\prec_K y \\quad \\Longleftrightarrow \\quad y - k \\in int(K) \u5e7f\u4e49\u4e0d\u7b49\u5f0f\u662f\u975e\u7ebf\u6027\u7684 \u6211\u4eec\u53ef\u4ee5\u6709 x \\preceq_K y x \\preceq_K y \u548c y \\preceq_K x y \\preceq_K x \u540c\u65f6\u6210\u7acb \u4f46\u662f\u5176\u4ed6\u5c5e\u6027\u90fd\u5f88\u76f8\u4f3c\uff0c\u5982 x \\preceq_K y, u \\preceq_K v \\quad \\Rightarrow x + u \\preceq_K y + v x \\preceq_K y, u \\preceq_K v \\quad \\Rightarrow x + u \\preceq_K y + v \u5e7f\u4e49\u4e0d\u7b49\u5f0f \u5206\u91cf\u4e0d\u7b49\u5f0f\uff08 K = \\mathbb{R}^n_+ K = \\mathbb{R}^n_+ \uff09 x \\preceq_{\\mathbb{R}^n_+} y \\quad \\Longleftrightarrow \\quad \\forall i, x_i \\leq y_i x \\preceq_{\\mathbb{R}^n_+} y \\quad \\Longleftrightarrow \\quad \\forall i, x_i \\leq y_i \u77e9\u9635\u4e0d\u7b49\u5f0f\uff08 K = \\mathbb{S}^n_+ K = \\mathbb{S}^n_+ \uff09 X \\preceq_{\\mathbb{S}^n_+} Y \\quad \\Longleftrightarrow \\quad Y - X \\text{\u534a\u6b63\u5b9a} X \\preceq_{\\mathbb{S}^n_+} Y \\quad \\Longleftrightarrow \\quad Y - X \\text{\u534a\u6b63\u5b9a}","title":"\u5e7f\u4e49\u4e0d\u7b49\u5f0f"},{"location":"optimisation/dual_cone_generalized_inequality/#_3","text":"\u5bf9\u5076\u9525 \u4e00\u4e2a\u9525 K K \u7684\u5bf9\u5076\u9525\u662f K^\\star = \\{y \\mid \\forall x \\in K, y^Tx \\geq 0\\} K^\\star = \\{y \\mid \\forall x \\in K, y^Tx \\geq 0\\} \u5bf9\u5076\u9525 K = \\mathbb{R}^n_+ K = \\mathbb{R}^n_+ : K^\\star = \\mathbb{R}^n_+ K^\\star = \\mathbb{R}^n_+ K = \\mathbb{S}^n_+ K = \\mathbb{S}^n_+ : K^\\star = \\mathbb{S}^n_+ K^\\star = \\mathbb{S}^n_+ K = \\{(x, t) \\mid \\Vert x \\Vert_2 \\leq t\\} K = \\{(x, t) \\mid \\Vert x \\Vert_2 \\leq t\\} : K^\\star = \\{(x, t) \\mid \\Vert x \\Vert_2 \\leq t\\} K^\\star = \\{(x, t) \\mid \\Vert x \\Vert_2 \\leq t\\} K = \\{(x, t) \\mid \\Vert x \\Vert_1 \\leq t\\} K = \\{(x, t) \\mid \\Vert x \\Vert_1 \\leq t\\} : K^\\star = \\{(x, t) \\mid \\Vert x \\Vert_\\inf \\leq t\\} K^\\star = \\{(x, t) \\mid \\Vert x \\Vert_\\inf \\leq t\\} \u5176\u4e2d\uff0c\u524d\u4e09\u4e2a\u9525\u7684\u5bf9\u5076\u9525\u4e0e\u5176\u672c\u8eab\u4e00\u81f4\uff0c\u6211\u4eec\u5c06\u5176\u79f0\u4e3a\u81ea\u5bf9\u5076\u9525\uff08self-dual cone\uff09\u3002 \u5bf9\u5076\u6b63\u5e38\u9525 \u6b63\u5e38\u9525\u7684\u5bf9\u5076\u9525\u4e5f\u6b63\u5e38\uff0c\u56e0\u6b64\u53ef\u4ee5\u5b9a\u4e49\u5e7f\u4e49\u4e0d\u7b49\u5f0f\uff1a y \\preceq_{K^\\star} 0, \\quad \\Longleftrightarrow \\quad \\forall x \\succeq_K 0, y^Tx \\geq 0 y \\preceq_{K^\\star} 0, \\quad \\Longleftrightarrow \\quad \\forall x \\succeq_K 0, y^Tx \\geq 0","title":"\u5bf9\u5076\u9525"},{"location":"optimisation/dual_cone_generalized_inequality/#_4","text":"\u5bf9\u5076\u4e0d\u7b49\u7684\u6700\u5c0f x x \u662f\u96c6\u5408 S S \u7684\u6700\u5c0f\u5143\uff0c\u5f53\u4e14\u4ec5\u5f53\u5bf9\u4e8e\u6240\u6709 \\lambda \\succ_{K^\\star} 0 \\lambda \\succ_{K^\\star} 0 \uff0c x x \u552f\u4e00\u6700\u5c0f\u5316 S S \u4e0a \\lambda^Tz \\lambda^Tz \u3002 \\forall y \\in S, \\ x \\preceq_K y \\forall y \\in S, \\ x \\preceq_K y \u5bf9\u5076\u4e0d\u7b49\u7684\u6781\u5c0f \u5bf9\u4e8e\u67d0\u4e9b \\lambda \\succ_{K^\\star} 0 \\lambda \\succ_{K^\\star} 0 \uff0c\u5982\u679c x x \u6700\u5c0f\u5316 S S \u4e0a\u7684 \\lambda^Tz \\lambda^Tz \uff0c\u90a3\u4e48 x x \u662f\u96c6\u5408 S S \u7684\u4e00\u4e2a\u6781\u5c0f\u5143\u3002 \u5982\u679c x x \u662f\u96c6\u5408 S S \u7684\u6781\u5c0f\u5143\uff0c\u90a3\u4e48\u5b58\u5728\u4e00\u4e2a\u4e0d\u4e3a\u96f6\u7684 \\lambda \\succ_{K^\\star} 0 \\lambda \\succ_{K^\\star} 0 \u4f7f\u5f97 x x \u6700\u5c0f\u5316 S S \u4e0a \\lambda^Tz \\lambda^Tz \u3002 \\forall y \\in S, \\ y \\preceq_K x \\Rightarrow y = x \\forall y \\in S, \\ y \\preceq_K x \\Rightarrow y = x -\\lambda -\\lambda \u5b9a\u4e49\u4e86\u652f\u6301\u8d85\u5e73\u9762\u3002 \u4e00\u4e2a\u96c6\u5408\u5fc5\u5b9a\u6709\u6700\u5c0f\u5143\u5417 \u4e0d\u662f","title":"\u5bf9\u5076\u4e0d\u7b49\u7684\u6700\u5c0f\u4e0e\u6781\u5c0f"},{"location":"optimisation/hyperplane_halfspace_polyhedra/","text":"\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u4ecb\u7ecd\u8d85\u5e73\u9762\u3001\u534a\u7a7a\u95f4\u4e0e\u591a\u9762\u4f53\u3002 \u8d85\u5e73\u9762 # \u8d85\u5e73\u9762 \u5982\u679c\u4e00\u4e2a\u96c6\u5408\u6ee1\u8db3 \\{x \\mid a^Tx = b\\} \\ s.t. \\ a \\in \\mathbb{R}^n, a \\neq 0, b \\in \\mathbb{R} \\{x \\mid a^Tx = b\\} \\ s.t. \\ a \\in \\mathbb{R}^n, a \\neq 0, b \\in \\mathbb{R} \u90a3\u4e48\u6211\u4eec\u5c06\u5176\u79f0\u4e3a\u4e00\u4e2a\u8d85\u5e73\u9762\u3002 \u4ece\u89e3\u6790\u6765\u770b\uff0c\u8d85\u5e73\u9762\u662f x x \u5206\u91cf\u4e2d\u7ebf\u6027\u4e0d\u5b9a\u65b9\u7a0b\u7684\u89e3\u96c6\uff1b\u4ece\u51e0\u4f55\u6765\u8bf4\uff0c\u8d85\u5e73\u9762\u4e5f\u53ef\u4ee5\u88ab\u89e3\u91ca\u4e3a\u4e0e\u7ed9\u5b9a\u5411\u91cf a a \u7684\u5185\u79ef\u4e3a\u4e00\u7279\u5b9a\u503c\u7684\u70b9\u96c6\uff1b\u7531\u4e8e\u5185\u79ef\u53ef\u4ee5\u88ab\u770b\u4f5c\u662f\u4e00\u4e2a\u5411\u91cf\u5728\u53e6\u4e00\u4e2a\u5411\u91cf\u7684\u6295\u5f71\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u5c06 a a \u7406\u89e3\u4e3a\u4e00\u4e2a\u6709\u8d85\u5e73\u9762\u7684 \u6cd5\u5411\u5411\u91cf \uff0c\u90a3\u4e48\u5e38\u6570 b b \u5c31\u662f\u786e\u5b9a\u8d85\u5e73\u9762\u8ddd\u79bb\u539f\u70b9\u7684\u504f\u79fb\u91cf\u3002\u5c06\u4e0a\u5f0f\u505a\u4e00\u4e2a\u7b80\u5355\u7684\u5f62\u53d8\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230 \\{x \\mid a^T (x - x_0) = 0\\} = a^\\perp + x_0 \\{x \\mid a^T (x - x_0) = 0\\} = a^\\perp + x_0 \u8d85\u5e73\u9762\u662f\u51f8\u8fd8\u662f\u4eff\u5c04 \u4eff\u5c04 \u5206\u5272\u8d85\u5e73\u9762 # \u5206\u5272\u8d85\u5e73\u9762 \u5bf9\u4e8e\u4e0d\u76f8\u4ea4\u7684\u975e\u7a7a\u51f8\u96c6 C, D C, D \uff0c\u5b58\u5728 a \\neq 0, b a \\neq 0, b \u4f7f\u5f97\uff1a a^Tx \\leq b \\text{for} x \\in C, \\ a^Tx \\geq b \\text{for} x \\in D a^Tx \\leq b \\text{for} x \\in C, \\ a^Tx \\geq b \\text{for} x \\in D \u90a3\u4e48\u6211\u4eec\u79f0\u8d85\u5e73\u9762 \\{x \\mid a^Tx = b\\} \\{x \\mid a^Tx = b\\} \u4e3a C C \u548c D D \u7684\u5206\u5272\u8d85\u5e73\u9762\u3002 \u4e25\u683c\u5206\u5272\u8d85\u5e73\u9762\u9700\u8981\u66f4\u591a\u5047\u8bbe\uff08\u6bd4\u5982 C C \u95ed\u5408\uff0c D D \u662f\u5355\u5143\u7d20\u96c6\uff08singleton set\uff09\uff09 \u652f\u6301\u8d85\u5e73\u9762 # \u652f\u6301\u8d85\u5e73\u9762 \u96c6\u5408 C C \u5728\u8fb9\u754c\u70b9 x_0 x_0 \u7684\u652f\u6301\u8d85\u5e73\u9762\u662f \\{x \\mid a^tx = a^tx_0\\} \\{x \\mid a^tx = a^tx_0\\} \u5176\u4e2d a \\neq 0, \\ \\forall x \\in C, a^T \\leq a^Tx_0 a \\neq 0, \\ \\forall x \\in C, a^T \\leq a^Tx_0 \u652f\u6301\u8d85\u5e73\u9762\u5b9a\u7406 \u652f\u6301\u8d85\u5e73\u9762\u53ea\u5728\u51f8\u7684\u8fb9\u754c\u70b9\u5b58\u5728 \u534a\u7a7a\u95f4 # \u7a7a\u95f4 S \\subseteq \\mathbb{R}^n S \\subseteq \\mathbb{R}^n \u4e2d\u7684\u8d85\u5e73\u9762\u5c06\u8be5\u7a7a\u95f4\u5212\u5206\u6210\u4e24\u4e2a\u534a\u7a7a\u95f4\u3002 \u534a\u7a7a\u95f4 \u5982\u679c\u4e00\u4e2a\u96c6\u5408\u6ee1\u8db3 \\{x \\mid a^Tx \\leq b\\} \\ s.t. \\ a \\neq 0 \\{x \\mid a^Tx \\leq b\\} \\ s.t. \\ a \\neq 0 \u90a3\u4e48\u6211\u4eec\u5c06\u5176\u79f0\u4e3a\u4e00\u4e2a\u534a\u7a7a\u95f4\u3002 \u534a\u7a7a\u95f4\u662f\u51f8\u8fd8\u662f\u4eff\u5c04 \u51f8 \u591a\u9762\u4f53 # \u4e00\u4e2a \u591a\u9762\u4f53\uff08polyhedra\uff09 \u6307\u7684\u662f\u4e00\u4e2a\u6709\u9650\u6570\u76ee\u7684\u7ebf\u6027\u7b49\u5f0f\u4e0e\u4e0d\u7b49\u5f0f\u7684\u89e3\u96c6\uff1a \u591a\u9762\u4f53 P = \\{x \\mid a^T_jx \\leq b_j,\\ j = 1, 2, ..., m,\\ c^T_jx = d_j,\\ j = 1, 2, ..., p\\} P = \\{x \\mid a^T_jx \\leq b_j,\\ j = 1, 2, ..., m,\\ c^T_jx = d_j,\\ j = 1, 2, ..., p\\} \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u4e00\u4e2a\u591a\u9762\u4f53\u5b9e\u9645\u4e0a\u662f\u4e00\u4e2a\u6709\u9650\u6570\u91cf\u7684\u8d85\u5e73\u9762\u4e0e\u534a\u7a7a\u95f4\u7684\u4ea4\u96c6\u3002\u4eff\u5c04\u96c6\uff08\u6bd4\u5982\u5b50\u7a7a\u95f4\u3001\u8d85\u5e73\u9762\u3001\u7ebf\uff09\u3001\u5c04\u7ebf\u3001\u7ebf\u6bb5\u3001\u534a\u7a7a\u95f4\u7b49\u90fd\u662f\u591a\u9762\u4f53\u3002 \u4e0a\u5f0f\u5e38\u88ab\u5316\u7b80\u4e3a P = \\{x \\mid Ax \\preceq b, Cx = d\\} P = \\{x \\mid Ax \\preceq b, Cx = d\\} \u3002 \\preceq \\preceq \u7b26\u53f7 \\preceq \\preceq \u8868\u793a \\mathbb{R}^n \\mathbb{R}^n \u4e2d\u7684 \u5411\u91cf\u4e0d\u7b49\uff08vector inequality\uff09 \u6216\u8005 \u5206\u91cf\u4e0d\u7b49\uff08componentwise inequality\uff09 \uff1a u \\preceq v u \\preceq v \u8868\u793a u_i \\leq v_i \\ s.t. \\ i = 1, 2, ..., m u_i \\leq v_i \\ s.t. \\ i = 1, 2, ..., m \u591a\u9762\u4f53\u51f8\u5417 \u51f8 \u4e00\u4e2a\u6709\u8fb9\u754c\u7684\u591a\u9762\u4f53\u6709\u65f6\u88ab\u79f0\u4e3a \u591a\u80de\u5f62\uff08polytope\uff09 ^\\star ^\\star \u3002 ^\\star ^\\star \uff1a\u6709\u4e9b\u4eba\u503e\u5411\u4e8e\u5c06\u591a\u80de\u5f62\u4e0e\u591a\u9762\u4f53\u53cd\u8fc7\u6765\u53eb\u3002","title":"\u8d85\u5e73\u9762\u3001\u534a\u7a7a\u95f4\u4e0e\u591a\u9762\u4f53"},{"location":"optimisation/hyperplane_halfspace_polyhedra/#_1","text":"\u8d85\u5e73\u9762 \u5982\u679c\u4e00\u4e2a\u96c6\u5408\u6ee1\u8db3 \\{x \\mid a^Tx = b\\} \\ s.t. \\ a \\in \\mathbb{R}^n, a \\neq 0, b \\in \\mathbb{R} \\{x \\mid a^Tx = b\\} \\ s.t. \\ a \\in \\mathbb{R}^n, a \\neq 0, b \\in \\mathbb{R} \u90a3\u4e48\u6211\u4eec\u5c06\u5176\u79f0\u4e3a\u4e00\u4e2a\u8d85\u5e73\u9762\u3002 \u4ece\u89e3\u6790\u6765\u770b\uff0c\u8d85\u5e73\u9762\u662f x x \u5206\u91cf\u4e2d\u7ebf\u6027\u4e0d\u5b9a\u65b9\u7a0b\u7684\u89e3\u96c6\uff1b\u4ece\u51e0\u4f55\u6765\u8bf4\uff0c\u8d85\u5e73\u9762\u4e5f\u53ef\u4ee5\u88ab\u89e3\u91ca\u4e3a\u4e0e\u7ed9\u5b9a\u5411\u91cf a a \u7684\u5185\u79ef\u4e3a\u4e00\u7279\u5b9a\u503c\u7684\u70b9\u96c6\uff1b\u7531\u4e8e\u5185\u79ef\u53ef\u4ee5\u88ab\u770b\u4f5c\u662f\u4e00\u4e2a\u5411\u91cf\u5728\u53e6\u4e00\u4e2a\u5411\u91cf\u7684\u6295\u5f71\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u5c06 a a \u7406\u89e3\u4e3a\u4e00\u4e2a\u6709\u8d85\u5e73\u9762\u7684 \u6cd5\u5411\u5411\u91cf \uff0c\u90a3\u4e48\u5e38\u6570 b b \u5c31\u662f\u786e\u5b9a\u8d85\u5e73\u9762\u8ddd\u79bb\u539f\u70b9\u7684\u504f\u79fb\u91cf\u3002\u5c06\u4e0a\u5f0f\u505a\u4e00\u4e2a\u7b80\u5355\u7684\u5f62\u53d8\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230 \\{x \\mid a^T (x - x_0) = 0\\} = a^\\perp + x_0 \\{x \\mid a^T (x - x_0) = 0\\} = a^\\perp + x_0 \u8d85\u5e73\u9762\u662f\u51f8\u8fd8\u662f\u4eff\u5c04 \u4eff\u5c04","title":"\u8d85\u5e73\u9762"},{"location":"optimisation/hyperplane_halfspace_polyhedra/#_2","text":"\u5206\u5272\u8d85\u5e73\u9762 \u5bf9\u4e8e\u4e0d\u76f8\u4ea4\u7684\u975e\u7a7a\u51f8\u96c6 C, D C, D \uff0c\u5b58\u5728 a \\neq 0, b a \\neq 0, b \u4f7f\u5f97\uff1a a^Tx \\leq b \\text{for} x \\in C, \\ a^Tx \\geq b \\text{for} x \\in D a^Tx \\leq b \\text{for} x \\in C, \\ a^Tx \\geq b \\text{for} x \\in D \u90a3\u4e48\u6211\u4eec\u79f0\u8d85\u5e73\u9762 \\{x \\mid a^Tx = b\\} \\{x \\mid a^Tx = b\\} \u4e3a C C \u548c D D \u7684\u5206\u5272\u8d85\u5e73\u9762\u3002 \u4e25\u683c\u5206\u5272\u8d85\u5e73\u9762\u9700\u8981\u66f4\u591a\u5047\u8bbe\uff08\u6bd4\u5982 C C \u95ed\u5408\uff0c D D \u662f\u5355\u5143\u7d20\u96c6\uff08singleton set\uff09\uff09","title":"\u5206\u5272\u8d85\u5e73\u9762"},{"location":"optimisation/hyperplane_halfspace_polyhedra/#_3","text":"\u652f\u6301\u8d85\u5e73\u9762 \u96c6\u5408 C C \u5728\u8fb9\u754c\u70b9 x_0 x_0 \u7684\u652f\u6301\u8d85\u5e73\u9762\u662f \\{x \\mid a^tx = a^tx_0\\} \\{x \\mid a^tx = a^tx_0\\} \u5176\u4e2d a \\neq 0, \\ \\forall x \\in C, a^T \\leq a^Tx_0 a \\neq 0, \\ \\forall x \\in C, a^T \\leq a^Tx_0 \u652f\u6301\u8d85\u5e73\u9762\u5b9a\u7406 \u652f\u6301\u8d85\u5e73\u9762\u53ea\u5728\u51f8\u7684\u8fb9\u754c\u70b9\u5b58\u5728","title":"\u652f\u6301\u8d85\u5e73\u9762"},{"location":"optimisation/hyperplane_halfspace_polyhedra/#_4","text":"\u7a7a\u95f4 S \\subseteq \\mathbb{R}^n S \\subseteq \\mathbb{R}^n \u4e2d\u7684\u8d85\u5e73\u9762\u5c06\u8be5\u7a7a\u95f4\u5212\u5206\u6210\u4e24\u4e2a\u534a\u7a7a\u95f4\u3002 \u534a\u7a7a\u95f4 \u5982\u679c\u4e00\u4e2a\u96c6\u5408\u6ee1\u8db3 \\{x \\mid a^Tx \\leq b\\} \\ s.t. \\ a \\neq 0 \\{x \\mid a^Tx \\leq b\\} \\ s.t. \\ a \\neq 0 \u90a3\u4e48\u6211\u4eec\u5c06\u5176\u79f0\u4e3a\u4e00\u4e2a\u534a\u7a7a\u95f4\u3002 \u534a\u7a7a\u95f4\u662f\u51f8\u8fd8\u662f\u4eff\u5c04 \u51f8","title":"\u534a\u7a7a\u95f4"},{"location":"optimisation/hyperplane_halfspace_polyhedra/#_5","text":"\u4e00\u4e2a \u591a\u9762\u4f53\uff08polyhedra\uff09 \u6307\u7684\u662f\u4e00\u4e2a\u6709\u9650\u6570\u76ee\u7684\u7ebf\u6027\u7b49\u5f0f\u4e0e\u4e0d\u7b49\u5f0f\u7684\u89e3\u96c6\uff1a \u591a\u9762\u4f53 P = \\{x \\mid a^T_jx \\leq b_j,\\ j = 1, 2, ..., m,\\ c^T_jx = d_j,\\ j = 1, 2, ..., p\\} P = \\{x \\mid a^T_jx \\leq b_j,\\ j = 1, 2, ..., m,\\ c^T_jx = d_j,\\ j = 1, 2, ..., p\\} \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u4e00\u4e2a\u591a\u9762\u4f53\u5b9e\u9645\u4e0a\u662f\u4e00\u4e2a\u6709\u9650\u6570\u91cf\u7684\u8d85\u5e73\u9762\u4e0e\u534a\u7a7a\u95f4\u7684\u4ea4\u96c6\u3002\u4eff\u5c04\u96c6\uff08\u6bd4\u5982\u5b50\u7a7a\u95f4\u3001\u8d85\u5e73\u9762\u3001\u7ebf\uff09\u3001\u5c04\u7ebf\u3001\u7ebf\u6bb5\u3001\u534a\u7a7a\u95f4\u7b49\u90fd\u662f\u591a\u9762\u4f53\u3002 \u4e0a\u5f0f\u5e38\u88ab\u5316\u7b80\u4e3a P = \\{x \\mid Ax \\preceq b, Cx = d\\} P = \\{x \\mid Ax \\preceq b, Cx = d\\} \u3002 \\preceq \\preceq \u7b26\u53f7 \\preceq \\preceq \u8868\u793a \\mathbb{R}^n \\mathbb{R}^n \u4e2d\u7684 \u5411\u91cf\u4e0d\u7b49\uff08vector inequality\uff09 \u6216\u8005 \u5206\u91cf\u4e0d\u7b49\uff08componentwise inequality\uff09 \uff1a u \\preceq v u \\preceq v \u8868\u793a u_i \\leq v_i \\ s.t. \\ i = 1, 2, ..., m u_i \\leq v_i \\ s.t. \\ i = 1, 2, ..., m \u591a\u9762\u4f53\u51f8\u5417 \u51f8 \u4e00\u4e2a\u6709\u8fb9\u754c\u7684\u591a\u9762\u4f53\u6709\u65f6\u88ab\u79f0\u4e3a \u591a\u80de\u5f62\uff08polytope\uff09 ^\\star ^\\star \u3002 ^\\star ^\\star \uff1a\u6709\u4e9b\u4eba\u503e\u5411\u4e8e\u5c06\u591a\u80de\u5f62\u4e0e\u591a\u9762\u4f53\u53cd\u8fc7\u6765\u53eb\u3002","title":"\u591a\u9762\u4f53"},{"location":"optimisation/introduction/","text":"\u4f18\u5316\u95ee\u9898\u4e00\u76f4\u4ee5\u6765\u90fd\u662f\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u95ee\u9898\u3002\u4ee4\u4eba\u9057\u61be\u7684\u662f\uff0c\u6211\u4eec\u73b0\u6709\u7684\u77e5\u8bc6\u5bf9\u4e8e\u975e\u51f8\u4f18\u5316\u95ee\u9898\u8fd8\u5904\u4e8e\u513f\u7ae5\u6c34\u51c6\u2013\u5927\u591a\u6570\u6c42\u89e3\u975e\u51f8\u4f18\u5316\u95ee\u9898\u7684\u65b9\u6cd5\u4e5f\u53ea\u662f\u5229\u7528\u51f8\u4f18\u5316\u7684\u601d\u8def\u53bb\u6c42\u89e3\uff0c\u6216\u8005\u76f4\u63a5\u5c06\u5176\u677e\u5f1b\u6210\u4e3a\u4e00\u4e2a\u51f8\u4f18\u5316\u95ee\u9898\u3002 \u5728\u672c\u7ae0\uff0c\u6211\u4eec\u9996\u5148\u4ecb\u7ecd\u4ec0\u4e48\u662f\u51f8\u3001\u4ec0\u4e48\u662f\u51f8\u51fd\u6570\uff0c\u968f\u540e\u6211\u4eec\u5c06\u4ecb\u7ecd\u51f8\u4f18\u5316\u7684\u65b9\u6cd5\u3002 \u540e\u8bb0 \u636e\u8bf4\u4ece\u4e8b\u51f8\u4f18\u5316\u7684\u4eba\u90fd\u79c3\u4e86\u3002\u6240\u4ee5\uff0c\u770b\u5230\u8fd9\u4e00\u7bc7\u6587\u7ae0\u7684\u4f60\uff0c\u786e\u5b9a\u8981\u51f8\u5417\uff1f","title":"\u4f18\u5316"},{"location":"optimisation/pareto_optimal_curve/","text":"\u5728\u5c0f\u8282\u7684\u6700\u540e\uff0c\u8ba9\u6211\u4eec\u8ba8\u8bba\u4e00\u4e0b\u5e15\u7d2f\u6258\u4f18\u5316\u66f2\u7ebf\u3002\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u5c06\u6781\u5c0f\u5143\u7684\u601d\u60f3\u5f15\u5165\u4f18\u5316\u3002","title":"\u5e15\u7d2f\u6258\u4f18\u5316\u66f2\u7ebf"},{"location":"sketch/20190610/","text":"\u6700\u8fd1\u6709\u5f88\u957f\u4e00\u6bb5\u65f6\u95f4\u6ca1\u6709\u66f4\u65b0\u8fc7\u7f51\u7ad9\u4e86\u3002 \u4eca\u665a\u7528Jupyter Notebook\uff0c\u88ab\u7eaf\u767d\u7684\u7f51\u9875\u95ea\u778e\u4e86\u773c\u3002\u8fd9\u624d\u60f3\u8d77\u81ea\u5df1\u7684\u7f51\u7ad9\u4e5f\u662f\u778e\u773c\u7684\u53ef\u4ee5\uff0c\u8d76\u5fd9\u56de\u6765\u628a\u7f51\u9875\u6539\u6210\u9ed1\u5e95\u3002 \u4e0d\u77e5\u600e\u7684\uff0c\u6700\u8fd1\u8d8a\u6765\u8d8a\u6d41\u884c\u6697\u8272\u80cc\u666f\u4e86\u3002\u5f53\u7136\u8fd9\u4e5f\u662f\u4ef6\u597d\u4e8b\uff0c\u6bd5\u7adf\u767d\u5e95\u5f00\u518d\u6697\u4e5f\u662f\u591f\u4eae\u7684\u3002\u8bf4\u8d77\u6765\uff0c\u82f9\u679c\u53c8\u8981\u641e\u56de\u62df\u7269\u5316\u4e86\u3002\u795e\u2122iOS 7\u90a3\u4e48\u6298\u817e\u73b0\u5728\u53c8\u8981\u5f80\u56de\u641e\u3002\u771f\u4e0d\u5e0c\u671b\u82f9\u679c\u4f1a\u662f\u4e0b\u4e00\u4e2a\u767e\u5ea6\u3002 \u770b\u4e86\u770b\u63d0\u4ea4\u65e5\u5fd7\uff0c\u4e4b\u524d\u8fd8\u7b54\u5e94\u8fc7\u4eba\u8981\u5199\u4e00\u4e9b\u6709\u5173Docker\u7684\u4e1c\u897f\u3002\u4f46\u662f\u4e00\u4e2a\u6708\u4e4b\u524d\u521b\u5efa\u4e86\u6587\u4ef6\u5939\u4e4b\u540e\u5230\u73b0\u5728\u4e5f\u90fd\u6ca1\u6765\u5f97\u53ca\u5199\u3002\u8054\u60f3\u7814\u7a76\u9662\u7684\u5b9e\u4e60\u7ecf\u5386\u4e5f\u662f\u5982\u6b64\u3002 \u518d\u7b97\u7b97\u62d6\u7740\u7684\u4e8b\u60c5\u2026\u2026\u56fd\u5173\u7684\u7f51\u7ad9\u3001\u672a\u540d\u7684\u5ba2\u6237\u7aef\u3001\u4e4b\u524d\u4e00\u76f4\u60f3\u6574\u7406\u7684\u6587\u7ae0\uff0c\u54e6\u5bf9\u4e86\uff0c\u8fd8\u6709\u6444\u5f71\uff0c\u4e00\u76f4\u60f3\u62cd\u4e9b\u7167\u7247\u653e\u4e0a\u6765\u4f46\u4e5f\u6ca1\u6709\u673a\u4f1a\u2026\u2026 \u8ba1\u7b97\u673a\u89c6\u89c9\u662f\u771f\u7684\u5934\u75bc\uff0c\u4ece\u6765\u6ca1\u60f3\u8fc7\u4e00\u4e2a\u4eba\u80fd\u5199\u5b8c\u90a3\u4e48\u5927\u7684\u4e00\u4e2a\u4f5c\u4e1a\uff0c\u5e0c\u671b\u6700\u540e\u80fd\u62ff\u4e00\u4e2a\u4e0d\u9519\u7684\u6210\u7ee9\u5427\u3002 \u9a6c\u4e0a\u5c31\u662f\u4e0b\u4e00\u95e8\u8003\u8bd5\uff0c\u6211\u5c45\u7136\u8fd8\u534a\u591c\u4e0d\u7761\u5728\u535a\u5ba2\u704c\u6c34\u2026\u2026 \u8fd8\u662f\u770b\u6211\u7684\u751f\u6d3b\u5927\u7206\u70b8\u53bb\u5427\u3002 2019\u5e7406\u670810\u65e5\u4e8e\u5bbf\u820d\u3002","title":"\u4e8c\u3007\u4e00\u4e5d\u5e74 \u516d\u6708 \u5341\u65e5"},{"location":"sketch/20191108/","text":"\u6700\u8fd1\u8003\u8bd5\u5468\uff0c\u4fbf\u7ea6\u4e86\u540c\u5b66\u4e00\u8d77CSIT\u901a\u5bb5\u3002\u4eca\u665a\u548c\u5927\u9505\u4e00\u8d77\u5403\u5b8c\u9ea6\u5f53\u52b3\uff0c\u5728SUPA24\u4e70\u6c34\u65f6\u9047\u5230\u4e86\u4e9b\u4e8b\uff0c\u6709\u611f\u800c\u53d1\uff0c\u7279\u64b0\u6b64\u6587\u3002 \u5f53\u65f6\u5e94\u662f\u665a\u5341\u4e00\u65f6\u524d\u540e\uff0c\u6211\u5728\u7ea0\u7ed3\u7a76\u7adf\u5e94\u5f53\u662f\u4e70\u4e2d\u676f\u53ef\u4e50\u3001\u5927\u676f\u53ef\u4e50\u8fd8\u662f\u8d85\u5927\u676f\u53ef\u4e50\u65f6\uff0c\u7a81\u7136\u542c\u5230\u8eab\u540e\u6709\u4eba\u5927\u558a\u201cFree Hong Kong\u201d\u4e00\u7c7b\u7684\u8bdd\uff0c\u5341\u5206\u60ca\u8bb6\u3002\u6211\u56de\u5934\u770b\u4e86\u770b\uff0c\u53d1\u73b0\u786e\u5b9e\u662f\u5728\u8ddf\u6211\u4eec\u8bf4\u8bdd\u3002\u8054\u60f3\u5230\u6628\u5929\u9999\u6e2f\u7acb\u6cd5\u4f1a\u67d0\u4f55\u59d3\u8bae\u5458\u906d\u5230\u8c0b\u6740\uff0c\u4fbf\u51fa\u8a00\u8868\u793a\u652f\u6301\u201cPlz make Hong Kong free ASAP, I\u2019m too sick of them\u201d\u3002\u968f\u540e\u4ed6\u53c8\u95ee\u6211\u4ec0\u4e48\u5668\u5b98\u3001\u65b0\u7586\u7b49\u7b49\uff0c\u6211\u8010\u5fc3\u5bf9\u4ed6\u7684\u95ee\u9898\u4e88\u4ee5\u56de\u590d\uff0c\u5e76\u5bf9\u5176\u53cb\u597d\u5efa\u8bae\u201cTo know China, one must go to China\u201d\u3002\u4ed6\u663e\u7136\u4e0d\u592a\u9886\u60c5\uff0c\u4fbf\u5f00\u59cb\u81ea\u987e\u81ea\u5730\u626f\u201cWhy are you in Australia\u201d\u3001\u201cWest is the best\u201d\u7b49\uff0c\u6211\u89c1\u65e0\u6cd5\u4e0e\u5176\u6c9f\u901a\uff0c\u53ea\u5f97\u4e0e\u4ed6\u4e00\u8d77\u81ea\u987e\u81ea\u5730\u8bf4\u6211\u7684\u3002\u5f88\u5feb\uff0c\u5e97\u5458\u5bf9\u5176\u8868\u793a\u8c34\u8d23\uff0c\u8981\u6c42\u5176\u4e0d\u8981\u518d\u6253\u6270\u6211\u4eec\u4e70\u4e1c\u897f\u3002\u968f\u540e\u65c1\u8fb9\u53e6\u4e00\u4e2a\u4eba\u8d70\u8fc7\u4e5f\u6084\u6084\u8ddf\u6211\u8bf4\u4e0d\u7528\u642d\u7406\u8fd9\u4e9b\u4eba\uff0c\u82f1\u8bed\u4e2d\u5bf9\u4ed6\u4eec\u6709\u4e00\u53e5\u8bdd\u53eb\u201cFuck it\u201d\u3002\u6211\u5bf9\u5176\u8868\u793a\u5341\u5206\u611f\u8c22\uff0c\u968f\u540e\u8bf4\u6211\u4e5f\u5f88\u65e0\u5948\u554a\uff0c\u897f\u65b9\u5bf9\u4e2d\u56fd\u5b58\u5728\u5f88\u591a\u8bef\u89e3\uff0c\u6211\u4eec\u4f5c\u4e3a\u7559\u5b66\u751f\u6709\u4e49\u52a1\u53bb\u89e3\u51b3\u8fd9\u4e9b\u8bef\u89e3\u7b49\u7b49\uff0c\u6b64\u5916\uff0c\u6bd5\u7adf\u603b\u8981\u5141\u8bb8\u4eba\u5bb6\u8bf4\u8bdd\u7684\u4e48\u3002\u6b64\u65f6\uff0c\u4ed6\u53c8\u5f00\u59cb\u5728\u4e00\u65c1\u903c\u903c\uff0c\u8fd9\u4e2a\u4eba\u4fbf\u8d70\u8fc7\u53bb\u55b7\u4e86\u4ed6\u4e00\u987f\u2026\u2026\u55ef\uff0c\u6211\u6e05\u695a\u7684\u542c\u5230\u4ed6\u8bf4\u4e86\u201cFuck it\u201d\u3002\u968f\u540e\u90a3\u4e24\u4eba\u4fbf\u79bb\u5f00\u4e86\u5c0f\u5e97\u3002\u7ed3\u8d26\u65f6\uff0c\u6536\u94f6\u5c0f\u54e5\u4e5f\u8ddf\u6211\u4eec\u8bf4\u522b\u653e\u5728\u5fc3\u4e0a\uff0c\u4ed6\u4e5f\u5f88\u7ecf\u5e38\u9047\u5230\u8fd9\u6837\u7684\u4eba\u7b49\u7b49\uff0c\u6211\u4eec\u4e00\u8d77\u5410\u69fd\u4e86\u4e24\u53e5\uff0c\u4e92\u9053\u665a\u5b89\u4fbf\u56de\u6765\u7ee7\u7eed\u5b66\u4e60\u3002 \u56de\u6765\u540e\u60f3\u60f3\uff0c\u4eca\u5929\u7684\u5e94\u5bf9\u65b9\u5f0f\u8fd8\u662f\u633a\u503c\u5f97\u8bb0\u4e00\u4e0b\u7684\u3002\u4e0e\u4eba\u8ba8\u8bba\u5f53\u4e0d\u5351\u4e0d\u4ea2\u3002\u80fd\u8ba8\u8bba\u5219\u8ba8\u8bba\uff0c\u4f46\u82e5\u5bf9\u65b9\u65e0\u610f\u8ba8\u8bba\uff0c\u4e5f\u6ca1\u5fc5\u8981\u4e00\u76f4\u8ddf\u4ed6\u7ea0\u7f20\uff0c\u5207\u5fcc\u88ab\u4eba\u7275\u7740\u9f3b\u5b50\u8d70\u3002\u6211\u4e2d\u534e\u4e43\u6587\u660e\u4e4b\u90a6\uff0c\u4e0e\u4eba\u8c08\u5f53\u6653\u4e4b\u4ee5\u60c5\u3001\u52a8\u4e4b\u4ee5\u7406\uff0c\u4e0d\u5e94\u9531\u94e2\u5fc5\u8f83\uff0c\u6709\u4f24\u793c\u4eea\u3002\u6b64\u5916\uff0c\u61c2\u662f\u975e\u3001\u660e\u4e8b\u7406\u7684\u4eba\u662f\u591a\u6570\uff0c\u4e5f\u6ca1\u5fc5\u8981\u592a\u8fc7\u5728\u610f\u5c11\u6570\u4eba\u3002 \u7279\u64b0\u6b64\u6587\uff0c\u4ee5\u4f9b\u8ba8\u8bba\u3002 \u5df1\u4ea5\u5e74\u8f9c\u6708 \u4e8e\u79d1\u5b66\u4e0e\u4fe1\u606f\u6280\u672f\u5b66\u9662","title":"\u4e8c\u3007\u4e00\u4e5d\u5e74 \u5341\u4e00\u6708 \u516b\u65e5"},{"location":"sketch/20200404/","text":"\u6390\u6307\u4e00\u7b97\uff0c\u8ddd\u79bb\u4e0a\u4e00\u6b21\u5199\u6587\u7ae0\u53c8\u5feb\u534a\u5e74\u4e86\u3002 \u8fc7\u53bb\u7684\u4e94\u4e2a\u6708\uff0c\u5c24\u5176\u662f\u8fc7\u53bb\u7684\u4e00\u4e2a\u6708\u591a\u8bf4\u662f\u6211\u6709\u8bb0\u5fc6\u4ee5\u6765\u6700\u5fd9\u788c\u7684\u4e00\u4e2a\u6708\u6015\u662f\u4e1d\u6beb\u4e0d\u8fc7\u5206\u3002\u671f\u672b\u8003\u5b8c\u660f\u660f\u7761\u4e86\u4e24\u5929\uff0c\u672c\u6765\u5df2\u7ecf\u653e\u5f03\u56de\u56fd\u7684\u5e0c\u671b\u65f6\u5728\u6e38\u535a\u58eb\u7684\u63a8\u8350\u4e0b\u62ff\u5230\u4e86\u5546\u6c64\u7684offer\u3002\u8fd8\u8bb0\u5f97\u5f53\u65f6\u62ff\u5230\u53e3\u5934offer\u65f6\u6709\u591a\u6fc0\u52a8\uff0c\u4ee5\u53ca\u4e4b\u540e\u8fdf\u8fdf\u7b49\u4e0d\u6765\u6b63\u5f0foffer\u65f6\u6709\u591a\u7126\u6025\u3002\u4f46\u90a3\u51e0\u5929\u6bcf\u5929\u6253\u6253\u6e38\u620f\u8ffd\u8ffd\u5267\uff0c\u665a\u4e0a\u53bb\u5403\u5df4\u8700\u7684\u5c0f\u7092\u8089\u662f\u771f\u7684\u5e78\u798f\u3002\u4ed4\u7ec6\u60f3\u60f3\uff0c\u597d\u50cf\u81ea\u56de\u56fd\u4ee5\u540e\u5c31\u8fd8\u4ece\u6765\u6ca1\u6253\u5f00\u8fc7\u6e38\u620f\u2026\u2026 \u628a\u65e5\u5386\u7ffb\u56de\u5e74\u524d\uff0c\u6700\u5f00\u59cb\u6211\u8fd8\u4e0d\u77e5\u9053\u5b9e\u4e60\u751f\u53ef\u4ee5\u63d0\u524d\u8d70\uff0c\u4e8e\u662f\u4fbf\u8ba2\u4e86\u5e74\u4e8c\u5341\u4e5d\u56de\u5bb6\u7684\u706b\u8f66\u7968\u300221\u53f7\u90a3\u5929\u6211\u4eec\u5728\u7406\u60f3\u9644\u8fd1\u5403\u996d\uff0c\u4e00\u884c\u4e94\u516d\u4e2a\u4eba\u5c31\u6211\u4e00\u4e2a\u6ca1\u6234\u53e3\u7f69\uff0c\u5f53\u65f6\u5927\u5bb6\u8fd8\u5f00\u73a9\u7b11\u8bf4\u522b\u4eba\u90fd\u6234\u4e86\u6211\u6234\u4e0d\u6234\u90fd\u4e00\u6837\u3002\u5f53\u65f6\u5927\u5bb6\u5e94\u8be5\u90fd\u6ca1\u610f\u8bc6\u5230\u8fd9\u6b21\u75ab\u60c5\u80fd\u53d1\u5c55\u5230\u73b0\u5728\u6b7b\u4ea1\u6570\u582a\u6bd4\u6d41\u611f\u7684\u5730\u6b65\u2013\u5f53\u65f6\u7684\u5f88\u591a\u8bc1\u636e\u90fd\u8868\u660e\u65b0\u51a0\u7684\u53d7\u4f53\u4eb2\u548c\u80fd\u529b\u4e0e\u975e\u5178\u63a5\u8fd1\uff0c\u518d\u52a0\u4e0a\u4e25\u91cd\u7a0b\u5ea6\u76f8\u6bd4\u5176\u4ed6\u51a0\u72b6\u75c5\u6bd2\u6240\u81f4\u80ba\u708e\u6765\u8bf4\u51e0\u4e4e\u662f\u5c0f\u513f\u79d1\u300223\u53f7\u56de\u5230\u5bb6\u662f\u8fd9\u51e0\u4e2a\u6708\u5c11\u6709\u7684\u95f2\u4e0b\u6765\u7684\u65f6\u5149\u3002\u95f2\u4e0b\u6765\u4fbf\u5237\u4e86\u5237\u624b\u673a\uff0c\u4e5f\u5927\u6982\u662f\u8fd9\u662f\u624d\u610f\u8bc6\u5230\u75ab\u60c5\u6bd4\u6211\u60f3\u8c61\u4e2d\u7684\u66f4\u4e25\u91cd\u3002\u4f5c\u4e3a\u4e00\u4e2a\u5fd7\u5728\u4ece\u4e8b\u6df1\u5ea6\u5b66\u4e60\u7684\u4eba\uff0c\u81ea\u7136\u603b\u662f\u5173\u6ce8\u6570\u636e\u7684\u3002\u4e8e\u662f\u4fbf\u60f3\u7740\u53d1\u8d77\u4e00\u4e2a\u9879\u76ee\u53bb\u6536\u96c6\u7ec6\u7c92\u5ea6\u6570\u636e\u4ee5\u4f9b\u4e4b\u540e\u5206\u6790\uff0c\u5c31\u8fd9\u6837\uff0cwuhan.support\u8bde\u751f\u4e86\u3002\u5f53\u5929\u665a\u4e0a\u6211\u4eec\u8ba8\u8bba\u4e86\u4e00\u4e0b\uff0c\u53c8\u8ba4\u4e3a\u6570\u636e\u673a\u5668\u6302\u7740\u6536\u96c6\u5c31\u597d\u4e86\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u8ba1\u7b97\u673a\u5b66\u751f\uff0c\u6211\u4eec\u80fd\u505a\u7684\u5e94\u8be5\u4f1a\u66f4\u591a\u4e00\u4e9b\u3002\u4e8e\u662f\uff0c\u6211\u4eec\u4ece\u4e00\u4e2a\u4e09\u4eba\u7684\u5c0f\u9879\u76ee\uff0c\u9010\u6e10\u6269\u5f20\u3001\u6269\u5f20\uff0c\u6700\u540e\u8fbe\u5230\u4e86\u4e94\u767e\u591a\u4eba\u7684\u89c4\u6a21\u3002\u6211\u7684\u65b0\u5e74\u4e5f\u6ca1\u4e86\uff0c\u8fc7\u53bb\u5341\u51e0\u5e74\u6ca1\u65ad\u8fc7\u7684\u6625\u665a\u5728\u4eca\u5e74\u65ad\u4e86\uff0c\u751a\u81f3\u4e8e\u6211\u7684\u5e74\u591c\u996d\u90fd\u6ce1\u4e86\u6c64\u3002\u671f\u95f4\u7684\u8f9b\u9178\u82e6\u8fa3\u8fd8\u662f\u4e0d\u63d0\u4e86\uff0c\u76f8\u6bd4\u4e8e\u5728\u4e00\u7ebf\u7684\u4eba\u5f88\u96be\u8bf4\u7b97\u5f97\u4e0a\u4ec0\u4e48\u3002\u4f46\u8fd8\u662f\u5f88\u9ad8\u5174\u80fd\u8ba4\u8bc6\u8fd9\u4e48\u591a\u5fd7\u540c\u9053\u5408\u7684\u4f19\u4f34\u3002 \u4eca\u5929\u5199\u4e86\u4e00\u5929\u6587\u6863\uff0c\u8f6c\u773c\u53c8\u5230\u4e86\u4e09\u70b9\u591a\u3002\u53ef\u601c\u62112300\u7684\u5f00\u53d1\u677f\u5230\u73b0\u5728\u8fd8\u6ca1\u88c5\u597d\u3002\u770b\u4e86\u770b\u7968\u5708\uff0c\u53c8\u88ab\u65b0\u51a0\u5237\u4e86\u5c4f\u3002\u539f\u6765\u662f\u4eca\u5929\u88ab\u5b9a\u4e3a\u4e86\u5168\u56fd\u54c0\u60bc\u65e5\u3002\u8111\u6d77\u91cc\u77ac\u95f4\u590d\u73b0\u4e86\u4e00\u5806\u4e1c\u897f\uff0c\u8bf8\u5982\u201c\u5929\u707e\u65e0\u60c5\u4eba\u6709\u60c5\u201d\u7b49\u7b49\u3002\u4f46\u6700\u7ec8\u5374\u4ec0\u4e48\u90fd\u6ca1\u80fd\u53d1\u51fa\u53bb\u3002\u751a\u81f3\u4e8e\u6b64\u65f6\uff0c\u4e5f\u4e0d\u77e5\u9053\u8fd8\u80fd\u518d\u5199\u4e9b\u4ec0\u4e48\u3002 \u901d\u8005\u5df2\u901d\uff0c\u8981\u575a\u5f3a\u3002 \u8c28\u4ee5\u6b64\u6587\u732e\u7ed9\u6240\u6709\u5728\u4e00\u7ebf\u594b\u6218\u7684\u4eba\u3002 \u5e9a\u5b50\u5e74\u6e05\u660e \u4e8ePNP\u5b75\u5316\u5668","title":"\u4e8c\u3007\u4e8c\u3007\u5e74 \u56db\u6708 \u56db\u65e5"},{"location":"sketch/20201006/","text":"\u8f6c\u773c\u95f4\uff0c\u53c8\u5230\u4e86\u5341\u6708\u3002\u8fd9\u5927\u6982\u662f\u6211\u7b2c\u4e00\u6b21\u5728\u751f\u65e5\u5199\u6587\u7ae0\uff0c\u5f88\u53ef\u80fd\u4e5f\u662f\u672a\u6765\u5f88\u957f\u65f6\u95f4\u5f53\u4e2d\u7684\u552f\u4e00\u4e00\u6b21\u3002\u672c\u8eab\u60f3\u591a\u5520\u53e8\u4e00\u4e9b\uff0c\u4f46\u662f\u5199\u4e86\u5f88\u591a\u5374\u59cb\u7ec8\u4e0d\u6ee1\u610f\uff08\u8bba\u8bed\u6b7b\u65e9\u7684\u4eba\u662f\u600e\u6837\u7684\uff09\u3002\u90a3\u4e48\u5c31\u7b80\u5355\u8c08\u8c08\u613f\u671b\u5427\u3002 \u6709\u4e00\u4f4d\u540c\u5b66\u66fe\u8ddf\u6211\u8bf4\u5f88\u4f69\u670d\u6211\u77e5\u9053\u81ea\u5df1\u60f3\u8981\u4ec0\u4e48\u3002\u6211\u4ece\u521d\u4e2d\u5f00\u59cb\u4e00\u77e5\u534a\u89e3\u7684\u770bC++\uff0c\u9ad8\u4e2d\u4e86\u89e3\u5230MSRA\uff0c\u5927\u5b66\u63a5\u89e6\u5230CV\u7acb\u5fd7\u6765\u5546\u6c64/\u65f7\u89c6\u5b9e\u4e60\u3001\u53bbMMLab\u505aRA\uff1b\u5982\u4eca1\u548c3\u90fd\u5df2\u5b9e\u73b0\uff0c2\u5927\u6982\u662f\u5dee\u70b9\u513f\u7f18\u5206\uff0c\u597d\u51e0\u56de\u90fd\u6ca1\u80fd\u6210\u884c\uff0c4\u7684\u8bdd\uff0c\u540c\u5fd7\u4ecd\u9700\u52aa\u529b\u3002\u770b\u4e0a\u53bb\u6211\u5b9e\u73b0\u4e86\u5927\u591a\u9636\u6bb5\u6027\u76ee\u6807\uff1f\u4f46\u5176\u5b9e\u6211\u6700\u5f00\u59cb\u60f3\u53bb\u505a\u4e00\u4e2a\u533b\u751f\uff0c\u540e\u88ab\u5404\u79cd\u56e0\u7d20\u529d\u9000\u3002\u60f3\u53bb\u505a\u4e00\u4e9b\u7c7b\u4f3c\u533b\u5b66\u5f71\u50cf\u4e4b\u7c7b\u7684\u5de5\u4f5c\u4e5f\u6ca1\u6709\u53bb\u505a\u3002\u4eca\u5e74\u5b9e\u4e60\u8fc7\u7a0b\u5f53\u4e2d\u63a5\u89e6\u5230\u4e86\u66f4\u591a\u7684\u9009\u62e9\uff0c\u4e5f\u66f4\u7ecf\u5e38\u7684\u9047\u5230\u8fd9\u4e2a\u95ee\u9898\u3002 \u6240\u4ee5\uff0c\u6211\u5e0c\u671b\u80fd\u6210\u4e3a\u8fd9\u6837\u4e00\u4e2a\u6e05\u695a\u5730\u77e5\u9053\u81ea\u5df1\u60f3\u8981\u7684\u7a76\u7adf\u662f\u4ec0\u4e48\uff0c\u5e76\u575a\u5b9a\u7684\u4ed8\u51fa\u52aa\u529b\u53bb\u5c06\u5176\u5b9e\u8df5\u7684\u4eba\u3002\u5e0c\u671b\u81ea\u5df1\u4ee5\u540e\u80fd\u66f4\u591a\u60f3\u3001\u591a\u95ee\u53bb\u5b9a\u4e0b\u4e00\u4e2a\u53c8\u4e00\u4e2a\u9636\u6bb5\u6027\u76ee\u6807\uff0c\u5e76\u52aa\u529b\u53bb\u5b9e\u8df5\u4ed6\u4eec\u3002 \u5728\u8fd9\u91cc\u4e5f\u7ed9\u81ea\u5df1\u5b9a\u4e0b\u4e00\u4e2a44\u5e74\u7684\u5c0f\u76ee\u6807\uff1a\u5e0c\u671b66\u5c81\u7684\u65f6\u5019\u4f9d\u7136\u5de5\u4f5c\u5728\u4ee3\u7801\u4e00\u7ebf\uff0c\u6bcf\u5468\u5199\u4ee3\u7801\u3002\u5230\u65f6\u5019\u4e5f\u80fd\u7ed9\u81ea\u5df1\u558a\u4e00\u58f066\u3002 \u4e0e\u8bf8\u541b\u5171\u52c9 \u5e9a\u5b50\u5e74\u4e2d\u79cb \u4e8e\u4e2d\u5173\u6751 \u54e6\u5bf9\u4e86\uff0c\u6211\u8fd9\u6837\u7684\u4eba\u600e\u4e48\u80fd\u6ca1\u6709\u4e00\u4e2a\u5fc3\u613f\u5462\u3002 \u5b89\u5f97\u5e7f\u53a6\u5343\u4e07\u95f4 \u5927\u5e87\u5929\u4e0b\u5bd2\u58eb\u4ff1\u6b22\u989c \u613fAI\u8ba9\u660e\u5929\u66f4\u7f8e\u597d","title":"\u4e8c\u3007\u4e8c\u3007\u5e74 \u5341\u6708 \u516d\u65e5"},{"location":"sketch/20201101/","text":"\u200b\u5341\u4e00\u6708\u7684\u5348\u540e\uff0c\u5174\u8bb8\u662f\u524d\u591c\u6253\u6e38\u620f\u6253\u5f97\u592a\u665a\uff0c\u6211\u4e94\u70b9\u591a\u624d\u7741\u5f00\u773c\u775b\u3002\u8fd9\u5929\uff0c\u5929\u7a7a\u6bd4\u5f80\u5e38\u6697\u4e86\u8bb8\u591a\u3002\u770b\u5411\u7a97\u5916\uff0c\u5f15\u5165\u773c\u5e18\u7684\u4e0d\u662f\u719f\u6089\u7684\u582a\u57f9\u62c9\u7684\u84dd\u5929\uff0c\u8fdc\u7aef\u662f\u4e00\u7247\u6df1\u7ea2\uff0c\u4eff\u4f5b\u5170\u5dde\u7684\u6c99\u5c18\u66b4\u4e00\u822c\u3002\u5237\u4e86\u4e24\u96c6\u7f8e\u5267\u540e\u4e0b\u697c\u5403\u996d\uff0c\u7a7a\u6c14\u4e5f\u4e0d\u518d\u201c\u6e05\u65b0\u751c\u7f8e\u201d\uff0c\u800c\u6709\u79cd\u67f4\u706b\u71c3\u70e7\u4e0e\u677e\u6728\u6df7\u5408\u7684\u5473\u9053\uff0c\u523a\u9f3b\u4e2d\u7adf\u5e26\u7740\u4e9b\u8bb8\u6e05\u65b0\u3002\u6211\u4e0d\u7981\u62ff\u51fa\u624b\u673a\u67e5\u4e86\u4e00\u4e0b\u6821\u89c4\uff0c\u518d\u6b21\u786e\u8ba4\u4e86\u4e00\u4e0b\u6ca1\u6709\u5b66\u6821\u88ab\u70e7\u6bc1\u540e\u6240\u6709\u4eba\u7acb\u5373\u6bd5\u4e1a\uff08pass by catastrophe\uff09\u7684\u89c4\u5b9a\uff0c\u4e0d\u7531\u5f97\u53f9\u4e86\u53e3\u6c14\u3002 \u554a\u7b49\u4e0b\uff0c\u8868\u7838\u7816\u5934\u561b\u2026\u2026\u6211\u9519\u9e1f\u2026\u2026\u4e00\u5e74\u4e4b\u524d\u5728\u98de\u673a\u4e0a\u4fef\u89c6\u5c71\u706b\u8086\u8650\u4eff\u4f5b\u8fd8\u662f\u6628\u5929\u7684\u4e8b\u60c5\uff0c\u5f53\u65f6\u6015\u662f\u8c01\u90fd\u6ca1\u80fd\u60f3\u5230\u6211\u8fd9\u4e00\u8eb2\u5c31\u662f\u4e00\u5e74\u3002\u8fd9\u4e00\u5e74\u5927\u6982\u662f\u6211\u8fc4\u4eca\u4e3a\u6b62\u6210\u957f\u6700\u5feb\u7684\u4e00\u5e74\u3002\u9762\u4e86\u5f88\u591a\u6b21\uff0c\u88ab\u6302\u8fc7\u5f88\u591a\u4e5f\u6302\u8fc7\u5f88\u591a\uff0c\u88ab\u9e3d\u8fc7\u4e5f\u9e3d\u8fc7\u3002\u6240\u4ee5\uff0c\u5728\u8fd9\u91cc\u5199\u70b9\u513f\u4e1c\u897f\uff0c\u5e0c\u671b\u80fd\u6709\u4e9b\u5e2e\u52a9\u3002 \u6309\u7167\u56fd\u9645\u60ef\u4f8b\uff0c\u5148\u5217\u4e00\u4e0b\u8fd9\u4e00\u5e74\u4e2d\u7684\u9762\u8bd5\u60c5\u51b5\uff08\u53ef\u80fd\u4e0d\u5b8c\u6574\uff09\u3002\u5176\u4e2d\u7070\u8272\u8868\u793a\u53d1\u751f\u4e86\u5947\u602a\u7684\u4e8b\u60c5\uff0c\u9ec4\u8272\u8868\u793a\u6211\u6302\u4e86\u5b83\uff0c\u6a59\u8272\u8868\u793a\u5b83\u6302\u4e86\u6211\uff0c\u84dd\u8272\u8868\u793a\u7ed9\u4e86\u6211offer\u6ca1\u53bb\uff0c\u7eff\u8272\u8868\u793a\u6700\u7ec8\u53bb\u5411\u3002 \u65f6\u95f4 \u7c7b\u578b \u804c\u4f4d \u516c\u53f8 \u65b9\u5411 \u7ed3\u679c 1910 \u79cb\u62db \u56fd\u9645\u5546\u4e1a\u673a\u5668 \u4e00\u9762\u6302 1910 \u5b9e\u4e60 \u4ea7\u54c1\u7ecf\u7406\u5b9e\u4e60\u751f \u6ef4\u6ef4\u51fa\u884c \u4ea7\u54c1 \u4e00\u9762\u6302 1911 \u5b9e\u4e60 2019\u5e74\u5b9e\u4e60\u751f \u65f7\u89c6 \u7814\u7a76 \u4e00\u9762\u6302 1911 \u5b9e\u4e60 \u89c1\u4e60\u7814\u7a76\u5458 \u5546\u6c64 \u5de5\u7a0b \u53bb\u5411 1911 \u5b9e\u4e60 \u5b9e\u4e60\u751f \u6e05\u534e\u731b\u72ee \u7814\u7a76/\u5de5\u7a0b \u610f\u5411 2003 \u5b9e\u4e60 \u8ba1\u7b97\u673a\u89c6\u89c9\u5b9e\u4e60\u751f \u5b57\u8282\u8df3\u52a8 \u4e00\u9762\u6302 2003 \u6625\u62db \u7814\u53d1\u5de5\u7a0b\u5e08 \u5c0f\u9a6c\u667a\u884c \u5de5\u7a0b/\u7b97\u6cd5 \u4e00\u9762\u6302 2004 \u5b9e\u4e60 \u5b9e\u4e60\u751f \u5fae\u8f6f\u4e9a\u6d32\u7814\u7a76\u9662 \u7814\u7a76 \u610f\u5411 2004 \u5b9e\u4e60 \u6691\u671f\u5b9e\u4e60\u751f \u817e\u8baf \u5de5\u7a0b \u4e00\u9762\u6302 2004 \u5b9e\u4e60 \u6691\u671f\u5b9e\u4e60\u751f \u817e\u8baf \u9884\u7814 \u4e8c\u9762\u672a\u53c2\u52a0 2004 Residency Resident \u56fe\u68ee \u5de5\u7a0b \u4e00\u9762\u6302 2004 \u793e\u62db \u4f18\u56fe\u8ba1\u7b97\u673a\u89c6\u89c9\u7814\u7a76\u5458 \u817e\u8baf \u5de5\u7a0b \u4e00\u9762\u6302 2005 \u5b9e\u4e60 \u89c1\u4e60\u7814\u7a76\u5458 \u5546\u6c64 \u5de5\u7a0b \u4e09\u9762\u672a\u53d1\u8d77 2005 \u5b9e\u4e60 \u8ba1\u7b97\u673a\u89c6\u89c9\u6838\u5fc3\u7b97\u6cd5\u5b9e\u4e60\u751f \u4f9d\u56fe \u7814\u7a76 \u4e00\u9762\u6302 2005 \u5b9e\u4e60 \u5b9e\u4e60\u751f \u5fae\u8f6f\u4e9a\u6d32\u7814\u7a76\u9662 \u7814\u7a76 \u610f\u5411 2005 \u5b9e\u4e60 \u5b9e\u4e60\u751f \u5317\u4eac\u5927\u5b66 \u7814\u7a76 \u610f\u5411 2006 \u5b9e\u4e60 \u8bbf\u95ee\u5b66\u751f \u897f\u6e56\u5927\u5b66 \u7814\u7a76 \u53bb\u5411 2006 \u5b9e\u4e60 2020\u5e74\u5b9e\u4e60\u751f \u65f7\u89c6 \u7814\u7a76/\u5de5\u7a0b \u610f\u5411 2006 \u79cb\u62db \u8ba1\u7b97\u673a\u89c6\u89c9\u5de5\u7a0b\u5e08 \u963f\u91cc\u5df4\u5df4 \u5de5\u7a0b \u4e00\u9762\u6302 2007 \u793e\u62db \u8ba1\u7b97\u673a\u89c6\u89c9\u7b97\u6cd5\u9ad8\u7ea7\u7814\u7a76\u5458 \u817e\u8baf \u4e8c\u9762\u6302 2009 \u5b9e\u4e60 \u5b9e\u4e60\u751f Momenta \u5de5\u7a0b \u610f\u5411 2009 \u5b9e\u4e60 2020\u5e74\u5b9e\u4e60\u751f \u65f7\u89c6 \u7814\u7a76/\u5de5\u7a0b \u610f\u5411 2009 \u5b9e\u4e60 \u89c1\u4e60\u7814\u7a76\u5458 \u5546\u6c64 \u7814\u7a76 \u4e8c\u9762\u6302 2009 \u5b9e\u4e60 \u5b9e\u4e60\u751f \u5fae\u8f6f\u4e9a\u6d32\u7814\u7a76\u9662 \u7814\u7a76 \u610f\u5411 2009 \u5b9e\u4e60 \u89c1\u4e60\u7814\u7a76\u5458 \u5546\u6c64 \u5de5\u7a0b \u4e8c\u9762\u672a\u53d1\u8d77 2009 \u5b9e\u4e60 \u89c1\u4e60\u7814\u7a76\u5458 \u5546\u6c64 \u7814\u7a76 \u53bb\u5411 2009 \u5b9e\u4e60 Project Intern -\u91cf\u5316\u6295\u8d44-\u7b56\u7565\u5f00\u53d1\u5b9e\u4e60\u751f \u4e2d\u91d1 \u4e00\u9762\u6302 \u9996\u5148\u8bf4\u4e00\u4e0b\u7b80\u5386\u548c\u81ea\u6211\u4ecb\u7ecd\u3002\u8fd9\u4e24\u4e2a\u90e8\u5206\u5bf9\u9762\u8bd5\u6765\u8bf4\u975e\u5e38\u91cd\u8981\u3002\u9762\u8bd5\u5b98\u5bf9\u4f60\u7684\u521d\u6b65\u6620\u50cf\u901a\u5e38\u662f\u5efa\u7acb\u5728\u8fd9\u4e24\u8005\u4e4b\u4e0a\u7684\uff0c\u4ed6\u4f1a\u95ee\u4f60\u7684\u95ee\u9898\u4e5f\u548c\u8fd9\u4e24\u8005\u9ad8\u5ea6\u76f8\u5173\u3002\u56e0\u6b64\uff0c\u5728\u7b80\u5386\u4e0a\u5199\u671f\u671b\u5bf9\u65b9\u4f1a\u95ee\u7684\u4e1c\u897f\uff0c\u800c\u4e0d\u662f\u4e00\u77e5\u534a\u89e3\u7684\u5185\u5bb9\u3002\u6bd4\u5982\u6709\u7684\u540c\u5b66\u5199\u7cbe\u901aPyTorch\u5374\u8fde\u5f20\u91cf\u7684stride\u90fd\u4e0d\u4e86\u89e3\uff0c\u8fd9\u4f1a\u7ed9\u4eba\u5f88\u5dee\u7684\u6620\u50cf\u3002\u7b80\u5386\u5207\u5fcc\u5207\u5fcc\u5199\u8fc7\u5927\u8fc7\u7a7a\u7684\u5185\u5bb9\u3002\u6b64\u5916\uff0c\u81ea\u5df1\u5f97\u610f\u7684\u7ecf\u5386\u4e00\u5b9a\u8981\u5199\u4e0a\u53bb\uff0c\u5982\u679c\u7279\u522b\u5f97\u610f\uff0c\u53ef\u4ee5\u591a\u5199\u4e24\u6bb5\uff0c\u628a\u4e0d\u91cd\u8981\u7684\u7ecf\u5386\u538b\u7f29\u3002\u5207\u8bb0\u8981\u7ed9\u9762\u8bd5\u5b98\u63d0\u4f9b\u8db3\u591f\u7684\u5207\u5165\u70b9\u3002 \u51c6\u5907\u597d\u4e86\u7b80\u5386\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u9009\u7ec4\u3002\u6709\u4e00\u4e2a\u4e94\u5e74\u8ba1\u5212\uff0c\u7136\u540e\u6839\u636e\u8fd9\u4e2a\u8ba1\u5212\u53bb\u4e00\u6b65\u6b65\u843d\u5b9e\uff0c\u6211\u89c9\u5f97\u662f\u975e\u5e38\u91cd\u8981\u7684\u3002\u901a\u8fc7\u89c2\u5bdf\u4e0a\u56fe\uff0c\u6613\u8bc1\u4e92\u8054\u7f51\u4f01\u4e1a\u6211\u53ea\u9762\u4e86\u4f20\u7edf\u610f\u4e49\u4e0a\u7684\u5927\u5382\uff0c\u4e5f\u5373BAT\u4e09\u5bb6\u3002\u8fd9\u662f\u56e0\u4e3a\u7edd\u5927\u591a\u6570\u516c\u53f8\u62db\u4f60\u662f\u5e0c\u671b\u4f60\u505a\u5de5\u7a0b\u7684\uff0c\u800c\u8fd9\u548c\u6211\u7684\u4e94\u5e74\u8ba1\u5212\u5e76\u4e0d\u76f8\u7b26\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\u5bb9\u6613\u88ab\u5ffd\u89c6\u7684\u91cd\u70b9\u662f\u7ec4\u7684\u9009\u62e9\u3002\u540c\u4e00\u4e2a\u516c\u53f8\u7684\u4e0d\u540c\u7ec4\u7684\u5dee\u5f02\u6bd4\u4e0d\u540c\u516c\u53f8\u7684\u5dee\u8ddd\u8fd8\u8981\u5927\u3002\u56e0\u6b64\uff0c\u5728\u9762\u8bd5\u7684\u8fc7\u7a0b\u5f53\u4e2d\u95ee\u6e05\u695a\u81ea\u5df1\u9762\u8bd5\u7684\u7ec4\u4ee5\u53ca\u8ba1\u5212\u7684\u672a\u6765\u5de5\u4f5c\u5185\u5bb9\u975e\u5e38\u91cd\u8981\u3002\u9009\u62e9\u4e00\u4e2a\u597d\u7684\u5de5\u4f5c\u5185\u5bb9\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a\u597d\u7684\u516c\u53f8\u3002\u6b64\u5916\uff0c\u5982\u679c\u53ef\u80fd\u7684\u8bdd\uff0c\u5c3d\u91cf\u5148\u77e5\u9053\u9762\u8bd5\u5b98\u7684\u59d3\u540d\uff0c\u67e5\u4e00\u4e0b\u5bf9\u65b9\u7684\u804c\u52a1\u548c\u5df2\u53d1\u8868\u5de5\u4f5c\u3002\u5982\u679c\u8bf4\u6709\u4ec0\u4e48\u80fd\u5e2e\u4f60\u5224\u65ad\u9762\u8bd5\u4e2d\u53ef\u80fd\u9047\u5230\u7684\u95ee\u9898\u7684\u8bdd\uff0c\u8fd9\u5c31\u662f\u6700\u91cd\u8981\u7684\u4e00\u4e2a\u3002\u77e5\u5df1\u77e5\u5f7c\u65b9\u80fd\u767e\u6218\u4e0d\u6b86\u3002 \u7b97\u6cd5\u5c97\u4e00\u822c\u5bf9\u7b97\u6cd5\u9898\u6ca1\u6709\u4ec0\u4e48\u8981\u6c42\uff08MSRA\u9664\u5916\uff0c\u4e00\u5b9a\u4f1a\u95ee\u4f60\u7b97\u6cd5\u9898\uff09\u3002\u4e00\u822c\u4f1a\u5199\u4ee3\u7801\u5373\u53ef\u3002\u5e38\u89c1\u7684\u95ee\u9898\u5305\u62ec\u9752\u86d9\u8df3\u53f0\u9636\uff08\u4f18\u56fe\uff09\u3001\u76f4\u65b9\u56fe\u6700\u5927\u77e9\u5f62\u9762\u79ef\uff08\u5546\u6c64\uff09\u3001\u94fe\u8868\u7684O(1)\u5220\u9664\uff08\u5546\u6c64\uff09\u3001H-index\uff08MSRA\uff09\u7b49\u7b49\u3002\u5bf9\u4e8e\u7edd\u5927\u591a\u6570\u9898\u76ee\u6765\u8bf4\uff0c\u4f60\u90fd\u4e0d\u9700\u8981\u5237\u4efb\u4f55\u9898\u4e5f\u80fd\u60f3\u51fa\u89e3\u6cd5\u3002\u8fd9\u4e5f\u7ed9\u6211\u60ef\u51fa\u4e86\u4e00\u4e2a\u6bdb\u75c5\u5c31\u662f\u4ece\u4e0d\u5237\u9898\uff0c\u7b14\u8bd5\u4e00\u5f8b\u767d\u5377\uff0c\u7531\u6b64\u8fd8\u6d6a\u8d39\u4e86\u8fbe\u6469\u9662\u79cb\u62db\u7684\u5185\u63a8\uff08\u7b11\u3002\u4e0d\u8fc7\u8fd1\u6765\u8d8a\u6765\u8d8a\u591a\u9762\u8bd5\u5b98\u559c\u6b22\u95eeCV\u4e2d\u5e94\u7528\u5230\u7684\u7b97\u6cd5\uff0c\u6bd4\u5982NMS\u7684\u5b9e\u73b0\uff08\u5546\u6c64\u3001\u65f7\u89c6\uff09\u3002\u6211\u8fd8\u662f\u5f88\u559c\u6b22\u56de\u7b54\u8fd9\u6837\u7684\u95ee\u9898\u7684\uff08\u6bd5\u7adf\u8c01\u4f1a\u81ea\u5df1\u53bb\u5b9e\u73b0\u4e00\u4e2a\u6392\u5e8f\uff1f\uff09\u3002\u5bf9\u4e8e\u7b97\u6cd5\u5f88\u5f3a\u7684\u540c\u5b66\u6211\u6709\u65f6\u5019\u4f1a\u52a0\u95ee\u4e00\u9053\u5377\u79ef\u7684\u8fd0\u7b97\uff0c\u4f46\u662f\u80fd\u7b54\u51faGEMM\u548cim2col\u7684\u8fd8\u6ca1\u6709\u4e00\u4e2a\u3002\u54e6\u5bf9\u4e86\uff0c\u81ea\u52a8\u9a7e\u9a76\u516c\u53f8\u4f3c\u4e4e\u90fd\u5f88\u7231\u8003\u7b97\u6cd5\u9898\uff0c\u6240\u4ee5\u5982\u679c\u4f60\u60f3\u53bb\u56fe\u68ee\u6216\u8005\u5c0f\u9a6c\u7684\u8bdd\u6216\u8bb8\u5e94\u8be5\u5237\u51e0\u9053\u3002 \u548c\u5f00\u53d1\u7684\u4f60\u80fd\u8bb2\u4e00\u4e0b\u63e1\u624b\u548c\u6325\u624b\u6709\u51e0\u6b21\u5206\u522b\u662f\u4ec0\u4e48\u4e48\uff08\u817e\u8baf\uff09\u4e00\u6837\uff0c\u7b97\u6cd5\u5c97\u4e5f\u6709\u5f88\u591a\u57fa\u7840\u9898\u76ee\u5341\u5206\u91cd\u8981\u3002\u673a\u5668\u5b66\u4e60\u4f60\u4eec\u5b66\u8fc7\u54ea\u4e9b\u5440\uff1f\u8bb2\u4e00\u4e0bKMeans\u548cKNN\u7684\u533a\u522b\u3002KMeans\u7684\u4f18\u5316\u4f60\u6709\u4e86\u89e3\u8fc7\u4e48\uff1f\u55ef\uff0cHMM\u4e24\u4e2a\u5047\u8bbe\u4e09\u4e2a\u95ee\u9898\u4e94\u4e2a\u5143\u7d20\u662f\u4ec0\u4e48\uff1fPCA\u7684\u539f\u7406\u662f\u4ec0\u4e48\uff1f\u7279\u5f81\u503c\u548c\u7279\u5f81\u5411\u91cf\u6709\u4ec0\u4e48\u51e0\u4f55\u610f\u4e49\uff1fL1\u548cL2\u6709\u5565\u533a\u522b\uff1f\u4f60\u770b\u8fc7ResNet\u4e48\uff1fResNet\u6709\u54ea\u4e9b\u4f18\u70b9\uff1fResNet\u4e3a\u4ec0\u4e48\u80fd\u7f13\u89e3\u68af\u5ea6\u6d88\u5931\uff1f\u5982\u679c\u7528ReLU\u7684\u8bdd\uff0c\u90a3\u5f53\u8f93\u51fa\u4e3a\u6b63\u7684\u65f6\u5019\u5bfc\u6570\u6052\u4e3a1\uff0c\u4e3a\u4ec0\u4e48\u8fd8\u4f1a\u6709\u68af\u5ea6\u6d88\u5931\uff1fResNet\u6700\u5f00\u59cb\u7684\u4f1a\u8bae\u7248\u548c\u671f\u520a\u7248\u6709\u54ea\u4e9b\u4e0d\u540c\uff1f\u4e3a\u4ec0\u4e48\u540e\u6765\u505a\u4e86\u8fd9\u4e9b\u6539\u8fdb\uff1fBN\u3001ReLU\u548c\u5377\u79ef\u7684\u987a\u5e8f\u4e0d\u540c\u4f1a\u6709\u54ea\u4e9b\u533a\u522b\uff1f\u8bf4\u5230BN\uff0cBN\u6709\u54ea\u4e9b\u597d\u5904\uff1f\u4ed6\u7684\u53ef\u5b66\u4e60\u53c2\u6570\u6709\u54ea\u4e9b\uff1f \u5bf9\u4e8e\u7b97\u6cd5\u5c97\u4f4d\u6765\u8bf4\uff0c\u9762\u8bd5\u7684\u91cd\u4e2d\u4e4b\u91cd\u662f\u8bba\u6587\u548c\u9879\u76ee\uff08\u6700\u7ec8\u8fd8\u662f\u8981\u5f52\u5230\u8bba\u6587\u4e0a\u6765\uff09\u3002\u4f60\u505a\u4e86\u54ea\u4e9b\u9879\u76ee\uff0c\u7528\u4e86\u54ea\u4e9b\u7b97\u6cd5\uff1f\u54e6\u597d\u7684\uff0c\u7528\u4e86Faster-RCNN\u5440\u3002\u4f60\u80fd\u7b80\u8981\u4ecb\u7ecd\u4e00\u4e0bRCNN\u51e0\u4e2a\u7b97\u6cd5\u4e48\uff1f\u55ef\u4e0d\u9519\uff0c\u4f60\u5bf9\u4e00\u9636\u7f51\u7edc\u6709\u54ea\u4e9b\u4e86\u89e3\uff1fAnchor free\u5462\uff1fAutoAssign\u770b\u8fc7\u4e48\uff0c\u8bf4\u8bf4\uff1f\u6700\u8fd1\u7684MoCo\u770b\u4e86\u4e48\uff0c\u4ed6\u7684\u6838\u5fc3\u8d21\u732e\u6709\u54ea\u4e9b\u5462\uff1f\u55ef\uff0cMoCo\u548cSimCLR\u7684loss\u6709\u4e00\u4e2a\u5c0f\u533a\u522b\uff0c\u662f\u4ec0\u4e48\u5462\uff1f\u8fd9\u4e2a\u4f60\u89c9\u5f97\u4f1a\u5e26\u6765\u54ea\u4e9b\u5f71\u54cd\uff1fBYOL\u7684loss\u548cInfoNCE\u6709\u54ea\u4e9b\u533a\u522b\uff1f\u90a3\u4f60\u89c9\u5f97\u4e3a\u4ec0\u4e48\u8fd9\u6837\u8fd8\u80fdwork\u5462\uff1f\u4f60\u5bf9SwAV\u600e\u4e48\u770b\uff1f\u4e4b\u524d\u7684\u81ea\u76d1\u7763\u65b9\u6cd5\u6709\u4e86\u89e3\u4e48\uff1f\u54ea\u5e74\u54ea\u7bc7\u63d0\u51fa\u4e86\u4ec0\u4e48\u65b9\u6cd5\u8fbe\u5230\u4e86\u591a\u5c11\u4e2a\u70b9\uff1f\u4e3a\u4ec0\u4e48\u4ed6\u4eecwork/\u4e0dwork\uff1f\u8bb2\u4e00\u4e0b\u4f60\u8fd9\u4e2a\u5de5\u4f5c\u5427\u3002\u8fd9\u4e2a\u5de5\u4f5c\u548cxxx\u6709\u4ec0\u4e48\u533a\u522b\u4e48\uff1f\u4f60\u8fd9\u6837\u903b\u8f91\u4e0a\u6709\u4e9b\u4e0d\u5bf9\u5440\uff0cblah blah\uff1f\u4e3a\u4ec0\u4e48\u4e0d\u5c1d\u8bd5\u8fd9\u4e48\u505a\u5462\uff1f\u4f60\u590d\u73b0\u90a3\u7bc7\u6587\u7ae0\u7684\u65f6\u5019\u6709\u9047\u5230\u54ea\u4e9b\u95ee\u9898\u5462\uff1f\u4e3a\u4ec0\u4e48Sync BN\u90a3\u4e48work\uff1f \u626f\u4e86\u8fd9\u4e48\u591a\uff0c\u5176\u5b9e\u4e5f\u6ca1\u5fc5\u8981\u53bb\u51c6\u5907\u6240\u6709\u7684\u95ee\u9898\uff08\u4f60\u4e5f\u51c6\u5907\u4e0d\u5b8c\u3002\u9762\u8bd5\u8fc7\u7a0b\u4e2d\u6700\u91cd\u8981\u7684\u662f\u5f15\u5bfc\u3002\u5f53\u9762\u8bd5\u5b98\u95ee\u4f60\u4e00\u4e2a\u95ee\u9898\u7684\u65f6\u5019\uff0c\u4f5c\u51fa\u56de\u7b54\uff0c\u5e76\u4e14\u5c06\u8bdd\u9898\u5f15\u5bfc\u5230\u4f60\u6240\u5e0c\u671b\u5bf9\u65b9\u95ee\u7684\u65b9\u5411\u53bb\u3002\u9762\u8bd5\u7684\u65f6\u95f4\u5f88\u591a\u65f6\u5019\u662f\u6709\u9650\u7684\uff0c\u5982\u679c\u5728\u4e00\u4e2a\u5730\u65b9\u628a\u81ea\u5df1\u7ed9\u7ed5\u8fdb\u53bb\u4e86\uff0c\u8003\u8651\u7ec8\u6b62\u5f53\u524d\u7684\u8bdd\u9898\u7136\u540e\u6362\u4e00\u4e2a\u3002\u4e0d\u7136\u4f60\u53ef\u80fd\u82b1\u534a\u4e2a\u5c0f\u65f6\u8bf4\u4e00\u5806\u9519\u7684\uff0c\u90a3\u5269\u4e0b\u7684\u9762\u8bd5\u65f6\u95f4\u6015\u662f\u53ea\u80fd\u8ddf\u9762\u8bd5\u5b98\u5439\u5439\u6c34\u7136\u540e\u7b49\u62d2\u4fe1\u4e86\u3002\u4f46\u5982\u679c\u8fd8\u6ca1\u6709\u628a\u81ea\u5df1\u7ed9\u7ed5\u8fdb\u53bb\uff0c\u90a3\u4e5f\u522b\u653e\u5f03\u5f97\u592a\u65e9\u3002\u544a\u8bc9\u9762\u8bd5\u5b98\u5bf9\u8fd9\u4e2a\u65b9\u5411\u4e0d\u662f\u5f88\u719f\u6089\u7136\u540e\u8bf4\u51fa\u4f60\u7684\u7b54\u6848\u3002\u6ca1\u6709\u4eba\u80fd\u56de\u7b54\u51fa\u6240\u6709\u95ee\u9898\uff0c\u5f88\u591a\u9762\u8bd5\u5b98\u90fd\u4f1a\u987a\u7740\u4f60\u7684\u8bdd\u9898\u4e00\u76f4\u63d0\u95ee\u76f4\u5230\u4f60\u4e0d\u61c2\u4e3a\u6b62\u6765\u5224\u65ad\u4f60\u77e5\u8bc6\u7684\u6df1\u5ea6\u3002 \u4f5c\u4e3a\u538b\u8f74\uff0c\u6211\u8fd8\u60f3\u5f3a\u8c03\u4e00\u70b9\u5c31\u662f\u9762\u8bd5\u4e00\u5b9a\u8981\u6709\u6536\u83b7\u3002\u6bd4\u5982\u6211\u6709\u6b21ResNet\u628a\u81ea\u5df1\u7ed9\u7ed5\u8fdb\u53bb\u7136\u540e\u6302\u4e86\uff0c\u540e\u9762\u5c31\u4ed4\u7ec6\u770b\u4e86\u4e00\u4e0b\u4e24\u7bc7\u6587\u7ae0\uff0c\u73b0\u5728\u76f2\u5199\u4e00\u4e2aResNet\u90fd\u53ef\u4ee5\u3002\u8fd8\u6709\u4e00\u6b21\u88ab\u95ee\u5230PyTorch\u7684\u5206\u5e03\u5f0f\uff0c\u8fd9\u4e2a\u540e\u6765\u4e5f\u6076\u8865\u4e86\u4e00\u4e0b\u3002\u6ca1\u6709\u7ed9\u4f60\u5e26\u6765\u63d0\u5347\u7684\u9762\u8bd5\u662f\u5f88\u5931\u8d25\u7684\u3002\u6240\u4ee5\u6211\u5728\u6700\u540e\u95ee\u9762\u8bd5\u5b98\u95ee\u9898\u7684\u65f6\u5019\u901a\u5e38\u5bf9\u4f1a\u95ee\u4f60\u89c9\u5f97\u6211\u5728\u4ec0\u4e48\u5730\u65b9\u53ef\u4ee5\u505a\u5f97\u66f4\u597d\uff1f\u54e6\u5bf9\u4e86\uff0c\u53e6\u5916\u4e00\u4e2a\u5e38\u95ee\u7684\u95ee\u9898\u662f\u4f60\u89c9\u5f97\u5728\u8d35\u53f8\u5de5\u4f5c\u662f\u5426\u5feb\u4e50\uff1f\u6709\u4e00\u4e2a\u9762\u8bd5\u5b98\u82b1\u4e86\u5f88\u957f\u65f6\u95f4\u53bb\u8bf4\u670d\u6211\u8fd9\u662f\u4e00\u4e2a\u975e\u5e38\u4e3b\u89c2\u7684\u4e1c\u897f\uff0c\u6bcf\u4e2a\u4eba\u611f\u53d7\u90fd\u4e0d\u4e00\u6837\u2026\u2026\u6211\u5145\u5206\u7406\u89e3\u8fd9\u4e00\u70b9\u3002\u4f46\u6211\u60f3\u4e86\u89e3\u7684\u662f\u8fd9\u4e2a\u516c\u53f8\u8ba9\u4f60\u611f\u53d7\u6700\u6df1\u7684\u662f\u4ec0\u4e48\uff1f\u9762\u8bd5\u6bd5\u7adf\u662f\u4e00\u4e2a\u53cc\u5411\u9009\u62e9\u7684\u8fc7\u7a0b\u3002 \u6700\u540e\u6211\u60f3\u8bf4\u4e00\u4e0b\u6211\u6700\u540e\u4e00\u5bb6\u9762\u8bd5\u7684\u516c\u53f8\uff0c\u4e2d\u91d1\u3002\u4e1c\u57ce\u533a\u9cde\u6b21\u6809\u6bd4\u7684\u9ad8\u697c\u7ed9\u6211\u7559\u4e0b\u7684\u6620\u50cf\u4e4b\u6df1\u8ba9\u6211\u81f3\u4eca\u4e0d\u80fd\u5fd8\u6000\uff08\u8fd9\u624d\u662f\u5317\u4eac\u554a\uff01\uff0c\u56fd\u8d38\u7684\u73af\u5883\u4e5f360\u00b0\u5168\u65b9\u4f4d\u65e0\u6b7b\u89d2\u540a\u6253\u7406\u60f3\u56fd\u9645\u3002\u91d1\u878d\u884c\u4e1a\u4e0eAI\u8fd8\u662f\u6709\u7740\u86ee\u5927\u5dee\u5f02\u7684\uff0c\u6211\u4eec\u901a\u5e38\u4e60\u60ef\u6bcf\u9762\u4e00\u4e2a\u9762\u8bd5\u5b98\uff0c\u603b\u5171\u4e24\u5230\u4e09\u9762\u3002\u4ed6\u4eec\u5219\u662f\u4e09\u4e2a\u9762\u8bd5\u5b98\u9762\u4e00\u9762\u3002\u53ef\u80fd\u7531\u4e8e\u65b9\u5411\u5dee\u5f02\u592a\u5927\uff0c\u9762\u8bd5\u5b98\u4e5f\u6ca1\u63d0\u4ec0\u4e48\u95ee\u9898\uff08\u5f53\u7136\u4e5f\u662f\u6211\u91d1\u878d\u77e5\u8bc6\u592a\u5dee\uff09\u3002\u6700\u4ee4\u6211\u5370\u8c61\u6df1\u523b\u7684\u662f\u4e2d\u91d1\u7684\u9762\u8bd5\u5b98\uff0c\u4ed6\u4eec\u4eba\u90fd\u975e\u5e38\u597d\uff0c\u4f1a\u4e3a\u4f60\u63d0\u4f9b\u4e00\u4e9b\u5efa\u8bae\u3002\u6b64\u5916\u4e5f\u8fd8\u633a\u53ef\u7231\u7684\uff0c\u76f8\u6bd4\u4e4b\u4e0b\u67d0\u4e9b\u516c\u53f8\u7684\u76db\u6c14\u51cc\u4eba\u2026\u2026\u55ef\uff0cCV\u76ee\u524d\u8fd9\u4e48\u5185\u5377\u7684\u60c5\u51b5\u4e0b\u627e\u4e00\u4e9b\u5e94\u7528AI\u7684\u5176\u4ed6\u516c\u53f8\u6211\u89c9\u5f97\u4e5f\u662f\u4e00\u6761\u4e0d\u9519\u7684\u9009\u62e9\u3002 \u6700\u540e\u7684\u6700\u540e\uff0c\u5546\u6c64\u738b\u98de\u7ec4\u62db\u6536\u5b9e\u4e60\u751f\u4e00\u540d\uff0c\u5de5\u4f5c\u5185\u5bb9\u662fTransformer in Vision\u548c\u81ea\u76d1\u7763\u5b66\u4e60\u3002\u7b80\u5386\u6295\u9012\u81f3 chenzhiyuan1@tetras.ai \uff0c\u4e5f\u53ef\u4ee5\u76f4\u63a5\u901a\u8fc7\u540e\u53f0\u8054\u7cfb\u6211~ \u5e9a\u5b50\u5e74\u66ae\u79cb \u4e8e\u6cf0\u9e4f","title":"\u4e8c\u3007\u4e8c\u3007\u5e74 \u5341\u4e00\u6708 \u4e00\u65e5"},{"location":"sot/MOT16-A-Benchmark-for-Muti-Object-Tracking/","text":"\u6807\u51c6\u5316\u57fa\u51c6\u5bf9\u5927\u591a\u6570\u8ba1\u7b97\u673a\u89c6\u89c9\u5e94\u7528\u6765\u8bf4\u662f\u81f3\u5173\u91cd\u8981\u7684\u3002\u5c3d\u7ba1\u6392\u884c\u699c\u4e0e\u6392\u540d\u8868\u4e0d\u5e94\u8be5\u88ab\u8fc7\u5206\u5f3a\u8c03\uff0c\u57fa\u51c6\u6d4b\u8bd5\u901a\u5e38\u63d0\u4f9b\u6700\u5ba2\u89c2\u7684\u6027\u80fd\u8bc4\u4ef7\u6807\u51c6\u5e76\u56e0\u6b64\u6210\u4e3a\u91cd\u8981\u7684\u7814\u7a76\u6307\u5bfc\u3002\u8fd1\u6765\uff0c\u4e3a\u4e86\u6536\u96c6\u73b0\u6709\u6570\u636e\u548c\u65b0\u6570\u636e\u5e76\u4e3a\u591a\u76ee\u6807\u8ddf\u8e2a\u65b9\u6cd5\u7684\u6807\u51c6\u5316\u8bc4\u4f30\u5efa\u7acb\u6846\u67b6\uff0c[28]\u63d0\u51fa\u4e86\u4e00\u4e2a\u65b0\u7684\u591a\u76ee\u6807\u8ddf\u8e2a\u57fa\u51c6\uff0cMOTChallenge\u3002\u8fd9\u4e2a\u57fa\u51c6\u7684\u7b2c\u4e00\u4e2a\u7248\u672c\u7740\u91cd\u4e8e\u591a\u4eba\u8ddf\u8e2a\uff0c\u56e0\u4e3a\u884c\u4eba\u662f\u8fc4\u4eca\u4e3a\u6b62\u88ab\u8ddf\u8e2a\u793e\u533a\u7814\u7a76\u6700\u591a\u7684\u3002\u672c\u8bba\u6587\u968f\u9644\u4e86\u65b0\u53d1\u5e03\u7684MOTChallenge\u57fa\u51c6\u3002\u4e0e\u521d\u59cb\u53d1\u5e03\u4e0d\u540c\uff0cMOT16\u4e2d\u6240\u6709\u7684\u89c6\u9891\u90fd\u9075\u5faa\u4e00\u81f4\u7684\u6807\u51c6\u88ab\u4ed4\u7ec6\u6807\u6ce8\u3002\u6b64\u5916\uff0c\u5b83\u4e0d\u4ec5\u5927\u5927\u589e\u52a0\u4e86\u8fb9\u754c\u6846\u7684\u6570\u91cf\uff0c\u800c\u4e14\u8fd8\u63d0\u4f9b\u9664\u4e86\u884c\u4eba\u4e4b\u5916\u7684\u591a\u4e2a\u76ee\u6807\u79cd\u7c7b\u4ee5\u53ca\u6bcf\u4e2a\u5174\u8da3\u76ee\u6807\u7684\u53ef\u89c1\u6027\u7ea7\u522b\u3002 \u4ecb\u7ecd # \u51fa\u4e8e\u591a\u79cd\u539f\u56e0\uff0c\u8bc4\u4f30\u548c\u6bd4\u8f83\u591a\u76ee\u6807\u8ddf\u8e2a\u65b9\u6cd5\u5e76\u4e0d\u662f\u4e00\u4ef6\u5bb9\u6613\u7684\u4e8b\uff08\u53c2\u89c1[34]\uff09\u3002\u9996\u5148\uff0c\u4e0e\u5176\u4ed6\u4efb\u52a1\uff08\u4f8b\u5982\u56fe\u50cf\u53bb\u566a\uff09\u4e0d\u540c\uff0c\u771f\u503c\uff0c\u5373\u4e00\u4e2a\u76ee\u6807\u8ddf\u8e2a\u5668\u65e8\u5728\u5b9e\u73b0\u7684\u5b8c\u7f8e\u7b54\u6848\uff0c\u5f88\u96be\u88ab\u660e\u786e\u5b9a\u4e49\u3002 \u90e8\u5206\u53ef\u89c1\uff0c\u88ab\u906e\u6321\u6216\u526a\u88c1\u7684\u76ee\u6807\uff0c\u955c\u5b50\u6216\u7a97\u6237\u4e0a\u7684\u53cd\u5c04\u4ee5\u53ca\u4e0e\u76ee\u6807\u975e\u5e38\u76f8\u4f3c\u7684\u7269\u4f53\u90fd\u5177\u6709\u5185\u5728\u7684\u6a21\u7cca\u6027\u3002\u56e0\u6b64\uff0c\u5373\u4f7f\u662f\u4eba\u7c7b\uff0c\u4e5f\u53ef\u80fd\u65e0\u6cd5\u8fbe\u6210\u4e00\u4e2a\u7279\u5b9a\u7684\u7406\u60f3\u89e3\u51b3\u65b9\u6848\u3002\u5176\u6b21\uff0c\u5e26\u6709\u81ea\u7531\u53c2\u6570\u548c\u4e0d\u660e\u786e\u7684\u5b9a\u4e49\u901a\u5e38\u5bfc\u81f4\u6574\u4e2a\u6587\u732e\u4e2d\u7684\u5b9a\u91cf\u7ed3\u679c\u76f8\u4e92\u77db\u76fe\u3002\u6700\u540e\uff0c\u7f3a\u4e4f\u9884\u5b9a\u4e49\u7684\u6d4b\u8bd5\u548c\u8bad\u7ec3\u6570\u636e\u96c6\u5bfc\u81f4\u516c\u5e73\u7684\u5bf9\u6bd4\u6240\u6709\u65b9\u6cd5\u975e\u5e38\u56f0\u96be\u3002 \u5c3d\u7ba1\u591a\u76ee\u6807\u8ddf\u8e2a\u662f\u573a\u666f\u7406\u89e3\u4e2d\u7684\u5173\u952e\u95ee\u9898\uff0c\u4f46\u76f4\u5230\u6700\u8fd1\uff0c\u5b83\u4ecd\u7f3a\u4e4f\u5927\u89c4\u6a21\u57fa\u51c6\u4ee5\u63d0\u4f9b\u8ddf\u8e2a\u65b9\u6cd5\u4e4b\u95f4\u7684\u516c\u5e73\u6bd4\u8f83\u30022014\u5e74\uff0c\u6211\u4eec\u53d1\u5e03\u4e86MOTChallenge\u57fa\u51c6\u6d4b\u8bd5\uff0c\u8be5\u57fa\u51c6\u6d4b\u8bd5\u5305\u542b\u4e09\u4e2a\u4e3b\u8981\u90e8\u5206\uff1a\uff081\uff09\uff08\u91cd\u65b0\uff09\u6536\u96c6\u516c\u5f00\u53ef\u7528\u548c\u65b0\u7684\u6570\u636e\u96c6\uff1b\uff082\uff09\u4e00\u4e2a\u4e2d\u5fc3\u5f0f\u8bc4\u4f30\u65b9\u6cd5\uff1b\uff083\uff09\u5141\u8bb8\u4f17\u5305\u7684\u57fa\u7840\u67b6\u6784\uff0c\u65b0\u6570\u636e\uff0c\u65b0\u8bc4\u4f30\u65b9\u6cd5\u751a\u81f3\u65b0\u6807\u6ce8\u3002\u672c\u6570\u636e\u96c6\u7684\u7b2c\u4e00\u4e2a\u53d1\u5e03\u7248\uff08MOT15\uff09\u5305\u542b11\u4e2a\u8bad\u7ec3\u5e8f\u5217\u548c11\u4e2a\u6d4b\u8bd5\u5e8f\u5217\uff0c\u603b\u517111286\u5e27\uff08996\u79d2\uff09\u7684\u89c6\u9891\u3002 \u6807\u6ce8\u89c4\u5219 # \u6211\u4eec\u9075\u5faa\u4e00\u7ec4\u89c4\u5219\uff0c\u4ee5\u5c3d\u53ef\u80fd\u51c6\u786e\u7684\u65b9\u5f0f\u4e3a\u6bcf\u4e2a\u5e8f\u5217\u4e2d\u7684\u6bcf\u4e2a\u79fb\u52a8\u7684\u4eba\u6216\u8f66\u8f86\u6dfb\u52a0\u8fb9\u754c\u6846\u3002\u5728\u4e0b\u6587\u4e2d\uff0c\u6211\u4eec\u5b9a\u4e49\u4e86\u4e00\u4e2a\u6e05\u6670\u7684\u534f\u8bae\uff0c\u8be5\u534f\u8bae\u5728\u6574\u4e2a\u6570\u636e\u96c6\u4e2d\u90fd\u9075\u5faa\u4ee5\u786e\u4fdd\u4e00\u81f4\u6027\u3002 \u76ee\u6807\u7c7b\u578b # \u5728\u6b64\u57fa\u51c6\u6d4b\u8bd5\u4e2d\uff0c\u6211\u4eec\u5bf9\u8ddf\u8e2a\u89c6\u9891\u4e2d\u7684\u79fb\u52a8\u5bf9\u8c61\u611f\u5174\u8da3\u3002\u7279\u522b\u7684\uff0c\u6211\u4eec\u5bf9\u8bc4\u4f30\u4eba\u8ddf\u8e2a\u7b97\u6cd5\u611f\u5174\u8da3\u3002\u56e0\u6b64\uff0c\u4eba\u5c06\u6210\u4e3a\u6211\u4eec\u6807\u6ce8\u7684\u5173\u6ce8\u4e2d\u5fc3\u3002\u6211\u4eec\u5c06\u76f8\u5173\u7c7b\u522b\u5206\u4e3a\u4e09\u7c7b\uff1a \u79fb\u52a8 \u6216 \u7ad9\u7acb \u884c\u4eba \u4e0d\u5904\u4e8e \u76f4\u7acb\u59ff\u52bf \u6216 \u4eba\u7c7b\u7684\u4eba\u9020\u4ee3\u8868 \u8f66\u8f86 \u548c \u906e\u6321\u7269 \u5728\u7b2c\u4e00\u7ec4\u4e2d\uff0c\u6211\u4eec\u6807\u6ce8\u6240\u6709\u5728\u89c6\u91ce\u4e2d\u5e76\u4e14\u53ef\u4ee5\u88ab\u89c2\u5bdf\u8005\u8ba4\u5b9a\u4e3a\u79fb\u52a8\u6216\u7ad9\u7acb\uff08\u76f4\u7acb\uff09\u7684\u884c\u4eba\u3002\u5728\u81ea\u884c\u8f66\u548c\u6ed1\u677f\u4e0a\u7684\u884c\u4eba\u4e5f\u4f1a\u5728\u672c\u7c7b\u4e2d\u88ab\u6807\u6ce8\uff08\u5e76\u4e14\u4e5f\u901a\u5e38\u88ab\u73b0\u4ee3\u884c\u4eba\u68c0\u6d4b\u5668\u53d1\u73b0\uff09\u3002\u66f4\u8fdb\u4e00\u6b65\u7684\uff0c\u5982\u679c\u4e00\u4e2a\u4eba \u77ed\u6682 \u5f2f\u8170\u6216\u8005\u8e72\u4e0b\uff0c\u4f8b\u5982\u62ff\u8d77\u4e1c\u897f\u6216\u4e0e\u5b69\u5b50\u4ea4\u8c08\uff0c\u4ed6\u4eec\u5e94\u4fdd\u6301\u5728\u6807\u51c6\u7684 \u884c\u4eba \u7c7b\u4e2d\u3002\u63d0\u4ea4\u7ed9\u6211\u4eec\u57fa\u51c6\u6d4b\u8bd5\u7684\u7b97\u6cd5\u88ab\u671f\u671b\u8ddf\u8e2a\u8fd9\u4e9b\u76ee\u6807\u3002 \u5728\u7b2c\u4e8c\u7ec4\u4e2d\uff0c\u6211\u4eec\u5305\u62ec\u6240\u6709\u786e\u5207\u5206\u7c7b\u662f\u6a21\u68f1\u4e24\u53ef\u7684\uff0c\u5e76\u4e14\u53ef\u80fd\u6839\u636e\u89c2\u5bdf\u8005\u3001\u5e94\u7528\u6216\u5176\u4ed6\u56e0\u7d20\u800c\u53d8\u5316\u7684\u7c7b\u4eba\u5bf9\u8c61\u3002\u6211\u4eec\u6807\u6ce8\u6240\u6709\u4e0d\u5904\u4e8e\u76f4\u7acb\u7684\u9759\u6b62\u4eba\u7269\uff0c\u6bd4\u5982\u5750\u7740\u3001\u8eba\u7740\u3002\u5728\u6b64\u7c7b\u522b\u4e2d\uff0c\u6211\u4eec\u8fd8\u5305\u62ec\u53ef\u80fd\u89e6\u53d1\u68c0\u6d4b\u54cd\u5e94\u7684\u4efb\u4f55\u4eba\u7c7b\u7684\u4eba\u9020\u4ee3\u8868\uff0c\u4f8b\u5982\u4eba\u4f53\u6a21\u578b\uff0c\u56fe\u7247\u6216\u53cd\u5c04\u3002\u5728\u73bb\u7483\u540e\u9762\u7684\u4eba\u4e5f\u5e94\u88ab\u6807\u8bb0\u4e3a\u5e72\u6270\u56e0\u7d20\u3002\u8fd9\u91cc\u7684\u60f3\u6cd5\u662f\u5728\u8bc4\u4f30\u4e2d\u4f7f\u7528\u8fd9\u4e9b\u6807\u6ce8\uff0c\u4ee5\u4f7f\u7b97\u6cd5\u5728\u8ddf\u8e2a\u5230\u6bd4\u5982\u4e00\u4e2a\u5750\u7740\u7684\u4eba\u6216\u8005\u53cd\u5c04\u65f6\u65e2\u4e0d\u88ab\u60e9\u7f5a\u4e5f\u4e0d\u88ab\u5956\u52b1\u3002 \u5728\u7b2c\u4e09\u7ec4\u4e2d\uff0c\u6211\u4eec\u5bf9\u6240\u6709\u884c\u9a76\u4e2d\u7684\u8f66\u8f86\uff08\u4f8b\u5982\u6c7d\u8f66\uff0c\u81ea\u884c\u8f66\uff0c\u6469\u6258\u8f66\u548c\u975e\u673a\u52a8\u8f66\u8f86\uff08\u4f8b\u5982\uff0c\u7ae5\u8f66\uff09\u4ee5\u53ca\u5176\u4ed6\u6f5c\u5728\u7684\u906e\u6321\u7269\uff09\u8fdb\u884c\u6807\u6ce8\u3002\u8fd9\u4e9b\u6807\u6ce8\u5c06\u4e0d\u4f1a\u5728\u8bc4\u4f30\u4e2d\u53d1\u6325\u4efb\u4f55\u4f5c\u7528\uff0c\u800c\u662f\u63d0\u4f9b\u7ed9\u7528\u6237\u7528\u4e8e\u8bad\u7ec3\u548c\u8ba1\u7b97\u884c\u4eba\u906e\u6321\u7684\u7a0b\u5ea6\u3002\u9759\u6001\u8f66\u8f86\uff08\u505c\u653e\u7684\u6c7d\u8f66\uff0c\u81ea\u884c\u8f66\uff09\u53ea\u8981\u4e0d\u906e\u6321\u4efb\u4f55\u884c\u4eba\uff0c\u5c31\u4e0d\u4f1a\u6dfb\u52a0\u6807\u6ce8\u3002 \u8fb9\u754c\u6846\u5bf9\u9f50 # \u8fb9\u754c\u6846\u5c3d\u53ef\u80fd\u7cbe\u786e\u5730\u4e0e\u5bf9\u8c61\u7684\u8303\u56f4\u5bf9\u9f50\u3002\u8fb9\u754c\u6846\u5e94\u5305\u542b\u5c5e\u4e8e\u8be5\u5bf9\u8c61\u7684\u6240\u6709\u50cf\u7d20\uff0c\u540c\u65f6\u5e94\u5c3d\u53ef\u80fd\u7d27\u5bc6\uff0c\u5373\uff0c\u4e0d\u5e94\u5728\u6846\u5916\u4fdd\u7559\u4efb\u4f55\u50cf\u7d20\u3002\u8fd9\u610f\u5473\u7740\u884c\u8d70\u7684\u4fa7\u89c6\u56fe\u884c\u4eba\u901a\u5e38\u5c06\u5177\u6709\u4e00\u4e2a\u5bbd\u5ea6\u968f\u6b65\u5e45\u800c\u5468\u671f\u6027\u53d8\u5316\u7684\u6846\uff0c\u800c\u6b63\u89c6\u56fe\u6216\u7ad9\u7acb\u7684\u4eba\u5c06\u968f\u65f6\u95f4\u4fdd\u6301\u66f4\u6052\u5b9a\u7684\u5bbd\u9ad8\u6bd4\u3002\u5982\u679c\u4eba\u88ab\u90e8\u5206\u906e\u6321\uff0c\u5219\u6839\u636e\u5176\u4ed6\u53ef\u7528\u4fe1\u606f\uff08\u4f8b\u5982\u9884\u671f\u5927\u5c0f\uff0c\u9634\u5f71\uff0c\u53cd\u5c04\uff0c\u5148\u524d\u548c\u5c06\u6765\u7684\u5e27\u4ee5\u53ca\u5176\u4ed6\u63d0\u793a\uff09\u6765\u4f30\u8ba1\u8303\u56f4\u3002\u5982\u679c\u4e00\u4e2a\u4eba\u88ab\u56fe\u50cf\u8fb9\u6846\u88c1\u526a\uff0c\u5219\u4f30\u8ba1\u6846\u8d85\u51fa\u539f\u59cb\u5e27\uff0c\u4ee5\u4ee3\u8868\u6574\u4e2a\u4eba\u5e76\u4f30\u7b97\u88c1\u526a\u6c34\u5e73\u3002\u5982\u679c\u4e00\u4e2a\u906e\u6321\u7269\u4e0d\u80fd\u51c6\u786e\u5730\u5c01\u95ed\u5728\u4e00\u4e2a\u6846\u5185\uff08\u4f8b\u5982\uff0c\u4e00\u68f5\u6709\u6811\u679d\u7684\u6811\u6216\u81ea\u52a8\u6276\u68af\u53ef\u80fd\u9700\u8981\u4e00\u4e2a\u8f83\u5927\u7684\u6846\uff0c\u5176\u4e2d\u5927\u90e8\u5206\u533a\u57df\u90fd\u4e0d\u5c5e\u4e8e\u5b9e\u9645\u5bf9\u8c61\uff09\uff0c\u5219\u53ef\u4ee5\u4f7f\u7528\u51e0\u4e2a\u6846\u6765\u66f4\u597d\u5730\u8fd1\u4f3c\u8be5\u6846\u3002\u8be5\u5bf9\u8c61\u7684\u8303\u56f4\u3002 \u8f66\u8f86\u4e0a\u7684\u4eba\u5458\u53ea\u6709\u5728\u6e05\u6670\u53ef\u89c1\u7684\u60c5\u51b5\u4e0b\u624d\u4e0e\u8f66\u8f86\u5206\u5f00\u6807\u6ce8\u3002\u4f8b\u5982\uff0c\u7ae5\u8f66\u4e2d\u7684\u5b69\u5b50\u6216\u8005\u8f66\u4e2d\u7684\u4eba\u4e0d\u4f1a\u88ab\u6807\u6ce8\uff0c\u4f46\u6469\u6258\u8f66\u624b\u6216\u81ea\u884c\u8f66\u624b\u5c06\u88ab\u6807\u6ce8\u3002 \u8f68\u8ff9\u7684\u5f00\u59cb\u4e0e\u7ed3\u675f # \u53ea\u8981\u4eba\u7684\u4f4d\u7f6e\u548c\u8303\u56f4\u53ef\u4ee5\u88ab\u7cbe\u786e\u786e\u5b9a\u4fbf\u4f1a\u51fa\u73b0\u4e00\u4e2a\u6846\uff08\u8f68\u9053\uff09\u3002\u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u5f53\u4eba\u7684\u224810\uff05\u53ef\u89c1\u65f6\u4f1a\u51fa\u73b0\u6846\u3002\u540c\u6837\uff0c\u5f53\u65e0\u6cd5\u518d\u7cbe\u786e\u5b9a\u4f4d\u65f6\uff0c\u8f68\u9053\u7ed3\u675f\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u6807\u6ce8\u5c3d\u53ef\u80fd\u65e9\u5730\u5f00\u59cb\u5e76\u4e14\u5c3d\u53ef\u80fd\u665a\u5730\u7ed3\u675f\uff0c\u4ece\u800c\u4e0d\u4f1a\u4e27\u5931\u51c6\u786e\u6027\u3002\u6846\u7684\u5750\u6807\u53ef\u80fd\u8d85\u51fa\u53ef\u89c1\u533a\u57df\u3002\u5982\u679c\u6709\u4eba\u79bb\u5f00\u89c6\u91ce\u5e76\u5728\u4ee5\u540e\u51fa\u73b0\uff0c\u5219\u5c06\u4e3a\u4ed6\u4eec\u5206\u914d\u65b0\u7684ID\u3002 \u6700\u5c0f\u5355\u4f4d # \u5c3d\u7ba1\u8bc4\u4f30\u4ec5\u8003\u8651\u4ee5\u50cf\u7d20\u4e3a\u5355\u4f4d\u7684\u6700\u5c0f\u9ad8\u5ea6\u7684\u884c\u4eba\uff0c\u4f46\u662f\u6807\u6ce8\u5c06\u5305\u542b\u6240\u6709\u5927\u5c0f\u7684\u6240\u6709\u5bf9\u8c61\uff0c\u53ea\u8981\u6807\u6ce8\u8005\u53ef\u4ee5\u533a\u5206\u5b83\u4eec\u5373\u53ef\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u56fe\u50cf\u4e0a\u7684\u6240\u6709\u76ee\u6807\u65e0\u8bba\u5176\u5927\u5c0f\u90fd\u5e94\u52a0\u4e0a\u6807\u6ce8\u3002 \u906e\u6321 # \u906e\u6321\u7ea7\u522b\u4e0d\u9700\u8981\u88ab\u663e\u793a\u6807\u6ce8\u3002\u8be5\u503c\u5c06\u4f7f\u7528\u5730\u5e73\u9762\u5047\u8bbe\u548c\u6807\u6ce8\u81ea\u52a8\u8ba1\u7b97\u3002\u6bcf\u4e00\u4e2a\u76ee\u6807\u90fd\u88ab\u901a\u8fc7\u906e\u6321\u5b8c\u5168\u6807\u6ce8\uff0c\u53ea\u8981\u53ef\u4ee5\u8db3\u591f\u51c6\u786e\u5730\u786e\u5b9a\u5176\u8303\u56f4\u548c\u4f4d\u7f6e\u3002\u5982\u679c\u76ee\u6807\u5728\u5e8f\u5217\u4e2d\u95f4\u5b8c\u5168\u88ab\u906e\u6321\uff0c\u4ee5\u540e\u53c8\u4e0d\u53ef\u89c1\uff0c\u5219\u5e94\u7ec8\u6b62\u8f68\u9053\uff08\u6807\u8bb0\u4e3a\u201coutside of view\u201d\uff09\u3002\u5982\u679c\u76ee\u6807\u5728\u957f\u65f6\u95f4\u540e\u91cd\u65b0\u51fa\u73b0\uff0c\u5373\u5176\u5728\u906e\u6321\u8fc7\u7a0b\u4e2d\u4f4d\u7f6e\u5e76\u4e0d\u660e\u786e\uff0c\u5b83\u5c06\u4ee5\u65b0\u7684ID\u91cd\u65b0\u51fa\u73b0\u3002 \u5065\u5168\u6027\u68c0\u67e5 # \u5728\u6240\u6709\u5e8f\u5217\u90fd\u5b8c\u6210\u6807\u6ce8\u540e\uff0c\u4e00\u4e2a\u201c\u5065\u5168\u6027\u68c0\u67e5\u201d\u88ab\u6267\u884c\u4ee5\u786e\u4fdd\u6ca1\u6709\u9057\u6f0f\u4efb\u4f55\u76f8\u5173\u5b9e\u4f53\u3002\u4e3a\u6b64\uff0c\u6211\u4eec\u5728\u6240\u6709\u89c6\u9891\u4e0a\u8fd0\u884c\u4e86\u884c\u4eba\u68c0\u6d4b\u5668\uff0c\u5e76\u5c06\u4e0e\u4eba\u7c7b\u6216\u5e72\u6270\u8005\u76f8\u5bf9\u5e94\u7684\u6240\u6709\u9ad8\u53ef\u4fe1\u5ea6\u68c0\u6d4b\u6dfb\u52a0\u5230\u4e86\u6807\u6ce8\u5217\u8868\u4e2d\u3002\u9884\u5148\u8ba1\u7b97\u7684\u5bf9\u8c61\u68c0\u6d4b\uff0c\u6807\u6ce8\uff08\u4ec5\u9488\u5bf9\u8bad\u7ec3\u5e8f\u5217\uff09\u548c\u4e00\u4e2a\u9488\u5bf9\u6240\u6709\u6570\u636e\u96c6\u7684\u901a\u7528\u8bc4\u4f30\u65b9\u6cd5\u5411\u6240\u6709\u53c2\u4e0e\u8005\u63d0\u4f9b\uff0c\u4ece\u800c\u53ef\u4ee5\u516c\u5e73\u5730\u6bd4\u8f83\u6240\u6709\u7ed3\u679c\u3002","title":"MOT16 A Benchmark for Muti Object Tracking"},{"location":"sot/MOT16-A-Benchmark-for-Muti-Object-Tracking/#_1","text":"\u51fa\u4e8e\u591a\u79cd\u539f\u56e0\uff0c\u8bc4\u4f30\u548c\u6bd4\u8f83\u591a\u76ee\u6807\u8ddf\u8e2a\u65b9\u6cd5\u5e76\u4e0d\u662f\u4e00\u4ef6\u5bb9\u6613\u7684\u4e8b\uff08\u53c2\u89c1[34]\uff09\u3002\u9996\u5148\uff0c\u4e0e\u5176\u4ed6\u4efb\u52a1\uff08\u4f8b\u5982\u56fe\u50cf\u53bb\u566a\uff09\u4e0d\u540c\uff0c\u771f\u503c\uff0c\u5373\u4e00\u4e2a\u76ee\u6807\u8ddf\u8e2a\u5668\u65e8\u5728\u5b9e\u73b0\u7684\u5b8c\u7f8e\u7b54\u6848\uff0c\u5f88\u96be\u88ab\u660e\u786e\u5b9a\u4e49\u3002 \u90e8\u5206\u53ef\u89c1\uff0c\u88ab\u906e\u6321\u6216\u526a\u88c1\u7684\u76ee\u6807\uff0c\u955c\u5b50\u6216\u7a97\u6237\u4e0a\u7684\u53cd\u5c04\u4ee5\u53ca\u4e0e\u76ee\u6807\u975e\u5e38\u76f8\u4f3c\u7684\u7269\u4f53\u90fd\u5177\u6709\u5185\u5728\u7684\u6a21\u7cca\u6027\u3002\u56e0\u6b64\uff0c\u5373\u4f7f\u662f\u4eba\u7c7b\uff0c\u4e5f\u53ef\u80fd\u65e0\u6cd5\u8fbe\u6210\u4e00\u4e2a\u7279\u5b9a\u7684\u7406\u60f3\u89e3\u51b3\u65b9\u6848\u3002\u5176\u6b21\uff0c\u5e26\u6709\u81ea\u7531\u53c2\u6570\u548c\u4e0d\u660e\u786e\u7684\u5b9a\u4e49\u901a\u5e38\u5bfc\u81f4\u6574\u4e2a\u6587\u732e\u4e2d\u7684\u5b9a\u91cf\u7ed3\u679c\u76f8\u4e92\u77db\u76fe\u3002\u6700\u540e\uff0c\u7f3a\u4e4f\u9884\u5b9a\u4e49\u7684\u6d4b\u8bd5\u548c\u8bad\u7ec3\u6570\u636e\u96c6\u5bfc\u81f4\u516c\u5e73\u7684\u5bf9\u6bd4\u6240\u6709\u65b9\u6cd5\u975e\u5e38\u56f0\u96be\u3002 \u5c3d\u7ba1\u591a\u76ee\u6807\u8ddf\u8e2a\u662f\u573a\u666f\u7406\u89e3\u4e2d\u7684\u5173\u952e\u95ee\u9898\uff0c\u4f46\u76f4\u5230\u6700\u8fd1\uff0c\u5b83\u4ecd\u7f3a\u4e4f\u5927\u89c4\u6a21\u57fa\u51c6\u4ee5\u63d0\u4f9b\u8ddf\u8e2a\u65b9\u6cd5\u4e4b\u95f4\u7684\u516c\u5e73\u6bd4\u8f83\u30022014\u5e74\uff0c\u6211\u4eec\u53d1\u5e03\u4e86MOTChallenge\u57fa\u51c6\u6d4b\u8bd5\uff0c\u8be5\u57fa\u51c6\u6d4b\u8bd5\u5305\u542b\u4e09\u4e2a\u4e3b\u8981\u90e8\u5206\uff1a\uff081\uff09\uff08\u91cd\u65b0\uff09\u6536\u96c6\u516c\u5f00\u53ef\u7528\u548c\u65b0\u7684\u6570\u636e\u96c6\uff1b\uff082\uff09\u4e00\u4e2a\u4e2d\u5fc3\u5f0f\u8bc4\u4f30\u65b9\u6cd5\uff1b\uff083\uff09\u5141\u8bb8\u4f17\u5305\u7684\u57fa\u7840\u67b6\u6784\uff0c\u65b0\u6570\u636e\uff0c\u65b0\u8bc4\u4f30\u65b9\u6cd5\u751a\u81f3\u65b0\u6807\u6ce8\u3002\u672c\u6570\u636e\u96c6\u7684\u7b2c\u4e00\u4e2a\u53d1\u5e03\u7248\uff08MOT15\uff09\u5305\u542b11\u4e2a\u8bad\u7ec3\u5e8f\u5217\u548c11\u4e2a\u6d4b\u8bd5\u5e8f\u5217\uff0c\u603b\u517111286\u5e27\uff08996\u79d2\uff09\u7684\u89c6\u9891\u3002","title":"\u4ecb\u7ecd"},{"location":"sot/MOT16-A-Benchmark-for-Muti-Object-Tracking/#_2","text":"\u6211\u4eec\u9075\u5faa\u4e00\u7ec4\u89c4\u5219\uff0c\u4ee5\u5c3d\u53ef\u80fd\u51c6\u786e\u7684\u65b9\u5f0f\u4e3a\u6bcf\u4e2a\u5e8f\u5217\u4e2d\u7684\u6bcf\u4e2a\u79fb\u52a8\u7684\u4eba\u6216\u8f66\u8f86\u6dfb\u52a0\u8fb9\u754c\u6846\u3002\u5728\u4e0b\u6587\u4e2d\uff0c\u6211\u4eec\u5b9a\u4e49\u4e86\u4e00\u4e2a\u6e05\u6670\u7684\u534f\u8bae\uff0c\u8be5\u534f\u8bae\u5728\u6574\u4e2a\u6570\u636e\u96c6\u4e2d\u90fd\u9075\u5faa\u4ee5\u786e\u4fdd\u4e00\u81f4\u6027\u3002","title":"\u6807\u6ce8\u89c4\u5219"},{"location":"sot/MOT16-A-Benchmark-for-Muti-Object-Tracking/#_3","text":"\u5728\u6b64\u57fa\u51c6\u6d4b\u8bd5\u4e2d\uff0c\u6211\u4eec\u5bf9\u8ddf\u8e2a\u89c6\u9891\u4e2d\u7684\u79fb\u52a8\u5bf9\u8c61\u611f\u5174\u8da3\u3002\u7279\u522b\u7684\uff0c\u6211\u4eec\u5bf9\u8bc4\u4f30\u4eba\u8ddf\u8e2a\u7b97\u6cd5\u611f\u5174\u8da3\u3002\u56e0\u6b64\uff0c\u4eba\u5c06\u6210\u4e3a\u6211\u4eec\u6807\u6ce8\u7684\u5173\u6ce8\u4e2d\u5fc3\u3002\u6211\u4eec\u5c06\u76f8\u5173\u7c7b\u522b\u5206\u4e3a\u4e09\u7c7b\uff1a \u79fb\u52a8 \u6216 \u7ad9\u7acb \u884c\u4eba \u4e0d\u5904\u4e8e \u76f4\u7acb\u59ff\u52bf \u6216 \u4eba\u7c7b\u7684\u4eba\u9020\u4ee3\u8868 \u8f66\u8f86 \u548c \u906e\u6321\u7269 \u5728\u7b2c\u4e00\u7ec4\u4e2d\uff0c\u6211\u4eec\u6807\u6ce8\u6240\u6709\u5728\u89c6\u91ce\u4e2d\u5e76\u4e14\u53ef\u4ee5\u88ab\u89c2\u5bdf\u8005\u8ba4\u5b9a\u4e3a\u79fb\u52a8\u6216\u7ad9\u7acb\uff08\u76f4\u7acb\uff09\u7684\u884c\u4eba\u3002\u5728\u81ea\u884c\u8f66\u548c\u6ed1\u677f\u4e0a\u7684\u884c\u4eba\u4e5f\u4f1a\u5728\u672c\u7c7b\u4e2d\u88ab\u6807\u6ce8\uff08\u5e76\u4e14\u4e5f\u901a\u5e38\u88ab\u73b0\u4ee3\u884c\u4eba\u68c0\u6d4b\u5668\u53d1\u73b0\uff09\u3002\u66f4\u8fdb\u4e00\u6b65\u7684\uff0c\u5982\u679c\u4e00\u4e2a\u4eba \u77ed\u6682 \u5f2f\u8170\u6216\u8005\u8e72\u4e0b\uff0c\u4f8b\u5982\u62ff\u8d77\u4e1c\u897f\u6216\u4e0e\u5b69\u5b50\u4ea4\u8c08\uff0c\u4ed6\u4eec\u5e94\u4fdd\u6301\u5728\u6807\u51c6\u7684 \u884c\u4eba \u7c7b\u4e2d\u3002\u63d0\u4ea4\u7ed9\u6211\u4eec\u57fa\u51c6\u6d4b\u8bd5\u7684\u7b97\u6cd5\u88ab\u671f\u671b\u8ddf\u8e2a\u8fd9\u4e9b\u76ee\u6807\u3002 \u5728\u7b2c\u4e8c\u7ec4\u4e2d\uff0c\u6211\u4eec\u5305\u62ec\u6240\u6709\u786e\u5207\u5206\u7c7b\u662f\u6a21\u68f1\u4e24\u53ef\u7684\uff0c\u5e76\u4e14\u53ef\u80fd\u6839\u636e\u89c2\u5bdf\u8005\u3001\u5e94\u7528\u6216\u5176\u4ed6\u56e0\u7d20\u800c\u53d8\u5316\u7684\u7c7b\u4eba\u5bf9\u8c61\u3002\u6211\u4eec\u6807\u6ce8\u6240\u6709\u4e0d\u5904\u4e8e\u76f4\u7acb\u7684\u9759\u6b62\u4eba\u7269\uff0c\u6bd4\u5982\u5750\u7740\u3001\u8eba\u7740\u3002\u5728\u6b64\u7c7b\u522b\u4e2d\uff0c\u6211\u4eec\u8fd8\u5305\u62ec\u53ef\u80fd\u89e6\u53d1\u68c0\u6d4b\u54cd\u5e94\u7684\u4efb\u4f55\u4eba\u7c7b\u7684\u4eba\u9020\u4ee3\u8868\uff0c\u4f8b\u5982\u4eba\u4f53\u6a21\u578b\uff0c\u56fe\u7247\u6216\u53cd\u5c04\u3002\u5728\u73bb\u7483\u540e\u9762\u7684\u4eba\u4e5f\u5e94\u88ab\u6807\u8bb0\u4e3a\u5e72\u6270\u56e0\u7d20\u3002\u8fd9\u91cc\u7684\u60f3\u6cd5\u662f\u5728\u8bc4\u4f30\u4e2d\u4f7f\u7528\u8fd9\u4e9b\u6807\u6ce8\uff0c\u4ee5\u4f7f\u7b97\u6cd5\u5728\u8ddf\u8e2a\u5230\u6bd4\u5982\u4e00\u4e2a\u5750\u7740\u7684\u4eba\u6216\u8005\u53cd\u5c04\u65f6\u65e2\u4e0d\u88ab\u60e9\u7f5a\u4e5f\u4e0d\u88ab\u5956\u52b1\u3002 \u5728\u7b2c\u4e09\u7ec4\u4e2d\uff0c\u6211\u4eec\u5bf9\u6240\u6709\u884c\u9a76\u4e2d\u7684\u8f66\u8f86\uff08\u4f8b\u5982\u6c7d\u8f66\uff0c\u81ea\u884c\u8f66\uff0c\u6469\u6258\u8f66\u548c\u975e\u673a\u52a8\u8f66\u8f86\uff08\u4f8b\u5982\uff0c\u7ae5\u8f66\uff09\u4ee5\u53ca\u5176\u4ed6\u6f5c\u5728\u7684\u906e\u6321\u7269\uff09\u8fdb\u884c\u6807\u6ce8\u3002\u8fd9\u4e9b\u6807\u6ce8\u5c06\u4e0d\u4f1a\u5728\u8bc4\u4f30\u4e2d\u53d1\u6325\u4efb\u4f55\u4f5c\u7528\uff0c\u800c\u662f\u63d0\u4f9b\u7ed9\u7528\u6237\u7528\u4e8e\u8bad\u7ec3\u548c\u8ba1\u7b97\u884c\u4eba\u906e\u6321\u7684\u7a0b\u5ea6\u3002\u9759\u6001\u8f66\u8f86\uff08\u505c\u653e\u7684\u6c7d\u8f66\uff0c\u81ea\u884c\u8f66\uff09\u53ea\u8981\u4e0d\u906e\u6321\u4efb\u4f55\u884c\u4eba\uff0c\u5c31\u4e0d\u4f1a\u6dfb\u52a0\u6807\u6ce8\u3002","title":"\u76ee\u6807\u7c7b\u578b"},{"location":"sot/MOT16-A-Benchmark-for-Muti-Object-Tracking/#_4","text":"\u8fb9\u754c\u6846\u5c3d\u53ef\u80fd\u7cbe\u786e\u5730\u4e0e\u5bf9\u8c61\u7684\u8303\u56f4\u5bf9\u9f50\u3002\u8fb9\u754c\u6846\u5e94\u5305\u542b\u5c5e\u4e8e\u8be5\u5bf9\u8c61\u7684\u6240\u6709\u50cf\u7d20\uff0c\u540c\u65f6\u5e94\u5c3d\u53ef\u80fd\u7d27\u5bc6\uff0c\u5373\uff0c\u4e0d\u5e94\u5728\u6846\u5916\u4fdd\u7559\u4efb\u4f55\u50cf\u7d20\u3002\u8fd9\u610f\u5473\u7740\u884c\u8d70\u7684\u4fa7\u89c6\u56fe\u884c\u4eba\u901a\u5e38\u5c06\u5177\u6709\u4e00\u4e2a\u5bbd\u5ea6\u968f\u6b65\u5e45\u800c\u5468\u671f\u6027\u53d8\u5316\u7684\u6846\uff0c\u800c\u6b63\u89c6\u56fe\u6216\u7ad9\u7acb\u7684\u4eba\u5c06\u968f\u65f6\u95f4\u4fdd\u6301\u66f4\u6052\u5b9a\u7684\u5bbd\u9ad8\u6bd4\u3002\u5982\u679c\u4eba\u88ab\u90e8\u5206\u906e\u6321\uff0c\u5219\u6839\u636e\u5176\u4ed6\u53ef\u7528\u4fe1\u606f\uff08\u4f8b\u5982\u9884\u671f\u5927\u5c0f\uff0c\u9634\u5f71\uff0c\u53cd\u5c04\uff0c\u5148\u524d\u548c\u5c06\u6765\u7684\u5e27\u4ee5\u53ca\u5176\u4ed6\u63d0\u793a\uff09\u6765\u4f30\u8ba1\u8303\u56f4\u3002\u5982\u679c\u4e00\u4e2a\u4eba\u88ab\u56fe\u50cf\u8fb9\u6846\u88c1\u526a\uff0c\u5219\u4f30\u8ba1\u6846\u8d85\u51fa\u539f\u59cb\u5e27\uff0c\u4ee5\u4ee3\u8868\u6574\u4e2a\u4eba\u5e76\u4f30\u7b97\u88c1\u526a\u6c34\u5e73\u3002\u5982\u679c\u4e00\u4e2a\u906e\u6321\u7269\u4e0d\u80fd\u51c6\u786e\u5730\u5c01\u95ed\u5728\u4e00\u4e2a\u6846\u5185\uff08\u4f8b\u5982\uff0c\u4e00\u68f5\u6709\u6811\u679d\u7684\u6811\u6216\u81ea\u52a8\u6276\u68af\u53ef\u80fd\u9700\u8981\u4e00\u4e2a\u8f83\u5927\u7684\u6846\uff0c\u5176\u4e2d\u5927\u90e8\u5206\u533a\u57df\u90fd\u4e0d\u5c5e\u4e8e\u5b9e\u9645\u5bf9\u8c61\uff09\uff0c\u5219\u53ef\u4ee5\u4f7f\u7528\u51e0\u4e2a\u6846\u6765\u66f4\u597d\u5730\u8fd1\u4f3c\u8be5\u6846\u3002\u8be5\u5bf9\u8c61\u7684\u8303\u56f4\u3002 \u8f66\u8f86\u4e0a\u7684\u4eba\u5458\u53ea\u6709\u5728\u6e05\u6670\u53ef\u89c1\u7684\u60c5\u51b5\u4e0b\u624d\u4e0e\u8f66\u8f86\u5206\u5f00\u6807\u6ce8\u3002\u4f8b\u5982\uff0c\u7ae5\u8f66\u4e2d\u7684\u5b69\u5b50\u6216\u8005\u8f66\u4e2d\u7684\u4eba\u4e0d\u4f1a\u88ab\u6807\u6ce8\uff0c\u4f46\u6469\u6258\u8f66\u624b\u6216\u81ea\u884c\u8f66\u624b\u5c06\u88ab\u6807\u6ce8\u3002","title":"\u8fb9\u754c\u6846\u5bf9\u9f50"},{"location":"sot/MOT16-A-Benchmark-for-Muti-Object-Tracking/#_5","text":"\u53ea\u8981\u4eba\u7684\u4f4d\u7f6e\u548c\u8303\u56f4\u53ef\u4ee5\u88ab\u7cbe\u786e\u786e\u5b9a\u4fbf\u4f1a\u51fa\u73b0\u4e00\u4e2a\u6846\uff08\u8f68\u9053\uff09\u3002\u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u5f53\u4eba\u7684\u224810\uff05\u53ef\u89c1\u65f6\u4f1a\u51fa\u73b0\u6846\u3002\u540c\u6837\uff0c\u5f53\u65e0\u6cd5\u518d\u7cbe\u786e\u5b9a\u4f4d\u65f6\uff0c\u8f68\u9053\u7ed3\u675f\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u6807\u6ce8\u5c3d\u53ef\u80fd\u65e9\u5730\u5f00\u59cb\u5e76\u4e14\u5c3d\u53ef\u80fd\u665a\u5730\u7ed3\u675f\uff0c\u4ece\u800c\u4e0d\u4f1a\u4e27\u5931\u51c6\u786e\u6027\u3002\u6846\u7684\u5750\u6807\u53ef\u80fd\u8d85\u51fa\u53ef\u89c1\u533a\u57df\u3002\u5982\u679c\u6709\u4eba\u79bb\u5f00\u89c6\u91ce\u5e76\u5728\u4ee5\u540e\u51fa\u73b0\uff0c\u5219\u5c06\u4e3a\u4ed6\u4eec\u5206\u914d\u65b0\u7684ID\u3002","title":"\u8f68\u8ff9\u7684\u5f00\u59cb\u4e0e\u7ed3\u675f"},{"location":"sot/MOT16-A-Benchmark-for-Muti-Object-Tracking/#_6","text":"\u5c3d\u7ba1\u8bc4\u4f30\u4ec5\u8003\u8651\u4ee5\u50cf\u7d20\u4e3a\u5355\u4f4d\u7684\u6700\u5c0f\u9ad8\u5ea6\u7684\u884c\u4eba\uff0c\u4f46\u662f\u6807\u6ce8\u5c06\u5305\u542b\u6240\u6709\u5927\u5c0f\u7684\u6240\u6709\u5bf9\u8c61\uff0c\u53ea\u8981\u6807\u6ce8\u8005\u53ef\u4ee5\u533a\u5206\u5b83\u4eec\u5373\u53ef\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u56fe\u50cf\u4e0a\u7684\u6240\u6709\u76ee\u6807\u65e0\u8bba\u5176\u5927\u5c0f\u90fd\u5e94\u52a0\u4e0a\u6807\u6ce8\u3002","title":"\u6700\u5c0f\u5355\u4f4d"},{"location":"sot/MOT16-A-Benchmark-for-Muti-Object-Tracking/#_7","text":"\u906e\u6321\u7ea7\u522b\u4e0d\u9700\u8981\u88ab\u663e\u793a\u6807\u6ce8\u3002\u8be5\u503c\u5c06\u4f7f\u7528\u5730\u5e73\u9762\u5047\u8bbe\u548c\u6807\u6ce8\u81ea\u52a8\u8ba1\u7b97\u3002\u6bcf\u4e00\u4e2a\u76ee\u6807\u90fd\u88ab\u901a\u8fc7\u906e\u6321\u5b8c\u5168\u6807\u6ce8\uff0c\u53ea\u8981\u53ef\u4ee5\u8db3\u591f\u51c6\u786e\u5730\u786e\u5b9a\u5176\u8303\u56f4\u548c\u4f4d\u7f6e\u3002\u5982\u679c\u76ee\u6807\u5728\u5e8f\u5217\u4e2d\u95f4\u5b8c\u5168\u88ab\u906e\u6321\uff0c\u4ee5\u540e\u53c8\u4e0d\u53ef\u89c1\uff0c\u5219\u5e94\u7ec8\u6b62\u8f68\u9053\uff08\u6807\u8bb0\u4e3a\u201coutside of view\u201d\uff09\u3002\u5982\u679c\u76ee\u6807\u5728\u957f\u65f6\u95f4\u540e\u91cd\u65b0\u51fa\u73b0\uff0c\u5373\u5176\u5728\u906e\u6321\u8fc7\u7a0b\u4e2d\u4f4d\u7f6e\u5e76\u4e0d\u660e\u786e\uff0c\u5b83\u5c06\u4ee5\u65b0\u7684ID\u91cd\u65b0\u51fa\u73b0\u3002","title":"\u906e\u6321"},{"location":"sot/MOT16-A-Benchmark-for-Muti-Object-Tracking/#_8","text":"\u5728\u6240\u6709\u5e8f\u5217\u90fd\u5b8c\u6210\u6807\u6ce8\u540e\uff0c\u4e00\u4e2a\u201c\u5065\u5168\u6027\u68c0\u67e5\u201d\u88ab\u6267\u884c\u4ee5\u786e\u4fdd\u6ca1\u6709\u9057\u6f0f\u4efb\u4f55\u76f8\u5173\u5b9e\u4f53\u3002\u4e3a\u6b64\uff0c\u6211\u4eec\u5728\u6240\u6709\u89c6\u9891\u4e0a\u8fd0\u884c\u4e86\u884c\u4eba\u68c0\u6d4b\u5668\uff0c\u5e76\u5c06\u4e0e\u4eba\u7c7b\u6216\u5e72\u6270\u8005\u76f8\u5bf9\u5e94\u7684\u6240\u6709\u9ad8\u53ef\u4fe1\u5ea6\u68c0\u6d4b\u6dfb\u52a0\u5230\u4e86\u6807\u6ce8\u5217\u8868\u4e2d\u3002\u9884\u5148\u8ba1\u7b97\u7684\u5bf9\u8c61\u68c0\u6d4b\uff0c\u6807\u6ce8\uff08\u4ec5\u9488\u5bf9\u8bad\u7ec3\u5e8f\u5217\uff09\u548c\u4e00\u4e2a\u9488\u5bf9\u6240\u6709\u6570\u636e\u96c6\u7684\u901a\u7528\u8bc4\u4f30\u65b9\u6cd5\u5411\u6240\u6709\u53c2\u4e0e\u8005\u63d0\u4f9b\uff0c\u4ece\u800c\u53ef\u4ee5\u516c\u5e73\u5730\u6bd4\u8f83\u6240\u6709\u7ed3\u679c\u3002","title":"\u5065\u5168\u6027\u68c0\u67e5"},{"location":"sot/siamfc/","text":"\u4e13\u6709\u540d\u8bcd\u7ffb\u8bd1\u548c\u7f29\u5199 \u5728\u672c\u6587\u5f53\u4e2d\uff0c\u4e13\u6709\u540d\u8bcd\u88ab\u5982\u4e0b\u7ffb\u8bd1\u548c\u7f29\u5199\uff1a anchor \u951a\u6846 Convolution Neural Network CNN \u5377\u79ef\u795e\u7ecf\u7f51\u7edc Meta-Learning \u5143\u5b66\u4e60 Padding \u586b\u5145 Regional Proposal Network RPN \u533a\u57df\u5019\u9009\u7f51\u7edc Siamese \u5b6a\u751f Single Object Tracking SOT \u5355\u76ee\u6807\u8ddf\u8e2a Visual Object Tracking VOT SiamFC\u662f\u725b\u6d25\u5927\u5b66\u7684Luca Bertinetto\u7b49\u63d0\u51fa\u7684\u7528\u4e8e\u5355\u76ee\u6807\u8ddf\u8e2a\u7684\u7f51\u7edc\u3002 \u7b80\u4ecb # \u8ba1\u7b97\u673a\u89c6\u89c9\u4e2d\u7684\u5f88\u591a\u95ee\u9898\u90fd\u5df2\u7ecf\u5728\u4ece\u5927\u578b\u76d1\u7763\u6570\u636e\u96c6\u8bad\u7ec3\u800c\u6765\u7684\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u5f53\u4e2d\u5f97\u5230\u957f\u8db3\u7684\u8fdb\u6b65\uff0c\u4f46\u662f\u76d1\u7763\u6570\u636e\u7684\u7a00\u7f3a\u548c\u5b9e\u65f6\u64cd\u4f5c\u7684\u7ea6\u675f\u963b\u6b62\u4e86\u7b80\u5355\u7684\u5c06\u6df1\u5ea6\u5b66\u4e60\u5e94\u7528\u5230\u4ece\u6bcf\u4e2a\u89c6\u9891\u5f53\u4e2d\u5b66\u4e60\u5230\u4e00\u4e2a\u68c0\u6d4b\u5668\u3002\u6700\u8fd1\u6709\u4e00\u4e9b\u5de5\u4f5c\u65e8\u5728\u514b\u670d\u8fd9\u4e9b\u95ee\u9898\uff0c\u4ed6\u4eec\u8981\u4e48\u5e94\u7528\u4e00\u4e9b\u201c\u7c97\u6d45\u201d\u7684\u65b9\u6cd5\uff08\u6bd4\u5982 \u76f8\u5173\u8fc7\u6ee4\u5668\uff09\uff0c\u5c06\u7f51\u7edc\u7684\u5185\u90e8\u8868\u793a\u4f5c\u4e3a\u7279\u5f81\uff0c\u6216\u8005\u901a\u8fc7SGD\u6765\u5fae\u8c03\u7f51\u7edc\u7684\u591a\u4e2a\u5c42\u3002\u7136\u800c\uff0c\u4f7f\u7528\u7c97\u6d45\u7684\u65b9\u6cd5\u5e76\u6ca1\u6709\u5229\u7528\u5230\u7aef\u5230\u7aef\u8bad\u7ec3\u7684\u5168\u90e8\u4f18\u70b9\uff0c\u4f7f\u7528SGD\u7684\u65b9\u6cd5\u8fbe\u5230SOTA\u7ed3\u679c\u7684\u5747\u4e0d\u80fd\u505a\u5230\u5b9e\u65f6\u64cd\u4f5c\u3002\u672c\u6587\u4f5c\u8005\u63d0\u51fa\u4e86\u4e00\u4e2a\u65b0\u7684\u65b9\u6cd5\uff0c\u8bad\u7ec3\u4e00\u4e2a\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u6765\u5728\u6700\u521d\u7684\u79bb\u7ebf\u9636\u6bb5\u89e3\u51b3\u66f4\u666e\u904d\u7684\u76f8\u4f3c\u6027\u5b66\u4e60\u95ee\u9898\uff0c\u7136\u540e\u53ea\u9700\u5728\u8ddf\u8e2a\u8fc7\u7a0b\u4e2d\u5728\u7ebf\u8bc4\u4f30\u6b64\u529f\u80fd\u3002 \u672c\u6587\u7684\u6838\u5fc3\u8d21\u732e\u5728\u4e8e\u672c\u6587\u6240\u63d0\u51fa\u7684\u65b9\u6cd5\u53ef\u4ee5\u5728\u8fdc\u8d85\u6240\u9700\u5e27\u7387\u7684\u901f\u5ea6\u65f6\u8fbe\u5230\u6781\u5177\u7ade\u4e89\u529b\u7684\u6027\u80fd\u3002\u7279\u522b\u7684\uff0c\u672c\u6587\u4f5c\u8005\u8bad\u7ec3\u4e00\u4e2a\u5b6a\u751f\u7f51\u7edc\u6765\u5728\u4e00\u4e2a\u5927\u7684 \u641c\u7d22 \u56fe\u50cf\u5f53\u4e2d\u5b9a\u4f4d\u4e00\u4e2a \u6837\u672c \u56fe\u50cf\u3002\u53e6\u4e00\u4e2a\u8d21\u732e\u662f\u76f8\u5bf9\u4e8e\u641c\u7d22\u56fe\u50cf\u7684\u5168\u5377\u79ef\u5b6a\u751f\u67b6\u6784\uff1a\u901a\u8fc7\u53cc\u7ebf\u6027\u5c42\u6765\u8ba1\u7b97\u4e24\u4e2a\u8f93\u5165\u7684\u4e92\u76f8\u5173\u6027\uff0c\u4ece\u800c\u5b9e\u73b0\u4e86\u5bc6\u96c6\u800c\u6709\u6548\u7684\u6ed1\u7a97\u8bc4\u4f30\u3002 \u672c\u6587\u4f5c\u8005\u8ba4\u4e3a\u76f8\u4f3c\u6027\u5b66\u4e60\u65b9\u6cd5\u76f8\u5bf9\u800c\u8a00\u4e00\u76f4\u53d7\u5230\u5ffd\u7565\u3002\u56e0\u4e3a\u8ddf\u8e2a\u793e\u533a\u6ca1\u6709\u5927\u91cf\u7684\u76d1\u7763\u6570\u636e\u96c6\u3002\u4e8b\u5b9e\u4e0a\uff0c\u76f4\u5230\u8fd1\uff0c\u53ef\u7528\u7684\u6570\u636e\u96c6\u4ec5\u5305\u542b\u6570\u767e\u4e2a\u5e26\u6ce8\u91ca\u7684\u89c6\u9891\u3002\u4f46\u65f6\uff0c\u672c\u6587\u4f5c\u8005\u8ba4\u4e3a\uff0c\u89c6\u9891\u4e2d\u7528\u4e8e\u5bf9\u8c61\u68c0\u6d4b\u7684ILSVRC\u6570\u636e\u96c6\u7684\u51fa\u73b0\u4f7f\u5f97\u8bad\u7ec3\u8fd9\u79cd\u6a21\u578b\u6210\u4e3a\u53ef\u80fd\u3002\u6b64\u5916\uff0c\u4f7f\u7528\u6765\u81ea\u540c\u4e00\u57df\u7684\u89c6\u9891\u8fdb\u884c\u8bad\u7ec3\u548c\u6d4b\u8bd5\u7528\u4e8e\u8ddf\u8e2a\u7684\u6df1\u5ea6\u6a21\u578b\u5728\u516c\u5e73\u6027\u4e0a\u5b58\u5728\u4e89\u8bae\uff0c\u6700\u8fd1VOT\u59d4\u5458\u4f1a\u5df2\u7ecf\u7981\u6b62\u8fd9\u6837\u505a\u3002\u672c\u6587\u4f5c\u8005\u5c55\u793a\u4e86\u672c\u6587\u63d0\u51fa\u7684\u6a21\u578b\u53ef\u4ee5\u4eceILSVRC\u57df\u63a8\u5e7f\u5230ALOV\u3001OTB\u3001VOT\u57df\uff0c\u4ece\u800c\u53ef\u4ee5\u5c06\u8ddf\u8e2a\u57fa\u51c6\u7684\u89c6\u9891\u4fdd\u7559\u7528\u4e8e\u6d4b\u8bd5\u3002 \u7528\u4e8e\u8ddf\u8e2a\u7684\u6df1\u5ea6\u76f8\u4f3c\u6027\u5b66\u4e60 # \u5b66\u4e60\u53bb\u8ffd\u8e2a\u4efb\u610f\u5bf9\u8c61\u53ef\u4ee5\u4f7f\u7528\u76f8\u4f3c\u6027\u5b66\u4e60\u6765\u89e3\u51b3\u3002\u672c\u6587\u4f5c\u8005\u63d0\u51fa\u4e86\u5b66\u4e60\u4e00\u4e2a\u51fd\u6570 f(\\mathcal{x}, \\mathcal{z}) f(\\mathcal{x}, \\mathcal{z}) \uff0c\u5b83\u5c06\u6837\u672c\u56fe\u50cf \\mathcal{z} \\mathcal{z} \u4e0e\u76f8\u540c\u5927\u5c0f\u7684\u5019\u9009\u56fe\u50cf \\mathcal{x} \\mathcal{x} \u8fdb\u884c\u6bd4\u8f83\uff0c\u5e76\u5728\u4e24\u4e2a\u56fe\u50cf\u90fd\u63cf\u7ed8\u540c\u4e00\u5bf9\u8c61\u65f6\u8fd4\u56de\u9ad8\u5206\uff0c\u5728\u5176\u4ed6\u60c5\u51b5\u4e0b\u8fd4\u56de\u4f4e\u5206\u3002\u4e3a\u4e86\u627e\u5230\u76ee\u6807\u5728\u65b0\u56fe\u50cf\u4e2d\u7684\u4f4d\u7f6e\uff0c\u672c\u6587\u4f5c\u8005\u53ef\u4ee5\u8be6\u5c3d\u7684\u5728\u6bcf\u4e00\u4e2a\u53ef\u80fd\u7684\u4f4d\u7f6e\u8fdb\u884c\u6d4b\u8bd5\uff0c\u5e76\u9009\u62e9\u4e0e\u5bf9\u8c61\u8fc7\u53bb\u7684\u6837\u5b50\u76f8\u4f3c\u5ea6\u6700\u9ad8\u7684\u5019\u9009\u3002\u5728\u5b9e\u9a8c\u4e2d\uff0c\u672c\u6587\u4f5c\u8005\u4ec5\u9009\u7528\u5bf9\u8c61\u521d\u59cb\u7684\u6837\u5b50\u4f5c\u4e3a\u6837\u672c\u3002\u51fd\u6570 f f \u4f1a\u901a\u8fc7\u4e00\u4e2a\u7531\u6807\u6ce8\u5bf9\u8c61\u8f68\u8ff9\u7684\u89c6\u9891\u6784\u6210\u7684\u6570\u636e\u96c6\u8bad\u7ec3\u3002 \u7531\u4e8e\u5b83\u5728\u8ba1\u7b97\u673a\u89c6\u89c9\u5f53\u4e2d\u7684\u5de8\u5927\u6210\u529f\uff0c\u672c\u6587\u4f5c\u8005\u5c06\u4f1a\u4f7f\u7528\u4e00\u4e2a\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u4f5c\u4e3a\u51fd\u6570 f f \u3002\u4f7f\u7528\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u8fdb\u884c\u76f8\u4f3c\u6027\u5b66\u4e60\u901a\u5e38\u4f7f\u7528\u5b6a\u751f\u67b6\u6784\u3002\u5b6a\u751f\u7f51\u7edc\u5c06\u540c\u4e00\u4e2a\u53d8\u6362 \\varphi \\varphi \u5206\u522b\u5e94\u7528\u5728\u4e24\u4e2a\u8f93\u5165\u4e0a\uff0c\u7136\u540e\u5c06\u4ed6\u4eec\u7684\u8868\u73b0\u901a\u8fc7\u53e6\u4e00\u4e2a\u51fd\u6570 g g \u57fa\u4e8e f(\\mathcal{x},\\mathcal{z}) = g(\\varphi\\mathcal{x}, \\varphi\\mathcal{z}) f(\\mathcal{x},\\mathcal{z}) = g(\\varphi\\mathcal{x}, \\varphi\\mathcal{z}) \u7ec4\u5408\u8d77\u6765\u3002\u5f53 g g \u662f\u4e00\u4e2a\u7b80\u5355\u7684\u8ddd\u79bb\u6216\u8005\u76f8\u4f3c\u5ea6\u5ea6\u91cf\uff0c\u51fd\u6570 \\varphi \\varphi \u53ef\u4ee5\u88ab\u8ba4\u4e3a\u662f\u5d4c\u5165\u3002\u6df1\u5ea6\u5b6a\u751f\u5377\u79ef\u7f51\u7edc\u66fe\u88ab\u5e94\u7528\u4e8e\u4eba\u8138\u9a8c\u8bc1\u3001\u5173\u952e\u70b9\u63cf\u8ff0\u5176\u5b66\u4e60\u548c\u5355\u6837\u672c\u5b57\u7b26\u8bc6\u522b\u3002 \u5168\u5377\u79ef\u5b6a\u751f\u67b6\u6784 # \u672c\u6587\u4f5c\u8005\u63d0\u51fa\u4e86\u4e00\u4e2a\u6709\u5173\u5019\u9009\u56fe\u50cf \\mathcal{x} \\mathcal{x} \u7684\u5168\u5377\u79ef\u7684\u5b6a\u751f\u67b6\u6784\u3002\u672c\u6587\u4f5c\u8005\u5c06\u4e00\u4e2a\u6ca1\u6709\u5e73\u79fb\u7684\u65b9\u6cd5\u79f0\u4f5c\u5168\u5377\u79ef\u3002\u66f4\u51c6\u786e\u5730\u8bf4\uff0c\u5bf9\u4e8e\u5e73\u79fb\u64cd\u4f5c L_\\tau L_\\tau \uff0c (L_{\\tau} x)[u]=x[u - \\tau] (L_{\\tau} x)[u]=x[u - \\tau] \u3002\u5bf9\u4e8e\u4efb\u4f55\u5e73\u79fb \\tau \\tau \uff0c\u5982\u679c\u5982\u679c h(L_{k\\tau}x)=L_{\\tau}h(x) h(L_{k\\tau}x)=L_{\\tau}h(x) \u6210\u7acb\uff0c\u5219\u6211\u4eec\u628a\u5c06\u4fe1\u53f7\u6620\u5c04\u5230\u5176\u4ed6\u4fe1\u53f7\u7684\u51fd\u6570 h h \u79f0\u505a\u6b65\u957f\u4e3a k k \u7684\u5168\u5377\u79ef\u3002 \u4f7f\u7528\u5168\u5377\u79ef\u7f51\u7edc\u7684\u4f18\u70b9\u5728\u4e8e\uff0c\u6211\u4eec\u53ef\u4ee5\u63d0\u4f9b\u66f4\u5927\u7684\u641c\u7d22\u56fe\u50cf\u4f5c\u4e3a\u8f93\u5165\uff0c\u4e14\u4ed6\u4f1a\u5728\u4e00\u6b21\u8bc4\u4f30\u4e2d\u8ba1\u7b97\u5bc6\u96c6\u7f51\u683c\u4e0a\u6240\u6709\u5df2\u5e73\u79fb\u7684\u5b50\u7a97\u53e3\u7684\u76f8\u4f3c\u5ea6\u3002\u4e3a\u6b64\uff0c\u672c\u6587\u4f5c\u8005\u4f7f\u7528\u4e86\u5377\u79ef\u5d4c\u5165\u51fd\u6570 \\varphi \\varphi \uff0c\u5e76\u4f7f\u7528\u4e92\u76f8\u5173\u5c42\u5c06\u751f\u6210\u7684\u7279\u5f81\u56fe\u8fdb\u884c\u7ec4\u5408\u3002 f(z, x) = \\varphi(z) * \\varphi(x) + b\\mathbb{1} f(z, x) = \\varphi(z) * \\varphi(x) + b\\mathbb{1} \u5176\u4e2d\uff0c b\\mathbb{1} b\\mathbb{1} \u8868\u793a\u4ece\u4fe1\u53f7 \u635f\u5931\u51fd\u6570 #","title":"SiamRPN"},{"location":"sot/siamfc/#_1","text":"\u8ba1\u7b97\u673a\u89c6\u89c9\u4e2d\u7684\u5f88\u591a\u95ee\u9898\u90fd\u5df2\u7ecf\u5728\u4ece\u5927\u578b\u76d1\u7763\u6570\u636e\u96c6\u8bad\u7ec3\u800c\u6765\u7684\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u5f53\u4e2d\u5f97\u5230\u957f\u8db3\u7684\u8fdb\u6b65\uff0c\u4f46\u662f\u76d1\u7763\u6570\u636e\u7684\u7a00\u7f3a\u548c\u5b9e\u65f6\u64cd\u4f5c\u7684\u7ea6\u675f\u963b\u6b62\u4e86\u7b80\u5355\u7684\u5c06\u6df1\u5ea6\u5b66\u4e60\u5e94\u7528\u5230\u4ece\u6bcf\u4e2a\u89c6\u9891\u5f53\u4e2d\u5b66\u4e60\u5230\u4e00\u4e2a\u68c0\u6d4b\u5668\u3002\u6700\u8fd1\u6709\u4e00\u4e9b\u5de5\u4f5c\u65e8\u5728\u514b\u670d\u8fd9\u4e9b\u95ee\u9898\uff0c\u4ed6\u4eec\u8981\u4e48\u5e94\u7528\u4e00\u4e9b\u201c\u7c97\u6d45\u201d\u7684\u65b9\u6cd5\uff08\u6bd4\u5982 \u76f8\u5173\u8fc7\u6ee4\u5668\uff09\uff0c\u5c06\u7f51\u7edc\u7684\u5185\u90e8\u8868\u793a\u4f5c\u4e3a\u7279\u5f81\uff0c\u6216\u8005\u901a\u8fc7SGD\u6765\u5fae\u8c03\u7f51\u7edc\u7684\u591a\u4e2a\u5c42\u3002\u7136\u800c\uff0c\u4f7f\u7528\u7c97\u6d45\u7684\u65b9\u6cd5\u5e76\u6ca1\u6709\u5229\u7528\u5230\u7aef\u5230\u7aef\u8bad\u7ec3\u7684\u5168\u90e8\u4f18\u70b9\uff0c\u4f7f\u7528SGD\u7684\u65b9\u6cd5\u8fbe\u5230SOTA\u7ed3\u679c\u7684\u5747\u4e0d\u80fd\u505a\u5230\u5b9e\u65f6\u64cd\u4f5c\u3002\u672c\u6587\u4f5c\u8005\u63d0\u51fa\u4e86\u4e00\u4e2a\u65b0\u7684\u65b9\u6cd5\uff0c\u8bad\u7ec3\u4e00\u4e2a\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u6765\u5728\u6700\u521d\u7684\u79bb\u7ebf\u9636\u6bb5\u89e3\u51b3\u66f4\u666e\u904d\u7684\u76f8\u4f3c\u6027\u5b66\u4e60\u95ee\u9898\uff0c\u7136\u540e\u53ea\u9700\u5728\u8ddf\u8e2a\u8fc7\u7a0b\u4e2d\u5728\u7ebf\u8bc4\u4f30\u6b64\u529f\u80fd\u3002 \u672c\u6587\u7684\u6838\u5fc3\u8d21\u732e\u5728\u4e8e\u672c\u6587\u6240\u63d0\u51fa\u7684\u65b9\u6cd5\u53ef\u4ee5\u5728\u8fdc\u8d85\u6240\u9700\u5e27\u7387\u7684\u901f\u5ea6\u65f6\u8fbe\u5230\u6781\u5177\u7ade\u4e89\u529b\u7684\u6027\u80fd\u3002\u7279\u522b\u7684\uff0c\u672c\u6587\u4f5c\u8005\u8bad\u7ec3\u4e00\u4e2a\u5b6a\u751f\u7f51\u7edc\u6765\u5728\u4e00\u4e2a\u5927\u7684 \u641c\u7d22 \u56fe\u50cf\u5f53\u4e2d\u5b9a\u4f4d\u4e00\u4e2a \u6837\u672c \u56fe\u50cf\u3002\u53e6\u4e00\u4e2a\u8d21\u732e\u662f\u76f8\u5bf9\u4e8e\u641c\u7d22\u56fe\u50cf\u7684\u5168\u5377\u79ef\u5b6a\u751f\u67b6\u6784\uff1a\u901a\u8fc7\u53cc\u7ebf\u6027\u5c42\u6765\u8ba1\u7b97\u4e24\u4e2a\u8f93\u5165\u7684\u4e92\u76f8\u5173\u6027\uff0c\u4ece\u800c\u5b9e\u73b0\u4e86\u5bc6\u96c6\u800c\u6709\u6548\u7684\u6ed1\u7a97\u8bc4\u4f30\u3002 \u672c\u6587\u4f5c\u8005\u8ba4\u4e3a\u76f8\u4f3c\u6027\u5b66\u4e60\u65b9\u6cd5\u76f8\u5bf9\u800c\u8a00\u4e00\u76f4\u53d7\u5230\u5ffd\u7565\u3002\u56e0\u4e3a\u8ddf\u8e2a\u793e\u533a\u6ca1\u6709\u5927\u91cf\u7684\u76d1\u7763\u6570\u636e\u96c6\u3002\u4e8b\u5b9e\u4e0a\uff0c\u76f4\u5230\u8fd1\uff0c\u53ef\u7528\u7684\u6570\u636e\u96c6\u4ec5\u5305\u542b\u6570\u767e\u4e2a\u5e26\u6ce8\u91ca\u7684\u89c6\u9891\u3002\u4f46\u65f6\uff0c\u672c\u6587\u4f5c\u8005\u8ba4\u4e3a\uff0c\u89c6\u9891\u4e2d\u7528\u4e8e\u5bf9\u8c61\u68c0\u6d4b\u7684ILSVRC\u6570\u636e\u96c6\u7684\u51fa\u73b0\u4f7f\u5f97\u8bad\u7ec3\u8fd9\u79cd\u6a21\u578b\u6210\u4e3a\u53ef\u80fd\u3002\u6b64\u5916\uff0c\u4f7f\u7528\u6765\u81ea\u540c\u4e00\u57df\u7684\u89c6\u9891\u8fdb\u884c\u8bad\u7ec3\u548c\u6d4b\u8bd5\u7528\u4e8e\u8ddf\u8e2a\u7684\u6df1\u5ea6\u6a21\u578b\u5728\u516c\u5e73\u6027\u4e0a\u5b58\u5728\u4e89\u8bae\uff0c\u6700\u8fd1VOT\u59d4\u5458\u4f1a\u5df2\u7ecf\u7981\u6b62\u8fd9\u6837\u505a\u3002\u672c\u6587\u4f5c\u8005\u5c55\u793a\u4e86\u672c\u6587\u63d0\u51fa\u7684\u6a21\u578b\u53ef\u4ee5\u4eceILSVRC\u57df\u63a8\u5e7f\u5230ALOV\u3001OTB\u3001VOT\u57df\uff0c\u4ece\u800c\u53ef\u4ee5\u5c06\u8ddf\u8e2a\u57fa\u51c6\u7684\u89c6\u9891\u4fdd\u7559\u7528\u4e8e\u6d4b\u8bd5\u3002","title":"\u7b80\u4ecb"},{"location":"sot/siamfc/#_2","text":"\u5b66\u4e60\u53bb\u8ffd\u8e2a\u4efb\u610f\u5bf9\u8c61\u53ef\u4ee5\u4f7f\u7528\u76f8\u4f3c\u6027\u5b66\u4e60\u6765\u89e3\u51b3\u3002\u672c\u6587\u4f5c\u8005\u63d0\u51fa\u4e86\u5b66\u4e60\u4e00\u4e2a\u51fd\u6570 f(\\mathcal{x}, \\mathcal{z}) f(\\mathcal{x}, \\mathcal{z}) \uff0c\u5b83\u5c06\u6837\u672c\u56fe\u50cf \\mathcal{z} \\mathcal{z} \u4e0e\u76f8\u540c\u5927\u5c0f\u7684\u5019\u9009\u56fe\u50cf \\mathcal{x} \\mathcal{x} \u8fdb\u884c\u6bd4\u8f83\uff0c\u5e76\u5728\u4e24\u4e2a\u56fe\u50cf\u90fd\u63cf\u7ed8\u540c\u4e00\u5bf9\u8c61\u65f6\u8fd4\u56de\u9ad8\u5206\uff0c\u5728\u5176\u4ed6\u60c5\u51b5\u4e0b\u8fd4\u56de\u4f4e\u5206\u3002\u4e3a\u4e86\u627e\u5230\u76ee\u6807\u5728\u65b0\u56fe\u50cf\u4e2d\u7684\u4f4d\u7f6e\uff0c\u672c\u6587\u4f5c\u8005\u53ef\u4ee5\u8be6\u5c3d\u7684\u5728\u6bcf\u4e00\u4e2a\u53ef\u80fd\u7684\u4f4d\u7f6e\u8fdb\u884c\u6d4b\u8bd5\uff0c\u5e76\u9009\u62e9\u4e0e\u5bf9\u8c61\u8fc7\u53bb\u7684\u6837\u5b50\u76f8\u4f3c\u5ea6\u6700\u9ad8\u7684\u5019\u9009\u3002\u5728\u5b9e\u9a8c\u4e2d\uff0c\u672c\u6587\u4f5c\u8005\u4ec5\u9009\u7528\u5bf9\u8c61\u521d\u59cb\u7684\u6837\u5b50\u4f5c\u4e3a\u6837\u672c\u3002\u51fd\u6570 f f \u4f1a\u901a\u8fc7\u4e00\u4e2a\u7531\u6807\u6ce8\u5bf9\u8c61\u8f68\u8ff9\u7684\u89c6\u9891\u6784\u6210\u7684\u6570\u636e\u96c6\u8bad\u7ec3\u3002 \u7531\u4e8e\u5b83\u5728\u8ba1\u7b97\u673a\u89c6\u89c9\u5f53\u4e2d\u7684\u5de8\u5927\u6210\u529f\uff0c\u672c\u6587\u4f5c\u8005\u5c06\u4f1a\u4f7f\u7528\u4e00\u4e2a\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u4f5c\u4e3a\u51fd\u6570 f f \u3002\u4f7f\u7528\u6df1\u5ea6\u5377\u79ef\u7f51\u7edc\u8fdb\u884c\u76f8\u4f3c\u6027\u5b66\u4e60\u901a\u5e38\u4f7f\u7528\u5b6a\u751f\u67b6\u6784\u3002\u5b6a\u751f\u7f51\u7edc\u5c06\u540c\u4e00\u4e2a\u53d8\u6362 \\varphi \\varphi \u5206\u522b\u5e94\u7528\u5728\u4e24\u4e2a\u8f93\u5165\u4e0a\uff0c\u7136\u540e\u5c06\u4ed6\u4eec\u7684\u8868\u73b0\u901a\u8fc7\u53e6\u4e00\u4e2a\u51fd\u6570 g g \u57fa\u4e8e f(\\mathcal{x},\\mathcal{z}) = g(\\varphi\\mathcal{x}, \\varphi\\mathcal{z}) f(\\mathcal{x},\\mathcal{z}) = g(\\varphi\\mathcal{x}, \\varphi\\mathcal{z}) \u7ec4\u5408\u8d77\u6765\u3002\u5f53 g g \u662f\u4e00\u4e2a\u7b80\u5355\u7684\u8ddd\u79bb\u6216\u8005\u76f8\u4f3c\u5ea6\u5ea6\u91cf\uff0c\u51fd\u6570 \\varphi \\varphi \u53ef\u4ee5\u88ab\u8ba4\u4e3a\u662f\u5d4c\u5165\u3002\u6df1\u5ea6\u5b6a\u751f\u5377\u79ef\u7f51\u7edc\u66fe\u88ab\u5e94\u7528\u4e8e\u4eba\u8138\u9a8c\u8bc1\u3001\u5173\u952e\u70b9\u63cf\u8ff0\u5176\u5b66\u4e60\u548c\u5355\u6837\u672c\u5b57\u7b26\u8bc6\u522b\u3002","title":"\u7528\u4e8e\u8ddf\u8e2a\u7684\u6df1\u5ea6\u76f8\u4f3c\u6027\u5b66\u4e60"},{"location":"sot/siamfc/#_3","text":"\u672c\u6587\u4f5c\u8005\u63d0\u51fa\u4e86\u4e00\u4e2a\u6709\u5173\u5019\u9009\u56fe\u50cf \\mathcal{x} \\mathcal{x} \u7684\u5168\u5377\u79ef\u7684\u5b6a\u751f\u67b6\u6784\u3002\u672c\u6587\u4f5c\u8005\u5c06\u4e00\u4e2a\u6ca1\u6709\u5e73\u79fb\u7684\u65b9\u6cd5\u79f0\u4f5c\u5168\u5377\u79ef\u3002\u66f4\u51c6\u786e\u5730\u8bf4\uff0c\u5bf9\u4e8e\u5e73\u79fb\u64cd\u4f5c L_\\tau L_\\tau \uff0c (L_{\\tau} x)[u]=x[u - \\tau] (L_{\\tau} x)[u]=x[u - \\tau] \u3002\u5bf9\u4e8e\u4efb\u4f55\u5e73\u79fb \\tau \\tau \uff0c\u5982\u679c\u5982\u679c h(L_{k\\tau}x)=L_{\\tau}h(x) h(L_{k\\tau}x)=L_{\\tau}h(x) \u6210\u7acb\uff0c\u5219\u6211\u4eec\u628a\u5c06\u4fe1\u53f7\u6620\u5c04\u5230\u5176\u4ed6\u4fe1\u53f7\u7684\u51fd\u6570 h h \u79f0\u505a\u6b65\u957f\u4e3a k k \u7684\u5168\u5377\u79ef\u3002 \u4f7f\u7528\u5168\u5377\u79ef\u7f51\u7edc\u7684\u4f18\u70b9\u5728\u4e8e\uff0c\u6211\u4eec\u53ef\u4ee5\u63d0\u4f9b\u66f4\u5927\u7684\u641c\u7d22\u56fe\u50cf\u4f5c\u4e3a\u8f93\u5165\uff0c\u4e14\u4ed6\u4f1a\u5728\u4e00\u6b21\u8bc4\u4f30\u4e2d\u8ba1\u7b97\u5bc6\u96c6\u7f51\u683c\u4e0a\u6240\u6709\u5df2\u5e73\u79fb\u7684\u5b50\u7a97\u53e3\u7684\u76f8\u4f3c\u5ea6\u3002\u4e3a\u6b64\uff0c\u672c\u6587\u4f5c\u8005\u4f7f\u7528\u4e86\u5377\u79ef\u5d4c\u5165\u51fd\u6570 \\varphi \\varphi \uff0c\u5e76\u4f7f\u7528\u4e92\u76f8\u5173\u5c42\u5c06\u751f\u6210\u7684\u7279\u5f81\u56fe\u8fdb\u884c\u7ec4\u5408\u3002 f(z, x) = \\varphi(z) * \\varphi(x) + b\\mathbb{1} f(z, x) = \\varphi(z) * \\varphi(x) + b\\mathbb{1} \u5176\u4e2d\uff0c b\\mathbb{1} b\\mathbb{1} \u8868\u793a\u4ece\u4fe1\u53f7","title":"\u5168\u5377\u79ef\u5b6a\u751f\u67b6\u6784"},{"location":"sot/siamfc/#_4","text":"","title":"\u635f\u5931\u51fd\u6570"},{"location":"sot/siamrpn%2B%2B/","text":"SiamRPN++\u662f\u5546\u6c64\u79d1\u6280\u7684\u674e\u535a\u7b49\u63d0\u51fa\u7684\u5355\u76ee\u6807\u8ddf\u8e2a\u7b97\u6cd5\u3002 \u7b80\u4ecb # \u5c3d\u7ba1SiamRPN\u5df2\u7ecf\u53d6\u5f97\u4e86\u8f83\u597d\u7684\u6210\u7ee9\uff0c\u5c24\u5176\u662f\u5728\u51c6\u786e\u7387\u548c\u901f\u5ea6\u7684\u5e73\u8861\u4e0a\u3002\u4f46\u662f\uff0c\u5c3d\u7ba1\u662f\u6027\u80fd\u6700\u597d\u7684\u5b6a\u751f\u8ddf\u8e2a\u5668\uff08Siamese Trackers\uff09\u4e5f\u4e0eSOTA\u7684\u4f20\u7edf\u65b9\u6cd5\u6709\u7740\u76f8\u8f83\u800c\u8a00\u5341\u5206\u660e\u663e\u7684\u6027\u80fd\u5dee\u8ddd\u3002\u5b6a\u751f\u8ddf\u8e2a\u5668\u5927\u90fd\u57fa\u4e8e\u8f83\u6d45\u7684AlexNet\uff0c\u4e14\u5728\u6362\u7528\u6df1\u5ea6\u7684ResNet\u7b49\u4e4b\u540e\u6ca1\u6709\u6027\u80fd\u63d0\u5347\uff0c\u751a\u81f3\u8fd8\u6709\u6240\u4e0b\u964d\u3002\u672c\u6587\u5bf9\u5b6a\u751f\u8ddf\u8e2a\u5668\u8fdb\u884c\u5206\u6790\uff0c\u53d1\u73b0\u524d\u8ff0\u7684\u6027\u80fd\u4e0b\u964d\u662f\u7531\u4e8e\u4e25\u683c\u5e73\u79fb\u4e0d\u53d8\u6027\u88ab\u7834\u574f\u6240\u5bfc\u81f4\u7684\u3002\u672c\u6587\u8fdb\u4e00\u6b65\u53d1\u73b0\u53ea\u6709\u96f6\u586b\u5145\uff08zero-padding\uff09\u7684AlexNet\u6ee1\u8db3\u8be5\u7a7a\u95f4\u4e0d\u53d8\u6027\u7684\u9650\u5236\u3002\u4e3a\u4e86\u8d8a\u8fc7\u8fd9\u4e2a\u9650\u5236\uff0c\u5e76\u4f7f\u5b6a\u751f\u8ddf\u8e2a\u5668\u5f97\u4ee5\u4e0e\u6df1\u5ea6\u795e\u7ecf\u7f51\u7edc\u914d\u5408\uff0c\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u7b80\u5355\u9ad8\u6548\u7684\u91c7\u6837\u65b9\u6cd5\u6765\u7a81\u7834\u5b6a\u751f\u8ddf\u8e2a\u5668\u7684\u7a7a\u95f4\u4e0d\u53d8\u6027\u9650\u5236\u3002\u672c\u6587\u6210\u529f\u7684\u8bad\u7ec3\u4e86\u4e00\u4e2a\u4f7f\u7528ResNet\u4f5c\u4e3a\u9aa8\u5e72\u7f51\u7edc\u7684\u57fa\u4e8eSiamRPN\u7684\u8ddf\u8e2a\u5668\u3002\u5f97\u76ca\u4e8eResNet\u7684\u67b6\u6784\uff0c\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u4e92\u76f8\u5173\u8fd0\u7b97\uff08cross-correlations operation\uff09\u7684\u9010\u5c42\u7279\u5f81\u805a\u5408\u7ed3\u6784\uff08layer-wise feature aggravation structure\uff09\u3002\u901a\u8fc7\u5bf9\u5b6a\u751f\u7f51\u7edc\u7684\u4e92\u76f8\u5173\u6027\u8fdb\u884c\u5206\u6790\uff0c\u672c\u6587\u53d1\u73b0\u4ed6\u4e24\u4e2a\u7f51\u7edc\u5206\u652f\u7684\u53c2\u6570\u5b58\u5728\u5f88\u5927\u7684\u4e0d\u5e73\u8861\u3002\u56e0\u6b64\uff0c\u672c\u6587\u8fdb\u4e00\u6b65\u63d0\u51fa\u4e86\u4e00\u4e2a\u9010\u6df1\u5ea6\u53ef\u5206\u79bb\u7684\u76f8\u5173\u7ed3\u6784\uff08depth-wise separable correlation structure\uff09\u3002\u5b83\u4e0d\u4f46\u6781\u5927\u7a0b\u5ea6\u4e0a\u7684\u964d\u4f4e\u4e86\u76ee\u6807\u6a21\u677f\u5206\u652f\u7684\u53c2\u6570\u6570\u91cf\uff0c\u5e76\u4e14\u7a33\u5b9a\u4e86\u6574\u4e2a\u6a21\u578b\u7684\u8bad\u7ec3\u8fc7\u7a0b\u3002\u6b64\u5916\uff0c\u4e00\u4e2a\u6709\u8da3\u7684\u53d1\u73b0\u88ab\u89c2\u5bdf\u5230\u2013\u5c5e\u4e8e\u76f8\u540c\u7c7b\u522b\u7684\u5bf9\u8c61\u5728\u540c\u4e00\u901a\u9053\uff08channel\uff09\u4e0a\u6709\u8f83\u9ad8\u7684\u54cd\u5e94\uff08response\uff09\uff0c\u800c\u5728\u5176\u4ed6\u901a\u9053\u4e0a\u7684\u54cd\u5e94\u5219\u88ab\u6291\u5236\u3002\u6b63\u4ea4\u5c5e\u6027\u4e5f\u53ef\u80fd\u63d0\u5347\u8ddf\u8e2a\u7684\u6027\u80fd\u3002\u672c\u6587\u7684\u8d21\u732e\u53ef\u4ee5\u88ab\u5212\u5206\u4e3a\u56db\u7c7b\uff1a \u672c\u6587\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5bf9\u5b6a\u751f\u8ddf\u8e2a\u5668\u7684\u6df1\u5ea6\u5206\u6790\uff0c\u5e76\u8bc1\u660e\u4f7f\u7528\u6df1\u5ea6\u7f51\u7edc\u65f6\u7684\u51c6\u786e\u7387\u964d\u4f4e\u6765\u81ea\u4e8e\u4e25\u683c\u5e73\u79fb\u4e0d\u53d8\u6027\u7684\u7834\u574f\u3002 \u672c\u6587\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b80\u5355\u9ad8\u6548\u7684\u91c7\u6837\u673a\u5236\u6765\u7a81\u7834\u7a7a\u95f4\u4e0d\u53d8\u6027\u9650\u5236\uff0c\u5e76\u501f\u6b64\u6210\u529f\u7684\u8bad\u7ec3\u4e86\u4e00\u4e2a\u901a\u8fc7ResNet\u67b6\u6784\u9a71\u52a8\u7684\u5b6a\u751f\u8ddf\u8e2a\u5668\u3002 \u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u5bf9\u4e92\u76f8\u5173\u8fd0\u7b97\u7684\u9010\u5c42\u7279\u5f81\u805a\u5408\u7ed3\u6784\uff0c\u5b83\u5e2e\u52a9\u8ddf\u8e2a\u5668\u4ece\u591a\u7b49\u7ea7\u4e2d\u5b66\u4e60\u5230\u7684\u7279\u5f81\u800c\u9884\u6d4b\u76f8\u5173\u56fe\u3002 \u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u9010\u6df1\u5ea6\u53ef\u5206\u79bb\u7684\u76f8\u5173\u7ed3\u6784\u6765\u589e\u5f3a\u4e92\u76f8\u5173\uff0c\u4ee5\u4ea7\u751f\u4e8e\u4e0d\u540c\u8bed\u4e49\u76f8\u5173\u7684\u591a\u4e2a\u76f8\u4f3c\u5ea6\u56fe\u3002 \u57fa\u4e8e\u4e0a\u8ff0\u7684\u7406\u8bba\u5206\u6790\u548c\u6280\u672f\u8d21\u732e\uff0c\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u6709\u6548\u4e14\u9ad8\u6548\u7684\u89c6\u89c9\u8ddf\u8e2a\u6a21\u578b\u3002\u8be5\u6a21\u578b\u5728\u8ddf\u8e2a\u51c6\u786e\u7387\u4e0a\u662f\u4e00\u4e2a\u65b0\u7684SOTA\uff0c\u540c\u65f6\u80fd\u8fbe\u523035FPS\u3002\u88ab\u63d0\u51fa\u7684\u8ddf\u8e2a\u5668\uff0c\u4e5f\u88ab\u79f0\u4e3aSiamRPN++\uff0c\u5728\u4e94\u4e2a\u5927\u7684\u8ddf\u8e2a\u57fa\u51c6\u6d4b\u8bd5\u4e2d\u5747\u53d6\u5f97\u4e86\u6700\u597d\u7684\u6210\u7ee9\u3002\u4e0e\u6b64\u540c\u65f6\uff0c\u672c\u6587\u4e5f\u63d0\u51fa\u4e86\u4e00\u4e2a\u57fa\u4e8eMobileNet\u9aa8\u5e72\u7684\u9ad8\u901f\u53d8\u79cd\uff0c\u5b83\u80fd\u5728\u4fdd\u6301\u6709\u7ade\u4e89\u529b\u7684\u6027\u80fd\u540c\u65f6\u8fbe\u523070FPS\u7684\u901f\u5ea6\u3002\u4e3a\u4e86\u4fbf\u4e8e\u89c6\u89c9\u8ddf\u8e2a\u4efb\u52a1\u7684\u8fdb\u4e00\u6b65\u7814\u7a76\uff0c\u672c\u6587\u7684\u6e90\u7801\u548c\u8bad\u7ec3\u6a21\u578b\u5747\u5df2\u5f00\u6e90\u3002 \u7531ResNet\u9a71\u52a8\u7684\u5b6a\u751f\u8ddf\u8e2a # \u539f\u59cb\u7684ResNet\u6709\u4e00\u4e2a\u8f83\u5927\u7684\u6b65\u957f\uff0c\u8fd9\u5bf9\u5bc6\u96c6\u7684\u5b6a\u751f\u7f51\u7edc\u6765\u8bf4\u6709\u4e9b\u4e0d\u592a\u5408\u9002\u3002\u5982\u56fe\u6240\u793a\uff0c\u672c\u6587\u5bf9conv4\u548cconv5\u8fdb\u884c\u4e86\u4fee\u6539\uff0c\u5c06\u4ed6\u4eec\u7684\u6b65\u957f\u753116\u50cf\u7d20\u548c32\u50cf\u7d20\u964d\u4f4e\u5230\u4e868\u50cf\u7d20\uff0c\u4ee5\u5f97\u5230\u5355\u4f4d\u7a7a\u95f4\u6b65\u957f\uff08unit spatial stride\uff09\uff0c\u5e76\u901a\u8fc7\u81a8\u80c0\u5377\u79ef\uff08dilated convolutions\uff09\u6765\u589e\u52a0\u5176\u63a5\u53d7\u573a\uff08receptive field\uff09\u3002\u4e00\u4e2a\u989d\u5916\u76841 \\times \\times 1\u5377\u79ef\u88ab\u6dfb\u52a0\u5230\u6bcf\u4e00\u4e2a\u6a21\u5757\u7684\u8f93\u51fa\u4e4b\u540e\u4ee5\u5c06\u901a\u9053\u964d\u4f4e\u4e3a256\u3002 \u7531\u4e8e\u6bcf\u5c42\u7684\u586b\u5145\u90fd\u88ab\u4fdd\u6301\uff0c\u6a21\u677f\u7684\u7a7a\u95f4\u5c3a\u5bf8\u589e\u52a0\u5230\u4e8615\uff0c\u8fd9\u4f1a\u5bf9\u76f8\u5173\u8ba1\u7b97\u6a21\u5757\u4e0a\u589e\u52a0\u6c89\u91cd\u7684\u8d1f\u62c5\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u622a\u53d6\u5176\u4e2d\u95f4\u76847 \\times \\times 7\u533a\u57df\u6765\u4f5c\u4e3a\u6a21\u677f\u7279\u5f81\u3002\u6bcf\u4e2a\u7279\u5f81\u5355\u5143\uff08feature cell\uff09\u4ecd\u80fd\u6355\u83b7\u6574\u4e2a\u76ee\u6807\u533a\u57df\u3002 Following [24]\uff0c \u6211\u4eec\u4f7f\u7528\u4e00\u4e2a\u7531\u4e92\u76f8\u5173\u5c42\u548c\u5168\u5377\u79ef\u5c42\u7684\u7ec4\u5408\u6765\u7ec4\u5efa\u4e00\u4e2a\u5934\u6a21\u5757\uff08head module\uff09\u4ee5\u8ba1\u7b97\u5206\u7c7b\u5206\uff08\u8868\u793a\u4e3a \\mathcal{S}\uff09\u548c\u4e00\u4e2a\u8fb9\u6846\u56de\u5f52\u5668\uff08\u8868\u793a\u4e3a \\mathcal{S}\uff09\u548c\u4e00\u4e2a\u8fb9\u6846\u56de\u5f52\u5668\uff08\u8868\u793a\u4e3a \\mathcal{B}\uff09\u3002\u5b6a\u751fRPN\u6a21\u5757\u8868\u793a\u4e3a$\\mathcal{P}\u3002 \u66f4\u8fdb\u4e00\u6b65\u7684\uff0c\u6211\u4eec\u53d1\u73b0\u4ed4\u7ec6\u5730\u5fae\u8c03ResNet\u4f1a\u589e\u52a0\u6027\u80fd\u3002\u901a\u8fc7\u5c06ResNet\u62bd\u53d6\u5668\u7684\u5b66\u4e60\u7387\u8bbe\u7f6e\u4e3aRPN\u90e8\u5206\u7684\u5341\u5206\u4e4b\u4e00\uff0c\u7279\u5f81\u8868\u793a\u4f1a\u66f4\u52a0\u9002\u5408\u8ddf\u8e2a\u4efb\u52a1\u3002[\u4e3a\u4ec0\u4e48\uff1f]\u4e0e\u4f20\u7edf\u7684\u5b6a\u751f\u65b9\u6cd5\u4e0d\u540c\uff0c\u6df1\u5ea6\u7f51\u7edc\u7684\u53c2\u6570\u662f\u4ee5\u7aef\u5230\u7aef\u7684\u5f62\u5f0f\u88ab\u4e00\u8d77\u8bad\u7ec3\u7684\u3002\u5c31\u672c\u6587\u4f5c\u8005\u6240\u77e5\uff0c\u672c\u6587\u662f\u7b2c\u4e00\u4e2a\u7aef\u5230\u7aef\u8bad\u7ec3\u4e00\u4e2a\u7528\u4e8e\u89c6\u89c9\u8ddf\u8e2a\u7684\u6df1\u5ea6\u5b6a\u751f\u7f51\u7edc\uff08 \\gt \\gt 20\u5c42\uff09\u7684\u3002 \u9010\u5c42\u7684\u805a\u5408 #","title":"SiamRPN++"},{"location":"sot/siamrpn%2B%2B/#_1","text":"\u5c3d\u7ba1SiamRPN\u5df2\u7ecf\u53d6\u5f97\u4e86\u8f83\u597d\u7684\u6210\u7ee9\uff0c\u5c24\u5176\u662f\u5728\u51c6\u786e\u7387\u548c\u901f\u5ea6\u7684\u5e73\u8861\u4e0a\u3002\u4f46\u662f\uff0c\u5c3d\u7ba1\u662f\u6027\u80fd\u6700\u597d\u7684\u5b6a\u751f\u8ddf\u8e2a\u5668\uff08Siamese Trackers\uff09\u4e5f\u4e0eSOTA\u7684\u4f20\u7edf\u65b9\u6cd5\u6709\u7740\u76f8\u8f83\u800c\u8a00\u5341\u5206\u660e\u663e\u7684\u6027\u80fd\u5dee\u8ddd\u3002\u5b6a\u751f\u8ddf\u8e2a\u5668\u5927\u90fd\u57fa\u4e8e\u8f83\u6d45\u7684AlexNet\uff0c\u4e14\u5728\u6362\u7528\u6df1\u5ea6\u7684ResNet\u7b49\u4e4b\u540e\u6ca1\u6709\u6027\u80fd\u63d0\u5347\uff0c\u751a\u81f3\u8fd8\u6709\u6240\u4e0b\u964d\u3002\u672c\u6587\u5bf9\u5b6a\u751f\u8ddf\u8e2a\u5668\u8fdb\u884c\u5206\u6790\uff0c\u53d1\u73b0\u524d\u8ff0\u7684\u6027\u80fd\u4e0b\u964d\u662f\u7531\u4e8e\u4e25\u683c\u5e73\u79fb\u4e0d\u53d8\u6027\u88ab\u7834\u574f\u6240\u5bfc\u81f4\u7684\u3002\u672c\u6587\u8fdb\u4e00\u6b65\u53d1\u73b0\u53ea\u6709\u96f6\u586b\u5145\uff08zero-padding\uff09\u7684AlexNet\u6ee1\u8db3\u8be5\u7a7a\u95f4\u4e0d\u53d8\u6027\u7684\u9650\u5236\u3002\u4e3a\u4e86\u8d8a\u8fc7\u8fd9\u4e2a\u9650\u5236\uff0c\u5e76\u4f7f\u5b6a\u751f\u8ddf\u8e2a\u5668\u5f97\u4ee5\u4e0e\u6df1\u5ea6\u795e\u7ecf\u7f51\u7edc\u914d\u5408\uff0c\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u7b80\u5355\u9ad8\u6548\u7684\u91c7\u6837\u65b9\u6cd5\u6765\u7a81\u7834\u5b6a\u751f\u8ddf\u8e2a\u5668\u7684\u7a7a\u95f4\u4e0d\u53d8\u6027\u9650\u5236\u3002\u672c\u6587\u6210\u529f\u7684\u8bad\u7ec3\u4e86\u4e00\u4e2a\u4f7f\u7528ResNet\u4f5c\u4e3a\u9aa8\u5e72\u7f51\u7edc\u7684\u57fa\u4e8eSiamRPN\u7684\u8ddf\u8e2a\u5668\u3002\u5f97\u76ca\u4e8eResNet\u7684\u67b6\u6784\uff0c\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u4e92\u76f8\u5173\u8fd0\u7b97\uff08cross-correlations operation\uff09\u7684\u9010\u5c42\u7279\u5f81\u805a\u5408\u7ed3\u6784\uff08layer-wise feature aggravation structure\uff09\u3002\u901a\u8fc7\u5bf9\u5b6a\u751f\u7f51\u7edc\u7684\u4e92\u76f8\u5173\u6027\u8fdb\u884c\u5206\u6790\uff0c\u672c\u6587\u53d1\u73b0\u4ed6\u4e24\u4e2a\u7f51\u7edc\u5206\u652f\u7684\u53c2\u6570\u5b58\u5728\u5f88\u5927\u7684\u4e0d\u5e73\u8861\u3002\u56e0\u6b64\uff0c\u672c\u6587\u8fdb\u4e00\u6b65\u63d0\u51fa\u4e86\u4e00\u4e2a\u9010\u6df1\u5ea6\u53ef\u5206\u79bb\u7684\u76f8\u5173\u7ed3\u6784\uff08depth-wise separable correlation structure\uff09\u3002\u5b83\u4e0d\u4f46\u6781\u5927\u7a0b\u5ea6\u4e0a\u7684\u964d\u4f4e\u4e86\u76ee\u6807\u6a21\u677f\u5206\u652f\u7684\u53c2\u6570\u6570\u91cf\uff0c\u5e76\u4e14\u7a33\u5b9a\u4e86\u6574\u4e2a\u6a21\u578b\u7684\u8bad\u7ec3\u8fc7\u7a0b\u3002\u6b64\u5916\uff0c\u4e00\u4e2a\u6709\u8da3\u7684\u53d1\u73b0\u88ab\u89c2\u5bdf\u5230\u2013\u5c5e\u4e8e\u76f8\u540c\u7c7b\u522b\u7684\u5bf9\u8c61\u5728\u540c\u4e00\u901a\u9053\uff08channel\uff09\u4e0a\u6709\u8f83\u9ad8\u7684\u54cd\u5e94\uff08response\uff09\uff0c\u800c\u5728\u5176\u4ed6\u901a\u9053\u4e0a\u7684\u54cd\u5e94\u5219\u88ab\u6291\u5236\u3002\u6b63\u4ea4\u5c5e\u6027\u4e5f\u53ef\u80fd\u63d0\u5347\u8ddf\u8e2a\u7684\u6027\u80fd\u3002\u672c\u6587\u7684\u8d21\u732e\u53ef\u4ee5\u88ab\u5212\u5206\u4e3a\u56db\u7c7b\uff1a \u672c\u6587\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5bf9\u5b6a\u751f\u8ddf\u8e2a\u5668\u7684\u6df1\u5ea6\u5206\u6790\uff0c\u5e76\u8bc1\u660e\u4f7f\u7528\u6df1\u5ea6\u7f51\u7edc\u65f6\u7684\u51c6\u786e\u7387\u964d\u4f4e\u6765\u81ea\u4e8e\u4e25\u683c\u5e73\u79fb\u4e0d\u53d8\u6027\u7684\u7834\u574f\u3002 \u672c\u6587\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b80\u5355\u9ad8\u6548\u7684\u91c7\u6837\u673a\u5236\u6765\u7a81\u7834\u7a7a\u95f4\u4e0d\u53d8\u6027\u9650\u5236\uff0c\u5e76\u501f\u6b64\u6210\u529f\u7684\u8bad\u7ec3\u4e86\u4e00\u4e2a\u901a\u8fc7ResNet\u67b6\u6784\u9a71\u52a8\u7684\u5b6a\u751f\u8ddf\u8e2a\u5668\u3002 \u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u5bf9\u4e92\u76f8\u5173\u8fd0\u7b97\u7684\u9010\u5c42\u7279\u5f81\u805a\u5408\u7ed3\u6784\uff0c\u5b83\u5e2e\u52a9\u8ddf\u8e2a\u5668\u4ece\u591a\u7b49\u7ea7\u4e2d\u5b66\u4e60\u5230\u7684\u7279\u5f81\u800c\u9884\u6d4b\u76f8\u5173\u56fe\u3002 \u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u9010\u6df1\u5ea6\u53ef\u5206\u79bb\u7684\u76f8\u5173\u7ed3\u6784\u6765\u589e\u5f3a\u4e92\u76f8\u5173\uff0c\u4ee5\u4ea7\u751f\u4e8e\u4e0d\u540c\u8bed\u4e49\u76f8\u5173\u7684\u591a\u4e2a\u76f8\u4f3c\u5ea6\u56fe\u3002 \u57fa\u4e8e\u4e0a\u8ff0\u7684\u7406\u8bba\u5206\u6790\u548c\u6280\u672f\u8d21\u732e\uff0c\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u6709\u6548\u4e14\u9ad8\u6548\u7684\u89c6\u89c9\u8ddf\u8e2a\u6a21\u578b\u3002\u8be5\u6a21\u578b\u5728\u8ddf\u8e2a\u51c6\u786e\u7387\u4e0a\u662f\u4e00\u4e2a\u65b0\u7684SOTA\uff0c\u540c\u65f6\u80fd\u8fbe\u523035FPS\u3002\u88ab\u63d0\u51fa\u7684\u8ddf\u8e2a\u5668\uff0c\u4e5f\u88ab\u79f0\u4e3aSiamRPN++\uff0c\u5728\u4e94\u4e2a\u5927\u7684\u8ddf\u8e2a\u57fa\u51c6\u6d4b\u8bd5\u4e2d\u5747\u53d6\u5f97\u4e86\u6700\u597d\u7684\u6210\u7ee9\u3002\u4e0e\u6b64\u540c\u65f6\uff0c\u672c\u6587\u4e5f\u63d0\u51fa\u4e86\u4e00\u4e2a\u57fa\u4e8eMobileNet\u9aa8\u5e72\u7684\u9ad8\u901f\u53d8\u79cd\uff0c\u5b83\u80fd\u5728\u4fdd\u6301\u6709\u7ade\u4e89\u529b\u7684\u6027\u80fd\u540c\u65f6\u8fbe\u523070FPS\u7684\u901f\u5ea6\u3002\u4e3a\u4e86\u4fbf\u4e8e\u89c6\u89c9\u8ddf\u8e2a\u4efb\u52a1\u7684\u8fdb\u4e00\u6b65\u7814\u7a76\uff0c\u672c\u6587\u7684\u6e90\u7801\u548c\u8bad\u7ec3\u6a21\u578b\u5747\u5df2\u5f00\u6e90\u3002","title":"\u7b80\u4ecb"},{"location":"sot/siamrpn%2B%2B/#resnet","text":"\u539f\u59cb\u7684ResNet\u6709\u4e00\u4e2a\u8f83\u5927\u7684\u6b65\u957f\uff0c\u8fd9\u5bf9\u5bc6\u96c6\u7684\u5b6a\u751f\u7f51\u7edc\u6765\u8bf4\u6709\u4e9b\u4e0d\u592a\u5408\u9002\u3002\u5982\u56fe\u6240\u793a\uff0c\u672c\u6587\u5bf9conv4\u548cconv5\u8fdb\u884c\u4e86\u4fee\u6539\uff0c\u5c06\u4ed6\u4eec\u7684\u6b65\u957f\u753116\u50cf\u7d20\u548c32\u50cf\u7d20\u964d\u4f4e\u5230\u4e868\u50cf\u7d20\uff0c\u4ee5\u5f97\u5230\u5355\u4f4d\u7a7a\u95f4\u6b65\u957f\uff08unit spatial stride\uff09\uff0c\u5e76\u901a\u8fc7\u81a8\u80c0\u5377\u79ef\uff08dilated convolutions\uff09\u6765\u589e\u52a0\u5176\u63a5\u53d7\u573a\uff08receptive field\uff09\u3002\u4e00\u4e2a\u989d\u5916\u76841 \\times \\times 1\u5377\u79ef\u88ab\u6dfb\u52a0\u5230\u6bcf\u4e00\u4e2a\u6a21\u5757\u7684\u8f93\u51fa\u4e4b\u540e\u4ee5\u5c06\u901a\u9053\u964d\u4f4e\u4e3a256\u3002 \u7531\u4e8e\u6bcf\u5c42\u7684\u586b\u5145\u90fd\u88ab\u4fdd\u6301\uff0c\u6a21\u677f\u7684\u7a7a\u95f4\u5c3a\u5bf8\u589e\u52a0\u5230\u4e8615\uff0c\u8fd9\u4f1a\u5bf9\u76f8\u5173\u8ba1\u7b97\u6a21\u5757\u4e0a\u589e\u52a0\u6c89\u91cd\u7684\u8d1f\u62c5\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u622a\u53d6\u5176\u4e2d\u95f4\u76847 \\times \\times 7\u533a\u57df\u6765\u4f5c\u4e3a\u6a21\u677f\u7279\u5f81\u3002\u6bcf\u4e2a\u7279\u5f81\u5355\u5143\uff08feature cell\uff09\u4ecd\u80fd\u6355\u83b7\u6574\u4e2a\u76ee\u6807\u533a\u57df\u3002 Following [24]\uff0c \u6211\u4eec\u4f7f\u7528\u4e00\u4e2a\u7531\u4e92\u76f8\u5173\u5c42\u548c\u5168\u5377\u79ef\u5c42\u7684\u7ec4\u5408\u6765\u7ec4\u5efa\u4e00\u4e2a\u5934\u6a21\u5757\uff08head module\uff09\u4ee5\u8ba1\u7b97\u5206\u7c7b\u5206\uff08\u8868\u793a\u4e3a \\mathcal{S}\uff09\u548c\u4e00\u4e2a\u8fb9\u6846\u56de\u5f52\u5668\uff08\u8868\u793a\u4e3a \\mathcal{S}\uff09\u548c\u4e00\u4e2a\u8fb9\u6846\u56de\u5f52\u5668\uff08\u8868\u793a\u4e3a \\mathcal{B}\uff09\u3002\u5b6a\u751fRPN\u6a21\u5757\u8868\u793a\u4e3a$\\mathcal{P}\u3002 \u66f4\u8fdb\u4e00\u6b65\u7684\uff0c\u6211\u4eec\u53d1\u73b0\u4ed4\u7ec6\u5730\u5fae\u8c03ResNet\u4f1a\u589e\u52a0\u6027\u80fd\u3002\u901a\u8fc7\u5c06ResNet\u62bd\u53d6\u5668\u7684\u5b66\u4e60\u7387\u8bbe\u7f6e\u4e3aRPN\u90e8\u5206\u7684\u5341\u5206\u4e4b\u4e00\uff0c\u7279\u5f81\u8868\u793a\u4f1a\u66f4\u52a0\u9002\u5408\u8ddf\u8e2a\u4efb\u52a1\u3002[\u4e3a\u4ec0\u4e48\uff1f]\u4e0e\u4f20\u7edf\u7684\u5b6a\u751f\u65b9\u6cd5\u4e0d\u540c\uff0c\u6df1\u5ea6\u7f51\u7edc\u7684\u53c2\u6570\u662f\u4ee5\u7aef\u5230\u7aef\u7684\u5f62\u5f0f\u88ab\u4e00\u8d77\u8bad\u7ec3\u7684\u3002\u5c31\u672c\u6587\u4f5c\u8005\u6240\u77e5\uff0c\u672c\u6587\u662f\u7b2c\u4e00\u4e2a\u7aef\u5230\u7aef\u8bad\u7ec3\u4e00\u4e2a\u7528\u4e8e\u89c6\u89c9\u8ddf\u8e2a\u7684\u6df1\u5ea6\u5b6a\u751f\u7f51\u7edc\uff08 \\gt \\gt 20\u5c42\uff09\u7684\u3002","title":"\u7531ResNet\u9a71\u52a8\u7684\u5b6a\u751f\u8ddf\u8e2a"},{"location":"sot/siamrpn%2B%2B/#_2","text":"","title":"\u9010\u5c42\u7684\u805a\u5408"},{"location":"sot/siamrpn/","text":"\u4e13\u6709\u540d\u8bcd\u7ffb\u8bd1\u548c\u7f29\u5199 \u5728\u672c\u6587\u5f53\u4e2d\uff0c\u4e13\u6709\u540d\u8bcd\u88ab\u5982\u4e0b\u7ffb\u8bd1\u548c\u7f29\u5199\uff1a anchor \u951a\u6846 Convolution Neural Network CNN \u5377\u79ef\u795e\u7ecf\u7f51\u7edc Meta-Learning \u5143\u5b66\u4e60 Padding \u586b\u5145 Regional Proposal Network RPN \u533a\u57df\u5019\u9009\u7f51\u7edc Siamese \u5b6a\u751f Visual Object Tracking VOT SiamRPN\u662f\u5546\u6c64\u79d1\u6280\u7684\u674e\u535a\u7b49\u63d0\u51fa\u7684\u5355\u76ee\u6807\u8ddf\u8e2a\u7b97\u6cd5\u3002 \u7b80\u4ecb \u672c\u6587\u901a\u8fc7AlexNet\u63d0\u53d6\u7279\u5f81\u56fe\uff0c\u901a\u8fc7RPN\u6784\u5efa\u76f8\u5173\u7279\u5f81\u56fe\u5e76\u4ece\u76f8\u5173\u7279\u5f81\u56fe\u4e0a\u63d0\u53d6\u548c\u4fee\u6b63\u5019\u9009\u533a\u57df\uff0c\u901a\u8fc7\u672c\u5730\u5355\u6837\u672c\u68c0\u6d4b\u6846\u67b6\u5bf9\u5019\u9009\u533a\u57df\u8bc4\u5206\uff0c\u6700\u540e\u9009\u53d6\u5206\u6570\u6700\u9ad8\u7684\u5019\u9009\u533a\u57df\u8f93\u51fa\u3002 \u672c\u6587\u7684\u57fa\u7840\u662f\uff1aSiamFC\u3001Faster-RCNN\u3002 \u8d21\u732e \u672c\u6587\u4f5c\u8005\u63d0\u51fa\u4e86\u4e00\u4e2a\u5b6a\u751f\u533a\u57df\u5019\u9009\u7f51\u7edc\uff08Siamese-RPN\uff09\u3002\u4ed6\u662f\u4e00\u4e2a\u4f7f\u7528\u5927\u91cf\u56fe\u7247\u7684\u7aef\u5230\u7aef\u79bb\u7ebf\u8bad\u7ec3\u7684\u7f51\u7edc\uff0c\u88ab\u7528\u4e8e\u8ddf\u8e2a\u4efb\u52a1\u3002 \u5728\u5728\u7ebf\u8ddf\u8e2a\u65f6\uff0c\u88ab\u63d0\u51fa\u7684\u6846\u67b6\u88ab\u8f6c\u5316\u4e3a\u4e00\u4e2a\u672c\u5730\u5355\u6837\u672c\u68c0\u6d4b\u4efb\u52a1\uff0c\u5b83\u53ef\u4ee5\u5b8c\u5584\u5019\u9009\u4ee5\u907f\u514d\u6602\u8d35\u7684\u591a\u5c3a\u5ea6\u6d4b\u8bd5\u3002 \u88ab\u63d0\u51fa\u7684\u6846\u67b6\u5728\u901f\u5ea6\u8fbe\u5230160FPS\u65f6\u5728VOT2015\u3001VOT2016\u3001VOT2017\u4efb\u52a1\u4e2d\u53d6\u5f97\u4e86\u9886\u5148\u6210\u7ee9\uff0c\u8fd9\u8bc1\u660e\u5b83\u5728\u901f\u5ea6\u548c\u51c6\u786e\u6027\u65b9\u9762\u7684\u4f18\u70b9\u3002 Siamese-RPN\u6846\u67b6 # \u5982\u56fe\u6240\u793a\uff0cSiamese-RPN\u6846\u67b6\u7531\u4e00\u4e2a\u8d1f\u8d23\u7279\u5f81\u63d0\u53d6\u7684\u5b6a\u751f\u5b50\u7f51\u7edc\u548c\u4e00\u4e2a\u8d1f\u8d23\u5019\u9009\u533a\u57df\u5224\u522b\u7684\u533a\u57df\u5019\u9009\u5b50\u7f51\u7edc\u6784\u6210\u3002\u7279\u522b\u7684\uff0c\u5728RPN\u81ea\u7f51\u7edc\u5f53\u4e2d\u6709\u4e24\u4e2a\u5206\u652f\uff0c\u4e00\u4e2a\u8d1f\u8d23\u524d-\u80cc\u666f\u5206\u7c7b\uff0c\u53e6\u4e00\u4e2a\u5219\u8d1f\u8d23\u5019\u9009\u533a\u57df\u4fee\u6b63\u3002\u6574\u4e2a\u7cfb\u7edf\u90fd\u88ab\u7aef\u5230\u7aef\u7684\u8bad\u7ec3\u3002 \u5b6a\u751f\u7279\u5f81\u63d0\u53d6\u5b50\u7f51\u7edc # \u672c\u6587\u7684\u5b6a\u751f\u7279\u5f81\u63d0\u53d6\u5b50\u7f51\u7edc\u4e0eSiamFC\u7684\u7279\u5f81\u63d0\u53d6\u90e8\u5206\u76f8\u540c\uff0c\u90fd\u662f\u4f7f\u7528\u5b6a\u751f\u67b6\u6784\u7684AlexNet\u4f5c\u4e3a\u540e\u7aef\u63d0\u53d6\u7279\u5f81\u56fe\u3002\u4e0eSiamFC\u7684\u4e3b\u8981\u533a\u522b\u5728\u4e8e\u5176\u8f93\u51fa\u7684\u7279\u5f81\u56fe\u7ef4\u5ea6\u4e3a 6 \\times 6 \\times 256 6 \\times 6 \\times 256 \u548c 22 \\times 22 \\times 256 22 \\times 22 \\times 256 \uff0c\u662fSiamFC\u7684\u4e24\u500d\u3002 \u5728\u5b6a\u751f\u7f51\u7edc\u4e2d\uff0c\u672c\u6587\u4f5c\u8005\u91c7\u7528\u4e86\u4e00\u4e2a\u6ca1\u6709\u586b\u5145\u7684\u5168\u5377\u79ef\u7f51\u7edc\u3002\u4f7f\u7528 L_\\tau L_\\tau \u8868\u793a\u53d8\u6362\u64cd\u4f5c\u5668\uff0c L_\\tau\\mathcal{x[u]=x[u-_\\tau]} L_\\tau\\mathcal{x[u]=x[u-_\\tau]} \uff0c\u7136\u540e\u6240\u6709\u7684\u586b\u5145\u90fd\u88ab\u79fb\u9664\u6765\u6ee1\u8db3\u6b65\u957f\u4e3a k k \u7684\u5168\u5377\u79ef\u7684\u5b9a\u4e49\uff1a h(L_{\\mathcal{k\\tau}}\\mathcal{x})=L_{\\tau}h(\\mathcal{x}) h(L_{\\mathcal{k\\tau}}\\mathcal{x})=L_{\\tau}h(\\mathcal{x}) \u8fd9\u91cc\uff0c\u672c\u6587\u4f5c\u8005\u4f7f\u7528\u4fee\u6539\u540e\u7684AlexNet\uff0c\u5176\u4e2dconv2\u5230conv4\u7684\u7ec4\u88ab\u79fb\u9664\u3002\u5b6a\u751f\u7279\u5f81\u63d0\u53d6\u5b50\u7f51\u7edc\u7531\u4e24\u4e2a\u5206\u652f\u7ec4\u6210\u3002\u7b2c\u4e00\u4e2a\u88ab\u79f0\u4e3a \u6a21\u677f\u5206\u652f\uff08template branch\uff09 \uff0c\u4ed6\u5c06\u9996\u5e27\u4f5c\u4e3a\u8f93\u5165\uff08\u8868\u793a\u4e3a \\mathcal{z} \\mathcal{z} \uff09\u3002\u53e6\u4e00\u4e2a\u5219\u88ab\u79f0\u4e3a \u68c0\u6d4b\u5206\u652f\uff08detection branch\uff09 \uff0c\u5b83\u5c06\u5f53\u524d\u5e27\u4f5c\u4e3a\u8f93\u5165\uff08\u8868\u793a\u4e3a \\mathcal{x} \\mathcal{x} \uff09\u3002\u4e24\u4e2a\u5206\u652f\u5171\u4eab\u6743\u91cd\u5377\u79ef\u795e\u7ecf\u7f51\u7edc\u4e2d\u7684\u53c2\u6570\uff0c\u56e0\u6b64\u4ed6\u4eec\u901a\u8fc7\u76f8\u540c\u7684\u9002\u5b9c\u4e8e\u968f\u540e\u5904\u7406\u7684\u53d8\u6362\u88ab\u9690\u5f0f\u7f16\u7801\u3002\u5b6a\u751f\u5b50\u7f51\u7edc\u7684\u8f93\u51fa\u5206\u522b\u88ab\u8868\u793a\u4e3a \\phi\\mathcal{(z)} \\phi\\mathcal{(z)} \u548c \\phi\\mathcal{(x)} \\phi\\mathcal{(x)} \u3002 \u533a\u57df\u5019\u9009\u5b50\u7f51\u7edc # \u533a\u57df\u5019\u9009\u5b50\u7f51\u7edc\u5305\u542b\u4e00\u4e2a\u4e92\u76f8\u5173\u5b50\u6bb5\u548c\u4e00\u4e2a\u76d1\u7763\u5b50\u6bb5\u3002\u76d1\u7763\u5b50\u6bb5\u6709\u4e24\u4e2a\u5206\u652f\uff0c\u4e00\u4e2a\u88ab\u7528\u4e8e\u524d-\u80cc\u666f\u5206\u79bb\uff0c\u53e6\u4e00\u4e2a\u88ab\u7528\u4e8e\u5019\u9009\u533a\u57df\u56de\u5f52\u3002\u5982\u679c\u603b\u5171\u7531 \\mathcal{k} \\mathcal{k} \u4e2a\u951a\u6846\uff0c\u7f51\u7edc\u9700\u8981\u8f93\u51fa \\mathcal{2k} \\mathcal{2k} \u4e2a\u901a\u9053\u6765\u5206\u7c7b\uff0c \\mathcal{4k} \\mathcal{4k} \u4e2a\u901a\u9053\u6765\u56de\u5f52\u3002\u6240\u4ee5\u4e92\u76f8\u5173\u5b50\u6bb5\u9996\u5148\u5c06 \\phi\\mathcal{(z)} \\phi\\mathcal{(z)} \u7684\u901a\u9053\u901a\u8fc7\u4e24\u4e2a\u5377\u79ef\u5c42\u63d0\u5347\u5230\u4e24\u4e2a\u5206\u652f [\\phi(\\mathcal{z})]_{\\mathcal{cls}} [\\phi(\\mathcal{z})]_{\\mathcal{cls}} \u548c [\\phi(\\mathcal{z})]_{\\mathcal{reg}} [\\phi(\\mathcal{z})]_{\\mathcal{reg}} \uff0c\u4ed6\u4eec\u5206\u522b\u6709 \\mathcal{2k} \\mathcal{2k} \u548c \\mathcal{4k} \\mathcal{4k} \u4e2a\u901a\u9053\u3002 \\phi\\mathcal{(x)} \\phi\\mathcal{(x)} \u4e5f\u901a\u8fc7\u4e24\u4e2a\u5377\u79ef\u5c42\u88ab\u5206\u4e3a [\\phi(\\mathcal{x})]_{\\mathcal{cls}} [\\phi(\\mathcal{x})]_{\\mathcal{cls}} \u548c [\\phi(\\mathcal{x})]_{\\mathcal{reg}} [\\phi(\\mathcal{x})]_{\\mathcal{reg}} \u4e24\u4e2a\u5206\u652f\uff0c\u4f46\u4fdd\u6301\u901a\u9053\u6570\u4e0d\u53d8\u3002 [\\phi\\mathcal{(z)}] [\\phi\\mathcal{(z)}] \u4ee5\u4e00\u4e2a\u201c\u7ec4\u201d\u7684\u65b9\u5f0f\u88ab\u7528\u4f5c [\\phi\\mathcal{(x)]} [\\phi\\mathcal{(x)]} \u7684\u76f8\u5173\u6838\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u4e00\u4e2a [\\phi(\\mathcal{z})] [\\phi(\\mathcal{z})] \u7684\u7ec4\u7684\u901a\u9053\u6570\u548c [\\phi(\\mathcal{x})] [\\phi(\\mathcal{x})] \u7684\u6574\u4f53\u901a\u9053\u6570\u76f8\u540c\u3002\u76f8\u5173\u6027\u662f\u5728\u5206\u7c7b\u5206\u652f\u548c\u56de\u5f52\u5206\u652f\u4e0a\u5171\u540c\u8ba1\u7b97\u7684\uff1a A{^{cls}_{\\mathcal{w \\times h \\times 2k}}} = [\\phi(\\mathcal{x})]_{\\mathcal{cls}} \\star [\\phi(\\mathcal{z})]_{\\mathcal{cls}} A{^{cls}_{\\mathcal{w \\times h \\times 2k}}} = [\\phi(\\mathcal{x})]_{\\mathcal{cls}} \\star [\\phi(\\mathcal{z})]_{\\mathcal{cls}} A{^{reg}_{\\mathcal{w \\times h \\times 4k}}} = [\\phi(\\mathcal{x})]_{\\mathcal{reg}} \\star [\\phi(\\mathcal{z})]_{\\mathcal{reg}} A{^{reg}_{\\mathcal{w \\times h \\times 4k}}} = [\\phi(\\mathcal{x})]_{\\mathcal{reg}} \\star [\\phi(\\mathcal{z})]_{\\mathcal{reg}}","title":"SiamRPN"},{"location":"sot/siamrpn/#siamese-rpn","text":"\u5982\u56fe\u6240\u793a\uff0cSiamese-RPN\u6846\u67b6\u7531\u4e00\u4e2a\u8d1f\u8d23\u7279\u5f81\u63d0\u53d6\u7684\u5b6a\u751f\u5b50\u7f51\u7edc\u548c\u4e00\u4e2a\u8d1f\u8d23\u5019\u9009\u533a\u57df\u5224\u522b\u7684\u533a\u57df\u5019\u9009\u5b50\u7f51\u7edc\u6784\u6210\u3002\u7279\u522b\u7684\uff0c\u5728RPN\u81ea\u7f51\u7edc\u5f53\u4e2d\u6709\u4e24\u4e2a\u5206\u652f\uff0c\u4e00\u4e2a\u8d1f\u8d23\u524d-\u80cc\u666f\u5206\u7c7b\uff0c\u53e6\u4e00\u4e2a\u5219\u8d1f\u8d23\u5019\u9009\u533a\u57df\u4fee\u6b63\u3002\u6574\u4e2a\u7cfb\u7edf\u90fd\u88ab\u7aef\u5230\u7aef\u7684\u8bad\u7ec3\u3002","title":"Siamese-RPN\u6846\u67b6"},{"location":"sot/siamrpn/#_1","text":"\u672c\u6587\u7684\u5b6a\u751f\u7279\u5f81\u63d0\u53d6\u5b50\u7f51\u7edc\u4e0eSiamFC\u7684\u7279\u5f81\u63d0\u53d6\u90e8\u5206\u76f8\u540c\uff0c\u90fd\u662f\u4f7f\u7528\u5b6a\u751f\u67b6\u6784\u7684AlexNet\u4f5c\u4e3a\u540e\u7aef\u63d0\u53d6\u7279\u5f81\u56fe\u3002\u4e0eSiamFC\u7684\u4e3b\u8981\u533a\u522b\u5728\u4e8e\u5176\u8f93\u51fa\u7684\u7279\u5f81\u56fe\u7ef4\u5ea6\u4e3a 6 \\times 6 \\times 256 6 \\times 6 \\times 256 \u548c 22 \\times 22 \\times 256 22 \\times 22 \\times 256 \uff0c\u662fSiamFC\u7684\u4e24\u500d\u3002 \u5728\u5b6a\u751f\u7f51\u7edc\u4e2d\uff0c\u672c\u6587\u4f5c\u8005\u91c7\u7528\u4e86\u4e00\u4e2a\u6ca1\u6709\u586b\u5145\u7684\u5168\u5377\u79ef\u7f51\u7edc\u3002\u4f7f\u7528 L_\\tau L_\\tau \u8868\u793a\u53d8\u6362\u64cd\u4f5c\u5668\uff0c L_\\tau\\mathcal{x[u]=x[u-_\\tau]} L_\\tau\\mathcal{x[u]=x[u-_\\tau]} \uff0c\u7136\u540e\u6240\u6709\u7684\u586b\u5145\u90fd\u88ab\u79fb\u9664\u6765\u6ee1\u8db3\u6b65\u957f\u4e3a k k \u7684\u5168\u5377\u79ef\u7684\u5b9a\u4e49\uff1a h(L_{\\mathcal{k\\tau}}\\mathcal{x})=L_{\\tau}h(\\mathcal{x}) h(L_{\\mathcal{k\\tau}}\\mathcal{x})=L_{\\tau}h(\\mathcal{x}) \u8fd9\u91cc\uff0c\u672c\u6587\u4f5c\u8005\u4f7f\u7528\u4fee\u6539\u540e\u7684AlexNet\uff0c\u5176\u4e2dconv2\u5230conv4\u7684\u7ec4\u88ab\u79fb\u9664\u3002\u5b6a\u751f\u7279\u5f81\u63d0\u53d6\u5b50\u7f51\u7edc\u7531\u4e24\u4e2a\u5206\u652f\u7ec4\u6210\u3002\u7b2c\u4e00\u4e2a\u88ab\u79f0\u4e3a \u6a21\u677f\u5206\u652f\uff08template branch\uff09 \uff0c\u4ed6\u5c06\u9996\u5e27\u4f5c\u4e3a\u8f93\u5165\uff08\u8868\u793a\u4e3a \\mathcal{z} \\mathcal{z} \uff09\u3002\u53e6\u4e00\u4e2a\u5219\u88ab\u79f0\u4e3a \u68c0\u6d4b\u5206\u652f\uff08detection branch\uff09 \uff0c\u5b83\u5c06\u5f53\u524d\u5e27\u4f5c\u4e3a\u8f93\u5165\uff08\u8868\u793a\u4e3a \\mathcal{x} \\mathcal{x} \uff09\u3002\u4e24\u4e2a\u5206\u652f\u5171\u4eab\u6743\u91cd\u5377\u79ef\u795e\u7ecf\u7f51\u7edc\u4e2d\u7684\u53c2\u6570\uff0c\u56e0\u6b64\u4ed6\u4eec\u901a\u8fc7\u76f8\u540c\u7684\u9002\u5b9c\u4e8e\u968f\u540e\u5904\u7406\u7684\u53d8\u6362\u88ab\u9690\u5f0f\u7f16\u7801\u3002\u5b6a\u751f\u5b50\u7f51\u7edc\u7684\u8f93\u51fa\u5206\u522b\u88ab\u8868\u793a\u4e3a \\phi\\mathcal{(z)} \\phi\\mathcal{(z)} \u548c \\phi\\mathcal{(x)} \\phi\\mathcal{(x)} \u3002","title":"\u5b6a\u751f\u7279\u5f81\u63d0\u53d6\u5b50\u7f51\u7edc"},{"location":"sot/siamrpn/#_2","text":"\u533a\u57df\u5019\u9009\u5b50\u7f51\u7edc\u5305\u542b\u4e00\u4e2a\u4e92\u76f8\u5173\u5b50\u6bb5\u548c\u4e00\u4e2a\u76d1\u7763\u5b50\u6bb5\u3002\u76d1\u7763\u5b50\u6bb5\u6709\u4e24\u4e2a\u5206\u652f\uff0c\u4e00\u4e2a\u88ab\u7528\u4e8e\u524d-\u80cc\u666f\u5206\u79bb\uff0c\u53e6\u4e00\u4e2a\u88ab\u7528\u4e8e\u5019\u9009\u533a\u57df\u56de\u5f52\u3002\u5982\u679c\u603b\u5171\u7531 \\mathcal{k} \\mathcal{k} \u4e2a\u951a\u6846\uff0c\u7f51\u7edc\u9700\u8981\u8f93\u51fa \\mathcal{2k} \\mathcal{2k} \u4e2a\u901a\u9053\u6765\u5206\u7c7b\uff0c \\mathcal{4k} \\mathcal{4k} \u4e2a\u901a\u9053\u6765\u56de\u5f52\u3002\u6240\u4ee5\u4e92\u76f8\u5173\u5b50\u6bb5\u9996\u5148\u5c06 \\phi\\mathcal{(z)} \\phi\\mathcal{(z)} \u7684\u901a\u9053\u901a\u8fc7\u4e24\u4e2a\u5377\u79ef\u5c42\u63d0\u5347\u5230\u4e24\u4e2a\u5206\u652f [\\phi(\\mathcal{z})]_{\\mathcal{cls}} [\\phi(\\mathcal{z})]_{\\mathcal{cls}} \u548c [\\phi(\\mathcal{z})]_{\\mathcal{reg}} [\\phi(\\mathcal{z})]_{\\mathcal{reg}} \uff0c\u4ed6\u4eec\u5206\u522b\u6709 \\mathcal{2k} \\mathcal{2k} \u548c \\mathcal{4k} \\mathcal{4k} \u4e2a\u901a\u9053\u3002 \\phi\\mathcal{(x)} \\phi\\mathcal{(x)} \u4e5f\u901a\u8fc7\u4e24\u4e2a\u5377\u79ef\u5c42\u88ab\u5206\u4e3a [\\phi(\\mathcal{x})]_{\\mathcal{cls}} [\\phi(\\mathcal{x})]_{\\mathcal{cls}} \u548c [\\phi(\\mathcal{x})]_{\\mathcal{reg}} [\\phi(\\mathcal{x})]_{\\mathcal{reg}} \u4e24\u4e2a\u5206\u652f\uff0c\u4f46\u4fdd\u6301\u901a\u9053\u6570\u4e0d\u53d8\u3002 [\\phi\\mathcal{(z)}] [\\phi\\mathcal{(z)}] \u4ee5\u4e00\u4e2a\u201c\u7ec4\u201d\u7684\u65b9\u5f0f\u88ab\u7528\u4f5c [\\phi\\mathcal{(x)]} [\\phi\\mathcal{(x)]} \u7684\u76f8\u5173\u6838\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u4e00\u4e2a [\\phi(\\mathcal{z})] [\\phi(\\mathcal{z})] \u7684\u7ec4\u7684\u901a\u9053\u6570\u548c [\\phi(\\mathcal{x})] [\\phi(\\mathcal{x})] \u7684\u6574\u4f53\u901a\u9053\u6570\u76f8\u540c\u3002\u76f8\u5173\u6027\u662f\u5728\u5206\u7c7b\u5206\u652f\u548c\u56de\u5f52\u5206\u652f\u4e0a\u5171\u540c\u8ba1\u7b97\u7684\uff1a A{^{cls}_{\\mathcal{w \\times h \\times 2k}}} = [\\phi(\\mathcal{x})]_{\\mathcal{cls}} \\star [\\phi(\\mathcal{z})]_{\\mathcal{cls}} A{^{cls}_{\\mathcal{w \\times h \\times 2k}}} = [\\phi(\\mathcal{x})]_{\\mathcal{cls}} \\star [\\phi(\\mathcal{z})]_{\\mathcal{cls}} A{^{reg}_{\\mathcal{w \\times h \\times 4k}}} = [\\phi(\\mathcal{x})]_{\\mathcal{reg}} \\star [\\phi(\\mathcal{z})]_{\\mathcal{reg}} A{^{reg}_{\\mathcal{w \\times h \\times 4k}}} = [\\phi(\\mathcal{x})]_{\\mathcal{reg}} \\star [\\phi(\\mathcal{z})]_{\\mathcal{reg}}","title":"\u533a\u57df\u5019\u9009\u5b50\u7f51\u7edc"},{"location":"stat/bayes/","text":"\u8d1d\u53f6\u65af\u5b66\u6d3e\u8bde\u751f\u5df2\u6709\u4e24\u767e\u4e94\u5341\u516d\u5e74\u7684\u5386\u53f2\uff0c\u4f46\u5728\u5f88\u957f\u4e00\u6bb5\u65f6\u95f4\u5f53\u4e2d\u90fd\u4e0d\u662f\u7edf\u8ba1\u5b66\u7684\u4e3b\u6d41\u3002\u5728\u672c\u6587\u4e2d\u6211\u4eec\u4f1a\u5bf9\u8d1d\u53f6\u65af\u63a8\u7406\u4ee5\u53ca\u8d1d\u53f6\u65af\u5b9a\u7406\u505a\u51fa\u7b80\u8981\u4ecb\u7ecd\u3002 \u4e0e\u524d\u4e00\u7bc7\u6587\u7ae0\u4e00\u6837\uff0c\u8ba9\u6211\u4eec\u5148\u4ece\u4e00\u4e2a\u4f8b\u5b50\u5f00\u59cb\u3002 \u827e\u6ecb\u75c5 \u5f97\u77e5\u827e\u6ecb\u75c5\u7684\u53d1\u75c5\u7387\uff08incidence rate\uff09\u7ea6\u4e3a0.02583%\u540e\uff0c\u201c\u6050\u827e\u75c7\u201d\u60a3\u8005\u5c0f\u738b\u53bb\u505a\u4e86\u827e\u6ecb\u75c5\u521d\u7b5b\uff0c\u5e76\u6536\u5230\u4e86\u521d\u7b5b\u9633\u6027\u7684\u7ed3\u679c\u3002\u5c0f\u738b\u56e0\u6b64\u591c\u4e0d\u80fd\u5bd0\u3001\u98df\u4e0d\u77e5\u5473\uff0c\u76f4\u5230\u4e09\u5929\u540e\u6536\u5230\u5f53\u5730\u75be\u63a7\u4e2d\u5fc3\u7684\u7535\u8bdd\u786e\u8ba4\u5176\u5e76\u6ca1\u6709\u611f\u67d3\u4eba\u7c7b\u514d\u75ab\u7f3a\u9677\u75c5\u6bd2\u3002\u4e8b\u5b9e\u4e0a\uff0c\u5218\u5efa\u793c\u7b49\u7684\u7814\u7a76\u7ed3\u679c\u6307\u51fa\u827e\u6ecb\u75c5\u521d\u7b5b\u9633\u6027\u6837\u672c\u7684\u603b\u4f53\u9633\u6027\u786e\u8bca\u7387\u4e3a37.6%\uff0c\u5176\u4e2d\u5973\u6027\u7684\u786e\u8bca\u9633\u6027\u7387\u4ec5\u4e3a6.9%\u3002\u4e3a\u4e86\u4f7f\u7ed3\u679c\u66f4\u52a0\u76f4\u89c2\uff0c\u5bf9\u4e8e\u67d0\u53d1\u75c5\u7387\u4e3a1%\uff08\u5148\u9a8c\u4fe1\u5ff5\uff09\u7684\u75be\u75c5\u8fdb\u884c\u4e00\u4e2a\u5047\u9633\u6027\u7387\u4e3a1%\uff081%\u7684\u5065\u5eb7\u4eba\u4f1a\u54cd\u5e94\u9633\u6027\u7ed3\u679c\uff09\u3001\u5047\u9634\u6027\u7387\u4e3a0\uff08\u6240\u6709\u60a3\u75c5\u4eba\u90fd\u4f1a\u54cd\u5e94\u9633\u6027\u7ed3\u679c\uff09\uff08\u540e\u9a8c\u4fe1\u5ff5\uff09\u68c0\u6d4b\uff0c\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u51fa\u5982\u4e0b\u8868\u683c\uff1a \u5065\u5eb7 \u60a3\u75c5 0.99 0.01 \u5065\u5eb7 \u60a3\u75c5 \u9633\u6027 0.01 1 \u9634\u6027 0.99 0 \u6211\u4eec\u53ef\u4ee5\u6839\u636e\u8fd9\u4e9b\u6570\u636e\uff0c\u901a\u8fc7\u8d1d\u53f6\u65af\u5b9a\u7406\u8ba1\u7b97\u51fa\u4e00\u4e2a\u4eba\u505a\u8be5\u68c0\u67e5\u7684\u7ed3\u679c\u6982\u7387\uff08\u8bc1\u636e\uff09\uff1a \u5065\u5eb7 \u60a3\u75c5 \u9633\u6027 0.44 0.56 \u9634\u6027 1 0 \u4f3c\u7136\u51fd\u6570 # \u5728\u6b63\u5f0f\u8fdb\u5165\u8d1d\u53f6\u65af\u5b9a\u7406\u4e4b\u524d\uff0c\u8ba9\u6211\u4eec\u5148\u4e86\u89e3\u4e00\u4e0b\u4f3c\u7136\u3002 \u4f3c\u7136\u7528\u4ee5\u9488\u5bf9\u7ed9\u5b9a\u7684\u4f4d\u7f6e\u53c2\u6570\u6d4b\u91cf\u7edf\u8ba1\u6a21\u578b\u4e0e\u6570\u636e\u6837\u672c\u7684\u62df\u5408\u4f18\u5ea6\u3002 \u5b83\u662f\u7531\u6837\u672c\u7684\u8054\u5408\u6982\u7387\u5206\u5e03\u5f62\u6210\u7684\uff0c\u4f46\u662f\u4ec5\u4f5c\u4e3a\u53c2\u6570\u7684\u51fd\u6570\u8fdb\u884c\u67e5\u770b\u548c\u4f7f\u7528\uff0c\u56e0\u6b64\u5c06\u968f\u673a\u53d8\u91cf\u56fa\u5b9a\u4e3a\u89c2\u5bdf\u503c\u3002 \u5c3d\u7ba1\u4f3c\u7136\u5728\u9891\u7387\u5b66\u6d3e\u5f53\u4e2d\u5e94\u7528\u66f4\u591a\uff08\u6211\u76f8\u4fe1\u4f60\u603b\u542c\u8fc7\u6700\u5927\u4f3c\u7136\u4f30\u8ba1\uff09\uff0c\u4f46\u5728\u8d1d\u53f6\u65af\u5b66\u6d3e\u4e2d\u4f3c\u7136\u51fd\u6570\u4e5f\u5360\u636e\u7740\u6781\u4e3a\u91cd\u8981\u7684\u5730\u4f4d\u3002","title":"\u8d1d\u53f6\u65af"},{"location":"stat/bayes/#_1","text":"\u5728\u6b63\u5f0f\u8fdb\u5165\u8d1d\u53f6\u65af\u5b9a\u7406\u4e4b\u524d\uff0c\u8ba9\u6211\u4eec\u5148\u4e86\u89e3\u4e00\u4e0b\u4f3c\u7136\u3002 \u4f3c\u7136\u7528\u4ee5\u9488\u5bf9\u7ed9\u5b9a\u7684\u4f4d\u7f6e\u53c2\u6570\u6d4b\u91cf\u7edf\u8ba1\u6a21\u578b\u4e0e\u6570\u636e\u6837\u672c\u7684\u62df\u5408\u4f18\u5ea6\u3002 \u5b83\u662f\u7531\u6837\u672c\u7684\u8054\u5408\u6982\u7387\u5206\u5e03\u5f62\u6210\u7684\uff0c\u4f46\u662f\u4ec5\u4f5c\u4e3a\u53c2\u6570\u7684\u51fd\u6570\u8fdb\u884c\u67e5\u770b\u548c\u4f7f\u7528\uff0c\u56e0\u6b64\u5c06\u968f\u673a\u53d8\u91cf\u56fa\u5b9a\u4e3a\u89c2\u5bdf\u503c\u3002 \u5c3d\u7ba1\u4f3c\u7136\u5728\u9891\u7387\u5b66\u6d3e\u5f53\u4e2d\u5e94\u7528\u66f4\u591a\uff08\u6211\u76f8\u4fe1\u4f60\u603b\u542c\u8fc7\u6700\u5927\u4f3c\u7136\u4f30\u8ba1\uff09\uff0c\u4f46\u5728\u8d1d\u53f6\u65af\u5b66\u6d3e\u4e2d\u4f3c\u7136\u51fd\u6570\u4e5f\u5360\u636e\u7740\u6781\u4e3a\u91cd\u8981\u7684\u5730\u4f4d\u3002","title":"\u4f3c\u7136\u51fd\u6570"},{"location":"stat/densities/","text":"\u672c\u6587\u4e2d\u6211\u4eec\u5c06\u8ba8\u8bba\u5206\u5e03\u3002 \u6982\u7387\u8d28\u91cf\u51fd\u6570\uff08Probability Mass Function\uff09 \u5bf9\u4e8e \u79bb\u6563\u76ee\u6807\u7a7a\u95f4 \\mathcal{T} \\mathcal{T} \uff0c\u6211\u4eec\u5c06 \u79bb\u6563\u968f\u673a\u53d8\u91cf X X \u4e3a\u67d0\u4e2a\u7279\u5b9a\u503c x \\in \\mathcal{T} x \\in \\mathcal{T} \u7684\u6982\u7387\u79f0\u4f5c\u5b83\u7684\u6982\u7387\u8d28\u91cf\u51fd\u6570\uff0c\u8bb0\u4f5c P(X = x) P(X = x) \u7d2f\u79ef\u5206\u5e03\u51fd\u6570\uff08Cumulative Distribution Function\uff09 \u5bf9\u4e8e \u8fde\u7eed\u76ee\u6807\u7a7a\u95f4 \\mathcal{T} \\mathcal{T} \uff0c\u6211\u4eec\u5c06 \u968f\u673a\u53d8\u91cf X X \u5728\u7279\u5b9a\u533a\u95f4 a, b \\in \\mathcal{T}, a \\leq b a, b \\in \\mathcal{T}, a \\leq b \u7684\u6982\u7387\u79f0\u4f5c\u5b83\u7684\u7d2f\u79ef\u5206\u5e03\u51fd\u6570\uff0c\u8bb0\u4f5c P(a \\leq X \\leq b) P(a \\leq X \\leq b) \u7d2f\u79ef\u5206\u5e03\u51fd\u6570\u662f\u6982\u7387\u5bc6\u5ea6\u51fd\u6570\uff08Probability Density Function\uff09\u7684\u79ef\u5206 \u6839\u636e\u60ef\u4f8b\uff0c\u6211\u4eec\u4e5f\u5c06 X X \u5c0f\u4e8e\u67d0\u4e2a\u7279\u5b9a\u503c x \\in \\mathcal{T} x \\in \\mathcal{T} \u8bb0\u4f5c P(X < x) P(X < x) \u79bb\u6563\u5206\u5e03 # \u8fb9\u7f18\u6982\u7387\uff08Marginal Probability\uff09 \u8fb9\u7f18\u6982\u7387\u5373\u4e3a\u6982\u7387\u8d28\u91cf\u51fd\u6570 \u6211\u4eec\u7528 X ~ P(X = x) X ~ P(X = x) \u6765\u8868\u793a X X \u4f9d\u636e P(X = x) P(X = x) \u5206\u5e03 \u8054\u5408\u6982\u7387\uff08Joint Probability\uff09 \u5bf9\u4e8e\u79bb\u6563\u76ee\u6807\u7a7a\u95f4 \\mathcal{T} \\mathcal{T} \uff0c\u6211\u4eec\u5c06\u79bb\u6563\u968f\u673a\u53d8\u91cf X, Y X, Y \u4e0e\u67d0\u4e24\u4e2a\u7279\u5b9a\u503c x, y \\in \\mathcal{T} x, y \\in \\mathcal{T} \u76f8\u7b49\uff0c\u5373 X = x, Y = y X = x, Y = y \u7684\u6982\u7387\u79f0\u4f5c\u5b83\u4eec\u7684\u8054\u5408\u6982\u7387\uff0c\u8bb0\u4f5c P(X = x, Y = y) P(X = x, Y = y) \u6839\u636e\u8d1d\u53f6\u65af\u5b9a\u7406\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230 P(X = x, Y = y) = P(X = x)P(X = x | Y = y) P(X = x, Y = y) = P(X = x)P(X = x | Y = y) \u6761\u4ef6\u6982\u7387\uff08Conditional Probability\uff09 \u5bf9\u4e8e\u79bb\u6563\u76ee\u6807\u7a7a\u95f4 \\mathcal{T} \\mathcal{T} \uff0c\u6211\u4eec\u5c06\u79bb\u6563\u968f\u673a\u53d8\u91cf X, Y X, Y \u4e0e\u67d0\u4e24\u4e2a\u7279\u5b9a\u503c x, y \\in \\mathcal{T} x, y \\in \\mathcal{T} \u5728 Y = y Y = y \u65f6 X = x X = x \u7684\u6982\u7387\u79f0\u4f5c\u6761\u4ef6\u6982\u7387\uff0c\u8bb0\u4f5c P(X = x | Y = y) P(X = x | Y = y) \u6839\u636e\u8d1d\u53f6\u65af\u5b9a\u7406\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230 P(X = x | Y = y) = \\frac{P(X = x, Y = y)}{(Y = y)} P(X = x | Y = y) = \\frac{P(X = x, Y = y)}{(Y = y)}","title":"\u5206\u5e03"},{"location":"stat/densities/#_1","text":"\u8fb9\u7f18\u6982\u7387\uff08Marginal Probability\uff09 \u8fb9\u7f18\u6982\u7387\u5373\u4e3a\u6982\u7387\u8d28\u91cf\u51fd\u6570 \u6211\u4eec\u7528 X ~ P(X = x) X ~ P(X = x) \u6765\u8868\u793a X X \u4f9d\u636e P(X = x) P(X = x) \u5206\u5e03 \u8054\u5408\u6982\u7387\uff08Joint Probability\uff09 \u5bf9\u4e8e\u79bb\u6563\u76ee\u6807\u7a7a\u95f4 \\mathcal{T} \\mathcal{T} \uff0c\u6211\u4eec\u5c06\u79bb\u6563\u968f\u673a\u53d8\u91cf X, Y X, Y \u4e0e\u67d0\u4e24\u4e2a\u7279\u5b9a\u503c x, y \\in \\mathcal{T} x, y \\in \\mathcal{T} \u76f8\u7b49\uff0c\u5373 X = x, Y = y X = x, Y = y \u7684\u6982\u7387\u79f0\u4f5c\u5b83\u4eec\u7684\u8054\u5408\u6982\u7387\uff0c\u8bb0\u4f5c P(X = x, Y = y) P(X = x, Y = y) \u6839\u636e\u8d1d\u53f6\u65af\u5b9a\u7406\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230 P(X = x, Y = y) = P(X = x)P(X = x | Y = y) P(X = x, Y = y) = P(X = x)P(X = x | Y = y) \u6761\u4ef6\u6982\u7387\uff08Conditional Probability\uff09 \u5bf9\u4e8e\u79bb\u6563\u76ee\u6807\u7a7a\u95f4 \\mathcal{T} \\mathcal{T} \uff0c\u6211\u4eec\u5c06\u79bb\u6563\u968f\u673a\u53d8\u91cf X, Y X, Y \u4e0e\u67d0\u4e24\u4e2a\u7279\u5b9a\u503c x, y \\in \\mathcal{T} x, y \\in \\mathcal{T} \u5728 Y = y Y = y \u65f6 X = x X = x \u7684\u6982\u7387\u79f0\u4f5c\u6761\u4ef6\u6982\u7387\uff0c\u8bb0\u4f5c P(X = x | Y = y) P(X = x | Y = y) \u6839\u636e\u8d1d\u53f6\u65af\u5b9a\u7406\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230 P(X = x | Y = y) = \\frac{P(X = x, Y = y)}{(Y = y)} P(X = x | Y = y) = \\frac{P(X = x, Y = y)}{(Y = y)}","title":"\u79bb\u6563\u5206\u5e03"},{"location":"stat/probability/","text":"\u91cf\u5b50\u529b\u5b66\u2026\u2026\u786e\u5b9e\u6709\u5f88\u591a\u7ed3\u8bba\uff0c\u4f46\u5e76\u6ca1\u6709\u8ba9\u6211\u4eec\u66f4\u63a5\u8fd1\u8001\u5bb6\u4f19\u7684\u79d8\u5bc6\u3002\u65e0\u8bba\u5982\u4f55\uff0c\u6211\u786e\u4fe1\u4ed6\u4e0d\u63b7\u9ab0\u5b50\u3002 \u2013 \u963f\u5c14\u4f2f\u7279\u00b7\u7231\u56e0\u65af\u5766 \u7231\u56e0\u65af\u5766\u5148\u751f\u5353\u8d8a\u7684\u6210\u5c31\u4f7f\u5176\u6210\u4e3a\u667a\u6167\u7684\u4ee3\u540d\u8bcd\uff0c\u4f46\u5728\u8fd9\u70b9\u4e0a\u4ed6\u5374\u9519\u4e86\u3002\u4e0d\u786e\u5b9a\u6027\u539f\u7406\u544a\u8bc9\u6211\u4eec\uff0c\u5fae\u89c2\u7c92\u5b50\u7684\u4f4d\u7f6e\u4e0e\u52a8\u91cf\u4e0d\u53ef\u540c\u65f6\u88ab\u786e\u5b9a\u3002\u4e8b\u5b9e\u4e0a\uff0c\u5728\u5b8f\u89c2\u7684\u73b0\u5b9e\u4e16\u754c\u5f53\u4e2d\u4e5f\u51e0\u4e4e\u6ca1\u6709\u5b8c\u5168\u786e\u5b9a\u7684\u4e8b\u60c5\u3002\u7528\u6570\u5b66\u8bed\u8a00\u53bb\u523b\u753b\u8fd9\u4e9b\u968f\u673a\u4e8b\u4ef6\uff0c\u6784\u6210\u4e86\u6211\u4eec\u4eca\u5929\u7684\u6982\u7387\u8bba\u3002 \u7531\u4e8e\u672c\u6587\u6d89\u53ca\u5230\u4e86\u90e8\u5206\u4e13\u6709\u540d\u8bcd\uff0c\u5728\u8fdb\u5165\u6b63\u6587\u4e4b\u524d\uff0c\u8ba9\u6211\u4eec\u5148\u770b\u4e00\u4e2a\u4f8b\u5b50\u4ee5\u5bf9\u8fd9\u4e9b\u4e13\u6709\u540d\u8bcd\u4ea7\u751f\u4e00\u4e2a\u76f4\u89c9\u3002 \u63b7\u9ab0\u5b50 \u5bf9\u4e8e\u516d\u9762\u666e\u901a\u9ab0\u5b50\uff0c\u6211\u4eec\u5c06\u5176\u6295\u63b7\u4e4b\u540e\u6b63\u9762\u5411\u4e0a\u7684\u70b9\u6570\u79f0\u4e3a\u968f\u673a\u53d8\u91cf X X \uff1b\u5b83\u7684\u53d6\u503c\u8303\u56f4\u79f0\u4e3a\u6837\u672c\u7a7a\u95f4 \\Omega \\Omega \u5373 \\{1, 2, 3, 4, 5, 6\\} \\{1, 2, 3, 4, 5, 6\\} \u3002\u82e5\u8be5\u9ab0\u5b50\u8d28\u5730\u5747\u4e00\uff0c\u5219\u4e00\u6b21\u6295\u63b7\u540e X X \u53d6\u4efb\u610f\u503c\u7684\u6982\u7387\u5747\u4e3a 1/6 1/6 \uff1b\u5176\u671f\u671b\u4e3a \\sum_{n=1}^{6} n / 6 = 3.5 \\sum_{n=1}^{6} n / 6 = 3.5 \uff1b\u5176\u65b9\u5dee\u4e3a \\sum_{n=1}^{6} (n-3.5)^2 / 6=35/12 \\sum_{n=1}^{6} (n-3.5)^2 / 6=35/12 \uff1b\u5176\u6807\u51c6\u5dee\u4e3a \\sqrt{35/12} = \\sqrt{105}/6 \\sqrt{35/12} = \\sqrt{105}/6 \u3002 \u6982\u7387 # \u4e00\u4e2a\u968f\u673a\u4e8b\u4ef6\u7684\u6982\u7387\u662f\u4e00\u4e2a\u4ecb\u4e8e0\u4e0e1\u4e4b\u95f4\u7684\u5b9e\u6570\uff0c\u662f\u5bf9\u968f\u673a\u4e8b\u4ef6\u53d1\u751f\u4e4b\u53ef\u80fd\u6027\u7684\u5ea6\u91cf\u3002 \u5bf9\u4e8e\u67d0\u4e2a\u968f\u673a\u4e8b\u4ef6\uff0c\u82e5\u5176\u6982\u7387\u4e3a0\u610f\u5473\u7740\u8fd9\u4e2a\u4e8b\u4ef6\u4e0d\u53ef\u80fd\u53d1\u751f\uff08\u4e0d\u53ef\u80fd\u4e8b\u4ef6\uff09\uff0c\u82e5\u5176\u6982\u7387\u4e3a1\u610f\u5473\u7740\u8fd9\u4e2a\u4e8b\u4ef6\u5fc5\u7136\u53d1\u751f\uff08\u5fc5\u7136\u4e8b\u4ef6\uff09\u3002 \u968f\u673a\u53d8\u91cf # \u5bf9\u4e8e\u6982\u7387\u7a7a\u95f4 (\\Omega, \\mathcal{F}, P) (\\Omega, \\mathcal{F}, P) \uff0c\u5bf9\u4e8e\u4efb\u610f\u5b9e\u6570 x x \u4e0e\u57fa\u672c\u4e8b\u4ef6 w w \uff0c\u90fd\u6709 {x \\in \\Omega: X(\\omega) \\leq x} \\in \\mathcal{F} {x \\in \\Omega: X(\\omega) \\leq x} \\in \\mathcal{F} \uff0c\u5219\u6211\u4eec\u5c06 X(w) X(w) \u79f0\u4e4b\u4e3a\u968f\u673a\u53d8\u91cf\u3002 \u968f\u673a\u53d8\u91cf\u662f\u4e00\u4e2a\u51fd\u6570\uff0c\u5b83\u7528\u6570\u5b57\u6765\u8868\u793a\u4e00\u4e2a\u53ef\u80fd\u51fa\u73b0\u7684\u4e8b\u4ef6\u3002 X X \u4e3a\u53ef\u6d4b\u96c6 S\\subseteq E S\\subseteq E \u4e0a\u7684\u67d0\u4e2a\u503c\u7684\u6982\u7387\u4e3a {\\mathrm{P}(X \\in S) = \\mathrm{P}(\\{\\omega \\in \\Omega \\mid X(\\omega) \\in S\\})}{\\mathrm{P}(X \\in S) = \\mathrm{P}(\\{\\omega \\in \\Omega \\mid X(\\omega )\\in S\\})} {\\mathrm{P}(X \\in S) = \\mathrm{P}(\\{\\omega \\in \\Omega \\mid X(\\omega) \\in S\\})}{\\mathrm{P}(X \\in S) = \\mathrm{P}(\\{\\omega \\in \\Omega \\mid X(\\omega )\\in S\\})} \u79bb\u6563\u968f\u673a\u53d8\u91cf # \u5bf9\u4e8e\u968f\u673a\u53d8\u91cf X X \uff0c\u82e5\u5b58\u5728\u975e\u8d1f\u51fd\u6570 f(x) f(x) \u548c F(X) F(X) \uff0c\u4f7f\u5f97 P(X = x) = f(x) P(X = x) = f(x) \uff0c P(X < x) = F(x) P(X < x) = F(x) \uff0c\u5219\u79f0 X X \u662f\u4e00\u4e2a\u79bb\u6563\u968f\u673a\u53d8\u91cf\u3002 \u79bb\u6563\u968f\u673a\u53d8\u91cf\u7684\u53d6\u503c\u8303\u56f4\u662f\u6709\u9650\u6216\u8005\u53ef\u5217\u7684\u3002 \u5728\u672c\u6587\u4e00\u5f00\u59cb\u7684\u63b7\u9ab0\u5b50\u4f8b\u5b50\u4e2d\u7684\u968f\u673a\u53d8\u91cf\u5373\u662f\u4e00\u4e2a\u79bb\u6563\u968f\u673a\u53d8\u91cf\u3002 \u8fde\u7eed\u968f\u673a\u53d8\u91cf # \u5bf9\u4e8e\u968f\u673a\u53d8\u91cf X X \uff0c\u82e5\u5b58\u5728\u975e\u8d1f\u51fd\u6570 f(x) f(x) \u548c F(X) F(X) \uff0c\u4f7f\u5f97 P(a \\leq X \\leq b) = \\int_{a}^{b} f(x) dx P(a \\leq X \\leq b) = \\int_{a}^{b} f(x) dx \uff0c P(X<x) = F(x) P(X<x) = F(x) \uff0c\u5219\u79f0 X X \u662f\u4e00\u4e2a\u8fde\u7eed\u968f\u673a\u53d8\u91cf\u3002 \u8fde\u7eed\u968f\u673a\u53d8\u91cf\u7684\u53d6\u503c\u8303\u56f4\u662f\u65e0\u9650\u6216\u8005\u4e0d\u53ef\u5217\u7684\u3002 \u4e3e\u4f8b\u6765\u8bf4\uff0c\u80af\u5fb7\u57fa\u51fa\u54c1\u7684\u542e\u6307\u539f\u5473\u9e21\u7684\u91cd\u91cf\u5373\u662f\u4e0d\u53ef\u5217\u7684\uff0c\u56e0\u6b64\u5176\u662f\u4e00\u4e2a\u8fde\u7eed\u968f\u673a\u53d8\u91cf\u3002 \u671f\u671b # \u6982\u7387\uff08\u6216\u5bc6\u5ea6\uff09\u4e3a\u6743\u91cd\u7684\u52a0\u6743\u5e73\u5747\u503c \\mathrm{E}[X] = \\sum_{x \\in X} x \\cdot P(x) \\mathrm{E}[X] = \\sum_{x \\in X} x \\cdot P(x) \u4e00\u4e2a\u968f\u673a\u53d8\u91cf\u7684\u671f\u671b\u523b\u753b\u7684\u662f\u8fd9\u4e2a\u968f\u673a\u53d8\u91cf\u7684\u6982\u7387\u5206\u5e03\u7684\u201c\u4e2d\u5fc3\u201d\u3002 \u7b80\u800c\u8a00\u4e4b\uff0c\u5f53\u6709\u65e0\u7a77\u591a\u6765\u81ea\u540c\u4e00\u4e2a\u6982\u7387\u5206\u5e03\u7684\u72ec\u7acb\u6837\u672c\u65f6\uff0c\u5b83\u4eec\u7684\u5e73\u5747\u503c\u5c31\u662f\u671f\u671b\u3002 \u65b9\u5dee # \u65b9\u5dee\u662f\u4e00\u4e2a\u968f\u673a\u53d8\u91cf\u4e0e\u5b83\u7684\u671f\u671b\u4e4b\u95f4\u7684\u5dee\u7684\u5e73\u65b9\u7684\u52a0\u6743\u5e73\u5747\u503c \\mathrm{Var}(X) = \\mathrm{E}[(X-\\mathrm{E}[X])^2] \\mathrm{Var}(X) = \\mathrm{E}[(X-\\mathrm{E}[X])^2] \u4e00\u4e2a\u968f\u673a\u53d8\u91cf\u7684\u65b9\u5dee\u523b\u753b\u7684\u662f\u8fd9\u4e2a\u968f\u673a\u53d8\u91cf\u7684\u6982\u7387\u5206\u5e03\u7684\u201c\u79bb\u6563\u5ea6\u201d\uff0c\u4e5f\u5373\u8be5\u53d8\u91cf\u4e0e\u5176\u671f\u671b\u503c\u7684\u8ddd\u79bb\u3002 \u6807\u51c6\u5dee # \u6807\u51c6\u5dee\u662f\u65b9\u5dee\u7684\u7b97\u6570\u5e73\u65b9\u6839 \\sigma = \\sqrt{\\mathrm{Var}(X)} \\sigma = \\sqrt{\\mathrm{Var}(X)}","title":"\u6982\u7387\u8bba"},{"location":"stat/probability/#_1","text":"\u4e00\u4e2a\u968f\u673a\u4e8b\u4ef6\u7684\u6982\u7387\u662f\u4e00\u4e2a\u4ecb\u4e8e0\u4e0e1\u4e4b\u95f4\u7684\u5b9e\u6570\uff0c\u662f\u5bf9\u968f\u673a\u4e8b\u4ef6\u53d1\u751f\u4e4b\u53ef\u80fd\u6027\u7684\u5ea6\u91cf\u3002 \u5bf9\u4e8e\u67d0\u4e2a\u968f\u673a\u4e8b\u4ef6\uff0c\u82e5\u5176\u6982\u7387\u4e3a0\u610f\u5473\u7740\u8fd9\u4e2a\u4e8b\u4ef6\u4e0d\u53ef\u80fd\u53d1\u751f\uff08\u4e0d\u53ef\u80fd\u4e8b\u4ef6\uff09\uff0c\u82e5\u5176\u6982\u7387\u4e3a1\u610f\u5473\u7740\u8fd9\u4e2a\u4e8b\u4ef6\u5fc5\u7136\u53d1\u751f\uff08\u5fc5\u7136\u4e8b\u4ef6\uff09\u3002","title":"\u6982\u7387"},{"location":"stat/probability/#_2","text":"\u5bf9\u4e8e\u6982\u7387\u7a7a\u95f4 (\\Omega, \\mathcal{F}, P) (\\Omega, \\mathcal{F}, P) \uff0c\u5bf9\u4e8e\u4efb\u610f\u5b9e\u6570 x x \u4e0e\u57fa\u672c\u4e8b\u4ef6 w w \uff0c\u90fd\u6709 {x \\in \\Omega: X(\\omega) \\leq x} \\in \\mathcal{F} {x \\in \\Omega: X(\\omega) \\leq x} \\in \\mathcal{F} \uff0c\u5219\u6211\u4eec\u5c06 X(w) X(w) \u79f0\u4e4b\u4e3a\u968f\u673a\u53d8\u91cf\u3002 \u968f\u673a\u53d8\u91cf\u662f\u4e00\u4e2a\u51fd\u6570\uff0c\u5b83\u7528\u6570\u5b57\u6765\u8868\u793a\u4e00\u4e2a\u53ef\u80fd\u51fa\u73b0\u7684\u4e8b\u4ef6\u3002 X X \u4e3a\u53ef\u6d4b\u96c6 S\\subseteq E S\\subseteq E \u4e0a\u7684\u67d0\u4e2a\u503c\u7684\u6982\u7387\u4e3a {\\mathrm{P}(X \\in S) = \\mathrm{P}(\\{\\omega \\in \\Omega \\mid X(\\omega) \\in S\\})}{\\mathrm{P}(X \\in S) = \\mathrm{P}(\\{\\omega \\in \\Omega \\mid X(\\omega )\\in S\\})} {\\mathrm{P}(X \\in S) = \\mathrm{P}(\\{\\omega \\in \\Omega \\mid X(\\omega) \\in S\\})}{\\mathrm{P}(X \\in S) = \\mathrm{P}(\\{\\omega \\in \\Omega \\mid X(\\omega )\\in S\\})}","title":"\u968f\u673a\u53d8\u91cf"},{"location":"stat/probability/#_3","text":"\u5bf9\u4e8e\u968f\u673a\u53d8\u91cf X X \uff0c\u82e5\u5b58\u5728\u975e\u8d1f\u51fd\u6570 f(x) f(x) \u548c F(X) F(X) \uff0c\u4f7f\u5f97 P(X = x) = f(x) P(X = x) = f(x) \uff0c P(X < x) = F(x) P(X < x) = F(x) \uff0c\u5219\u79f0 X X \u662f\u4e00\u4e2a\u79bb\u6563\u968f\u673a\u53d8\u91cf\u3002 \u79bb\u6563\u968f\u673a\u53d8\u91cf\u7684\u53d6\u503c\u8303\u56f4\u662f\u6709\u9650\u6216\u8005\u53ef\u5217\u7684\u3002 \u5728\u672c\u6587\u4e00\u5f00\u59cb\u7684\u63b7\u9ab0\u5b50\u4f8b\u5b50\u4e2d\u7684\u968f\u673a\u53d8\u91cf\u5373\u662f\u4e00\u4e2a\u79bb\u6563\u968f\u673a\u53d8\u91cf\u3002","title":"\u79bb\u6563\u968f\u673a\u53d8\u91cf"},{"location":"stat/probability/#_4","text":"\u5bf9\u4e8e\u968f\u673a\u53d8\u91cf X X \uff0c\u82e5\u5b58\u5728\u975e\u8d1f\u51fd\u6570 f(x) f(x) \u548c F(X) F(X) \uff0c\u4f7f\u5f97 P(a \\leq X \\leq b) = \\int_{a}^{b} f(x) dx P(a \\leq X \\leq b) = \\int_{a}^{b} f(x) dx \uff0c P(X<x) = F(x) P(X<x) = F(x) \uff0c\u5219\u79f0 X X \u662f\u4e00\u4e2a\u8fde\u7eed\u968f\u673a\u53d8\u91cf\u3002 \u8fde\u7eed\u968f\u673a\u53d8\u91cf\u7684\u53d6\u503c\u8303\u56f4\u662f\u65e0\u9650\u6216\u8005\u4e0d\u53ef\u5217\u7684\u3002 \u4e3e\u4f8b\u6765\u8bf4\uff0c\u80af\u5fb7\u57fa\u51fa\u54c1\u7684\u542e\u6307\u539f\u5473\u9e21\u7684\u91cd\u91cf\u5373\u662f\u4e0d\u53ef\u5217\u7684\uff0c\u56e0\u6b64\u5176\u662f\u4e00\u4e2a\u8fde\u7eed\u968f\u673a\u53d8\u91cf\u3002","title":"\u8fde\u7eed\u968f\u673a\u53d8\u91cf"},{"location":"stat/probability/#_5","text":"\u6982\u7387\uff08\u6216\u5bc6\u5ea6\uff09\u4e3a\u6743\u91cd\u7684\u52a0\u6743\u5e73\u5747\u503c \\mathrm{E}[X] = \\sum_{x \\in X} x \\cdot P(x) \\mathrm{E}[X] = \\sum_{x \\in X} x \\cdot P(x) \u4e00\u4e2a\u968f\u673a\u53d8\u91cf\u7684\u671f\u671b\u523b\u753b\u7684\u662f\u8fd9\u4e2a\u968f\u673a\u53d8\u91cf\u7684\u6982\u7387\u5206\u5e03\u7684\u201c\u4e2d\u5fc3\u201d\u3002 \u7b80\u800c\u8a00\u4e4b\uff0c\u5f53\u6709\u65e0\u7a77\u591a\u6765\u81ea\u540c\u4e00\u4e2a\u6982\u7387\u5206\u5e03\u7684\u72ec\u7acb\u6837\u672c\u65f6\uff0c\u5b83\u4eec\u7684\u5e73\u5747\u503c\u5c31\u662f\u671f\u671b\u3002","title":"\u671f\u671b"},{"location":"stat/probability/#_6","text":"\u65b9\u5dee\u662f\u4e00\u4e2a\u968f\u673a\u53d8\u91cf\u4e0e\u5b83\u7684\u671f\u671b\u4e4b\u95f4\u7684\u5dee\u7684\u5e73\u65b9\u7684\u52a0\u6743\u5e73\u5747\u503c \\mathrm{Var}(X) = \\mathrm{E}[(X-\\mathrm{E}[X])^2] \\mathrm{Var}(X) = \\mathrm{E}[(X-\\mathrm{E}[X])^2] \u4e00\u4e2a\u968f\u673a\u53d8\u91cf\u7684\u65b9\u5dee\u523b\u753b\u7684\u662f\u8fd9\u4e2a\u968f\u673a\u53d8\u91cf\u7684\u6982\u7387\u5206\u5e03\u7684\u201c\u79bb\u6563\u5ea6\u201d\uff0c\u4e5f\u5373\u8be5\u53d8\u91cf\u4e0e\u5176\u671f\u671b\u503c\u7684\u8ddd\u79bb\u3002","title":"\u65b9\u5dee"},{"location":"stat/probability/#_7","text":"\u6807\u51c6\u5dee\u662f\u65b9\u5dee\u7684\u7b97\u6570\u5e73\u65b9\u6839 \\sigma = \\sqrt{\\mathrm{Var}(X)} \\sigma = \\sqrt{\\mathrm{Var}(X)}","title":"\u6807\u51c6\u5dee"},{"location":"stat/statistics/","text":"\u4e0d\u7ba1\u662f\u56de\u5f52\u8fd8\u662f\u5206\u7c7b\uff0c\u673a\u5668\u5b66\u4e60\u51e0\u4e4e\u5904\u5904\u90fd\u5e94\u7528\u5230\u4e86\u7edf\u8ba1\u5b66\u77e5\u8bc6\u3002 \u672c\u6587\u65e8\u5728\u7b80\u8981\u7684\u5bf9\u7edf\u8ba1\u5b66\u7684\u4e24\u5927\u5b66\u6d3e\u2013\u8d1d\u53f6\u65af\u5b66\u6d3e\u4e0e\u9891\u7387\u5b66\u6d3e\u8fdb\u884c\u4ecb\u7ecd\u3002 \u7edf\u8ba1\u5b66\u4ece\u67d0\u79cd\u610f\u4e49\u4e0a\u6765\u8bf4\u53ef\u4ee5\u5206\u6210\u9891\u7387\u4e0e\u8d1d\u53f6\u65af\u4e24\u5927\u5b66\u6d3e\uff0c\u4ed6\u4eec\u4e4b\u95f4\u7684\u6700\u5927\u5dee\u522b\u4ea7\u751f\u4e8e\u5bf9\u53c2\u6570\u7a7a\u95f4 \\theta \\theta \u7684\u4e0d\u540c\u770b\u6cd5\u3002 \u53c2\u6570\u6307\u4e8b\u60c5\u53d1\u751f\u7684\u80cc\u666f\u60c5\u51b5\u3002 \u9891\u7387\u5b66\u6d3e # \u9891\u7387\u5b66\u6d3e\u8ba4\u4e3a\u53c2\u6570\u662f\u4e00\u4e2a\u5ba2\u89c2\u5b58\u5728\uff0c\u5b83\u867d\u672a\u77e5\u4f46\u5374\u662f\u56fa\u5b9a\u7684\u3002\u56e0\u6b64\uff0c\u9891\u7387\u5b66\u6d3e\u6240\u5173\u6ce8\u7684\u662f \u54ea\u4e2a\u503c\u6700\u6709\u53ef\u80fd\u662f\u53c2\u6570\u7684\u771f\u503c \u3002\u6240\u4ee5\u9891\u7387\u5b66\u6d3e\u5173\u5fc3 \u4f3c\u7136\uff08likelihood\uff09 \u3001 \u7f6e\u4fe1\u533a\u95f4\uff08confidence interval\uff09 \u3002 \u8d1d\u53f6\u65af\u5b66\u6d3e # \u8d1d\u53f6\u65af\u5b66\u6d3e\u8ba4\u4e3a\u53c2\u6570\u7a7a\u95f4\u91cc\u7684\u6bcf\u4e2a\u503c\u90fd\u6709\u53ef\u80fd\u662f\u53c2\u6570\u7684\u771f\u503c\uff0c\u533a\u522b\u53ea\u662f\u6982\u7387\u4e0d\u540c\u3002\u6240\u4ee5\u8d1d\u53f6\u65af\u5b66\u6d3e\u5f15\u5165\u4e86 \u5148\u9a8c\u4fe1\u5ff5\uff08prior belief\uff09 \u548c \u540e\u9a8c\u4fe1\u5ff5\uff08posterior belief\uff09 \u8fd9\u6837\u7684\u6982\u5ff5\u6765\u8bbe\u6cd5\u627e\u51fa\u53c2\u6570\u7a7a\u95f4\u4e0a\u7684\u6bcf\u4e2a\u503c\u7684\u6982\u7387\u3002 \u4f8b\u5b50 \u5f53\u4f60\u5728\u4f60\u5973\u670b\u53cb\u7684\u5305\u91cc\u53d1\u73b0\u4e86\u4e00\u6761\u4e0d\u5c5e\u4e8e\u4f60\u4e14\u88ab\u4f7f\u7528\u8fc7\u7684\u7537\u58eb\u5185\u88e4\u65f6\uff0c\u4f60\u8be5\u5982\u4f55\u5224\u65ad\u4f60\u662f\u4e0d\u662f\u6709\u4e86\u4e00\uff08\u6216\u591a\uff09\u9876\u7eff\u5e3d\u5b50\u7684\u6982\u7387\uff1f\u5728\u6536\u96c6\u5230\u5341\u4e07\u4e2a\u7ed3\u679c\u4e4b\u540e\uff0c\u9891\u7387\u5b66\u6d3e\u544a\u8bc9\u4f60\u4f60\u88ab\u7eff\u4e86\u7684\u53ef\u80fd\u662fx%\u3002\u4f46\u8d1d\u53f6\u65af\u5b66\u6d3e\u8fd8\u9700\u8981\u4e00\u4e2a\u8bc1\u636e\uff08evidence\uff09\uff0c\u6bd4\u5982\u6837\u8c8c\u6216\u8005\u4e13\u4e1a\uff0c\u6700\u540e\u518d\u544a\u8bc9\u4f60\u6839\u636e\u4f60\u5973\u670b\u53cb\u7684\u6837\u8c8c\u6216\u8005\u4e13\u4e1a\uff0c\u4f60\u88ab\u7eff\u4e86\u7684\u53ef\u80fd\u6027\u662fy%\u3002 \u5982\u679c\u4f60\u771f\u7684\u5728\u4f60\u5973\u670b\u53cb\u7684\u5305\u91cc\u53d1\u73b0\u4e86\u4e00\u6761\u4e0d\u5c5e\u4e8e\u4f60\u4e14\u88ab\u4f7f\u7528\u8fc7\u7684\u7537\u58eb\u5185\u88e4\uff0c\u90a3\u4e48\u4f60\u88ab\u7eff\u4e86\u3002 \u7531\u4e8e\u8d1d\u53f6\u65af\u65b9\u6cd5\u672c\u8eab\u5b58\u5728\u5f88\u591a\u95ee\u9898\uff0c\u6bd4\u5982\u5f53\u5148\u9a8c\u9009\u7684\u4e0d\u597d\u65f6\u4f60\u751a\u81f3\u90fd\u5f88\u96be\u5199\u51fa\u540e\u9a8c\u7684\u5177\u4f53\u5f62\u5f0f\uff0c\u6545\u867d\u7136\u8d1d\u53f6\u65af\u5b66\u6d3e\u6709\u7740\u66f4\u4e3a\u4e45\u8fdc\u7684\u5386\u53f2\uff0c\u4f46\u662f\u9891\u7387\u5b66\u6d3e\u53d1\u5c55\u4e00\u76f4\u8981\u597d\u5f88\u591a\u3002\u8fd1\u5e74\u6765\uff0c\u5f97\u76ca\u4e8e\u8ba1\u7b97\u673a\u7b49\u7684\u9ad8\u901f\u53d1\u5c55\uff0c\u8d1d\u53f6\u65af\u5b66\u6d3e\u4e5f\u53d7\u5230\u4e86\u8d8a\u6765\u8d8a\u591a\u7684\u5173\u6ce8\u3002\u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\uff0c\u6211\u4eec\u5c06\u5bf9\u8d1d\u53f6\u65af\u5b9a\u7406\u8fdb\u884c\u7b80\u5355\u4ecb\u7ecd\u3002","title":"\u7edf\u8ba1"},{"location":"stat/statistics/#_1","text":"\u9891\u7387\u5b66\u6d3e\u8ba4\u4e3a\u53c2\u6570\u662f\u4e00\u4e2a\u5ba2\u89c2\u5b58\u5728\uff0c\u5b83\u867d\u672a\u77e5\u4f46\u5374\u662f\u56fa\u5b9a\u7684\u3002\u56e0\u6b64\uff0c\u9891\u7387\u5b66\u6d3e\u6240\u5173\u6ce8\u7684\u662f \u54ea\u4e2a\u503c\u6700\u6709\u53ef\u80fd\u662f\u53c2\u6570\u7684\u771f\u503c \u3002\u6240\u4ee5\u9891\u7387\u5b66\u6d3e\u5173\u5fc3 \u4f3c\u7136\uff08likelihood\uff09 \u3001 \u7f6e\u4fe1\u533a\u95f4\uff08confidence interval\uff09 \u3002","title":"\u9891\u7387\u5b66\u6d3e"},{"location":"stat/statistics/#_2","text":"\u8d1d\u53f6\u65af\u5b66\u6d3e\u8ba4\u4e3a\u53c2\u6570\u7a7a\u95f4\u91cc\u7684\u6bcf\u4e2a\u503c\u90fd\u6709\u53ef\u80fd\u662f\u53c2\u6570\u7684\u771f\u503c\uff0c\u533a\u522b\u53ea\u662f\u6982\u7387\u4e0d\u540c\u3002\u6240\u4ee5\u8d1d\u53f6\u65af\u5b66\u6d3e\u5f15\u5165\u4e86 \u5148\u9a8c\u4fe1\u5ff5\uff08prior belief\uff09 \u548c \u540e\u9a8c\u4fe1\u5ff5\uff08posterior belief\uff09 \u8fd9\u6837\u7684\u6982\u5ff5\u6765\u8bbe\u6cd5\u627e\u51fa\u53c2\u6570\u7a7a\u95f4\u4e0a\u7684\u6bcf\u4e2a\u503c\u7684\u6982\u7387\u3002 \u4f8b\u5b50 \u5f53\u4f60\u5728\u4f60\u5973\u670b\u53cb\u7684\u5305\u91cc\u53d1\u73b0\u4e86\u4e00\u6761\u4e0d\u5c5e\u4e8e\u4f60\u4e14\u88ab\u4f7f\u7528\u8fc7\u7684\u7537\u58eb\u5185\u88e4\u65f6\uff0c\u4f60\u8be5\u5982\u4f55\u5224\u65ad\u4f60\u662f\u4e0d\u662f\u6709\u4e86\u4e00\uff08\u6216\u591a\uff09\u9876\u7eff\u5e3d\u5b50\u7684\u6982\u7387\uff1f\u5728\u6536\u96c6\u5230\u5341\u4e07\u4e2a\u7ed3\u679c\u4e4b\u540e\uff0c\u9891\u7387\u5b66\u6d3e\u544a\u8bc9\u4f60\u4f60\u88ab\u7eff\u4e86\u7684\u53ef\u80fd\u662fx%\u3002\u4f46\u8d1d\u53f6\u65af\u5b66\u6d3e\u8fd8\u9700\u8981\u4e00\u4e2a\u8bc1\u636e\uff08evidence\uff09\uff0c\u6bd4\u5982\u6837\u8c8c\u6216\u8005\u4e13\u4e1a\uff0c\u6700\u540e\u518d\u544a\u8bc9\u4f60\u6839\u636e\u4f60\u5973\u670b\u53cb\u7684\u6837\u8c8c\u6216\u8005\u4e13\u4e1a\uff0c\u4f60\u88ab\u7eff\u4e86\u7684\u53ef\u80fd\u6027\u662fy%\u3002 \u5982\u679c\u4f60\u771f\u7684\u5728\u4f60\u5973\u670b\u53cb\u7684\u5305\u91cc\u53d1\u73b0\u4e86\u4e00\u6761\u4e0d\u5c5e\u4e8e\u4f60\u4e14\u88ab\u4f7f\u7528\u8fc7\u7684\u7537\u58eb\u5185\u88e4\uff0c\u90a3\u4e48\u4f60\u88ab\u7eff\u4e86\u3002 \u7531\u4e8e\u8d1d\u53f6\u65af\u65b9\u6cd5\u672c\u8eab\u5b58\u5728\u5f88\u591a\u95ee\u9898\uff0c\u6bd4\u5982\u5f53\u5148\u9a8c\u9009\u7684\u4e0d\u597d\u65f6\u4f60\u751a\u81f3\u90fd\u5f88\u96be\u5199\u51fa\u540e\u9a8c\u7684\u5177\u4f53\u5f62\u5f0f\uff0c\u6545\u867d\u7136\u8d1d\u53f6\u65af\u5b66\u6d3e\u6709\u7740\u66f4\u4e3a\u4e45\u8fdc\u7684\u5386\u53f2\uff0c\u4f46\u662f\u9891\u7387\u5b66\u6d3e\u53d1\u5c55\u4e00\u76f4\u8981\u597d\u5f88\u591a\u3002\u8fd1\u5e74\u6765\uff0c\u5f97\u76ca\u4e8e\u8ba1\u7b97\u673a\u7b49\u7684\u9ad8\u901f\u53d1\u5c55\uff0c\u8d1d\u53f6\u65af\u5b66\u6d3e\u4e5f\u53d7\u5230\u4e86\u8d8a\u6765\u8d8a\u591a\u7684\u5173\u6ce8\u3002\u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u5f53\u4e2d\uff0c\u6211\u4eec\u5c06\u5bf9\u8d1d\u53f6\u65af\u5b9a\u7406\u8fdb\u884c\u7b80\u5355\u4ecb\u7ecd\u3002","title":"\u8d1d\u53f6\u65af\u5b66\u6d3e"}]}